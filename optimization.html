<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Chapter&nbsp;8 Optimization</title>
    <link rel="stylesheet" href="mvl.css" type="text/css">
    <meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2">
    <link rel="start" href="index.html" title="{book-title}">
    <link rel="up" href="" title="">
    <link rel="prev" href="backup-and-recovery.html" title="Chapter&nbsp;7 Backup and Recovery">
    <link rel="next" href="language-structure.html" title="Chapter&nbsp;9 Language Structure">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script></head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
    <table width="100%" summary="Navigation header">
        <tbody><tr>
            <th colspan="3" align="center">Chapter&nbsp;8 Optimization</th>
        </tr>
        <tr>
            <td width="20%" align="left"><a accesskey="p" href="backup-and-recovery.html">Prev</a>&nbsp;</td>
            <th width="60%" align="center"></th>
            <td width="20%" align="right">&nbsp;<a accesskey="n" href="language-structure.html">Next</a></td>
        </tr>
        </tbody></table>
    <hr>
</div>
<div class="chapter">
    <div class="titlepage">
        <div>
            <div>
                <h1 class="title"><a name="optimization"></a>Chapter&nbsp;8&nbsp;Optimization</h1>

            </div>

        </div>

    </div>
    <div class="toc">
        <p><b>Table of Contents</b></p><p style="color:blue;">目录</p><p></p><dl class="toc"><dt><span class="section"><a href="optimization.html#optimize-overview">8.1 Optimization Overview</a></span></dt><dt><span class="section"><a href="optimization.html#statement-optimization">8.2 Optimizing SQL Statements</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#select-optimization">8.2.1 Optimizing SELECT Statements</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-optimization">8.2.2 Optimizing Subqueries, Derived Tables, and View References</a></span></dt><dt><span class="section"><a href="optimization.html#information-schema-optimization">8.2.3 Optimizing INFORMATION_SCHEMA Queries</a></span></dt><dt><span class="section"><a href="optimization.html#data-change-optimization">8.2.4 Optimizing Data Change Statements</a></span></dt><dt><span class="section"><a href="optimization.html#permission-optimization">8.2.5 Optimizing Database Privileges</a></span></dt><dt><span class="section"><a href="optimization.html#miscellaneous-optimization-tips">8.2.6 Other Optimization Tips</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimization-indexes">8.3 Optimization and Indexes</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#mysql-indexes">8.3.1 How MySQL Uses Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#primary-key-optimization">8.3.2 Primary Key Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#foreign-key-optimization">8.3.3 Foreign Key Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#column-indexes">8.3.4 Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">8.3.5 Multiple-Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#verifying-index-usage">8.3.6 Verifying Index Usage</a></span></dt><dt><span class="section"><a href="optimization.html#index-statistics">8.3.7 InnoDB and MyISAM Index Statistics Collection</a></span></dt><dt><span class="section"><a href="optimization.html#index-btree-hash">8.3.8 Comparison of B-Tree and Hash Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#index-extensions">8.3.9 Use of Index Extensions</a></span></dt><dt><span class="section"><a href="optimization.html#generated-column-index-optimizations">8.3.10 Optimizer Use of Generated Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#timestamp-lookups">8.3.11 Indexed Lookups from TIMESTAMP Columns</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-database-structure">8.4 Optimizing Database Structure</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#data-size">8.4.1 Optimizing Data Size</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-data-types">8.4.2 Optimizing MySQL Data Types</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-multi-tables">8.4.3 Optimizing for Many Tables</a></span></dt><dt><span class="section"><a href="optimization.html#internal-temporary-tables">8.4.4 Internal Temporary Table Use in MySQL</a></span></dt><dt><span class="section"><a href="optimization.html#database-count-limit">8.4.5 Limits on Number of Databases and Tables</a></span></dt><dt><span class="section"><a href="optimization.html#table-size-limit">8.4.6 Limits on Table Size</a></span></dt><dt><span class="section"><a href="optimization.html#column-count-limit">8.4.7 Limits on Table Column Count and Row Size</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-innodb">8.5 Optimizing for InnoDB Tables</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#optimizing-innodb-storage-layout">8.5.1 Optimizing Storage Layout for InnoDB Tables</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-transaction-management">8.5.2 Optimizing InnoDB Transaction Management</a></span></dt><dt><span class="section"><a href="optimization.html#innodb-performance-ro-txn">8.5.3 Optimizing InnoDB Read-Only Transactions</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-logging">8.5.4 Optimizing InnoDB Redo Logging</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-bulk-data-loading">8.5.5 Bulk Data Loading for InnoDB Tables</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-queries">8.5.6 Optimizing InnoDB Queries</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-ddl-operations">8.5.7 Optimizing InnoDB DDL Operations</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-diskio">8.5.8 Optimizing InnoDB Disk I/O</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-configuration-variables">8.5.9 Optimizing InnoDB Configuration Variables</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-many-tables">8.5.10 Optimizing InnoDB for Systems with Many Tables</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-myisam">8.6 Optimizing for MyISAM Tables</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#optimizing-queries-myisam">8.6.1 Optimizing MyISAM Queries</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-myisam-bulk-data-loading">8.6.2 Bulk Data Loading for MyISAM Tables</a></span></dt><dt><span class="section"><a href="optimization.html#repair-table-optimization">8.6.3 Optimizing REPAIR TABLE Statements</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-memory-tables">8.7 Optimizing for MEMORY Tables</a></span></dt><dt><span class="section"><a href="optimization.html#execution-plan-information">8.8 Understanding the Query Execution Plan</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#using-explain">8.8.1 Optimizing Queries with EXPLAIN</a></span></dt><dt><span class="section"><a href="optimization.html#explain-output">8.8.2 EXPLAIN Output Format</a></span></dt><dt><span class="section"><a href="optimization.html#explain-extended">8.8.3 Extended EXPLAIN Output Format</a></span></dt><dt><span class="section"><a href="optimization.html#explain-for-connection">8.8.4 Obtaining Execution Plan Information for a Named Connection</a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">8.8.5 Estimating Query Performance</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#controlling-optimizer">8.9 Controlling the Query Optimizer</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#controlling-query-plan-evaluation">8.9.1 Controlling Query Plan Evaluation</a></span></dt><dt><span class="section"><a href="optimization.html#switchable-optimizations">8.9.2 Switchable Optimizations</a></span></dt><dt><span class="section"><a href="optimization.html#optimizer-hints">8.9.3 Optimizer Hints</a></span></dt><dt><span class="section"><a href="optimization.html#index-hints">8.9.4 Index Hints</a></span></dt><dt><span class="section"><a href="optimization.html#cost-model">8.9.5 The Optimizer Cost Model</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#buffering-caching">8.10 Buffering and Caching</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#innodb-buffer-pool-optimization">8.10.1 InnoDB Buffer Pool Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">8.10.2 The MyISAM Key Cache</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache">8.10.3 The MySQL Query Cache</a></span></dt><dt><span class="section"><a href="optimization.html#statement-caching">8.10.4 Caching of Prepared Statements and Stored Programs</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#locking-issues">8.11 Optimizing Locking Operations</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#internal-locking">8.11.1 Internal Locking Methods</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">8.11.2 Table Locking Issues</a></span></dt><dt><span class="section"><a href="optimization.html#concurrent-inserts">8.11.3 Concurrent Inserts</a></span></dt><dt><span class="section"><a href="optimization.html#metadata-locking">8.11.4 Metadata Locking</a></span></dt><dt><span class="section"><a href="optimization.html#external-locking">8.11.5 External Locking</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-server">8.12 Optimizing the MySQL Server</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#system-optimization">8.12.1 System Factors</a></span></dt><dt><span class="section"><a href="optimization.html#disk-issues">8.12.2 Optimizing Disk I/O</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links">8.12.3 Using Symbolic Links</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-memory">8.12.4 Optimizing Memory Use</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-network">8.12.5 Optimizing Network Use</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimize-benchmarking">8.13 Measuring Performance (Benchmarking)</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#select-benchmarking">8.13.1 Measuring the Speed of Expressions and Functions</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">8.13.2 Using Your Own Benchmarks</a></span></dt><dt><span class="section"><a href="optimization.html#monitoring-performance-schema">8.13.3 Measuring Performance with performance_schema</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#thread-information">8.14 Examining Thread Information</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#thread-commands">8.14.1 Thread Command Values</a></span></dt><dt><span class="section"><a href="optimization.html#general-thread-states">8.14.2 General Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-thread-states">8.14.3 Query Cache Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#master-thread-states">8.14.4 Replication Master Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#slave-io-thread-states">8.14.5 Replication Slave I/O Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#slave-sql-thread-states">8.14.6 Replication Slave SQL Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#slave-connection-thread-states">8.14.7 Replication Slave Connection Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-cluster-thread-states">8.14.8 NDB Cluster Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#event-scheduler-thread-states">8.14.9 Event Scheduler Thread States</a></span></dt></dl></dd></dl>
    </div>
    <a class="indexterm" name="idm140286876180416"></a><a class="indexterm" name="idm140286876179344"></a><a class="indexterm" name="idm140286876178272"></a><p>
    This chapter explains how to optimize MySQL performance and provides
    examples. Optimization involves configuring, tuning, and measuring
    performance, at several levels. Depending on your job role
    (developer, DBA, or a combination of both), you might optimize at
    the level of individual SQL statements, entire applications, a
    single database server, or multiple networked database servers.
    Sometimes you can be proactive and plan in advance for performance,
    while other times you might troubleshoot a configuration or code
    issue after a problem occurs. Optimizing CPU and memory usage can
    also improve scalability, allowing the database to handle more load
    without slowing down.
</p><p style="color:blue;">本章介绍如何优化mysql性能并提供示例。优化包括在多个级别上配置、调整和度量性能。根据您的工作角色（开发人员、dba或两者的组合），您可以在单个sql语句、整个应用程序、单个数据库服务器或多个网络数据库服务器的级别上进行优化。有时，您可以主动地提前计划性能，而其他时候，您可能会在出现问题后解决配置或代码问题。优化cpu和内存使用也可以提高可伸缩性，允许数据库在不减慢速度的情况下处理更多的负载。</p><p></p>
    <div class="section">

        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="optimize-overview"></a>8.1&nbsp;Optimization Overview</h2>
                </div>
            </div>
        </div>
        <p>
            Database performance depends on several factors at the database
            level, such as tables, queries, and configuration settings. These
            software constructs result in CPU and I/O operations at the
            hardware level, which you must minimize and make as efficient as
            possible. As you work on database performance, you start by
            learning the high-level rules and guidelines for the software
            side, and measuring performance using wall-clock time. As you
            become an expert, you learn more about what happens internally,
            and start measuring things such as CPU cycles and I/O operations.
        </p><p style="color:blue;">数据库性能取决于数据库级别的几个因素，如表、查询和配置设置。这些软件结构会导致在硬件级别上执行CPU和I/O操作，您必须尽可能减少这些操作并使其尽可能高效。在研究数据库性能时，首先学习软件方面的高级规则和指南，然后使用挂钟时间测量性能。当你成为一名专家时，你会学到更多关于内部发生的事情，并开始测量诸如cpu周期和i/o操作之类的事情。</p><p></p><p>
        Typical users aim to get the best database performance out of
        their existing software and hardware configurations. Advanced
        users look for opportunities to improve the MySQL software itself,
        or develop their own storage engines and hardware appliances to
        expand the MySQL ecosystem.
    </p><p style="color:blue;">典型用户的目标是从现有的软件和硬件配置中获得最好的数据库性能。高级用户寻找机会来改进mysql软件本身，或者开发自己的存储引擎和硬件设备来扩展mysql生态系统。</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#optimize-database-level" title="Optimizing at the Database Level">Optimizing at the Database Level</a></p><p style="color:blue;">在数据库级别优化</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimize-hardware-level" title="Optimizing at the Hardware Level">Optimizing at the Hardware Level</a></p><p style="color:blue;">硬件优化</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimize-portability-performance" title="Balancing Portability and Performance">Balancing Portability and Performance</a></p><p style="color:blue;">平衡便携性和性能</p><p></p></li></ul>
        </div>

        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="optimize-database-level"></a>Optimizing at the Database Level</h3>

                    </div>

                </div>

            </div>
            <p>
                The most important factor in making a database application fast
                is its basic design:
            </p><p style="color:blue;">使数据库应用程序快速运行的最重要因素是其基本设计：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Are the tables structured properly? In particular, do the
                    columns have the right data types, and does each table have
                    the appropriate columns for the type of work? For example,
                    applications that perform frequent updates often have many
                    tables with few columns, while applications that analyze
                    large amounts of data often have few tables with many
                    columns.
                </p><p style="color:blue;">桌子的结构是否合理？特别是，列是否具有正确的数据类型，每个表是否具有适合工作类型的列？例如，执行频繁更新的应用程序通常有许多表和很少的列，而分析大量数据的应用程序通常有很少的表和很多列。</p><p></p></li><li class="listitem"><p>
                    Are the right
                    <a class="link" href="optimization.html#optimization-indexes" title="8.3&nbsp;Optimization and Indexes">indexes</a> in place
                    to make queries efficient?
                </p><p style="color:blue;">是否有适当的索引来提高查询效率？</p><p></p></li><li class="listitem"><p>
                    Are you using the appropriate storage engine for each table,
                    and taking advantage of the strengths and features of each
                    storage engine you use? In particular, the choice of a
                    transactional storage engine such as
                    <code class="literal"><a class="link" href="optimization.html#optimizing-innodb" title="8.5&nbsp;Optimizing for InnoDB Tables">InnoDB</a></code>
                    or a nontransactional one such as
                    <code class="literal"><a class="link" href="optimization.html#optimizing-myisam" title="8.6&nbsp;Optimizing for MyISAM Tables">MyISAM</a></code>
                    can be very important for performance and scalability.
                </p><p style="color:blue;">您是否为每个表使用了适当的存储引擎，并利用了您使用的每个存储引擎的优势和功能？特别是，事务性存储引擎（如innodb）或非事务性存储引擎（如myisam）的选择对于性能和可伸缩性非常重要。</p><p></p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            <code class="literal">InnoDB</code> is the default storage engine
                            for new tables. In practice, the advanced
                            <code class="literal">InnoDB</code> performance features mean that
                            <code class="literal">InnoDB</code> tables often outperform the
                            simpler <code class="literal">MyISAM</code> tables, especially for a
                            busy database.
                        </p><p style="color:blue;">innodb是新表的默认存储引擎。实际上，高级的innodb性能特性意味着innodb表的性能通常优于更简单的myisam表，特别是对于繁忙的数据库。</p><p></p>
                    </div>
                </li><li class="listitem"><p>
                    Does each table use an appropriate row format? This choice
                    also depends on the storage engine used for the table. In
                    particular, compressed tables use less disk space and so
                    require less disk I/O to read and write the data.
                    Compression is available for all kinds of workloads with
                    <code class="literal">InnoDB</code> tables, and for read-only
                    <code class="literal">MyISAM</code> tables.
                </p><p style="color:blue;">每个表是否使用适当的行格式？此选择还取决于用于表的存储引擎。特别是，压缩表使用更少的磁盘空间，因此读写数据所需的磁盘I/O更少。压缩可用于具有innodb表的各种工作负载，也可用于只读myisam表。</p><p></p></li><li class="listitem"><p>
                    Does the application use an appropriate
                    <a class="link" href="optimization.html#locking-issues" title="8.11&nbsp;Optimizing Locking Operations">locking strategy</a>? For
                    example, by allowing shared access when possible so that
                    database operations can run concurrently, and requesting
                    exclusive access when appropriate so that critical
                    operations get top priority. Again, the choice of storage
                    engine is significant. The <code class="literal">InnoDB</code> storage
                    engine handles most locking issues without involvement from
                    you, allowing for better concurrency in the database and
                    reducing the amount of experimentation and tuning for your
                    code.
                </p><p style="color:blue;">应用程序是否使用适当的锁定策略？例如，尽可能允许共享访问，以便数据库操作可以并发运行，并在适当时请求独占访问，以便关键操作获得最高优先级。再次，存储引擎的选择是重要的。innodb存储引擎可以在不需要您参与的情况下处理大多数锁定问题，从而在数据库中实现更好的并发性，并减少代码的实验和调整量。</p><p></p></li><li class="listitem"><p>
                    Are all <a class="link" href="optimization.html#buffering-caching" title="8.10&nbsp;Buffering and Caching">memory areas used
                    for caching</a> sized correctly? That is, large enough to
                    hold frequently accessed data, but not so large that they
                    overload physical memory and cause paging. The main memory
                    areas to configure are the <code class="literal">InnoDB</code> buffer
                    pool, the <code class="literal">MyISAM</code> key cache, and the MySQL
                    query cache.
                </p><p style="color:blue;">所有用于缓存的内存区域大小是否正确？也就是说，大到可以容纳频繁访问的数据，但不能大到使物理内存过载并导致分页。要配置的主要内存区域是innodb缓冲池、myisam密钥缓存和mysql查询缓存。</p><p></p></li></ul>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="optimize-hardware-level"></a>Optimizing at the Hardware Level</h3>

                    </div>

                </div>

            </div>
            <p>
                Any database application eventually hits hardware limits as the
                database becomes more and more busy. A DBA must evaluate whether
                it is possible to tune the application or reconfigure the server
                to avoid these
                <a class="link" href="glossary.html#glos_bottleneck" title="bottleneck">bottlenecks</a>, or whether
                more hardware resources are required. System bottlenecks
                typically arise from these sources:
            </p><p style="color:blue;">随着数据库变得越来越繁忙，任何数据库应用程序最终都会遇到硬件限制。dba必须评估是否可以优化应用程序或重新配置服务器以避免这些瓶颈，或者是否需要更多的硬件资源。系统瓶颈通常来自以下方面：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Disk seeks. It takes time for the disk to find a piece of
                    data. With modern disks, the mean time for this is usually
                    lower than 10ms, so we can in theory do about 100 seeks a
                    second. This time improves slowly with new disks and is very
                    hard to optimize for a single table. The way to optimize
                    seek time is to distribute the data onto more than one disk.
                </p><p style="color:blue;">磁盘查找。磁盘查找数据需要时间。对于现代磁盘，平均时间通常低于10毫秒，因此理论上我们可以做大约100次寻道。这一次在使用新磁盘时改进缓慢，而且很难针对单个表进行优化。优化寻道时间的方法是将数据分发到多个磁盘上。</p><p></p></li><li class="listitem"><p>
                    Disk reading and writing. When the disk is at the correct
                    position, we need to read or write the data. With modern
                    disks, one disk delivers at least 10–20MB/s
                    throughput. This is easier to optimize than seeks because
                    you can read in parallel from multiple disks.
                </p><p style="color:blue;">磁盘读写。当磁盘处于正确位置时，我们需要读取或写入数据。使用现代磁盘，一个磁盘至少提供10–20MB/s的吞吐量。这比查找更容易优化，因为您可以从多个磁盘并行读取。</p><p></p></li><li class="listitem"><p>
                    CPU cycles. When the data is in main memory, we must process
                    it to get our result. Having large tables compared to the
                    amount of memory is the most common limiting factor. But
                    with small tables, speed is usually not the problem.
                </p><p style="color:blue;">CPU周期。当数据在主存中时，我们必须对其进行处理才能得到结果。与内存量相比，拥有大表是最常见的限制因素。但是对于小桌子来说，速度通常不是问题。</p><p></p></li><li class="listitem"><p>
                    Memory bandwidth. When the CPU needs more data than can fit
                    in the CPU cache, main memory bandwidth becomes a
                    bottleneck. This is an uncommon bottleneck for most systems,
                    but one to be aware of.
                </p><p style="color:blue;">内存带宽。当cpu需要的数据超过cpu缓存的容量时，主存带宽成为瓶颈。对于大多数系统来说，这是一个不常见的瓶颈，但需要注意。</p><p></p></li></ul>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="optimize-portability-performance"></a>Balancing Portability and Performance</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286876138128"></a><p>
            To use performance-oriented SQL extensions in a portable MySQL
            program, you can wrap MySQL-specific keywords in a statement
            within <code class="literal">/*! */</code> comment delimiters. Other SQL
            servers ignore the commented keywords. For information about
            writing comments, see <a class="xref" href="language-structure.html#comments" title="9.6&nbsp;Comment Syntax">Section&nbsp;9.6, “Comment Syntax”</a>.
        </p><p style="color:blue;">要在可移植的mysql程序中使用面向性能的sql扩展，可以在/*中的语句中包装mysql特定的关键字！*/注释分隔符。其他SQL服务器忽略已注释的关键字。有关编写注释的信息，请参见第9.6节“注释语法”。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="statement-optimization"></a>8.2&nbsp;Optimizing SQL Statements</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#select-optimization">8.2.1 Optimizing SELECT Statements</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-optimization">8.2.2 Optimizing Subqueries, Derived Tables, and View References</a></span></dt><dt><span class="section"><a href="optimization.html#information-schema-optimization">8.2.3 Optimizing INFORMATION_SCHEMA Queries</a></span></dt><dt><span class="section"><a href="optimization.html#data-change-optimization">8.2.4 Optimizing Data Change Statements</a></span></dt><dt><span class="section"><a href="optimization.html#permission-optimization">8.2.5 Optimizing Database Privileges</a></span></dt><dt><span class="section"><a href="optimization.html#miscellaneous-optimization-tips">8.2.6 Other Optimization Tips</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286876133648"></a><p>
        The core logic of a database application is performed through SQL
        statements, whether issued directly through an interpreter or
        submitted behind the scenes through an API. The tuning guidelines
        in this section help to speed up all kinds of MySQL applications.
        The guidelines cover SQL operations that read and write data, the
        behind-the-scenes overhead for SQL operations in general, and
        operations used in specific scenarios such as database monitoring.
    </p><p style="color:blue;">数据库应用程序的核心逻辑是通过sql语句执行的，无论是直接通过解释器发出还是通过api在后台提交。本节中的调整指导原则有助于加快各种mysql应用程序的速度。这些指导原则包括读取和写入数据的sql操作、sql操作的幕后开销，以及在特定场景（如数据库监视）中使用的操作。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="select-optimization"></a>8.2.1&nbsp;Optimizing SELECT Statements</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#where-optimization">8.2.1.1 WHERE Clause Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#range-optimization">8.2.1.2 Range Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-optimization">8.2.1.3 Index Merge Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#condition-pushdown-optimization">8.2.1.4 Engine Condition Pushdown Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#index-condition-pushdown-optimization">8.2.1.5 Index Condition Pushdown Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#nested-loop-joins">8.2.1.6 Nested-Loop Join Algorithms</a></span></dt><dt><span class="section"><a href="optimization.html#nested-join-optimization">8.2.1.7 Nested Join Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-optimization">8.2.1.8 Outer Join Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-simplification">8.2.1.9 Outer Join Simplification</a></span></dt><dt><span class="section"><a href="optimization.html#mrr-optimization">8.2.1.10 Multi-Range Read Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#bnl-bka-optimization">8.2.1.11 Block Nested-Loop and Batched Key Access Joins</a></span></dt><dt><span class="section"><a href="optimization.html#condition-filtering">8.2.1.12 Condition Filtering</a></span></dt><dt><span class="section"><a href="optimization.html#is-null-optimization">8.2.1.13 IS NULL Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#order-by-optimization">8.2.1.14 ORDER BY Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#group-by-optimization">8.2.1.15 GROUP BY Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#distinct-optimization">8.2.1.16 DISTINCT Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#limit-optimization">8.2.1.17 LIMIT Query Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#function-optimization">8.2.1.18 Function Call Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#row-constructor-optimization">8.2.1.19 Row Constructor Expression Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#table-scan-avoidance">8.2.1.20 Avoiding Full Table Scans</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286876130096"></a><a class="indexterm" name="idm140286876128640"></a><a class="indexterm" name="idm140286876127152"></a><p>
            Queries, in the form of <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
            statements, perform all the lookup operations in the database.
            Tuning these statements is a top priority, whether to achieve
            sub-second response times for dynamic web pages, or to chop
            hours off the time to generate huge overnight reports.
        </p><p style="color:blue;">查询以select语句的形式执行数据库中的所有查找操作。优化这些语句是首要任务，无论是实现动态网页的亚秒响应时间，还是缩短生成巨大的夜间报告的时间。</p><p></p><p>
            Besides <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, the
            tuning techniques for queries also apply to constructs such as
            <a class="link" href="sql-syntax.html#create-table-select" title="13.1.18.5&nbsp;CREATE TABLE ... SELECT Syntax"><code class="literal">CREATE
                TABLE...AS SELECT</code></a>,
            <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT
                INTO...SELECT</code></a>, and <code class="literal">WHERE</code> clauses in
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements. Those
            statements have additional performance considerations because
            they combine write operations with the read-oriented query
            operations.
        </p><p style="color:blue;">除了select语句之外，查询的优化技术还适用于create table…as select、insert in to…select和delete语句中的where子句等构造。这些语句有额外的性能考虑，因为它们将写操作与面向读的查询操作结合起来。</p><p></p><p>
            NDB Cluster supports a join pushdown optimization whereby a
            qualifying join is sent in its entirety to NDB Cluster data
            nodes, where it can be distributed among them and executed in
            parallel. For more information about this optimization, see
            <a class="xref" href="mysql-cluster.html#ndb_join_pushdown-conditions" title="Conditions for NDB pushdown joins">Conditions for NDB pushdown joins</a>,
        </p><p style="color:blue;">ndb cluster支持连接下推优化，通过该优化，合格的连接将整体发送到ndb cluster数据节点，在这些节点之间可以分布并并行执行。有关此优化的详细信息，请参见ndb下推联接的条件，</p><p></p><p>
            The main considerations for optimizing queries are:
        </p><p style="color:blue;">优化查询的主要考虑因素是：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To make a slow <code class="literal">SELECT ... WHERE</code> query
                    faster, the first thing to check is whether you can add an
                    <a class="link" href="glossary.html#glos_index" title="index">index</a>. Set up indexes on
                    columns used in the <code class="literal">WHERE</code> clause, to
                    speed up evaluation, filtering, and the final retrieval of
                    results. To avoid wasted disk space, construct a small set
                    of indexes that speed up many related queries used in your
                    application.
                </p><p style="color:blue;">做一个缓慢的选择…在查询速度更快的地方，首先要检查是否可以添加索引。在where子句中使用的列上设置索引，以加快计算、筛选和最终检索结果的速度。为了避免浪费磁盘空间，请构造一组索引，以加快应用程序中使用的许多相关查询。</p><p></p><p>
                    Indexes are especially important for queries that reference
                    different tables, using features such as
                    <a class="link" href="glossary.html#glos_join" title="join">joins</a> and
                    <a class="link" href="glossary.html#glos_foreign_key" title="foreign key">foreign keys</a>. You
                    can use the <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement
                    to determine which indexes are used for a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>. See
                    <a class="xref" href="optimization.html#mysql-indexes" title="8.3.1&nbsp;How MySQL Uses Indexes">Section&nbsp;8.3.1, “How MySQL Uses Indexes”</a> and
                    <a class="xref" href="optimization.html#using-explain" title="8.8.1&nbsp;Optimizing Queries with EXPLAIN">Section&nbsp;8.8.1, “Optimizing Queries with EXPLAIN”</a>.
                </p><p style="color:blue;">索引对于使用联接和外键等功能引用不同表的查询尤其重要。您可以使用explain语句来确定用于select的索引。参见第8.3.1节“MySQL如何使用索引”和第8.8.1节“使用explain优化查询”。</p><p></p></li><li class="listitem"><p>
                    Isolate and tune any part of the query, such as a function
                    call, that takes excessive time. Depending on how the query
                    is structured, a function could be called once for every row
                    in the result set, or even once for every row in the table,
                    greatly magnifying any inefficiency.
                </p><p style="color:blue;">隔离和优化查询的任何部分，如函数调用，这会占用大量时间。根据查询的结构，可以为结果集中的每一行调用一次函数，甚至为表中的每一行调用一次函数，这将大大提高效率。</p><p></p></li><li class="listitem"><p>
                    Minimize the number of
                    <a class="link" href="glossary.html#glos_full_table_scan" title="full table scan">full table scans</a>
                    in your queries, particularly for big tables.
                </p><p style="color:blue;">最小化查询中的完整表扫描数，特别是对于大表。</p><p></p></li><li class="listitem"><p>
                    Keep table statistics up to date by using the
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> statement
                    periodically, so the optimizer has the information needed to
                    construct an efficient execution plan.
                </p><p style="color:blue;">通过定期使用analyze table语句，使表统计信息保持最新，这样优化器就拥有了构建高效执行计划所需的信息。</p><p></p></li><li class="listitem"><p>
                    Learn the tuning techniques, indexing techniques, and
                    configuration parameters that are specific to the storage
                    engine for each table. Both <code class="literal">InnoDB</code> and
                    <code class="literal">MyISAM</code> have sets of guidelines for
                    enabling and sustaining high performance in queries. For
                    details, see <a class="xref" href="optimization.html#optimizing-innodb-queries" title="8.5.6&nbsp;Optimizing InnoDB Queries">Section&nbsp;8.5.6, “Optimizing InnoDB Queries”</a> and
                    <a class="xref" href="optimization.html#optimizing-queries-myisam" title="8.6.1&nbsp;Optimizing MyISAM Queries">Section&nbsp;8.6.1, “Optimizing MyISAM Queries”</a>.
                </p><p style="color:blue;">了解针对每个表的存储引擎所特有的优化技术、索引技术和配置参数。innodb和myisam都有一套指导方针来支持和维持查询的高性能。有关详细信息，请参阅第8.5.6节“优化innodb查询”和第8.6.1节“优化myisam查询”。</p><p></p></li><li class="listitem"><p>
                    You can optimize single-query transactions for
                    <code class="literal">InnoDB</code> tables, using the technique in
                    <a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3&nbsp;Optimizing InnoDB Read-Only Transactions">Section&nbsp;8.5.3, “Optimizing InnoDB Read-Only Transactions”</a>.
                </p><p style="color:blue;">您可以使用8.5.3节“优化InnoDB只读事务”中的技术为InnoDB表优化单查询事务。</p><p></p></li><li class="listitem"><p>
                    Avoid transforming the query in ways that make it hard to
                    understand, especially if the optimizer does some of the
                    same transformations automatically.
                </p><p style="color:blue;">避免以难以理解的方式转换查询，特别是如果优化器自动执行某些相同的转换。</p><p></p></li><li class="listitem"><p>
                    If a performance issue is not easily solved by one of the
                    basic guidelines, investigate the internal details of the
                    specific query by reading the
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> plan and adjusting
                    your indexes, <code class="literal">WHERE</code> clauses, join
                    clauses, and so on. (When you reach a certain level of
                    expertise, reading the
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> plan might be your
                    first step for every query.)
                </p><p style="color:blue;">如果某个性能问题不容易通过基本准则之一解决，请通过阅读解释计划并调整索引、where子句、join子句等来调查特定查询的内部详细信息。（当您达到一定的专业水平时，阅读解释计划可能是您每次查询的第一步。）</p><p></p></li><li class="listitem"><p>
                    Adjust the size and properties of the memory areas that
                    MySQL uses for caching. With efficient use of the
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>,
                    <code class="literal">MyISAM</code> key cache, and the MySQL query
                    cache, repeated queries run faster because the results are
                    retrieved from memory the second and subsequent times.
                </p><p style="color:blue;">调整mysql用于缓存的内存区域的大小和属性。通过有效地使用innodb缓冲池、myisam密钥缓存和mysql查询缓存，重复的查询运行得更快，因为第二次和随后的时间会从内存中检索结果。</p><p></p></li><li class="listitem"><p>
                    Even for a query that runs fast using the cache memory
                    areas, you might still optimize further so that they require
                    less cache memory, making your application more scalable.
                    Scalability means that your application can handle more
                    simultaneous users, larger requests, and so on without
                    experiencing a big drop in performance.
                </p><p style="color:blue;">即使对于使用缓存内存区域快速运行的查询，您仍然可以进一步优化，以便它们需要更少的缓存内存，从而使您的应用程序更具可伸缩性。可伸缩性意味着您的应用程序可以处理更多的同时用户、更大的请求等，而不会出现性能的大幅下降。</p><p></p></li><li class="listitem"><p>
                    Deal with locking issues, where the speed of your query
                    might be affected by other sessions accessing the tables at
                    the same time.
                </p><p style="color:blue;">处理锁定问题，其中查询的速度可能会受到同时访问表的其他会话的影响。</p><p></p></li></ul>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="where-optimization"></a>8.2.1.1&nbsp;WHERE Clause Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286876080624"></a><a class="indexterm" name="idm140286876079584"></a><p>
                This section discusses optimizations that can be made for
                processing <code class="literal">WHERE</code> clauses. The examples use
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, but the same
                optimizations apply for <code class="literal">WHERE</code> clauses in
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> and
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements.
            </p><p style="color:blue;">本节讨论可用于处理where子句的优化。这些示例使用select语句，但相同的优化也适用于delete和update语句中的where子句。</p><p></p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Because work on the MySQL optimizer is ongoing, not all of
                        the optimizations that MySQL performs are documented here.
                    </p><p style="color:blue;">因为mysql优化器的工作正在进行中，所以这里并没有记录mysql执行的所有优化。</p><p></p>
                </div>
                <p>
                    You might be tempted to rewrite your queries to make
                    arithmetic operations faster, while sacrificing readability.
                    Because MySQL does similar optimizations automatically, you
                    can often avoid this work, and leave the query in a more
                    understandable and maintainable form. Some of the
                    optimizations performed by MySQL follow:
                </p><p style="color:blue;">您可能会试图重写查询以使算术运算更快，同时牺牲可读性。因为mysql会自动执行类似的优化，所以您通常可以避免这项工作，并将查询保留在一个更易于理解和维护的表单中。mysql执行的一些优化如下：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Removal of unnecessary parentheses:
                    </p><p style="color:blue;">删除不必要的括号：</p><p></p><pre data-lang="sql" class="programlisting">   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&gt; (a AND b AND c) OR (a AND b AND c AND d)
</pre></li><li class="listitem"><p>
                        Constant folding:
                    </p><p style="color:blue;">不断折叠：</p><p></p><pre data-lang="sql" class="programlisting">   (a&lt;b AND b=c) AND a=5
-&gt; b&gt;5 AND b=c AND a=5
</pre></li><li class="listitem"><p>
                        Constant condition removal:
                    </p><p style="color:blue;">恒定条件去除：</p><p></p><pre data-lang="sql" class="programlisting">   (b&gt;=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
-&gt; b=5 OR b=6
</pre></li><li class="listitem"><p>
                        Constant expressions used by indexes are evaluated only
                        once.
                    </p><p style="color:blue;">索引使用的常量表达式只计算一次。</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_count"><code class="literal">COUNT(*)</code></a> on a single table
                        without a <code class="literal">WHERE</code> is retrieved directly
                        from the table information for <code class="literal">MyISAM</code>
                        and <code class="literal">MEMORY</code> tables. This is also done
                        for any <code class="literal">NOT NULL</code> expression when used
                        with only one table.
                    </p><p style="color:blue;">不带where的单个表上的count（*）直接从myisam和内存表的表信息中检索。当只与一个表一起使用时，这也适用于任何非空表达式。</p><p></p></li><li class="listitem"><p>
                        Early detection of invalid constant expressions. MySQL
                        quickly detects that some
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements are
                        impossible and returns no rows.
                    </p><p style="color:blue;">早期检测无效的常量表达式。mysql快速检测到某些select语句是不可能的，并且不返回任何行。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">HAVING</code> is merged with
                        <code class="literal">WHERE</code> if you do not use <code class="literal">GROUP
                        BY</code> or aggregate functions
                        (<a class="link" href="functions.html#function_count"><code class="literal">COUNT()</code></a>,
                        <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a>, and so on).
                    </p><p style="color:blue;">如果不使用GROUPBY或聚合函数（count（）、min（），等等），HAVING将与WHERE合并。</p><p></p></li><li class="listitem"><p>
                        For each table in a join, a simpler
                        <code class="literal">WHERE</code> is constructed to get a fast
                        <code class="literal">WHERE</code> evaluation for the table and also
                        to skip rows as soon as possible.
                    </p><p style="color:blue;">对于联接中的每个表，构造一个更简单的where，以获得表的快速where求值，并尽快跳过行。</p><p></p></li><li class="listitem"><p>
                        <a class="indexterm" name="idm140286876048384"></a>

                        <a class="indexterm" name="idm140286876047312"></a>

                        All constant tables are read first before any other tables
                        in the query. A constant table is any of the following:
                    </p><p style="color:blue;">在查询中的任何其他表之前，先读取所有常量表。常数表是下列任一项：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                An empty table or a table with one row.
                            </p><p style="color:blue;">一张空表或一行表。</p><p></p></li><li class="listitem"><p>
                                A table that is used with a <code class="literal">WHERE</code>
                                clause on a <code class="literal">PRIMARY KEY</code> or a
                                <code class="literal">UNIQUE</code> index, where all index parts
                                are compared to constant expressions and are defined
                                as <code class="literal">NOT NULL</code>.
                            </p><p style="color:blue;">与主键或唯一索引上的where子句一起使用的表，其中所有索引部分都与常量表达式进行比较，并定义为非空。</p><p></p></li></ul>
                        </div>
                        <p>
                            All of the following tables are used as constant tables:
                        </p><p style="color:blue;">以下所有表都用作常量表：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t WHERE <em class="replaceable"><code>primary_key</code></em>=1;
SELECT * FROM t1,t2
  WHERE t1.<em class="replaceable"><code>primary_key</code></em>=1 AND t2.<em class="replaceable"><code>primary_key</code></em>=t1.id;
</pre></li><li class="listitem"><p>
                        The best join combination for joining the tables is found
                        by trying all possibilities. If all columns in
                        <code class="literal">ORDER BY</code> and <code class="literal">GROUP
                        BY</code> clauses come from the same table, that table
                        is preferred first when joining.
                    </p><p style="color:blue;">通过尝试所有可能的方法，可以找到连接表的最佳连接组合。如果ORDERBY和GROUPBY子句中的所有列都来自同一个表，则在联接时首选该表。</p><p></p></li><li class="listitem"><p>
                        If there is an <code class="literal">ORDER BY</code> clause and a
                        different <code class="literal">GROUP BY</code> clause, or if the
                        <code class="literal">ORDER BY</code> or <code class="literal">GROUP BY</code>
                        contains columns from tables other than the first table in
                        the join queue, a temporary table is created.
                    </p><p style="color:blue;">如果存在ORDER BY子句和其他GROUP BY子句，或者ORDER BY或GROUP BY包含联接队列中第一个表以外的表中的列，则创建临时表。</p><p></p></li><li class="listitem"><p>
                        If you use the <code class="literal">SQL_SMALL_RESULT</code>
                        modifier, MySQL uses an in-memory temporary table.
                    </p><p style="color:blue;">如果使用sql_small_result修饰符，mysql将使用内存中的临时表。</p><p></p></li><li class="listitem"><p>
                        Each table index is queried, and the best index is used
                        unless the optimizer believes that it is more efficient to
                        use a table scan. At one time, a scan was used based on
                        whether the best index spanned more than 30% of the table,
                        but a fixed percentage no longer determines the choice
                        between using an index or a scan. The optimizer now is
                        more complex and bases its estimate on additional factors
                        such as table size, number of rows, and I/O block size.
                    </p><p style="color:blue;">查询每个表索引，并使用最佳索引，除非优化器认为使用表扫描更有效。有一次，使用扫描是基于最佳索引是否跨越了表的30%以上，但固定百分比不再决定使用索引还是扫描的选择。优化器现在更为复杂，它的估计基于其他因素，如表大小、行数和I/O块大小。</p><p></p></li><li class="listitem"><p>
                        In some cases, MySQL can read rows from the index without
                        even consulting the data file. If all columns used from
                        the index are numeric, only the index tree is used to
                        resolve the query.
                    </p><p style="color:blue;">在某些情况下，mysql甚至可以在不查阅数据文件的情况下从索引中读取行。如果索引中使用的所有列都是数字，则仅使用索引树来解析查询。</p><p></p></li><li class="listitem"><p>
                        Before each row is output, those that do not match the
                        <code class="literal">HAVING</code> clause are skipped.
                    </p><p style="color:blue;">在输出每一行之前，将跳过那些与HAVING子句不匹配的行。</p><p></p></li></ul>
                </div>
                <p>
                    Some examples of queries that are very fast:
                </p><p style="color:blue;">一些非常快速的查询示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT COUNT(*) FROM <em class="replaceable"><code>tbl_name</code></em>;

SELECT MIN(<em class="replaceable"><code>key_part1</code></em>),MAX(<em class="replaceable"><code>key_part1</code></em>) FROM <em class="replaceable"><code>tbl_name</code></em>;

SELECT MAX(<em class="replaceable"><code>key_part2</code></em>) FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>constant</code></em>;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... LIMIT 10;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC, ... LIMIT 10;
</pre><p>
                MySQL resolves the following queries using only the index
                tree, assuming that the indexed columns are numeric:
            </p><p style="color:blue;">mysql仅使用索引树解析以下查询，假设索引列是数字的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>val</code></em>;

SELECT COUNT(*) FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>val1</code></em> AND <em class="replaceable"><code>key_part2</code></em>=<em class="replaceable"><code>val2</code></em>;

SELECT <em class="replaceable"><code>key_part2</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> GROUP BY <em class="replaceable"><code>key_part1</code></em>;
</pre><p>
                The following queries use indexing to retrieve the rows in
                sorted order without a separate sorting pass:
            </p><p style="color:blue;">以下查询使用索引来检索排序顺序的行，而不需要单独的排序传递：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... ;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC, ... ;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="range-optimization"></a>8.2.1.2&nbsp;Range Optimization</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a> access method
                    uses a single index to retrieve a subset of table rows that
                    are contained within one or several index value intervals. It
                    can be used for a single-part or multiple-part index. The
                    following sections describe conditions under which the
                    optimizer uses range access.
                </p><p style="color:blue;">range访问方法使用单个索引来检索包含在一个或多个索引值间隔内的表行子集。它可以用于单个部分或多个部分索引。以下部分描述优化器使用范围访问的条件。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#range-access-single-part" title="Range Access Method for Single-Part Indexes">Range Access Method for Single-Part Indexes</a></p><p style="color:blue;">单部分索引的范围访问方法</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#range-access-multi-part" title="Range Access Method for Multiple-Part Indexes">Range Access Method for Multiple-Part Indexes</a></p><p style="color:blue;">多部分索引的范围访问方法</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#equality-range-optimization" title="Equality Range Optimization of Many-Valued Comparisons">Equality Range Optimization of Many-Valued Comparisons</a></p><p style="color:blue;">多值比较的等式范围优化</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#row-constructor-range-optimization" title="Range Optimization of Row Constructor Expressions">Range Optimization of Row Constructor Expressions</a></p><p style="color:blue;">行构造函数表达式的范围优化</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#range-optimization-memory-use" title="Limiting Memory Use for Range Optimization">Limiting Memory Use for Range Optimization</a></p><p style="color:blue;">限制用于范围优化的内存使用</p><p></p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="range-access-single-part"></a>Range Access Method for Single-Part Indexes</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        For a single-part index, index value intervals can be
                        conveniently represented by corresponding conditions in the
                        <code class="literal">WHERE</code> clause, denoted as
                        <span class="firstterm">range conditions</span>
                        rather than <span class="quote">“<span class="quote">intervals.</span>”</span>
                    </p><p style="color:blue;">对于单个部分索引，索引值间隔可以方便地用where子句中的相应条件表示，表示为范围条件而不是“间隔”。</p><p></p><p>
                    The definition of a range condition for a single-part index
                    is as follows:
                </p><p style="color:blue;">单个部件索引的范围条件定义如下：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            For both <code class="literal">BTREE</code> and
                            <code class="literal">HASH</code> indexes, comparison of a key
                            part with a constant value is a range condition when
                            using the
                            <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a>,
                            <a class="link" href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
                            <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a>, <a class="link" href="functions.html#operator_is-null"><code class="literal">IS
                            NULL</code></a>, or <a class="link" href="functions.html#operator_is-not-null"><code class="literal">IS NOT
                            NULL</code></a> operators.
                        </p><p style="color:blue;">对于btree和hash索引，当使用=、&lt;=&gt;、in（）、is null或is not null运算符时，键部分与常量值的比较是一个范围条件。</p><p></p></li><li class="listitem"><p>
                            Additionally, for <code class="literal">BTREE</code> indexes,
                            comparison of a key part with a constant value is a
                            range condition when using the
                            <a class="link" href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
                            <a class="link" href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
                            <a class="link" href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
                            <a class="link" href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
                            <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>,
                            <a class="link" href="functions.html#operator_not-equal"><code class="literal">!=</code></a>,
                            or
                            <a class="link" href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>
                            operators, or <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a>
                            comparisons if the argument to
                            <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> is a constant string
                            that does not start with a wildcard character.
                        </p><p style="color:blue;">此外，对于btree索引，当使用&gt;、&lt;、&gt;=、&lt;=、between时，键部分与常量值的比较是一个范围条件！=，或&lt;&gt;运算符，或like比较（如果like的参数不是以通配符开头的常量字符串）。</p><p></p></li><li class="listitem"><p>
                            For all index types, multiple range conditions combined
                            with <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a> or
                            <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a> form a range condition.
                        </p><p style="color:blue;">对于所有索引类型，多个范围条件与或组合在一起，形成一个范围条件。</p><p></p></li></ul>
                    </div>
                    <p>
                        <span class="quote">“<span class="quote">Constant value</span>”</span> in the preceding descriptions
                        means one of the following:
                    </p><p style="color:blue;">上述“定值”是指下列各项之一：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A constant from the query string
                        </p><p style="color:blue;">查询字符串中的常量</p><p></p></li><li class="listitem"><p>
                            A column of a <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a>
                            or <a class="link" href="optimization.html#jointype_system"><code class="literal">system</code></a> table from
                            the same join
                        </p><p style="color:blue;">同一联接中的常量或系统表的列</p><p></p></li><li class="listitem"><p>
                            The result of an uncorrelated subquery
                        </p><p style="color:blue;">不相关子查询的结果</p><p></p></li><li class="listitem"><p>
                            Any expression composed entirely from subexpressions of
                            the preceding types
                        </p><p style="color:blue;">完全由前面类型的子表达式组成的任何表达式</p><p></p></li></ul>
                    </div>
                    <p>
                        Here are some examples of queries with range conditions in
                        the <code class="literal">WHERE</code> clause:
                    </p><p style="color:blue;">以下是在where子句中使用范围条件的一些查询示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> &gt; 1
  AND <em class="replaceable"><code>key_col</code></em> &lt; 10;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> = 1
  OR <em class="replaceable"><code>key_col</code></em> IN (15,18,20);

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'ab%'
  OR <em class="replaceable"><code>key_col</code></em> BETWEEN 'bar' AND 'foo';
</pre><p>
                    Some nonconstant values may be converted to constants during
                    the optimizer constant propagation phase.
                </p><p style="color:blue;">在优化器常量传播阶段，一些非常量值可能会转换为常量。</p><p></p><p>
                    MySQL tries to extract range conditions from the
                    <code class="literal">WHERE</code> clause for each of the possible
                    indexes. During the extraction process, conditions that
                    cannot be used for constructing the range condition are
                    dropped, conditions that produce overlapping ranges are
                    combined, and conditions that produce empty ranges are
                    removed.
                </p><p style="color:blue;">mysql尝试从where子句中为每个可能的索引提取范围条件。在提取过程中，将删除不能用于构造范围条件的条件，合并产生重叠范围的条件，并删除产生空范围的条件。</p><p></p><p>
                    Consider the following statement, where
                    <code class="literal">key1</code> is an indexed column and
                    <code class="literal">nonkey</code> is not indexed:
                </p><p style="color:blue;">考虑下面的语句，其中key1是一个索引列，而nonkey没有索引：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE
  (key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 &lt; 'bar' AND nonkey = 4) OR
  (key1 &lt; 'uux' AND key1 &gt; 'z');
</pre><p>
                    The extraction process for key <code class="literal">key1</code> is as
                    follows:
                </p><p style="color:blue;">密钥key1的提取过程如下：</p><p></p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Start with original <code class="literal">WHERE</code> clause:
                        </p><p style="color:blue;">从原始where子句开始：</p><p></p><pre data-lang="sql" class="programlisting">(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 &lt; 'bar' AND nonkey = 4) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li><li class="listitem"><p>
                            Remove <code class="literal">nonkey = 4</code> and <code class="literal">key1
                            LIKE '%b'</code> because they cannot be used for a
                            range scan. The correct way to remove them is to replace
                            them with <code class="literal">TRUE</code>, so that we do not
                            miss any matching rows when doing the range scan.
                            Replacing them with <code class="literal">TRUE</code> yields:
                        </p><p style="color:blue;">删除nonkey=4和key1，如'%b'，因为它们不能用于范围扫描。删除它们的正确方法是将它们替换为true，以便在执行范围扫描时不会遗漏任何匹配的行。用真实收益率代替它们：</p><p></p><pre data-lang="sql" class="programlisting">(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 &lt; 'bar' AND TRUE) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li><li class="listitem"><p>
                            Collapse conditions that are always true or false:
                        </p><p style="color:blue;">总是正确或错误的折叠条件：</p><p></p>
                            <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                    <code class="literal">(key1 LIKE 'abcde%' OR TRUE)</code> is
                                    always true
                                </p><p style="color:blue;">（key1如'abcde%'或true）始终为true</p><p></p></li><li class="listitem"><p>
                                    <code class="literal">(key1 &lt; 'uux' AND key1 &gt;
                                        'z')</code> is always false
                                </p><p style="color:blue;">（key1&lt;'uux'和key1&gt;'z'）始终为false</p><p></p></li></ul>
                            </div>
                            <p>
                                Replacing these conditions with constants yields:
                            </p><p style="color:blue;">用常数替换这些条件会产生：</p><p></p><pre data-lang="clike" class="programlisting">(key1 &lt; 'abc' AND TRUE) OR (key1 &lt; 'bar' AND TRUE) OR (FALSE)
</pre><p>
                                Removing unnecessary <code class="literal">TRUE</code> and
                                <code class="literal">FALSE</code> constants yields:
                            </p><p style="color:blue;">删除不必要的真和假常量会产生：</p><p></p><pre data-lang="clike" class="programlisting">(key1 &lt; 'abc') OR (key1 &lt; 'bar')
</pre></li><li class="listitem"><p>
                            Combining overlapping intervals into one yields the
                            final condition to be used for the range scan:
                        </p><p style="color:blue;">将重叠间隔合并为一个间隔可得到用于范围扫描的最终条件：</p><p></p><pre data-lang="clike" class="programlisting">(key1 &lt; 'bar')
</pre></li></ol>
                    </div>
                    <p>
                        In general (and as demonstrated by the preceding example),
                        the condition used for a range scan is less restrictive than
                        the <code class="literal">WHERE</code> clause. MySQL performs an
                        additional check to filter out rows that satisfy the range
                        condition but not the full <code class="literal">WHERE</code> clause.
                    </p><p style="color:blue;">一般来说（如前一个示例所示），范围扫描使用的条件比where子句的限制性更小。mysql执行一个额外的检查，以筛选出满足范围条件但不满足完整where子句的行。</p><p></p><p>
                    The range condition extraction algorithm can handle nested
                    <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a>/<a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a>
                    constructs of arbitrary depth, and its output does not
                    depend on the order in which conditions appear in
                    <code class="literal">WHERE</code> clause.
                </p><p style="color:blue;">范围条件提取算法可以处理任意深度的嵌套和/或构造，其输出不取决于条件在where子句中出现的顺序。</p><p></p><p>
                    MySQL does not support merging multiple ranges for the
                    <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a> access method for
                    spatial indexes. To work around this limitation, you can use
                    a <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> with identical
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, except
                    that you put each spatial predicate in a different
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>.
                </p><p style="color:blue;">对于空间索引的范围访问方法，mysql不支持合并多个范围。要解决此限制，可以使用具有相同select语句的并集，但将每个空间谓词放在不同的select中除外。</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="range-access-multi-part"></a>Range Access Method for Multiple-Part Indexes</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Range conditions on a multiple-part index are an extension
                        of range conditions for a single-part index. A range
                        condition on a multiple-part index restricts index rows to
                        lie within one or several key tuple intervals. Key tuple
                        intervals are defined over a set of key tuples, using
                        ordering from the index.
                    </p><p style="color:blue;">多部分索引上的范围条件是单个部分索引的范围条件的扩展。多部分索引上的范围条件限制索引行位于一个或多个键元组间隔内。键元组间隔是在一组键元组上定义的，使用索引中的排序。</p><p></p><p>
                    For example, consider a multiple-part index defined as
                    <code class="literal">key1(<em class="replaceable"><code>key_part1</code></em>,
                        <em class="replaceable"><code>key_part2</code></em>,
                        <em class="replaceable"><code>key_part3</code></em>)</code>, and the
                    following set of key tuples listed in key order:
                </p><p style="color:blue;">例如，考虑定义为key1的多部分索引（key_part1、key_part2、key_part3）和以下按键顺序列出的键元组集：</p><p></p><pre data-lang="clike" class="programlisting"><em class="replaceable"><code>key_part1</code></em>  <em class="replaceable"><code>key_part2</code></em>  <em class="replaceable"><code>key_part3</code></em>
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
</pre><p>
                    The condition <code class="literal"><em class="replaceable"><code>key_part1</code></em>
                    = 1</code> defines this interval:
                </p><p style="color:blue;">条件键_part1=1定义此间隔：</p><p></p><pre data-lang="clike" class="programlisting">(1,-inf,-inf) &lt;= (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,<em class="replaceable"><code>key_part3</code></em>) &lt; (1,+inf,+inf)
</pre><p>
                    The interval covers the 4th, 5th, and 6th tuples in the
                    preceding data set and can be used by the range access
                    method.
                </p><p style="color:blue;">间隔覆盖了前面数据集中的第4、第5和第6个元组，可由范围访问方法使用。</p><p></p><p>
                    By contrast, the condition
                    <code class="literal"><em class="replaceable"><code>key_part3</code></em> =
                        'abc'</code> does not define a single interval and cannot
                    be used by the range access method.
                </p><p style="color:blue;">相比之下，条件键“part3=”abc“不定义单个间隔，不能由范围访问方法使用。</p><p></p><p>
                    The following descriptions indicate how range conditions
                    work for multiple-part indexes in greater detail.
                </p><p style="color:blue;">下面的描述将更详细地说明范围条件如何适用于多个零件索引。</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            For <code class="literal">HASH</code> indexes, each interval
                            containing identical values can be used. This means that
                            the interval can be produced only for conditions in the
                            following form:
                        </p><p style="color:blue;">对于哈希索引，可以使用包含相同值的每个间隔。这意味着，只能在以下条件下生成间隔：</p><p></p><pre data-lang="sql" class="programlisting">    <em class="replaceable"><code>key_part1</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>const1</code></em>
AND <em class="replaceable"><code>key_part2</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>const2</code></em>
AND ...
AND <em class="replaceable"><code>key_partN</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>constN</code></em>;
</pre><p>
                            Here, <em class="replaceable"><code>const1</code></em>,
                            <em class="replaceable"><code>const2</code></em>, … are
                            constants, <em class="replaceable"><code>cmp</code></em> is one of the
                            <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a>,
                            <a class="link" href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
                            or <a class="link" href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a> comparison
                            operators, and the conditions cover all index parts.
                            (That is, there are <em class="replaceable"><code>N</code></em>
                            conditions, one for each part of an
                            <em class="replaceable"><code>N</code></em>-part index.) For example,
                            the following is a range condition for a three-part
                            <code class="literal">HASH</code> index:
                        </p><p style="color:blue;">这里，const1，const2，…是常量，cmp是=，&lt;=&gt;或是空比较运算符之一，并且条件覆盖所有索引部分。（即，存在n个条件，n部分索引的每个部分对应一个条件。）例如，以下是三部分哈希索引的范围条件：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>key_part1</code></em> = 1 AND <em class="replaceable"><code>key_part2</code></em> IS NULL AND <em class="replaceable"><code>key_part3</code></em> = 'foo'
</pre><p>
                            For the definition of what is considered to be a
                            constant, see
                            <a class="xref" href="optimization.html#range-access-single-part" title="Range Access Method for Single-Part Indexes">Range Access Method for Single-Part Indexes</a>.
                        </p><p style="color:blue;">有关被视为常量的定义，请参见单部分索引的范围访问方法。</p><p></p></li><li class="listitem"><p>
                            For a <code class="literal">BTREE</code> index, an interval might
                            be usable for conditions combined with
                            <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a>, where each condition
                            compares a key part with a constant value using
                            <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a>,
                            <a class="link" href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
                            <a class="link" href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a>,
                            <a class="link" href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
                            <a class="link" href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
                            <a class="link" href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
                            <a class="link" href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
                            <a class="link" href="functions.html#operator_not-equal"><code class="literal">!=</code></a>,
                            <a class="link" href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>,
                            <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>, or
                            <a class="link" href="functions.html#operator_like"><code class="literal">LIKE
                                '<em class="replaceable"><code>pattern</code></em>'</code></a> (where
                            <code class="literal">'<em class="replaceable"><code>pattern</code></em>'</code>
                            does not start with a wildcard). An interval can be used
                            as long as it is possible to determine a single key
                            tuple containing all rows that match the condition (or
                            two intervals if
                            <a class="link" href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>
                            or <a class="link" href="functions.html#operator_not-equal"><code class="literal">!=</code></a>
                            is used).
                        </p><p style="color:blue;">对于btree索引，间隔可能可用于与和组合的条件，其中每个条件使用=，&lt;=&gt;，将关键部分与常量值进行比较，即为空，&gt;，&lt;，&gt;=，&lt;=，！=、&lt;&gt;、介于或类似于“pattern”（其中“pattern”不以通配符开头）。只要能够确定包含与条件匹配的所有行的单键元组，就可以使用间隔（如果&lt;&gt;或，则可以使用两个间隔！=已使用）。</p><p></p><p>
                            The optimizer attempts to use additional key parts to
                            determine the interval as long as the comparison
                            operator is
                            <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a>,
                            <a class="link" href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
                            or <a class="link" href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a>. If the operator
                            is
                            <a class="link" href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
                            <a class="link" href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
                            <a class="link" href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
                            <a class="link" href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
                            <a class="link" href="functions.html#operator_not-equal"><code class="literal">!=</code></a>,
                            <a class="link" href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>,
                            <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>, or
                            <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a>, the
                            optimizer uses it but considers no more key parts. For
                            the following expression, the optimizer uses
                            <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a> from
                            the first comparison. It also uses
                            <a class="link" href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>
                            from the second comparison but considers no further key
                            parts and does not use the third comparison for interval
                            construction:
                        </p><p style="color:blue;">只要比较运算符为=、&lt;=&gt;或为空，优化器就会尝试使用其他关键部分来确定间隔。如果操作员是&gt;，&lt;，&gt;=，&lt;=，！=，&lt;&gt;，介于或类似，优化器使用它，但不考虑更多的关键部分。对于下面的表达式，优化器使用第一个比较中的。它还使用第二次比较中的&gt;=但不考虑其他关键部分，也不使用第三次比较进行区间构造：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>key_part1</code></em> = 'foo' AND <em class="replaceable"><code>key_part2</code></em> &gt;= 10 AND <em class="replaceable"><code>key_part3</code></em> &gt; 10
</pre><p>
                            The single interval is:
                        </p><p style="color:blue;">单个间隔是：</p><p></p><pre data-lang="sql" class="programlisting">('foo',10,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,<em class="replaceable"><code>key_part3</code></em>) &lt; ('foo',+inf,+inf)
</pre><p>
                            It is possible that the created interval contains more
                            rows than the initial condition. For example, the
                            preceding interval includes the value <code class="literal">('foo',
                            11, 0)</code>, which does not satisfy the original
                            condition.
                        </p><p style="color:blue;">创建的间隔可能包含的行数多于初始条件。例如，前面的间隔包括不满足原始条件的值（'foo'，11，0）。</p><p></p></li><li class="listitem"><p>
                            If conditions that cover sets of rows contained within
                            intervals are combined with
                            <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a>, they form a condition
                            that covers a set of rows contained within the union of
                            their intervals. If the conditions are combined with
                            <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a>, they form a condition
                            that covers a set of rows contained within the
                            intersection of their intervals. For example, for this
                            condition on a two-part index:
                        </p><p style="color:blue;">如果覆盖间隔内包含的行集合的条件与或组合在一起，则它们构成覆盖间隔并集内包含的行集合的条件。如果这些条件与和组合在一起，则它们将形成一个条件，该条件覆盖包含在其间隔相交处的一组行。例如，对于两部分索引的这种情况：</p><p></p><pre data-lang="sql" class="programlisting">(<em class="replaceable"><code>key_part1</code></em> = 1 AND <em class="replaceable"><code>key_part2</code></em> &lt; 2) OR (<em class="replaceable"><code>key_part1</code></em> &gt; 5)
</pre><p>
                            The intervals are:
                        </p><p style="color:blue;">间隔为：</p><p></p><pre data-lang="sql" class="programlisting">(1,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>) &lt; (1,2)
(5,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>)
</pre><p>
                            In this example, the interval on the first line uses one
                            key part for the left bound and two key parts for the
                            right bound. The interval on the second line uses only
                            one key part. The <code class="literal">key_len</code> column in
                            the <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output
                            indicates the maximum length of the key prefix used.
                        </p><p style="color:blue;">在本例中，第一行的间隔使用一个键部分作为左边界，使用两个键部分作为右边界。第二行的间隔只使用一个关键部分。explain输出中的key_len列指示使用的密钥前缀的最大长度。</p><p></p><p>
                            In some cases, <code class="literal">key_len</code> may indicate
                            that a key part was used, but that might be not what you
                            would expect. Suppose that
                            <em class="replaceable"><code>key_part1</code></em> and
                            <em class="replaceable"><code>key_part2</code></em> can be
                            <code class="literal">NULL</code>. Then the
                            <code class="literal">key_len</code> column displays two key part
                            lengths for the following condition:
                        </p><p style="color:blue;">在某些情况下，key_len可能表示使用了密钥部分，但这可能不是您所期望的。假设key_part1和key_part2可以为空。在下列情况下，“关键长度”列将显示两个关键零件长度：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>key_part1</code></em> &gt;= 1 AND <em class="replaceable"><code>key_part2</code></em> &lt; 2
</pre><p>
                            But, in fact, the condition is converted to this:
                        </p><p style="color:blue;">但是，事实上，条件转换为：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>key_part1</code></em> &gt;= 1 AND <em class="replaceable"><code>key_part2</code></em> IS NOT NULL
</pre></li></ul>
                    </div>
                    <p>
                        For a description of how optimizations are performed to
                        combine or eliminate intervals for range conditions on a
                        single-part index, see
                        <a class="xref" href="optimization.html#range-access-single-part" title="Range Access Method for Single-Part Indexes">Range Access Method for Single-Part Indexes</a>. Analogous steps
                        are performed for range conditions on multiple-part indexes.
                    </p><p style="color:blue;">有关如何执行优化以合并或消除单个部分索引上范围条件的间隔的说明，请参见单个部分索引的范围访问方法。对多个部分索引的范围条件执行类似的步骤。</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="equality-range-optimization"></a>Equality Range Optimization of Many-Valued Comparisons</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Consider these expressions, where
                        <em class="replaceable"><code>col_name</code></em> is an indexed column:
                    </p><p style="color:blue;">考虑这些表达式，其中col_name是一个索引列：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>col_name</code></em> IN(<em class="replaceable"><code>val1</code></em>, ..., <em class="replaceable"><code>valN</code></em>)
<em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>val1</code></em> OR ... OR <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>valN</code></em>
</pre><p>
                    Each expression is true if
                    <em class="replaceable"><code>col_name</code></em> is equal to any of
                    several values. These comparisons are equality range
                    comparisons (where the <span class="quote">“<span class="quote">range</span>”</span> is a single
                    value). The optimizer estimates the cost of reading
                    qualifying rows for equality range comparisons as follows:
                </p><p style="color:blue;">如果col_name等于多个值中的任何一个，则每个表达式都为true。这些比较是相等范围比较（其中“范围”是单个值）。优化器估计读取符合条件的行进行相等范围比较的成本，如下所示：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            If there is a unique index on
                            <em class="replaceable"><code>col_name</code></em>, the row estimate
                            for each range is 1 because at most one row can have the
                            given value.
                        </p><p style="color:blue;">如果列名称上有唯一索引，则每个范围的行估计值为1，因为最多有一行可以具有给定值。</p><p></p></li><li class="listitem"><p>
                            Otherwise, any index on
                            <em class="replaceable"><code>col_name</code></em> is nonunique and the
                            optimizer can estimate the row count for each range
                            using dives into the index or index statistics.
                        </p><p style="color:blue;">否则，col_name上的任何索引都是非唯一的，优化器可以使用deep into the index或index statistics估计每个范围的行数。</p><p></p></li></ul>
                    </div>
                    <a class="indexterm" name="idm140286875811248"></a><p>
                    With index dives, the optimizer makes a dive at each end of
                    a range and uses the number of rows in the range as the
                    estimate. For example, the expression
                    <code class="literal"><em class="replaceable"><code>col_name</code></em> IN (10, 20,
                        30)</code> has three equality ranges and the optimizer
                    makes two dives per range to generate a row estimate. Each
                    pair of dives yields an estimate of the number of rows that
                    have the given value.
                </p><p style="color:blue;">使用index dive，优化器在范围的每一端进行一次跳水，并使用范围中的行数作为估计值。例如，（10，20，30）中的表达式col_name有三个相等范围，优化器对每个范围进行两次潜水以生成行估计。每一对潜水都会产生具有给定值的行数的估计值。</p><p></p><p>
                    Index dives provide accurate row estimates, but as the
                    number of comparison values in the expression increases, the
                    optimizer takes longer to generate a row estimate. Use of
                    index statistics is less accurate than index dives but
                    permits faster row estimation for large value lists.
                </p><p style="color:blue;">indexdive提供准确的行估计，但是随着表达式中比较值的数量增加，优化器生成行估计所需的时间会更长。使用索引统计信息的准确性不如索引分解，但允许对大型值列表进行更快的行估计。</p><p></p><p>
                    The
                    <a class="link" href="server-administration.html#sysvar_eq_range_index_dive_limit"><code class="literal">eq_range_index_dive_limit</code></a>
                    system variable enables you to configure the number of
                    values at which the optimizer switches from one row
                    estimation strategy to the other. To permit use of index
                    dives for comparisons of up to <em class="replaceable"><code>N</code></em>
                    equality ranges, set
                    <a class="link" href="server-administration.html#sysvar_eq_range_index_dive_limit"><code class="literal">eq_range_index_dive_limit</code></a>
                    to <em class="replaceable"><code>N</code></em> + 1. To disable use of
                    statistics and always use index dives regardless of
                    <em class="replaceable"><code>N</code></em>, set
                    <a class="link" href="server-administration.html#sysvar_eq_range_index_dive_limit"><code class="literal">eq_range_index_dive_limit</code></a>
                    to 0.
                </p><p style="color:blue;">eq_range_index_dive_limit系统变量允许您配置优化器从一个行估计策略切换到另一个行估计策略时的值数。若要允许使用索引俯冲来比较最多n个相等范围，请将eq_range_index_dive_limit设置为n+1。若要禁用统计信息的使用并始终使用索引潜水，而不考虑n，请将eq_range_index_dive_limit设置为0。</p><p></p><p>
                    To update table index statistics for best estimates, use
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>.
                </p><p style="color:blue;">要更新表索引统计信息以获得最佳估计值，请使用analyze table。</p><p></p><p>
                    Even under conditions when index dives would otherwise be
                    used, they are skipped for queries that satisfy all these
                    conditions:
                </p><p style="color:blue;">即使在使用索引dive的情况下，也会跳过满足所有这些条件的查询：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A single-index <code class="literal">FORCE INDEX</code> index hint
                            is present. The idea is that if index use is forced,
                            there is nothing to be gained from the additional
                            overhead of performing dives into the index.
                        </p><p style="color:blue;">存在单个索引强制索引索引提示。其想法是，如果强制使用指数，那么从对指数进行跳水的额外开销中不会获得任何收益。</p><p></p></li><li class="listitem"><p>
                            The index is nonunique and not a
                            <code class="literal">FULLTEXT</code> index.
                        </p><p style="color:blue;">索引不统一，不是全文索引。</p><p></p></li><li class="listitem"><p>
                            No subquery is present.
                        </p><p style="color:blue;">不存在子查询。</p><p></p></li><li class="listitem"><p>
                            No <code class="literal">DISTINCT</code>, <code class="literal">GROUP
                            BY</code>, or <code class="literal">ORDER BY</code> clause is
                            present.
                        </p><p style="color:blue;">不存在DISTINCT、GROUPBY或ORDER BY子句。</p><p></p></li></ul>
                    </div>
                    <p>
                        Those dive-skipping conditions apply only for single-table
                        queries. Index dives are not skipped for multiple-table
                        queries (joins).
                    </p><p style="color:blue;">这些跳转条件仅适用于单表查询。对于多个表查询（联接），不跳过索引剥离。</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="row-constructor-range-optimization"></a>Range Optimization of Row Constructor Expressions</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The optimizer is able to apply the range scan access method
                        to queries of this form:
                    </p><p style="color:blue;">优化器可以将范围扫描访问方法应用于此表单的查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( 'a', 'b' ), ( 'c', 'd' ));
</pre><p>
                    Previously, for range scans to be used, it was necessary to
                    write the query as:
                </p><p style="color:blue;">以前，要使用范围扫描，必须将查询编写为：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ... FROM t1 WHERE ( col_1 = 'a' AND col_2 = 'b' )
OR ( col_1 = 'c' AND col_2 = 'd' );
</pre><p>
                    For the optimizer to use a range scan, queries must satisfy
                    these conditions:
                </p><p style="color:blue;">要使优化器使用范围扫描，查询必须满足以下条件：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Only <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a> predicates are
                            used, not <a class="link" href="functions.html#operator_not-in"><code class="literal">NOT IN()</code></a>.
                        </p><p style="color:blue;">只使用in（）谓词，不使用in（）。</p><p></p></li><li class="listitem"><p>
                            On the left side of the
                            <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a> predicate, the row
                            constructor contains only column references.
                        </p><p style="color:blue;">在in（）谓词的左侧，行构造函数只包含列引用。</p><p></p></li><li class="listitem"><p>
                            On the right side of the
                            <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a> predicate, row
                            constructors contain only runtime constants, which are
                            either literals or local column references that are
                            bound to constants during execution.
                        </p><p style="color:blue;">在in（）谓词的右侧，行构造函数只包含运行时常量，这些常量是在执行期间绑定到常量的文本或本地列引用。</p><p></p></li><li class="listitem"><p>
                            On the right side of the
                            <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a> predicate, there is
                            more than one row constructor.
                        </p><p style="color:blue;">在in（）谓词的右侧，有多个行构造函数。</p><p></p></li></ul>
                    </div>
                    <p>
                        For more information about the optimizer and row
                        constructors, see
                        <a class="xref" href="optimization.html#row-constructor-optimization" title="8.2.1.19&nbsp;Row Constructor Expression Optimization">Section&nbsp;8.2.1.19, “Row Constructor Expression Optimization”</a>
                    </p><p style="color:blue;">有关优化器和行构造函数的更多信息，请参阅8.2.1.19节，“行构造函数表达式优化”</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="range-optimization-memory-use"></a>Limiting Memory Use for Range Optimization</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To control the memory available to the range optimizer, use
                        the
                        <a class="link" href="server-administration.html#sysvar_range_optimizer_max_mem_size"><code class="literal">range_optimizer_max_mem_size</code></a>
                        system variable:
                    </p><p style="color:blue;">要控制范围优化器可用的内存，请使用range_optimizer_max_mem_size系统变量：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A value of 0 means <span class="quote">“<span class="quote">no limit.</span>”</span>
                        </p><p style="color:blue;">值为0表示“无限制”。</p><p></p></li><li class="listitem"><p>
                            With a value greater than 0, the optimizer tracks the
                            memory consumed when considering the range access
                            method. If the specified limit is about to be exceeded,
                            the range access method is abandoned and other methods,
                            including a full table scan, are considered instead.
                            This could be less optimal. If this happens, the
                            following warning occurs (where
                            <em class="replaceable"><code>N</code></em> is the current
                            <a class="link" href="server-administration.html#sysvar_range_optimizer_max_mem_size"><code class="literal">range_optimizer_max_mem_size</code></a>
                            value):
                        </p><p style="color:blue;">如果值大于0，优化器将在考虑范围访问方法时跟踪消耗的内存。如果即将超过指定的限制，则放弃范围访问方法，而考虑其他方法，包括完整表扫描。这可能不太理想。如果发生这种情况，将出现以下警告（其中n是当前范围优化器最大内存大小值）：</p><p></p><pre data-lang="none" class="programlisting">Warning    3170    Memory capacity of <em class="replaceable"><code>N</code></em> bytes for
                   'range_optimizer_max_mem_size' exceeded. Range
                   optimization was not done for this query.
</pre></li><li class="listitem"><p>
                            For <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> and
                            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements, if the
                            optimizer falls back to a full table scan and the
                            <a class="link" href="server-administration.html#sysvar_sql_safe_updates"><code class="literal">sql_safe_updates</code></a> system
                            variable is enabled, an error occurs rather than a
                            warning because, in effect, no key is used to determine
                            which rows to modify. For more information, see
                            <a class="xref" href="programs.html#safe-updates" title="Using Safe-Updates Mode (--safe-updates)">Using Safe-Updates Mode (--safe-updates)</a>.
                        </p><p style="color:blue;">对于UPDATE和DELETE语句，如果优化器返回到完整表扫描，并且启用了SQL SAFE U UPDATES系统变量，则会发生错误而不是警告，因为实际上没有使用键来确定要修改哪些行。有关详细信息，请参见使用安全更新模式（--safe updates）。</p><p></p></li></ul>
                    </div>
                    <p>
                        For individual queries that exceed the available range
                        optimization memory and for which the optimizer falls back
                        to less optimal plans, increasing the
                        <a class="link" href="server-administration.html#sysvar_range_optimizer_max_mem_size"><code class="literal">range_optimizer_max_mem_size</code></a>
                        value may improve performance.
                    </p><p style="color:blue;">对于超出可用范围优化内存且优化器返回到不太优化的计划的单个查询，增加范围优化器最大内存大小值可能会提高性能。</p><p></p><p>
                    To estimate the amount of memory needed to process a range
                    expression, use these guidelines:
                </p><p style="color:blue;">要估计处理范围表达式所需的内存量，请使用以下准则：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            For a simple query such as the following, where there is
                            one candidate key for the range access method, each
                            predicate combined with <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a>
                            uses approximately 230 bytes:
                        </p><p style="color:blue;">对于一个简单的查询，如以下，在范围访问方法中有一个候选关键字，每个谓词结合或使用大约230个字节：</p><p></p><pre data-lang="sql" class="programlisting">SELECT COUNT(*) FROM t
WHERE a=1 OR a=2 OR a=3 OR .. . a=<em class="replaceable"><code>N</code></em>;
</pre></li><li class="listitem"><p>
                            Similarly for a query such as the following, each
                            predicate combined with <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a>
                            uses approximately 125 bytes:
                        </p><p style="color:blue;">类似地，对于如下的查询，每个谓词结合并使用大约125字节：</p><p></p><pre data-lang="sql" class="programlisting">SELECT COUNT(*) FROM t
WHERE a=1 AND b=1 AND c=1 ... <em class="replaceable"><code>N</code></em>;
</pre></li><li class="listitem"><p>
                            For a query with <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a>
                            predicates:
                        </p><p style="color:blue;">对于带有in（）谓词的查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT COUNT(*) FROM t
WHERE a IN (1,2, ..., <em class="replaceable"><code>M</code></em>) AND b IN (1,2, ..., <em class="replaceable"><code>N</code></em>);
</pre><p>
                            Each literal value in an
                            <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a> list counts as a
                            predicate combined with <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a>.
                            If there are two <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a>
                            lists, the number of predicates combined with
                            <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a> is the product of the
                            number of literal values in each list. Thus, the number
                            of predicates combined with
                            <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a> in the preceding case is
                            <em class="replaceable"><code>M</code></em> ×
                            <em class="replaceable"><code>N</code></em>.
                        </p><p style="color:blue;">in（）列表中的每个文本值都算作与或组合的谓词。如果有两个in（）列表，则谓词的数量与每个列表中的文字值的数量之积。因此，与前一种情况结合或在前一种情况中的谓词的数目是m×n。</p><p></p></li></ul>
                    </div>
                    <p>
                        Before 5.7.11, the number of bytes per predicate combined
                        with <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a> was higher,
                        approximately 700 bytes.
                    </p><p style="color:blue;">在5.7.11之前，每个谓词的字节数与或大于或等于700字节。</p><p></p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="index-merge-optimization"></a>8.2.1.3&nbsp;Index Merge Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286875735056"></a><a class="indexterm" name="idm140286875734016"></a><a class="indexterm" name="idm140286875732928"></a><p>
                The <span class="firstterm">Index Merge</span> access
                method retrieves rows with multiple
                <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a> scans and merges
                their results into one. This access method merges index scans
                from a single table only, not scans across multiple tables.
                The merge can produce unions, intersections, or
                unions-of-intersections of its underlying scans.
            </p><p style="color:blue;">索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并来自单个表的索引扫描，而不是跨多个表的扫描。合并可以生成其底层扫描的并集、交叉点或交叉点的并集。</p><p></p><p>
                Example queries for which Index Merge may be used:
            </p><p style="color:blue;">可对其使用索引合并的示例查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key1</code></em> = 10 OR <em class="replaceable"><code>key2</code></em> = 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key1</code></em> = 10 OR <em class="replaceable"><code>key2</code></em> = 20) AND <em class="replaceable"><code>non_key</code></em> = 30;

SELECT * FROM t1, t2
  WHERE (t1.<em class="replaceable"><code>key1</code></em> IN (1,2) OR t1.<em class="replaceable"><code>key2</code></em> LIKE '<em class="replaceable"><code>value</code></em>%')
  AND t2.<em class="replaceable"><code>key1</code></em> = t1.<em class="replaceable"><code>some_col</code></em>;

SELECT * FROM t1, t2
  WHERE t1.<em class="replaceable"><code>key1</code></em> = 1
  AND (t2.<em class="replaceable"><code>key1</code></em> = t1.<em class="replaceable"><code>some_col</code></em> OR t2.<em class="replaceable"><code>key2</code></em> = t1.<em class="replaceable"><code>some_col2</code></em>);
</pre>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The Index Merge optimization algorithm has the following
                        known limitations:
                    </p><p style="color:blue;">索引合并优化算法具有以下已知限制：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            If your query has a complex <code class="literal">WHERE</code>
                            clause with deep
                            <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a>/<a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a>
                            nesting and MySQL does not choose the optimal plan, try
                            distributing terms using the following identity
                            transformations:
                        </p><p style="color:blue;">如果您的查询有一个具有深度和/或嵌套的复杂where子句，并且mysql没有选择最佳计划，请尝试使用以下标识转换分发术语：</p><p></p><pre data-lang="sql" class="programlisting">(<em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>y</code></em>) OR <em class="replaceable"><code>z</code></em> =&gt; (<em class="replaceable"><code>x</code></em> OR <em class="replaceable"><code>z</code></em>) AND (<em class="replaceable"><code>y</code></em> OR <em class="replaceable"><code>z</code></em>)
(<em class="replaceable"><code>x</code></em> OR <em class="replaceable"><code>y</code></em>) AND <em class="replaceable"><code>z</code></em> =&gt; (<em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>z</code></em>) OR (<em class="replaceable"><code>y</code></em> AND <em class="replaceable"><code>z</code></em>)
</pre></li><li class="listitem"><p>
                            Index Merge is not applicable to full-text indexes.
                        </p><p style="color:blue;">索引合并不适用于全文索引。</p><p></p></li></ul>
                    </div>

                </div>
                <p>
                    In <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output, the Index
                    Merge method appears as
                    <a class="link" href="optimization.html#jointype_index_merge"><code class="literal">index_merge</code></a> in the
                    <code class="literal">type</code> column. In this case, the
                    <code class="literal">key</code> column contains a list of indexes used,
                    and <code class="literal">key_len</code> contains a list of the longest
                    key parts for those indexes.
                </p><p style="color:blue;">在explain output中，index merge方法在type列中显示为index_merge。在本例中，key列包含所用索引的列表，key_len包含这些索引的最长键部分的列表。</p><p></p><p>
                The Index Merge access method has several algorithms, which
                are displayed in the <code class="literal">Extra</code> field of
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output:
            </p><p style="color:blue;">索引合并访问方法有几个算法，这些算法显示在explain输出的额外字段中：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Using intersect(...)</code>
                    </p><p style="color:blue;">使用intersect（…）</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using union(...)</code>
                    </p><p style="color:blue;">使用联合（…）</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using sort_union(...)</code>
                    </p><p style="color:blue;">使用排序联合（…）</p><p></p></li></ul>
                </div>
                <p>
                    The following sections describe these algorithms in greater
                    detail. The optimizer chooses between different possible Index
                    Merge algorithms and other access methods based on cost
                    estimates of the various available options.
                </p><p style="color:blue;">以下各节将更详细地描述这些算法。优化器根据对各种可用选项的成本估计，在不同的可能索引合并算法和其他访问方法之间进行选择。</p><p></p><p>
                Use of Index Merge is subject to the value of the
                <code class="literal">index_merge</code>,
                <code class="literal">index_merge_intersection</code>,
                <code class="literal">index_merge_union</code>, and
                <code class="literal">index_merge_sort_union</code> flags of the
                <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                variable. See <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>. By
                default, all those flags are <code class="literal">on</code>. To enable
                only certain algorithms, set <code class="literal">index_merge</code> to
                <code class="literal">off</code>, and enable only such of the others as
                should be permitted.
            </p><p style="color:blue;">索引合并的使用取决于优化器交换系统变量的索引合并、索引合并交集、索引合并并和索引合并排序并标志的值。见第8.9.2节“可切换优化”。默认情况下，所有这些标志都处于启用状态。要仅启用某些算法，请将index_merge设置为off，并仅启用应允许的其他算法。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#index-merge-intersection" title="Index Merge Intersection Access Algorithm">Index Merge Intersection Access Algorithm</a></p><p style="color:blue;">索引合并交叉口访问算法</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#index-merge-union" title="Index Merge Union Access Algorithm">Index Merge Union Access Algorithm</a></p><p style="color:blue;">索引合并联合访问算法</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#index-merge-sort-union" title="Index Merge Sort-Union Access Algorithm">Index Merge Sort-Union Access Algorithm</a></p><p style="color:blue;">索引合并排序联合访问算法</p><p></p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="index-merge-intersection"></a>Index Merge Intersection Access Algorithm</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        This access algorithm is applicable when a
                        <code class="literal">WHERE</code> clause is converted to several
                        range conditions on different keys combined with
                        <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a>, and each condition is one
                        of the following:
                    </p><p style="color:blue;">当where子句转换为与和组合在一起的不同键上的多个范围条件时，此访问算法适用，并且每个条件都是以下条件之一：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            An <em class="replaceable"><code>N</code></em>-part expression of this
                            form, where the index has exactly
                            <em class="replaceable"><code>N</code></em> parts (that is, all index
                            parts are covered):
                        </p><p style="color:blue;">此表单的n部分表达式，其中索引正好有n个部分（即，包含所有索引部分）：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>const1</code></em> AND <em class="replaceable"><code>key_part2</code></em> = <em class="replaceable"><code>const2</code></em> ... AND <em class="replaceable"><code>key_partN</code></em> = <em class="replaceable"><code>constN</code></em>
</pre></li><li class="listitem"><p>
                            Any range condition over the primary key of an
                            <code class="literal">InnoDB</code> table.
                        </p><p style="color:blue;">InnoDB表主键上的任何范围条件。</p><p></p></li></ul>
                    </div>
                    <p>
                        Examples:
                    </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>innodb_table</code></em>
  WHERE <em class="replaceable"><code>primary_key</code></em> &lt; 10 AND <em class="replaceable"><code>key_col1</code></em> = 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key1_part1</code></em> = 1 AND <em class="replaceable"><code>key1_part2</code></em> = 2 AND <em class="replaceable"><code>key2</code></em> = 2;
</pre><p>
                    The Index Merge intersection algorithm performs simultaneous
                    scans on all used indexes and produces the intersection of
                    row sequences that it receives from the merged index scans.
                </p><p style="color:blue;">索引合并交集算法对所有使用的索引同时执行扫描，并生成从合并索引扫描接收到的行序列的交集。</p><p></p><p>
                    If all columns used in the query are covered by the used
                    indexes, full table rows are not retrieved
                    (<a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output contains
                    <code class="literal">Using index</code> in <code class="literal">Extra</code>
                    field in this case). Here is an example of such a query:
                </p><p style="color:blue;">如果查询中使用的所有列都被使用的索引覆盖，则不检索完整的表行（在本例中，解释输出包含在额外字段中使用索引）。下面是这样一个查询的示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT COUNT(*) FROM t1 WHERE key1 = 1 AND key2 = 1;
</pre><p>
                    If the used indexes do not cover all columns used in the
                    query, full rows are retrieved only when the range
                    conditions for all used keys are satisfied.
                </p><p style="color:blue;">如果使用的索引不包括查询中使用的所有列，则仅当满足所有使用的键的范围条件时才检索整行。</p><p></p><p>
                    If one of the merged conditions is a condition over the
                    primary key of an <code class="literal">InnoDB</code> table, it is not
                    used for row retrieval, but is used to filter out rows
                    retrieved using other conditions.
                </p><p style="color:blue;">如果合并的条件之一是innodb表主键上的条件，则它不用于行检索，而是用于筛选使用其他条件检索的行。</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="index-merge-union"></a>Index Merge Union Access Algorithm</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The criteria for this algorithm are similar to those for the
                        Index Merge intersection algorithm. The algorithm is
                        applicable when the table's <code class="literal">WHERE</code> clause
                        is converted to several range conditions on different keys
                        combined with <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a>, and each
                        condition is one of the following:
                    </p><p style="color:blue;">此算法的准则与索引合并交集算法的准则相似。当表的where子句被转换为与or组合在一起的不同键上的多个范围条件时，该算法适用，并且每个条件都是以下条件之一：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            An <em class="replaceable"><code>N</code></em>-part expression of this
                            form, where the index has exactly
                            <em class="replaceable"><code>N</code></em> parts (that is, all index
                            parts are covered):
                        </p><p style="color:blue;">此表单的n部分表达式，其中索引正好有n个部分（即，包含所有索引部分）：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>const1</code></em> AND <em class="replaceable"><code>key_part2</code></em> = <em class="replaceable"><code>const2</code></em> ... AND <em class="replaceable"><code>key_partN</code></em> = <em class="replaceable"><code>constN</code></em>
</pre></li><li class="listitem"><p>
                            Any range condition over a primary key of an
                            <code class="literal">InnoDB</code> table.
                        </p><p style="color:blue;">InnoDB表主键上的任何范围条件。</p><p></p></li><li class="listitem"><p>
                            A condition for which the Index Merge intersection
                            algorithm is applicable.
                        </p><p style="color:blue;">索引合并交集算法适用的条件。</p><p></p></li></ul>
                    </div>
                    <p>
                        Examples:
                    </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key1</code></em> = 1 OR <em class="replaceable"><code>key2</code></em> = 2 OR <em class="replaceable"><code>key3</code></em> = 3;

SELECT * FROM <em class="replaceable"><code>innodb_table</code></em>
  WHERE (<em class="replaceable"><code>key1</code></em> = 1 AND <em class="replaceable"><code>key2</code></em> = 2)
     OR (<em class="replaceable"><code>key3</code></em> = 'foo' AND <em class="replaceable"><code>key4</code></em> = 'bar') AND <em class="replaceable"><code>key5</code></em> = 5;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="index-merge-sort-union"></a>Index Merge Sort-Union Access Algorithm</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        This access algorithm is applicable when the
                        <code class="literal">WHERE</code> clause is converted to several
                        range conditions combined by
                        <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a>, but the Index Merge union
                        algorithm is not applicable.
                    </p><p style="color:blue;">当where子句转换为由or组合的多个范围条件时，此访问算法适用，但索引合并联合算法不适用。</p><p></p><p>
                    Examples:
                </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_col1</code></em> &lt; 10 OR <em class="replaceable"><code>key_col2</code></em> &lt; 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key_col1</code></em> &gt; 10 OR <em class="replaceable"><code>key_col2</code></em> = 20) AND <em class="replaceable"><code>nonkey_col</code></em> = 30;
</pre><p>
                    The difference between the sort-union algorithm and the
                    union algorithm is that the sort-union algorithm must first
                    fetch row IDs for all rows and sort them before returning
                    any rows.
                </p><p style="color:blue;">排序联合算法和联合算法的区别在于，排序联合算法必须首先获取所有行的行ID，并在返回任何行之前对它们进行排序。</p><p></p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="condition-pushdown-optimization"></a>8.2.1.4&nbsp;Engine Condition Pushdown Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286875632960"></a><a class="indexterm" name="idm140286875631872"></a><p>
                This optimization improves the efficiency of direct
                comparisons between a nonindexed column and a constant. In
                such cases, the condition is <span class="quote">“<span class="quote">pushed down</span>”</span> to the
                storage engine for evaluation. This optimization can be used
                only by the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine.
            </p><p style="color:blue;">这种优化提高了无索引列和常数之间直接比较的效率。在这种情况下，条件将“下推”到存储引擎进行评估。此优化只能由ndb存储引擎使用。</p><p></p><p>
                For NDB Cluster, this optimization can eliminate the need to
                send nonmatching rows over the network between the
                cluster's data nodes and the MySQL server that issued the
                query, and can speed up queries where it is used by a factor
                of 5 to 10 times over cases where condition pushdown could be
                but is not used.
            </p><p style="color:blue;">对于ndb集群，这种优化可以消除在集群的数据节点和发出查询的mysql服务器之间通过网络发送非匹配行的需要，并且可以在条件下推（condition pushdown）可以但不使用的情况下，以5到10倍的倍数加快查询速度。</p><p></p><p>
                Suppose that an NDB Cluster table is defined as follows:
            </p><p style="color:blue;">假设ndb集群表定义如下：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
    a INT,
    b INT,
    KEY(a)
) ENGINE=NDB;
</pre><p>
                Condition pushdown can be used with queries such as the one
                shown here, which includes a comparison between a nonindexed
                column and a constant:
            </p><p style="color:blue;">条件下推可用于如下所示的查询，其中包括非索引列和常量之间的比较：</p><p></p><pre data-lang="sql" class="programlisting">SELECT a, b FROM t1 WHERE b = 10;
</pre><p>
                The use of condition pushdown can be seen in the output of
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>:
            </p><p style="color:blue;">在explain:</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where with pushed condition
</pre><p>
                However, condition pushdown <span class="emphasis"><em>cannot</em></span> be
                used with either of these two queries:
            </p><p style="color:blue;">但是，条件下推不能用于以下两个查询之一：</p><p></p><pre data-lang="sql" class="programlisting">SELECT a,b FROM t1 WHERE a = 10;
SELECT a,b FROM t1 WHERE b + 1 = 10;
</pre><p>
                Condition pushdown is not applicable to the first query
                because an index exists on column <code class="literal">a</code>. (An
                index access method would be more efficient and so would be
                chosen in preference to condition pushdown.) Condition
                pushdown cannot be employed for the second query because the
                comparison involving the nonindexed column
                <code class="literal">b</code> is indirect. (However, condition pushdown
                could be applied if you were to reduce <code class="literal">b + 1 =
                10</code> to <code class="literal">b = 9</code> in the
                <code class="literal">WHERE</code> clause.)
            </p><p style="color:blue;">条件下推不适用于第一个查询，因为在A列上存在索引（索引访问方法将更高效，因此将优先于条件下推。）条件下推不能用于第二个查询，因为涉及非索引列B的比较是间接的。（但是，如果要在where子句中将b+1=10减少到b=9，则可以应用条件下推。）</p><p></p><p>
                Condition pushdown may also be employed when an indexed column
                is compared with a constant using a <code class="literal">&gt;</code> or
                <code class="literal">&lt;</code> operator:
            </p><p style="color:blue;">当使用&gt;或&lt;运算符将索引列与常量进行比较时，也可以使用条件下推：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT a, b FROM t1 WHERE a &lt; 2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: range
possible_keys: a
          key: a
      key_len: 5
          ref: NULL
         rows: 2
        Extra: Using where with pushed condition
</pre><p>
                Other supported comparisons for condition pushdown include the
                following:
            </p><p style="color:blue;">其他支持的条件下推比较包括：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal"><em class="replaceable"><code>column</code></em> [NOT] LIKE
                            <em class="replaceable"><code>pattern</code></em></code>
                    </p><p style="color:blue;">柱状[非]图案</p><p></p><p>
                        <em class="replaceable"><code>pattern</code></em> must be a string
                        literal containing the pattern to be matched; for syntax,
                        see <a class="xref" href="functions.html#string-comparison-functions" title="12.5.1&nbsp;String Comparison Functions and Operators">Section&nbsp;12.5.1, “String Comparison Functions and Operators”</a>.
                    </p><p style="color:blue;">模式必须是包含要匹配的模式的字符串文本；有关语法，请参阅第12.5.1节“字符串比较函数和运算符”。</p><p></p></li><li class="listitem"><p>
                        <code class="literal"><em class="replaceable"><code>column</code></em> IS [NOT]
                            NULL</code>
                    </p><p style="color:blue;">列为[不]空</p><p></p></li><li class="listitem"><p>
                        <code class="literal"><em class="replaceable"><code>column</code></em> IN
                            (<em class="replaceable"><code>value_list</code></em>)</code>
                    </p><p style="color:blue;">列（值列表）</p><p></p><p>
                        Each item in the <em class="replaceable"><code>value_list</code></em>
                        must be a constant, literal value.
                    </p><p style="color:blue;">值列表中的每个项都必须是一个常量、文本值。</p><p></p></li><li class="listitem"><p>
                        <code class="literal"><em class="replaceable"><code>column</code></em> BETWEEN
                            <em class="replaceable"><code>constant1</code></em> AND
                            <em class="replaceable"><code>constant2</code></em></code>
                    </p><p style="color:blue;">constant1和constant2之间的列</p><p></p><p>
                        <em class="replaceable"><code>constant1</code></em> and
                        <em class="replaceable"><code>constant2</code></em> must each be a
                        constant, literal value.
                    </p><p style="color:blue;">constant1和constant2都必须是一个常量，文本值。</p><p></p></li></ul>
                </div>
                <p>
                    In all of the cases in the preceding list, it is possible for
                    the condition to be converted into the form of one or more
                    direct comparisons between a column and a constant.
                </p><p style="color:blue;">在前面列表中的所有情况下，都可以将条件转换为列和常量之间的一个或多个直接比较的形式。</p><p></p><p>
                Engine condition pushdown is enabled by default. To disable it
                at server startup, set the
                <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                variable. For example, in a <code class="filename">my.cnf</code> file,
                use these lines:
            </p><p style="color:blue;">默认情况下，启用发动机状况下推。要在服务器启动时禁用它，请设置optimizer_switch系统变量。例如，在my.cnf文件中，使用以下行：</p><p></p><pre data-lang="ini" class="programlisting">[mysqld]
optimizer_switch=engine_condition_pushdown=off
</pre><p>
                At runtime, disable condition pushdown like this:
            </p><p style="color:blue;">在运行时，禁用条件下推，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">SET optimizer_switch='engine_condition_pushdown=off';
</pre><p><b>Limitations.&nbsp;</b>
                Engine condition pushdown is subject to the following
                limitations:
            </p><p style="color:blue;">限制。发动机状况下推受到以下限制：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Condition pushdown is supported only by the
                        <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> storage engine.
                    </p><p style="color:blue;">条件下推仅由ndb存储引擎支持。</p><p></p></li><li class="listitem"><p>
                        Columns may be compared with constants only; however, this
                        includes expressions which evaluate to constant values.
                    </p><p style="color:blue;">列只能与常量进行比较；但是，这包括计算为常量值的表达式。</p><p></p></li><li class="listitem"><p>
                        Columns used in comparisons cannot be of any of the
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> types. This exclusion
                        extends to <a class="link" href="data-types.html#json" title="11.6&nbsp;The JSON Data Type"><code class="literal">JSON</code></a>,
                        <a class="link" href="data-types.html#bit-type" title="11.2.4&nbsp;Bit-Value Type - BIT"><code class="literal">BIT</code></a>, and
                        <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> columns as well.
                    </p><p style="color:blue;">比较中使用的列不能是任何blob或文本类型。这种排除也扩展到json、bit和enum列。</p><p></p></li><li class="listitem"><p>
                        A string value to be compared with a column must use the
                        same collation as the column.
                    </p><p style="color:blue;">要与列进行比较的字符串值必须使用与列相同的排序规则。</p><p></p></li><li class="listitem"><p>
                        Joins are not directly supported; conditions involving
                        multiple tables are pushed separately where possible. Use
                        extended <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output to
                        determine which conditions are actually pushed down. See
                        <a class="xref" href="optimization.html#explain-extended" title="8.8.3&nbsp;Extended EXPLAIN Output Format">Section&nbsp;8.8.3, “Extended EXPLAIN Output Format”</a>.
                    </p><p style="color:blue;">不直接支持联接；在可能的情况下，涉及多个表的条件将分别推送。使用扩展解释输出来确定哪些条件实际上被下推。见第8.8.3节，“扩展解释输出格式”。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="index-condition-pushdown-optimization"></a>8.2.1.5&nbsp;Index Condition Pushdown Optimization</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Index Condition Pushdown (ICP) is an optimization for the case
                    where MySQL retrieves rows from a table using an index.
                    Without ICP, the storage engine traverses the index to locate
                    rows in the base table and returns them to the MySQL server
                    which evaluates the <code class="literal">WHERE</code> condition for the
                    rows. With ICP enabled, and if parts of the
                    <code class="literal">WHERE</code> condition can be evaluated by using
                    only columns from the index, the MySQL server pushes this part
                    of the <code class="literal">WHERE</code> condition down to the storage
                    engine. The storage engine then evaluates the pushed index
                    condition by using the index entry and only if this is
                    satisfied is the row read from the table. ICP can reduce the
                    number of times the storage engine must access the base table
                    and the number of times the MySQL server must access the
                    storage engine.
                </p><p style="color:blue;">索引条件下推（icp）是针对mysql使用索引从表中检索行的情况进行的优化。如果没有icp，存储引擎将遍历索引以定位基表中的行，并将它们返回到mysql服务器，mysql服务器将计算行的where条件。如果启用了icp，并且where条件的一部分可以通过只使用索引中的列来计算，那么mysql服务器会将where条件的这一部分下推到存储引擎。然后，存储引擎使用索引项计算推送索引条件，并且只有在满足此条件时，才从表中读取行。icp可以减少存储引擎必须访问基表的次数以及mysql服务器必须访问存储引擎的次数。</p><p></p><p>
                Applicability of the Index Condition Pushdown optimization is
                subject to these conditions:
            </p><p style="color:blue;">指数条件下推优化的适用性取决于以下条件：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        ICP is used for the
                        <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a>,
                        <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a>,
                        <a class="link" href="optimization.html#jointype_eq_ref"><code class="literal">eq_ref</code></a>, and
                        <a class="link" href="optimization.html#jointype_ref_or_null"><code class="literal">ref_or_null</code></a> access
                        methods when there is a need to access full table rows.
                    </p><p style="color:blue;">当需要访问完整的表行时，icp用于range、ref、eq_ref和ref_或_null访问方法。</p><p></p></li><li class="listitem"><p>
                        ICP can be used for <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>
                        and <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables, including
                        partitioned <code class="literal">InnoDB</code> and
                        <code class="literal">MyISAM</code> tables.
                    </p><p style="color:blue;">icp可用于innodb和myisam表，包括分区的innodb和myisam表。</p><p></p></li><li class="listitem"><p>
                        For <code class="literal">InnoDB</code> tables, ICP is used only for
                        secondary indexes. The goal of ICP is to reduce the number
                        of full-row reads and thereby reduce I/O operations. For
                        <code class="literal">InnoDB</code> clustered indexes, the complete
                        record is already read into the <code class="literal">InnoDB</code>
                        buffer. Using ICP in this case does not reduce I/O.
                    </p><p style="color:blue;">对于innodb表，icp仅用于二级索引。icp的目标是减少整行读取的次数，从而减少i/o操作。对于innodb聚集索引，完整的记录已经被读入innodb缓冲区。在这种情况下使用icp不会减少i/o。</p><p></p></li><li class="listitem"><p>
                        ICP is not supported with secondary indexes created on
                        virtual generated columns. <code class="literal">InnoDB</code>
                        supports secondary indexes on virtual generated columns.
                    </p><p style="color:blue;">虚拟生成列上创建的辅助索引不支持icp。innodb支持虚拟生成列的二级索引。</p><p></p></li><li class="listitem"><p>
                        Conditions that refer to subqueries cannot be pushed down.
                    </p><p style="color:blue;">不能向下推引用子查询的条件。</p><p></p></li><li class="listitem"><p>
                        Conditions that refer to stored functions cannot be pushed
                        down. Storage engines cannot invoke stored functions.
                    </p><p style="color:blue;">不能向下推引用存储函数的条件。存储引擎无法调用存储函数。</p><p></p></li><li class="listitem"><p>
                        Triggered conditions cannot be pushed down. (For
                        information about triggered conditions, see
                        <a class="xref" href="optimization.html#subquery-optimization-with-exists" title="8.2.2.3&nbsp;Optimizing Subqueries with the EXISTS Strategy">Section&nbsp;8.2.2.3, “Optimizing Subqueries with the EXISTS Strategy”</a>.)
                    </p><p style="color:blue;">无法向下推触发的条件。（有关触发条件的信息，请参阅8.2.2.3节，“使用现有策略优化子查询”。）</p><p></p></li></ul>
                </div>
                <p>
                    To understand how this optimization works, first consider how
                    an index scan proceeds when Index Condition Pushdown is not
                    used:
                </p><p style="color:blue;">若要了解此优化的工作原理，请首先考虑不使用索引条件下推时索引扫描如何进行：</p><p></p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Get the next row, first by reading the index tuple, and
                        then by using the index tuple to locate and read the full
                        table row.
                    </p><p style="color:blue;">获取下一行，首先读取索引元组，然后使用索引元组定位并读取整个表行。</p><p></p></li><li class="listitem"><p>
                        Test the part of the <code class="literal">WHERE</code> condition
                        that applies to this table. Accept or reject the row based
                        on the test result.
                    </p><p style="color:blue;">测试适用于此表的where条件的部分。根据测试结果接受或拒绝行。</p><p></p></li></ol>
                </div>
                <p>
                    Using Index Condition Pushdown, the scan proceeds like this
                    instead:
                </p><p style="color:blue;">使用索引条件下推，扫描将按如下方式进行：</p><p></p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Get the next row's index tuple (but not the full table
                        row).
                    </p><p style="color:blue;">获取下一行的索引元组（但不是整个表行）。</p><p></p></li><li class="listitem"><p>
                        Test the part of the <code class="literal">WHERE</code> condition
                        that applies to this table and can be checked using only
                        index columns. If the condition is not satisfied, proceed
                        to the index tuple for the next row.
                    </p><p style="color:blue;">测试适用于此表且只能使用索引列检查的where条件的一部分。如果条件不满足，则转到下一行的索引元组。</p><p></p></li><li class="listitem"><p>
                        If the condition is satisfied, use the index tuple to
                        locate and read the full table row.
                    </p><p style="color:blue;">如果满足条件，则使用索引元组定位并读取完整的表行。</p><p></p></li><li class="listitem"><p>
                        Test the remaining part of the <code class="literal">WHERE</code>
                        condition that applies to this table. Accept or reject the
                        row based on the test result.
                    </p><p style="color:blue;">测试适用于此表的where条件的其余部分。根据测试结果接受或拒绝行。</p><p></p></li></ol>
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output shows
                    <code class="literal">Using index condition</code> in the
                    <code class="literal">Extra</code> column when Index Condition Pushdown
                    is used. It does not show <code class="literal">Using index</code>
                    because that does not apply when full table rows must be read.
                </p><p style="color:blue;">explain output显示在使用索引条件下推时在额外列中使用索引条件。它不显示using index，因为当必须读取完整的表行时，这不适用。</p><p></p><p>
                Suppose that a table contains information about people and
                their addresses and that the table has an index defined as
                <code class="literal">INDEX (zipcode, lastname, firstname)</code>. If we
                know a person's <code class="literal">zipcode</code> value but are not
                sure about the last name, we can search like this:
            </p><p style="color:blue;">假设一个表包含有关人员及其地址的信息，并且该表有一个定义为index（zipcode、lastname和firstname）的索引。如果我们知道一个人的zipcode值，但不确定姓氏，我们可以这样搜索：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%etrunia%'
  AND address LIKE '%Main Street%';
</pre><p>
                MySQL can use the index to scan through people with
                <code class="literal">zipcode='95054'</code>. The second part
                (<code class="literal">lastname LIKE '%etrunia%'</code>) cannot be used
                to limit the number of rows that must be scanned, so without
                Index Condition Pushdown, this query must retrieve full table
                rows for all people who have
                <code class="literal">zipcode='95054'</code>.
            </p><p style="color:blue;">mysql可以使用索引扫描zipcode为95054的人。第二部分（姓氏，如'%etrunia%'）不能用于限制必须扫描的行数，因此如果没有索引条件下推，此查询必须检索所有zipcode为'95054'的人的完整表行。</p><p></p><p>
                With Index Condition Pushdown, MySQL checks the
                <code class="literal">lastname LIKE '%etrunia%'</code> part before
                reading the full table row. This avoids reading full rows
                corresponding to index tuples that match the
                <code class="literal">zipcode</code> condition but not the
                <code class="literal">lastname</code> condition.
            </p><p style="color:blue;">使用索引条件下推，mysql在读取完整表行之前检查姓氏，如'%etrunia%'部分。这样可以避免读取与与zipcode条件（而不是lastname条件）匹配的索引元组对应的整行。</p><p></p><p>
                Index Condition Pushdown is enabled by default. It can be
                controlled with the
                <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                variable by setting the
                <code class="literal">index_condition_pushdown</code> flag:
            </p><p style="color:blue;">默认情况下，已启用索引条件下推。可以通过设置INDEX U CONDITUS_PUSHDOWN标志，使用优化器_开关系统变量对其进行控制：</p><p></p><pre data-lang="sql" class="programlisting">SET optimizer_switch = 'index_condition_pushdown=off';
SET optimizer_switch = 'index_condition_pushdown=on';
</pre><p>
                See <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>.
            </p><p style="color:blue;">见第8.9.2节“可切换优化”。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="nested-loop-joins"></a>8.2.1.6&nbsp;Nested-Loop Join Algorithms</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286875521600"></a><a class="indexterm" name="idm140286875520544"></a><a class="indexterm" name="idm140286875519056"></a><a class="indexterm" name="idm140286875517968"></a><p>
                MySQL executes joins between tables using a nested-loop
                algorithm or variations on it.
            </p><p style="color:blue;">mysql使用嵌套循环算法或其变体执行表之间的连接。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#nested-loop-join-algorithm" title="Nested-Loop Join Algorithm">Nested-Loop Join Algorithm</a></p><p style="color:blue;">嵌套循环连接算法</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#block-nested-loop-join-algorithm" title="Block Nested-Loop Join Algorithm">Block Nested-Loop Join Algorithm</a></p><p style="color:blue;">块嵌套循环连接算法</p><p></p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="nested-loop-join-algorithm"></a>Nested-Loop Join Algorithm</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        A simple nested-loop join (NLJ) algorithm reads rows from
                        the first table in a loop one at a time, passing each row to
                        a nested loop that processes the next table in the join.
                        This process is repeated as many times as there remain
                        tables to be joined.
                    </p><p style="color:blue;">一个简单的嵌套循环连接（nlj）算法一次从循环中的第一个表读取一行，将每行传递给处理连接中的下一个表的嵌套循环。此过程重复的次数与仍有表要联接的次数相同。</p><p></p><p>
                    Assume that a join between three tables
                    <code class="literal">t1</code>, <code class="literal">t2</code>, and
                    <code class="literal">t3</code> is to be executed using the following
                    join types:
                </p><p style="color:blue;">假设三个表T1、T2和T3之间的联接将使用以下联接类型执行：</p><p></p><pre data-lang="none" class="programlisting">Table   Join Type
t1      range
t2      ref
t3      ALL
</pre><p>
                    If a simple NLJ algorithm is used, the join is processed
                    like this:
                </p><p style="color:blue;">如果使用简单的nlj算法，则会按如下方式处理连接：</p><p></p><pre data-lang="clike" class="programlisting">for each row in t1 matching range {
  for each row in t2 matching reference key {
    for each row in t3 {
      if row satisfies join conditions, send to client
    }
  }
}
</pre><p>
                    Because the NLJ algorithm passes rows one at a time from
                    outer loops to inner loops, it typically reads tables
                    processed in the inner loops many times.
                </p><p style="color:blue;">由于nlj算法一次将一行从外部循环传递到内部循环，因此它通常会多次读取内部循环中处理的表。</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="block-nested-loop-join-algorithm"></a>Block Nested-Loop Join Algorithm</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        A Block Nested-Loop (BNL) join algorithm uses buffering of
                        rows read in outer loops to reduce the number of times that
                        tables in inner loops must be read. For example, if 10 rows
                        are read into a buffer and the buffer is passed to the next
                        inner loop, each row read in the inner loop can be compared
                        against all 10 rows in the buffer. This reduces by an order
                        of magnitude the number of times the inner table must be
                        read.
                    </p><p style="color:blue;">块嵌套循环（bnl）连接算法使用缓冲外部循环中读取的行来减少必须读取内部循环中的表的次数。例如，如果将10行读取到一个缓冲区中，并将该缓冲区传递到下一个内部循环，则可以将内部循环中读取的每一行与缓冲区中的所有10行进行比较。这将使必须读取内部表的次数减少一个数量级。</p><p></p><p>
                    MySQL join buffering has these characteristics:
                </p><p style="color:blue;">mysql连接缓冲具有以下特点：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Join buffering can be used when the join is of type
                            <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a> or
                            <a class="link" href="optimization.html#jointype_index"><code class="literal">index</code></a> (in other
                            words, when no possible keys can be used, and a full
                            scan is done, of either the data or index rows,
                            respectively), or
                            <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a>. Use of
                            buffering is also applicable to outer joins, as
                            described in <a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.11&nbsp;Block Nested-Loop and Batched Key Access Joins">Section&nbsp;8.2.1.11, “Block Nested-Loop and Batched Key Access Joins”</a>.
                        </p><p style="color:blue;">当连接类型为all或index（换句话说，当不能使用可能的键，并且分别对数据行或索引行进行了完整扫描）或range时，可以使用连接缓冲。缓冲的使用也适用于外部连接，如第8.2.1.11节“块嵌套循环和批处理密钥访问连接”所述。</p><p></p></li><li class="listitem"><p>
                            A join buffer is never allocated for the first
                            nonconstant table, even if it would be of type
                            <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a> or
                            <a class="link" href="optimization.html#jointype_index"><code class="literal">index</code></a>.
                        </p><p style="color:blue;">从不为第一个非连续表分配联接缓冲区，即使它是ALL或INDEX类型的。</p><p></p></li><li class="listitem"><p>
                            Only columns of interest to a join are stored in its
                            join buffer, not whole rows.
                        </p><p style="color:blue;">只有连接感兴趣的列才会存储在其连接缓冲区中，而不是整个行。</p><p></p></li><li class="listitem"><p>
                            The <a class="link" href="server-administration.html#sysvar_join_buffer_size"><code class="literal">join_buffer_size</code></a>
                            system variable determines the size of each join buffer
                            used to process a query.
                        </p><p style="color:blue;">join_buffer_size系统变量决定用于处理查询的每个联接缓冲区的大小。</p><p></p></li><li class="listitem"><p>
                            One buffer is allocated for each join that can be
                            buffered, so a given query might be processed using
                            multiple join buffers.
                        </p><p style="color:blue;">为每个可以缓冲的连接分配一个缓冲区，因此可以使用多个连接缓冲区处理给定的查询。</p><p></p></li><li class="listitem"><p>
                            A join buffer is allocated prior to executing the join
                            and freed after the query is done.
                        </p><p style="color:blue;">在执行join之前分配一个join缓冲区，并在查询完成后释放。</p><p></p></li></ul>
                    </div>
                    <p>
                        For the example join described previously for the NLJ
                        algorithm (without buffering), the join is done as follows
                        using join buffering:
                    </p><p style="color:blue;">对于前面为nlj算法描述的示例连接（不带缓冲），使用连接缓冲按如下方式进行连接：</p><p></p><pre data-lang="clike" class="programlisting">for each row in t1 matching range {
  for each row in t2 matching reference key {
    store used columns from t1, t2 in join buffer
    if buffer is full {
      for each row in t3 {
        for each t1, t2 combination in join buffer {
          if row satisfies join conditions, send to client
        }
      }
      empty join buffer
    }
  }
}

if buffer is not empty {
  for each row in t3 {
    for each t1, t2 combination in join buffer {
      if row satisfies join conditions, send to client
    }
  }
}
</pre><p>
                    If <em class="replaceable"><code>S</code></em> is the size of each stored
                    <code class="literal">t1</code>, <code class="literal">t2</code> combination in
                    the join buffer and <em class="replaceable"><code>C</code></em> is the
                    number of combinations in the buffer, the number of times
                    table <code class="literal">t3</code> is scanned is:
                </p><p style="color:blue;">如果s是连接缓冲区中每个存储的t1、t2组合的大小，c是缓冲区中的组合数，则扫描表t3的次数为：</p><p></p><pre data-lang="clike" class="programlisting">(<em class="replaceable"><code>S</code></em> * <em class="replaceable"><code>C</code></em>)/join_buffer_size + 1
</pre><p>
                    The number of <code class="literal">t3</code> scans decreases as the
                    value of <a class="link" href="server-administration.html#sysvar_join_buffer_size"><code class="literal">join_buffer_size</code></a>
                    increases, up to the point when
                    <a class="link" href="server-administration.html#sysvar_join_buffer_size"><code class="literal">join_buffer_size</code></a> is large
                    enough to hold all previous row combinations. At that point,
                    no speed is gained by making it larger.
                </p><p style="color:blue;">t3扫描的数量随着join_buffer_size值的增加而减少，直到join_buffer_size大到足以容纳所有以前的行组合时为止。在这一点上，没有速度是通过使它更大。</p><p></p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="nested-join-optimization"></a>8.2.1.7&nbsp;Nested Join Optimization</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The syntax for expressing joins permits nested joins. The
                    following discussion refers to the join syntax described in
                    <a class="xref" href="sql-syntax.html#join" title="13.2.9.2&nbsp;JOIN Syntax">Section&nbsp;13.2.9.2, “JOIN Syntax”</a>.
                </p><p style="color:blue;">表示联接的语法允许嵌套联接。以下讨论涉及第13.2.9.2节“连接语法”中描述的连接语法。</p><p></p><p>
                The syntax of <em class="replaceable"><code>table_factor</code></em> is
                extended in comparison with the SQL Standard. The latter
                accepts only <em class="replaceable"><code>table_reference</code></em>, not a
                list of them inside a pair of parentheses. This is a
                conservative extension if we consider each comma in a list of
                <em class="replaceable"><code>table_reference</code></em> items as equivalent
                to an inner join. For example:
            </p><p style="color:blue;">与sql标准相比，扩展了表因子的语法。后者只接受table_引用，而不接受一对圆括号内的一组引用。如果我们认为表引用项列表中的每个逗号都等同于内部联接，则这是一个保守的扩展。例如：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
                Is equivalent to:
            </p><p style="color:blue;">相当于：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
                In MySQL, <code class="literal">CROSS JOIN</code> is syntactically
                equivalent to <code class="literal">INNER JOIN</code>; they can replace
                each other. In standard SQL, they are not equivalent.
                <code class="literal">INNER JOIN</code> is used with an
                <code class="literal">ON</code> clause; <code class="literal">CROSS JOIN</code> is
                used otherwise.
            </p><p style="color:blue;">在mysql中，交叉连接在语法上等同于内部连接；它们可以相互替换。在标准sql中，它们是不等价的。内部联接与on子句一起使用；否则使用交叉联接。</p><p></p><p>
                In general, parentheses can be ignored in join expressions
                containing only inner join operations. Consider this join
                expression:
            </p><p style="color:blue;">通常，在只包含内部联接操作的联接表达式中，可以忽略圆括号。请考虑以下联接表达式：</p><p></p><pre data-lang="sql" class="programlisting">t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
   ON t1.a=t2.a
</pre><p>
                After removing parentheses and grouping operations to the
                left, that join expression transforms into this expression:
            </p><p style="color:blue;">在删除左侧的括号和分组操作后，该联接表达式将转换为此表达式：</p><p></p><pre data-lang="sql" class="programlisting">(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    ON t2.b=t3.b OR t2.b IS NULL
</pre><p>
                Yet, the two expressions are not equivalent. To see this,
                suppose that the tables <code class="literal">t1</code>,
                <code class="literal">t2</code>, and <code class="literal">t3</code> have the
                following state:
            </p><p style="color:blue;">然而，这两个表达式并不等价。为此，假设表T1、T2和T3具有以下状态：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Table <code class="literal">t1</code> contains rows
                        <code class="literal">(1)</code>, <code class="literal">(2)</code>
                    </p><p style="color:blue;">表T1包含行（1），（2）</p><p></p></li><li class="listitem"><p>
                        Table <code class="literal">t2</code> contains row
                        <code class="literal">(1,101)</code>
                    </p><p style="color:blue;">表T2包含行（1101）</p><p></p></li><li class="listitem"><p>
                        Table <code class="literal">t3</code> contains row
                        <code class="literal">(101)</code>
                    </p><p style="color:blue;">表T3包含行（101）</p><p></p></li></ul>
                </div>
                <p>
                    In this case, the first expression returns a result set
                    including the rows <code class="literal">(1,1,101,101)</code>,
                    <code class="literal">(2,NULL,NULL,NULL)</code>, whereas the second
                    expression returns the rows <code class="literal">(1,1,101,101)</code>,
                    <code class="literal">(2,NULL,NULL,101)</code>:
                </p><p style="color:blue;">在这种情况下，第一个表达式返回包含行（1,1101101），（2，null，null，null）的结果集，而第二个表达式返回行（1,1101101），（2，null，null，101）：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM t1</code></strong>
            <strong class="userinput"><code>LEFT JOIN</code></strong>
            <strong class="userinput"><code>(t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</code></strong>
            <strong class="userinput"><code>ON t1.a=t2.a;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)</code></strong>
            <strong class="userinput"><code>LEFT JOIN t3</code></strong>
            <strong class="userinput"><code>ON t2.b=t3.b OR t2.b IS NULL;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
</pre><p>
                In the following example, an outer join operation is used
                together with an inner join operation:
            </p><p style="color:blue;">在以下示例中，外部联接操作与内部联接操作一起使用：</p><p></p><pre data-lang="sql" class="programlisting">t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
</pre><p>
                That expression cannot be transformed into the following
                expression:
            </p><p style="color:blue;">无法将该表达式转换为以下表达式：</p><p></p><pre data-lang="sql" class="programlisting">t1 LEFT JOIN t2 ON t1.a=t2.a, t3
</pre><p>
                For the given table states, the two expressions return
                different sets of rows:
            </p><p style="color:blue;">对于给定的表状态，这两个表达式返回不同的行集：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
       <strong class="userinput"><code>FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
</pre><p>
                Therefore, if we omit parentheses in a join expression with
                outer join operators, we might change the result set for the
                original expression.
            </p><p style="color:blue;">因此，如果在具有外部联接运算符的联接表达式中省略圆括号，则可能会更改原始表达式的结果集。</p><p></p><p>
                More exactly, we cannot ignore parentheses in the right
                operand of the left outer join operation and in the left
                operand of a right join operation. In other words, we cannot
                ignore parentheses for the inner table expressions of outer
                join operations. Parentheses for the other operand (operand
                for the outer table) can be ignored.
            </p><p style="color:blue;">更确切地说，我们不能忽略左外部联接操作的右操作数和右联接操作的左操作数中的括号。换句话说，我们不能忽略外部联接操作的内部表表达式的括号。其他操作数（外部表的操作数）的括号可以忽略。</p><p></p><p>
                The following expression:
            </p><p style="color:blue;">以下表达式：</p><p></p><pre data-lang="sql" class="programlisting">(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)
</pre><p>
                Is equivalent to this expression for any tables
                <code class="literal">t1,t2,t3</code> and any condition
                <code class="literal">P</code> over attributes <code class="literal">t2.b</code>
                and <code class="literal">t3.b</code>:
            </p><p style="color:blue;">对于属性t2.b和t3.b上的任何表t1、t2、t3和任何条件p，都等效于此表达式：</p><p></p><pre data-lang="sql" class="programlisting">t1, t2 LEFT JOIN t3 ON P(t2.b,t3.b)
</pre><p>
                Whenever the order of execution of join operations in a join
                expression (<em class="replaceable"><code>joined_table</code></em>) is not
                from left to right, we talk about nested joins. Consider the
                following queries:
            </p><p style="color:blue;">每当联接表达式（联接表）中联接操作的执行顺序不是从左到右时，我们就讨论嵌套联接。考虑以下问题：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
  WHERE t1.a &gt; 1

SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
  WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a &gt; 1
</pre><p>
                Those queries are considered to contain these nested joins:
            </p><p style="color:blue;">这些查询被视为包含这些嵌套联接：</p><p></p><pre data-lang="sql" class="programlisting">t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3
</pre><p>
                In the first query, the nested join is formed with a left join
                operation. In the second query, it is formed with an inner
                join operation.
            </p><p style="color:blue;">在第一个查询中，嵌套联接由左联接操作形成。在第二个查询中，它由一个内部连接操作构成。</p><p></p><p>
                In the first query, the parentheses can be omitted: The
                grammatical structure of the join expression will dictate the
                same order of execution for join operations. For the second
                query, the parentheses cannot be omitted, although the join
                expression here can be interpreted unambiguously without them.
                In our extended syntax, the parentheses in <code class="literal">(t2,
                t3)</code> of the second query are required, although
                theoretically the query could be parsed without them: We still
                would have unambiguous syntactical structure for the query
                because <code class="literal">LEFT JOIN</code> and <code class="literal">ON</code>
                play the role of the left and right delimiters for the
                expression <code class="literal">(t2,t3)</code>.
            </p><p style="color:blue;">在第一个查询中，可以省略括号：连接表达式的语法结构将指示连接操作的相同执行顺序。对于第二个查询，不能省略括号，尽管这里的连接表达式可以在没有括号的情况下进行明确的解释。在我们的扩展语法中，第二个查询（t2，t3）中的括号是必需的，尽管理论上可以在不使用它们的情况下解析查询：我们仍然会对查询有明确的语法结构，因为left join和on扮演表达式（t2，t3）的左右分隔符的角色。</p><p></p><p>
                The preceding examples demonstrate these points:
            </p><p style="color:blue;">前面的示例演示了这些要点：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For join expressions involving only inner joins (and not
                        outer joins), parentheses can be removed and joins
                        evaluated left to right. In fact, tables can be evaluated
                        in any order.
                    </p><p style="color:blue;">对于只涉及内部联接（而不是外部联接）的联接表达式，可以删除括号并从左到右计算联接。实际上，表可以按任何顺序计算。</p><p></p></li><li class="listitem"><p>
                        The same is not true, in general, for outer joins or for
                        outer joins mixed with inner joins. Removal of parentheses
                        may change the result.
                    </p><p style="color:blue;">通常情况下，对于外部连接或与内部连接混合的外部连接，情况并非如此。删除括号可能会更改结果。</p><p></p></li></ul>
                </div>
                <a class="indexterm" name="idm140286875414720"></a><a class="indexterm" name="idm140286875413232"></a><p>
                Queries with nested outer joins are executed in the same
                pipeline manner as queries with inner joins. More exactly, a
                variation of the nested-loop join algorithm is exploited.
                Recall the algorithm by which the nested-loop join executes a
                query (see <a class="xref" href="optimization.html#nested-loop-joins" title="8.2.1.6&nbsp;Nested-Loop Join Algorithms">Section&nbsp;8.2.1.6, “Nested-Loop Join Algorithms”</a>). Suppose that
                a join query over 3 tables <code class="literal">T1,T2,T3</code> has
                this form:
            </p><p style="color:blue;">具有嵌套外部联接的查询与具有内部联接的查询以相同的管道方式执行。更准确地说，利用了嵌套循环连接算法的一种变体。回想一下嵌套循环连接执行查询时使用的算法（请参阅8.2.1.6节，“嵌套循环连接算法”）。假设3个表T1、T2、T3上的联接查询具有以下形式：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)
                 INNER JOIN T3 ON P2(T2,T3)
  WHERE P(T1,T2,T3)
</pre><p>
                Here, <code class="literal">P1(T1,T2)</code> and
                <code class="literal">P2(T3,T3)</code> are some join conditions (on
                expressions), whereas <code class="literal">P(T1,T2,T3)</code> is a
                condition over columns of tables <code class="literal">T1,T2,T3</code>.
            </p><p style="color:blue;">这里，p1（t1，t2）和p2（t3，t3）是一些连接条件（在表达式上），而p（t1，t2，t3）是表t1，t2，t3列上的条件。</p><p></p><p>
                The nested-loop join algorithm would execute this query in the
                following manner:
            </p><p style="color:blue;">嵌套循环联接算法将按以下方式执行此查询：</p><p></p><pre data-lang="clike" class="programlisting">FOR each row t1 in T1 {
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
                The notation <code class="literal">t1||t2||t3</code> indicates a row
                constructed by concatenating the columns of rows
                <code class="literal">t1</code>, <code class="literal">t2</code>, and
                <code class="literal">t3</code>. In some of the following examples,
                <code class="literal">NULL</code> where a table name appears means a row
                in which <code class="literal">NULL</code> is used for each column of
                that table. For example, <code class="literal">t1||t2||NULL</code>
                indicates a row constructed by concatenating the columns of
                rows <code class="literal">t1</code> and <code class="literal">t2</code>, and
                <code class="literal">NULL</code> for each column of
                <code class="literal">t3</code>. Such a row is said to be
                <code class="literal">NULL</code>-complemented.
            </p><p style="color:blue;">符号T1 T2 T3表示通过连接行T1、T2和T3的列而构造的行。在下面的一些示例中，表名出现的空表示一行，其中空用于该表的每一列。例如，T1 T2空表示通过连接T1和T2行的列而构造的行，而对于T3的每列则为空。这样的一行称为空补。</p><p></p><a class="indexterm" name="idm140286875394816"></a><p>
                Now consider a query with nested outer joins:
            </p><p style="color:blue;">现在考虑使用嵌套外部联接的查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON P2(T2,T3))
              ON P1(T1,T2)
  WHERE P(T1,T2,T3)
</pre><p>
                For this query, modify the nested-loop pattern to obtain:
            </p><p style="color:blue;">对于此查询，修改嵌套循环模式以获取：</p><p></p><pre data-lang="clike" class="programlisting">FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF P(t1,t2,NULL) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
                In general, for any nested loop for the first inner table in
                an outer join operation, a flag is introduced that is turned
                off before the loop and is checked after the loop. The flag is
                turned on when for the current row from the outer table a
                match from the table representing the inner operand is found.
                If at the end of the loop cycle the flag is still off, no
                match has been found for the current row of the outer table.
                In this case, the row is complemented by
                <code class="literal">NULL</code> values for the columns of the inner
                tables. The result row is passed to the final check for the
                output or into the next nested loop, but only if the row
                satisfies the join condition of all embedded outer joins.
            </p><p style="color:blue;">通常，对于外部联接操作中第一个内部表的任何嵌套循环，都会引入一个标志，该标志在循环之前关闭，在循环之后检查。当外部表中的当前行与表示内部操作数的表匹配时，该标志将打开。如果在循环结束时标志仍处于关闭状态，则未找到外部表的当前行的匹配项。在这种情况下，行由内部表的列的空值补充。结果行被传递到输出的最终检查或下一个嵌套循环中，但前提是该行满足所有嵌入外部联接的联接条件。</p><p></p><p>
                In the example, the outer join table expressed by the
                following expression is embedded:
            </p><p style="color:blue;">在该示例中，嵌入了由以下表达式表示的外部联接表：</p><p></p><pre data-lang="sql" class="programlisting">(T2 LEFT JOIN T3 ON P2(T2,T3))
</pre><p>
                For the query with inner joins, the optimizer could choose a
                different order of nested loops, such as this one:
            </p><p style="color:blue;">对于具有内部联接的查询，优化器可以选择嵌套循环的不同顺序，例如：</p><p></p><pre data-lang="clike" class="programlisting">FOR each row t3 in T3 {
  FOR each row t2 in T2 such that P2(t2,t3) {
    FOR each row t1 in T1 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
                For queries with outer joins, the optimizer can choose only
                such an order where loops for outer tables precede loops for
                inner tables. Thus, for our query with outer joins, only one
                nesting order is possible. For the following query, the
                optimizer evaluates two different nestings. In both nestings,
                <code class="literal">T1</code> must be processed in the outer loop
                because it is used in an outer join. <code class="literal">T2</code> and
                <code class="literal">T3</code> are used in an inner join, so that join
                must be processed in the inner loop. However, because the join
                is an inner join, <code class="literal">T2</code> and
                <code class="literal">T3</code> can be processed in either order.
            </p><p style="color:blue;">对于具有外部联接的查询，优化器只能选择外部表的循环先于内部表的循环的顺序。因此，对于具有外部连接的查询，只有一个嵌套顺序是可能的。对于以下查询，优化器计算两个不同的嵌套。在这两个嵌套中，T1必须在外部循环中处理，因为它在外部联接中使用。t2和t3用于内部连接，因此必须在内部循环中处理连接。但是，由于连接是一个内部连接，t2和t3可以按任意顺序处理。</p><p></p><pre data-lang="sql" class="programlisting">SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
  WHERE P(T1,T2,T3)
</pre><p>
                One nesting evaluates <code class="literal">T2</code>, then
                <code class="literal">T3</code>:
            </p><p style="color:blue;">一个嵌套计算t2，然后t3：</p><p></p><pre data-lang="clike" class="programlisting">FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t1,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
                The other nesting evaluates <code class="literal">T3</code>, then
                <code class="literal">T2</code>:
            </p><p style="color:blue;">另一个嵌套计算t3，然后计算t2：</p><p></p><pre data-lang="clike" class="programlisting">FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t3 in T3 such that P2(t1,t3) {
    FOR each row t2 in T2 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
                When discussing the nested-loop algorithm for inner joins, we
                omitted some details whose impact on the performance of query
                execution may be huge. We did not mention so-called
                <span class="quote">“<span class="quote">pushed-down</span>”</span> conditions. Suppose that our
                <code class="literal">WHERE</code> condition
                <code class="literal">P(T1,T2,T3)</code> can be represented by a
                conjunctive formula:
            </p><p style="color:blue;">在讨论内部连接的嵌套循环算法时，我们忽略了一些对查询执行性能影响很大的细节。我们没有提到所谓的“推倒”条件。假设我们的where条件p（t1，t2，t3）可以用一个连接式表示：</p><p></p><pre data-lang="clike" class="programlisting">P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3).
</pre><p>
                In this case, MySQL actually uses the following nested-loop
                algorithm for the execution of the query with inner joins:
            </p><p style="color:blue;">在这种情况下，mysql实际上使用以下嵌套循环算法执行带有内部连接的查询：</p><p></p><pre data-lang="clike" class="programlisting">FOR each row t1 in T1 such that C1(t1) {
  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
                You see that each of the conjuncts <code class="literal">C1(T1)</code>,
                <code class="literal">C2(T2)</code>, <code class="literal">C3(T3)</code> are
                pushed out of the most inner loop to the most outer loop where
                it can be evaluated. If <code class="literal">C1(T1)</code> is a very
                restrictive condition, this condition pushdown may greatly
                reduce the number of rows from table <code class="literal">T1</code>
                passed to the inner loops. As a result, the execution time for
                the query may improve immensely.
            </p><p style="color:blue;">你可以看到每个连接点c1（t1），c2（t2），c3（t3）被从最内部的循环中推出到最外部的循环中，在那里它可以被评估。如果c1（t1）是一个非常严格的条件，那么这个条件下推可以大大减少从表t1传递到内部循环的行数。因此，查询的执行时间可能会大大提高。</p><p></p><p>
                For a query with outer joins, the <code class="literal">WHERE</code>
                condition is to be checked only after it has been found that
                the current row from the outer table has a match in the inner
                tables. Thus, the optimization of pushing conditions out of
                the inner nested loops cannot be applied directly to queries
                with outer joins. Here we must introduce conditional
                pushed-down predicates guarded by the flags that are turned on
                when a match has been encountered.
            </p><p style="color:blue;">对于具有外部联接的查询，只有在发现外部表中的当前行在内部表中具有匹配项之后，才会检查where条件。因此，将条件从内部嵌套循环中推出的优化不能直接应用于具有外部联接的查询。在这里，我们必须引入由遇到匹配时打开的标志保护的条件下推谓词。</p><p></p><p>
                Recall this example with outer joins:
            </p><p style="color:blue;">回想一下这个带有外部连接的示例：</p><p></p><pre data-lang="clike" class="programlisting">P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)
</pre><p>
                For that example, the nested-loop algorithm using guarded
                pushed-down conditions looks like this:
            </p><p style="color:blue;">对于该示例，使用保护下推条件的嵌套循环算法如下所示：</p><p></p><pre data-lang="clike" class="programlisting">FOR each row t1 in T1 such that C1(t1) {
  BOOL f1:=FALSE;
  FOR each row t2 in T2
      such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3
        such that P2(t2,t3) AND (f1&amp;&amp;f2?C3(t3):TRUE) {
      IF (f1&amp;&amp;f2?TRUE:(C2(t2) AND C3(t3))) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF (f1?TRUE:C2(t2) &amp;&amp; P(t1,t2,NULL)) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1 &amp;&amp; P(t1,NULL,NULL)) {
      t:=t1||NULL||NULL; OUTPUT t;
  }
}
</pre><p>
                In general, pushed-down predicates can be extracted from join
                conditions such as <code class="literal">P1(T1,T2)</code> and
                <code class="literal">P(T2,T3)</code>. In this case, a pushed-down
                predicate is guarded also by a flag that prevents checking the
                predicate for the <code class="literal">NULL</code>-complemented row
                generated by the corresponding outer join operation.
            </p><p style="color:blue;">通常，下推谓词可以从连接条件（如p1（t1，t2）和p（t2，t3））中提取。在这种情况下，下推谓词还由一个标志来保护，该标志防止检查谓词中由相应的外部联接操作生成的空补行。</p><p></p><p>
                Access by key from one inner table to another in the same
                nested join is prohibited if it is induced by a predicate from
                the <code class="literal">WHERE</code> condition.
            </p><p style="color:blue;">如果由where条件的谓词诱导，则禁止在同一嵌套联接中通过键从一个内部表访问另一个内部表。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="outer-join-optimization"></a>8.2.1.8&nbsp;Outer Join Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286875352992"></a><a class="indexterm" name="idm140286875351504"></a><a class="indexterm" name="idm140286875350016"></a><a class="indexterm" name="idm140286875348944"></a><a class="indexterm" name="idm140286875347456"></a><a class="indexterm" name="idm140286875346384"></a><p>
                Outer joins include <code class="literal">LEFT JOIN</code> and
                <code class="literal">RIGHT JOIN</code>.
            </p><p style="color:blue;">外部连接包括左连接和右连接。</p><p></p><p>
                MySQL implements an <code class="literal"><em class="replaceable"><code>A</code></em> LEFT
                JOIN <em class="replaceable"><code>B</code></em>
                <em class="replaceable"><code>join_specification</code></em></code> as
                follows:
            </p><p style="color:blue;">mysql实现了a left join b join_规范，如下所示：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Table <em class="replaceable"><code>B</code></em> is set to depend on
                        table <em class="replaceable"><code>A</code></em> and all tables on which
                        <em class="replaceable"><code>A</code></em> depends.
                    </p><p style="color:blue;">表B设置为依赖于表A和A所依赖的所有表。</p><p></p></li><li class="listitem"><p>
                        Table <em class="replaceable"><code>A</code></em> is set to depend on all
                        tables (except <em class="replaceable"><code>B</code></em>) that are used
                        in the <code class="literal">LEFT JOIN</code> condition.
                    </p><p style="color:blue;">表A设置为依赖于在左联接条件中使用的所有表（B除外）。</p><p></p></li><li class="listitem"><p>
                        The <code class="literal">LEFT JOIN</code> condition is used to
                        decide how to retrieve rows from table
                        <em class="replaceable"><code>B</code></em>. (In other words, any
                        condition in the <code class="literal">WHERE</code> clause is not
                        used.)
                    </p><p style="color:blue;">左联接条件用于决定如何从表B检索行（换句话说，不使用where子句中的任何条件）。</p><p></p></li><li class="listitem"><p>
                        All standard join optimizations are performed, with the
                        exception that a table is always read after all tables on
                        which it depends. If there is a circular dependency, an
                        error occurs.
                    </p><p style="color:blue;">执行所有标准联接优化，但表总是在其所依赖的所有表之后读取。如果存在循环依赖项，则会发生错误。</p><p></p></li><li class="listitem"><p>
                        All standard <code class="literal">WHERE</code> optimizations are
                        performed.
                    </p><p style="color:blue;">执行优化的所有标准。</p><p></p></li><li class="listitem"><p>
                        If there is a row in <em class="replaceable"><code>A</code></em> that
                        matches the <code class="literal">WHERE</code> clause, but there is
                        no row in <em class="replaceable"><code>B</code></em> that matches the
                        <code class="literal">ON</code> condition, an extra
                        <em class="replaceable"><code>B</code></em> row is generated with all
                        columns set to <code class="literal">NULL</code>.
                    </p><p style="color:blue;">如果a中有一行与where子句匹配，但b中没有与on条件匹配的行，则会生成一个额外的b行，并将所有列设置为空。</p><p></p></li><li class="listitem"><p>
                        If you use <code class="literal">LEFT JOIN</code> to find rows that
                        do not exist in some table and you have the following
                        test: <code class="literal"><em class="replaceable"><code>col_name</code></em> IS
                        NULL</code> in the <code class="literal">WHERE</code> part, where
                        <em class="replaceable"><code>col_name</code></em> is a column that is
                        declared as <code class="literal">NOT NULL</code>, MySQL stops
                        searching for more rows (for a particular key combination)
                        after it has found one row that matches the <code class="literal">LEFT
                        JOIN</code> condition.
                    </p><p style="color:blue;">如果使用左联接查找不存在于某个表中的行，则有以下测试：CyLNEX在WHERE部分中为NULL，其中COLLNEX是声明为NULL的列，MySQL在找到与左联接条件匹配的一行之后停止搜索更多行（对于特定键组合）。</p><p></p></li></ul>
                </div>
                <p>
                    The <code class="literal">RIGHT JOIN</code> implementation is analogous
                    to that of <code class="literal">LEFT JOIN</code> with the table roles
                    reversed. Right joins are converted to equivalent left joins,
                    as described in <a class="xref" href="optimization.html#outer-join-simplification" title="8.2.1.9&nbsp;Outer Join Simplification">Section&nbsp;8.2.1.9, “Outer Join Simplification”</a>.
                </p><p style="color:blue;">right join实现类似于表角色颠倒的left join实现。右连接转换为等效的左连接，如第8.2.1.9节“外部连接简化”所述。</p><p></p><p>
                For a <code class="literal">LEFT JOIN</code>, if the
                <code class="literal">WHERE</code> condition is always false for the
                generated <code class="literal">NULL</code> row, the <code class="literal">LEFT
                JOIN</code> is changed to an inner join. For example, the
                <code class="literal">WHERE</code> clause would be false in the
                following query if <code class="literal">t2.column1</code> were
                <code class="literal">NULL</code>:
            </p><p style="color:blue;">对于左联接，如果生成的空行的where条件始终为false，则左联接将更改为内部联接。例如，如果t2.column1为空，则在以下查询中where子句将为false：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
</pre><p>
                Therefore, it is safe to convert the query to an inner join:
            </p><p style="color:blue;">因此，将查询转换为内部联接是安全的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;
</pre><a class="indexterm" name="idm140286875309856"></a><p>
                Now the optimizer can use table <code class="literal">t2</code> before
                table <code class="literal">t1</code> if doing so would result in a
                better query plan. To provide a hint about the table join
                order, use <code class="literal">STRAIGHT_JOIN</code>; see
                <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>. However,
                <code class="literal">STRAIGHT_JOIN</code> may prevent indexes from
                being used because it disables semijoin transformations; see
                <a class="xref" href="optimization.html#semijoins" title="8.2.2.1&nbsp;Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations">Section&nbsp;8.2.2.1, “Optimizing Subqueries, Derived Tables, and View References with Semijoin
                    Transformations”</a>.
            </p><p style="color:blue;">现在优化器可以在表t1之前使用表t2，如果这样做会产生更好的查询计划。要提供有关表联接顺序的提示，请使用直联接；请参阅第13.2.9节“选择语法”。但是，直连接可能会禁止使用索引，因为它禁用半连接转换；请参阅第8.2.2.1节“使用半连接转换优化子查询、派生表和视图引用”。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="outer-join-simplification"></a>8.2.1.9&nbsp;Outer Join Simplification</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Table expressions in the <code class="literal">FROM</code> clause of a
                    query are simplified in many cases.
                </p><p style="color:blue;">在许多情况下，查询的from子句中的表表达式都会被简化。</p><p></p><p>
                At the parser stage, queries with right outer join operations
                are converted to equivalent queries containing only left join
                operations. In the general case, the conversion is performed
                such that this right join:
            </p><p style="color:blue;">在解析器阶段，具有右外部连接操作的查询转换为仅包含左连接操作的等效查询。在一般情况下，执行转换以使此右联接：</p><p></p><pre data-lang="sql" class="programlisting">(T1, ...) RIGHT JOIN (T2, ...) ON P(T1, ..., T2, ...)
</pre><p>
                Becomes this equivalent left join:
            </p><p style="color:blue;">成为等效的左连接：</p><p></p><pre data-lang="sql" class="programlisting">(T2, ...) LEFT JOIN (T1, ...) ON P(T1, ..., T2, ...)
</pre><p>
                All inner join expressions of the form <code class="literal">T1 INNER JOIN
                T2 ON P(T1,T2)</code> are replaced by the list
                <code class="literal">T1,T2</code>, <code class="literal">P(T1,T2)</code> being
                joined as a conjunct to the <code class="literal">WHERE</code> condition
                (or to the join condition of the embedding join, if there is
                any).
            </p><p style="color:blue;">p（t1，t2）上的形式t1 inner join t2的所有内部连接表达式都替换为列表t1，t2，p（t1，t2）作为where条件（或嵌入连接的连接条件（如果有）的连接而连接。</p><p></p><p>
                When the optimizer evaluates plans for outer join operations,
                it takes into consideration only plans where, for each such
                operation, the outer tables are accessed before the inner
                tables. The optimizer choices are limited because only such
                plans enable outer joins to be executed using the nested-loop
                algorithm.
            </p><p style="color:blue;">当优化器评估外部联接操作的计划时，它只考虑在每个这样的操作中，在内部表之前访问外部表的计划。优化器的选择是有限的，因为只有这样的计划才能使用嵌套循环算法执行外部联接。</p><p></p><p>
                Consider a query of this form, where <code class="literal">R(T2)</code>
                greatly narrows the number of matching rows from table
                <code class="literal">T2</code>:
            </p><p style="color:blue;">考虑这个表单的查询，其中r（t2）极大地缩小了来自表t2的匹配行数：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
  WHERE P(T1,T2) AND R(T2)
</pre><p>
                If the query is executed as written, the optimizer has no
                choice but to access the less-restricted table
                <code class="literal">T1</code> before the more-restricted table
                <code class="literal">T2</code>, which may produce a very inefficient
                execution plan.
            </p><p style="color:blue;">如果查询是按写的方式执行的，优化器就别无选择，只能在受限程度较低的表t2之前访问受限程度较低的表t1，这可能会产生非常低效的执行计划。</p><p></p><p>
                Instead, MySQL converts the query to a query with no outer
                join operation if the <code class="literal">WHERE</code> condition is
                null-rejected. (That is, it converts the outer join to an
                inner join.) A condition is said to be null-rejected for an
                outer join operation if it evaluates to
                <code class="literal">FALSE</code> or <code class="literal">UNKNOWN</code> for any
                <code class="literal">NULL</code>-complemented row generated for the
                operation.
            </p><p style="color:blue;">相反，如果where条件为空，mysql会将查询转换为不带外部连接操作的查询。（即，它将外部联接转换为内部联接。）对于外部联接操作，如果为该操作生成的任何空补行的计算结果为false或unknown，则称该条件为空拒绝。</p><p></p><a class="indexterm" name="idm140286875285552"></a><a class="indexterm" name="idm140286875284480"></a><p>
                Thus, for this outer join:
            </p><p style="color:blue;">因此，对于这个外部连接：</p><p></p><pre data-lang="sql" class="programlisting">T1 LEFT JOIN T2 ON T1.A=T2.A
</pre><p>
                Conditions such as these are null-rejected because they cannot
                be true for any <code class="literal">NULL</code>-complemented row (with
                <code class="literal">T2</code> columns set to <code class="literal">NULL</code>):
            </p><p style="color:blue;">此类条件被空拒绝，因为对于任何空补行（t2列设置为空）它们不能为真：</p><p></p><pre data-lang="sql" class="programlisting">T2.B IS NOT NULL
T2.B &gt; 3
T2.C &lt;= T1.C
T2.B &lt; 2 OR T2.C &gt; 1
</pre><p>
                Conditions such as these are not null-rejected because they
                might be true for a <code class="literal">NULL</code>-complemented row:
            </p><p style="color:blue;">此类条件不会被空拒绝，因为对于空补行，它们可能为真：</p><p></p><pre data-lang="sql" class="programlisting">T2.B IS NULL
T1.B &lt; 3 OR T2.B IS NOT NULL
T1.B &lt; 3 OR T2.B &gt; 3
</pre><p>
                The general rules for checking whether a condition is
                null-rejected for an outer join operation are simple:
            </p><p style="color:blue;">检查外部联接操作的条件是否为空的一般规则很简单：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        It is of the form <code class="literal">A IS NOT NULL</code>, where
                        <code class="literal">A</code> is an attribute of any of the inner
                        tables
                    </p><p style="color:blue;">它的形式是a不为空，其中a是任何内部表的属性</p><p></p></li><li class="listitem"><p>
                        It is a predicate containing a reference to an inner table
                        that evaluates to <code class="literal">UNKNOWN</code> when one of
                        its arguments is <code class="literal">NULL</code>
                    </p><p style="color:blue;">它是一个谓词，包含对内部表的引用，当其中一个参数为空时，该表的计算结果为未知</p><p></p></li><li class="listitem"><p>
                        It is a conjunction containing a null-rejected condition
                        as a conjunct
                    </p><p style="color:blue;">它是一个连接词，包含一个空的拒绝条件作为连接词</p><p></p></li><li class="listitem"><p>
                        It is a disjunction of null-rejected conditions
                    </p><p style="color:blue;">它是空拒绝条件的析取。</p><p></p></li></ul>
                </div>
                <p>
                    A condition can be null-rejected for one outer join operation
                    in a query and not null-rejected for another. In this query,
                    the <code class="literal">WHERE</code> condition is null-rejected for
                    the second outer join operation but is not null-rejected for
                    the first one:
                </p><p style="color:blue;">对于查询中的一个外部联接操作，条件可以为空，而对于另一个外部联接操作，条件不能为空。在此查询中，对于第二个外部联接操作，where条件为空拒绝，而对于第一个外部联接操作，where条件为非空拒绝：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T1.B
  WHERE T3.C &gt; 0
</pre><p>
                If the <code class="literal">WHERE</code> condition is null-rejected for
                an outer join operation in a query, the outer join operation
                is replaced by an inner join operation.
            </p><p style="color:blue;">如果查询中的外部联接操作的where条件为空，则外部联接操作将替换为内部联接操作。</p><p></p><p>
                For example, in the preceding query, the second outer join is
                null-rejected and can be replaced by an inner join:
            </p><p style="color:blue;">例如，在前面的查询中，第二个外部联接被空拒绝，可以被内部联接替换：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T1.B
  WHERE T3.C &gt; 0
</pre><p>
                For the original query, the optimizer evaluates only plans
                compatible with the single table-access order
                <code class="literal">T1,T2,T3</code>. For the rewritten query, it
                additionally considers the access order
                <code class="literal">T3,T1,T2</code>.
            </p><p style="color:blue;">对于原始查询，优化器只计算与单表访问顺序T1、T2、T3兼容的计划。对于重写的查询，它还考虑访问顺序t3、t1、t2。</p><p></p><p>
                A conversion of one outer join operation may trigger a
                conversion of another. Thus, the query:
            </p><p style="color:blue;">一个外部联接操作的转换可能会触发另一个操作的转换。因此，查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T2.B
  WHERE T3.C &gt; 0
</pre><p>
                Is first converted to the query:
            </p><p style="color:blue;">首先转换为查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T2.B
  WHERE T3.C &gt; 0
</pre><p>
                Which is equivalent to the query:
            </p><p style="color:blue;">相当于查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre><p>
                The remaining outer join operation can also be replaced by an
                inner join because the condition <code class="literal">T3.B=T2.B</code>
                is null-rejected. This results in a query with no outer joins
                at all:
            </p><p style="color:blue;">剩余的外部联接操作也可以替换为内部联接，因为条件t3.b=t2.b被空拒绝。这将导致查询完全没有外部联接：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre><p>
                Sometimes the optimizer succeeds in replacing an embedded
                outer join operation, but cannot convert the embedding outer
                join. The following query:
            </p><p style="color:blue;">有时优化器会成功替换嵌入的外部联接操作，但无法转换嵌入的外部联接。以下查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C &gt; 0
</pre><p>
                Is converted to:
            </p><p style="color:blue;">转换为：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 INNER JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C &gt; 0
</pre><p>
                That can be rewritten only to the form still containing the
                embedding outer join operation:
            </p><p style="color:blue;">只能重写为仍包含嵌入外部联接操作的窗体：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2,T3)
              ON (T2.A=T1.A AND T3.B=T2.B)
  WHERE T3.C &gt; 0
</pre><p>
                Any attempt to convert an embedded outer join operation in a
                query must take into account the join condition for the
                embedding outer join together with the
                <code class="literal">WHERE</code> condition. In this query, the
                <code class="literal">WHERE</code> condition is not null-rejected for
                the embedded outer join, but the join condition of the
                embedding outer join <code class="literal">T2.A=T1.A AND
                T3.C=T1.C</code> is null-rejected:
            </p><p style="color:blue;">任何转换查询中嵌入的外部联接操作的尝试都必须考虑嵌入外部联接的联接条件和where条件。在此查询中，对于嵌入的外部联接，where条件不为空，但嵌入的外部联接t2.a=t1.a和t3.c=t1.c的联接条件为空：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A AND T3.C=T1.C
  WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre><p>
                Consequently, the query can be converted to:
            </p><p style="color:blue;">因此，查询可以转换为：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2, T3)
              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
  WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="mrr-optimization"></a>8.2.1.10&nbsp;Multi-Range Read Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286875242224"></a><a class="indexterm" name="idm140286875240768"></a><p>
                Reading rows using a range scan on a secondary index can
                result in many random disk accesses to the base table when the
                table is large and not stored in the storage engine's cache.
                With the Disk-Sweep Multi-Range Read (MRR) optimization, MySQL
                tries to reduce the number of random disk access for range
                scans by first scanning the index only and collecting the keys
                for the relevant rows. Then the keys are sorted and finally
                the rows are retrieved from the base table using the order of
                the primary key. The motivation for Disk-sweep MRR is to
                reduce the number of random disk accesses and instead achieve
                a more sequential scan of the base table data.
            </p><p style="color:blue;">当表较大且未存储在存储引擎的缓存中时，使用范围扫描对辅助索引读取行可能会导致对基表的许多随机磁盘访问。通过磁盘扫描多范围读取（mrr）优化，mysql尝试通过首先只扫描索引并收集相关行的键来减少范围扫描的随机磁盘访问数。然后对键进行排序，最后使用主键的顺序从基表中检索行。磁盘扫描mrr的动机是减少随机磁盘访问的数量，而是实现对基表数据的更连续的扫描。</p><p></p><p>
                The Multi-Range Read optimization provides these benefits:
            </p><p style="color:blue;">多范围读取优化提供了以下好处：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        MRR enables data rows to be accessed sequentially rather
                        than in random order, based on index tuples. The server
                        obtains a set of index tuples that satisfy the query
                        conditions, sorts them according to data row ID order, and
                        uses the sorted tuples to retrieve data rows in order.
                        This makes data access more efficient and less expensive.
                    </p><p style="color:blue;">mrr允许基于索引元组按顺序而不是按随机顺序访问数据行。服务器获取一组满足查询条件的索引元组，根据数据行id顺序进行排序，并使用排序后的元组按顺序检索数据行。这使得数据访问更高效、成本更低。</p><p></p></li><li class="listitem"><p>
                        MRR enables batch processing of requests for key access
                        for operations that require access to data rows through
                        index tuples, such as range index scans and equi-joins
                        that use an index for the join attribute. MRR iterates
                        over a sequence of index ranges to obtain qualifying index
                        tuples. As these results accumulate, they are used to
                        access the corresponding data rows. It is not necessary to
                        acquire all index tuples before starting to read data
                        rows.
                    </p><p style="color:blue;">对于需要通过索引元组访问数据行的操作（例如范围索引扫描和对join属性使用索引的equi连接），mrr支持对键访问请求的批处理。mrr对一系列索引范围进行迭代，以获得合格的索引元组。随着这些结果的累积，它们被用来访问相应的数据行。在开始读取数据行之前，不必获取所有索引元组。</p><p></p></li></ul>
                </div>
                <p>
                    The MRR optimization is not supported with secondary indexes
                    created on virtual generated columns.
                    <code class="literal">InnoDB</code> supports secondary indexes on
                    virtual generated columns.
                </p><p style="color:blue;">在虚拟生成列上创建的辅助索引不支持MRR优化。innodb支持虚拟生成列的二级索引。</p><p></p><p>
                The following scenarios illustrate when MRR optimization can
                be advantageous:
            </p><p style="color:blue;">以下场景说明了何时mrr优化是有利的：</p><p></p><p>
                Scenario A: MRR can be used for <code class="literal">InnoDB</code> and
                <code class="literal">MyISAM</code> tables for index range scans and
                equi-join operations.
            </p><p style="color:blue;">场景a:mrr可以用于innodb和myisam表，用于索引范围扫描和equi连接操作。</p><p></p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        A portion of the index tuples are accumulated in a buffer.
                    </p><p style="color:blue;">索引元组的一部分累积在缓冲区中。</p><p></p></li><li class="listitem"><p>
                        The tuples in the buffer are sorted by their data row ID.
                    </p><p style="color:blue;">缓冲区中的元组按其数据行ID排序。</p><p></p></li><li class="listitem"><p>
                        Data rows are accessed according to the sorted index tuple
                        sequence.
                    </p><p style="color:blue;">根据已排序的索引元组序列访问数据行。</p><p></p></li></ol>
                </div>
                <p>
                    Scenario B: MRR can be used for
                    <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a> tables for multiple-range
                    index scans or when performing an equi-join by an attribute.
                </p><p style="color:blue;">场景B:MRR可以用于多范围索引扫描的NDB表，也可以用于按属性执行EQUI联接的情况。</p><p></p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        A portion of ranges, possibly single-key ranges, is
                        accumulated in a buffer on the central node where the
                        query is submitted.
                    </p><p style="color:blue;">一部分范围（可能是单键范围）累积在提交查询的中心节点上的缓冲区中。</p><p></p></li><li class="listitem"><p>
                        The ranges are sent to the execution nodes that access
                        data rows.
                    </p><p style="color:blue;">范围被发送到访问数据行的执行节点。</p><p></p></li><li class="listitem"><p>
                        The accessed rows are packed into packages and sent back
                        to the central node.
                    </p><p style="color:blue;">访问的行打包成包并发送回中心节点。</p><p></p></li><li class="listitem"><p>
                        The received packages with data rows are placed in a
                        buffer.
                    </p><p style="color:blue;">接收到的带有数据行的包被放在缓冲区中。</p><p></p></li><li class="listitem"><p>
                        Data rows are read from the buffer.
                    </p><p style="color:blue;">从缓冲区读取数据行。</p><p></p></li></ol>
                </div>
                <p>
                    When MRR is used, the <code class="literal">Extra</code> column in
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output shows
                    <code class="literal">Using MRR</code>.
                </p><p style="color:blue;">当使用mrr时，explain输出中的额外列显示使用mrr。</p><p></p><p>
                <code class="literal">InnoDB</code> and <code class="literal">MyISAM</code> do not
                use MRR if full table rows need not be accessed to produce the
                query result. This is the case if results can be produced
                entirely on the basis on information in the index tuples
                (through a <a class="link" href="glossary.html#glos_covering_index" title="covering index">covering
                index</a>); MRR provides no benefit.
            </p><p style="color:blue;">如果不需要访问完整的表行来生成查询结果，innodb和myisam不使用mrr。如果结果可以完全基于索引元组中的信息（通过覆盖索引）生成，则会出现这种情况；mrr没有提供任何好处。</p><p></p><p>
                Two <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                variable flags provide an interface to the use of MRR
                optimization. The <code class="literal">mrr</code> flag controls whether
                MRR is enabled. If <code class="literal">mrr</code> is enabled
                (<code class="literal">on</code>), the <code class="literal">mrr_cost_based</code>
                flag controls whether the optimizer attempts to make a
                cost-based choice between using and not using MRR
                (<code class="literal">on</code>) or uses MRR whenever possible
                (<code class="literal">off</code>). By default, <code class="literal">mrr</code>
                is <code class="literal">on</code> and <code class="literal">mrr_cost_based</code>
                is <code class="literal">on</code>. See
                <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>.
            </p><p style="color:blue;">两个optimizer_switch系统变量标志提供了使用mrr优化的接口。mrr标志控制是否启用mrr。如果启用了mrr（on），则基于mrr_cost_的标志控制优化器是否尝试在使用和不使用mrr（on）之间进行基于成本的选择，或者尽可能使用mrr（off）。默认情况下，“mrr”处于启用状态，“mrr_cost_based”处于启用状态。见第8.9.2节“可切换优化”。</p><p></p><p>
                For MRR, a storage engine uses the value of the
                <a class="link" href="server-administration.html#sysvar_read_rnd_buffer_size"><code class="literal">read_rnd_buffer_size</code></a> system
                variable as a guideline for how much memory it can allocate
                for its buffer. The engine uses up to
                <a class="link" href="server-administration.html#sysvar_read_rnd_buffer_size"><code class="literal">read_rnd_buffer_size</code></a> bytes
                and determines the number of ranges to process in a single
                pass.
            </p><p style="color:blue;">对于MRR，存储引擎使用READ RND BUFFER大小系统变量的值作为可以为其缓冲区分配多少内存的准则。引擎使用至多个读取缓冲区大小的字节，并确定在一次传递中要处理的范围数。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="bnl-bka-optimization"></a>8.2.1.11&nbsp;Block Nested-Loop and Batched Key Access Joins</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286875199072"></a><a class="indexterm" name="idm140286875197616"></a><a class="indexterm" name="idm140286875196128"></a><a class="indexterm" name="idm140286875194640"></a><p>
                In MySQL, a Batched Key Access (BKA) Join algorithm is
                available that uses both index access to the joined table and
                a join buffer. The BKA algorithm supports inner join, outer
                join, and semijoin operations, including nested outer joins.
                Benefits of BKA include improved join performance due to more
                efficient table scanning. Also, the Block Nested-Loop (BNL)
                Join algorithm previously used only for inner joins is
                extended and can be employed for outer join and semijoin
                operations, including nested outer joins.
            </p><p style="color:blue;">在mysql中，一个批处理键访问（bka）连接算法是可用的，它同时使用对连接表的索引访问和一个连接缓冲区。bka算法支持内部连接、外部连接和半连接操作，包括嵌套的外部连接。bka的好处包括由于更有效的表扫描而提高了连接性能。此外，扩展了以前仅用于内部连接的块嵌套循环（bnl）连接算法，并可用于外部连接和半连接操作，包括嵌套外部连接。</p><p></p><p>
                The following sections discuss the join buffer management that
                underlies the extension of the original BNL algorithm, the
                extended BNL algorithm, and the BKA algorithm. For information
                about semijoin strategies, see <a class="xref" href="optimization.html#semijoins" title="8.2.2.1&nbsp;Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations">Section&nbsp;8.2.2.1, “Optimizing Subqueries, Derived Tables, and View References with Semijoin
                Transformations”</a>
            </p><p style="color:blue;">以下各节讨论了作为原始bnl算法、扩展bnl算法和bka算法扩展基础的连接缓冲区管理。有关半联接策略的信息，请参阅第8.2.2.1节“使用半联接转换优化子查询、派生表和视图引用”</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#join-buffer-management" title="Join Buffer Management for Block Nested-Loop and Batched Key Access Algorithms">Join Buffer Management for Block Nested-Loop and Batched Key Access
                        Algorithms</a></p><p style="color:blue;">块嵌套循环和批密钥访问算法的连接缓冲区管理</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#bnl-optimization" title="Block Nested-Loop Algorithm for Outer Joins and Semijoins">Block Nested-Loop Algorithm for Outer Joins and Semijoins</a></p><p style="color:blue;">外连接和半连接的块嵌套循环算法</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#bka-optimization" title="Batched Key Access Joins">Batched Key Access Joins</a></p><p style="color:blue;">成批密钥访问联接</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#bnl-bka-optimizer-hints" title="Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms">Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms</a></p><p style="color:blue;">块嵌套循环和批处理密钥访问算法的优化器提示</p><p></p></li></ul>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="join-buffer-management"></a>Join Buffer Management for Block Nested-Loop and Batched Key Access
                                    Algorithms</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        MySQL can employ join buffers to execute not only inner
                        joins without index access to the inner table, but also
                        outer joins and semijoins that appear after subquery
                        flattening. Moreover, a join buffer can be effectively used
                        when there is an index access to the inner table.
                    </p><p style="color:blue;">mysql可以使用连接缓冲区来执行内部连接，而不必对内部表进行索引访问，还可以执行外部连接和子查询展平后出现的半连接。此外，当有对内部表的索引访问时，可以有效地使用连接缓冲区。</p><p></p><p>
                    The join buffer management code slightly more efficiently
                    utilizes join buffer space when storing the values of the
                    interesting row columns: No additional bytes are allocated
                    in buffers for a row column if its value is
                    <code class="literal">NULL</code>, and the minimum number of bytes is
                    allocated for any value of the
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> type.
                </p><p style="color:blue;">在存储感兴趣的行列的值时，连接缓冲区管理代码稍微更有效地利用了连接缓冲区空间：如果行列的值为空，则不会在缓冲区中为行列分配额外的字节，并且为varchar类型的任何值分配最小字节数。</p><p></p><p>
                    The code supports two types of buffers, regular and
                    incremental. Suppose that join buffer <code class="literal">B1</code>
                    is employed to join tables <code class="literal">t1</code> and
                    <code class="literal">t2</code> and the result of this operation is
                    joined with table <code class="literal">t3</code> using join buffer
                    <code class="literal">B2</code>:
                </p><p style="color:blue;">代码支持两种类型的缓冲区：常规缓冲区和增量缓冲区。假设使用联接缓冲区b1联接表t1和t2，并且此操作的结果使用联接缓冲区b2与表t3联接：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            A regular join buffer contains columns from each join
                            operand. If <code class="literal">B2</code> is a regular join
                            buffer, each row <em class="replaceable"><code>r</code></em> put into
                            <code class="literal">B2</code> is composed of the columns of a
                            row <em class="replaceable"><code>r1</code></em> from
                            <code class="literal">B1</code> and the interesting columns of a
                            matching row <em class="replaceable"><code>r2</code></em> from table
                            <code class="literal">t3</code>.
                        </p><p style="color:blue;">常规联接缓冲区包含每个联接操作数中的列。如果b2是一个常规连接缓冲区，那么放入b2的每一行r都由b1中的r1列和表t3中匹配的r2列组成。</p><p></p></li><li class="listitem"><p>
                            An incremental join buffer contains only columns from
                            rows of the table produced by the second join operand.
                            That is, it is incremental to a row from the first
                            operand buffer. If <code class="literal">B2</code> is an
                            incremental join buffer, it contains the interesting
                            columns of the row <em class="replaceable"><code>r2</code></em>
                            together with a link to the row
                            <em class="replaceable"><code>r1</code></em> from
                            <code class="literal">B1</code>.
                        </p><p style="color:blue;">增量联接缓冲区仅包含第二个联接操作数生成的表行中的列。也就是说，它是从第一个操作数缓冲区递增到一行的。如果b2是增量连接缓冲区，则它包含行r2的有趣列以及从b1到行r1的链接。</p><p></p></li></ul>
                    </div>
                    <p>
                        Incremental join buffers are always incremental relative to
                        a join buffer from an earlier join operation, so the buffer
                        from the first join operation is always a regular buffer. In
                        the example just given, the buffer <code class="literal">B1</code>
                        used to join tables <code class="literal">t1</code> and
                        <code class="literal">t2</code> must be a regular buffer.
                    </p><p style="color:blue;">增量连接缓冲区始终相对于早期连接操作的连接缓冲区是增量的，因此第一个连接操作的缓冲区始终是常规缓冲区。在刚刚给出的示例中，用于联接表T1和T2的缓冲区B1必须是常规缓冲区。</p><p></p><p>
                    Each row of the incremental buffer used for a join operation
                    contains only the interesting columns of a row from the
                    table to be joined. These columns are augmented with a
                    reference to the interesting columns of the matched row from
                    the table produced by the first join operand. Several rows
                    in the incremental buffer can refer to the same row
                    <em class="replaceable"><code>r</code></em> whose columns are stored in the
                    previous join buffers insofar as all these rows match row
                    <em class="replaceable"><code>r</code></em>.
                </p><p style="color:blue;">用于联接操作的增量缓冲区的每一行只包含要联接的表中某行的有趣列。这些列用对第一个联接操作数生成的表中匹配行的有趣列的引用进行扩充。增量缓冲区中的几行可以引用同一行r，只要这些行都与行r匹配，那么这些行的列就存储在前一个联接缓冲区中。</p><p></p><p>
                    Incremental buffers enable less frequent copying of columns
                    from buffers used for previous join operations. This
                    provides a savings in buffer space because in the general
                    case a row produced by the first join operand can be matched
                    by several rows produced by the second join operand. It is
                    unnecessary to make several copies of a row from the first
                    operand. Incremental buffers also provide a savings in
                    processing time due to the reduction in copying time.
                </p><p style="color:blue;">增量缓冲区允许较不频繁地从用于以前联接操作的缓冲区复制列。这节省了缓冲区空间，因为在一般情况下，第一个联接操作数生成的行可以与第二个联接操作数生成的几行相匹配。从第一个操作数复制一行是不必要的。由于减少了复制时间，增量缓冲区还节省了处理时间。</p><p></p><p>
                    The <code class="literal">block_nested_loop</code> and
                    <code class="literal">batched_key_access</code> flags of the
                    <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                    variable control how the optimizer uses the Block
                    Nested-Loop and Batched Key Access join algorithms. By
                    default, <code class="literal">block_nested_loop</code> is
                    <code class="literal">on</code> and
                    <code class="literal">batched_key_access</code> is
                    <code class="literal">off</code>. See
                    <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>. Optimizer hints
                    may also be applied; see
                    <a class="xref" href="optimization.html#bnl-bka-optimizer-hints" title="Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms">Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms</a>.
                </p><p style="color:blue;">优化器交换系统变量的block_nested_loop和batched_key_access标志控制优化器如何使用block嵌套循环和batched key access join算法。默认情况下，block_nested_loop处于打开状态，batched_key_access处于关闭状态。见第8.9.2节“可切换优化”。也可以应用优化器提示；请参阅块嵌套循环和批处理密钥访问算法的优化器提示。</p><p></p><p>
                    For information about semijoin strategies, see
                    <a class="xref" href="optimization.html#semijoins" title="8.2.2.1&nbsp;Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations">Section&nbsp;8.2.2.1, “Optimizing Subqueries, Derived Tables, and View References with Semijoin
                        Transformations”</a>
                </p><p style="color:blue;">有关半联接策略的信息，请参阅第8.2.2.1节“使用半联接转换优化子查询、派生表和视图引用”</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="bnl-optimization"></a>Block Nested-Loop Algorithm for Outer Joins and Semijoins</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286875152832"></a><a class="indexterm" name="idm140286875151376"></a><p>
                    The original implementation of the MySQL BNL algorithm is
                    extended to support outer join and semijoin operations.
                </p><p style="color:blue;">对mysql bnl算法的原始实现进行了扩展，以支持外部连接和半连接操作。</p><p></p><p>
                    When these operations are executed with a join buffer, each
                    row put into the buffer is supplied with a match flag.
                </p><p style="color:blue;">当使用联接缓冲区执行这些操作时，放入缓冲区的每一行都会提供一个匹配标志。</p><p></p><p>
                    If an outer join operation is executed using a join buffer,
                    each row of the table produced by the second operand is
                    checked for a match against each row in the join buffer.
                    When a match is found, a new extended row is formed (the
                    original row plus columns from the second operand) and sent
                    for further extensions by the remaining join operations. In
                    addition, the match flag of the matched row in the buffer is
                    enabled. After all rows of the table to be joined have been
                    examined, the join buffer is scanned. Each row from the
                    buffer that does not have its match flag enabled is extended
                    by <code class="literal">NULL</code> complements
                    (<code class="literal">NULL</code> values for each column in the
                    second operand) and sent for further extensions by the
                    remaining join operations.
                </p><p style="color:blue;">如果使用联接缓冲区执行外部联接操作，则将针对联接缓冲区中的每一行检查由第二个操作数生成的表的每一行是否匹配。找到匹配时，将形成一个新的扩展行（原始行加上第二个操作数中的列），并通过其余的连接操作发送进一步的扩展。此外，将启用缓冲区中匹配行的匹配标志。在检查要联接的表的所有行之后，将扫描联接缓冲区。缓冲区中未启用匹配标志的每一行由空补码（第二个操作数中的每一列的空值）扩展，并由其余的联接操作发送进一步的扩展。</p><p></p><p>
                    The <code class="literal">block_nested_loop</code> flag of the
                    <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                    variable controls how the optimizer uses the Block
                    Nested-Loop algorithm. By default,
                    <code class="literal">block_nested_loop</code> is
                    <code class="literal">on</code>. See
                    <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>. Optimizer hints
                    may also be applied; see
                    <a class="xref" href="optimization.html#bnl-bka-optimizer-hints" title="Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms">Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms</a>.
                </p><p style="color:blue;">优化器开关系统变量的block_nested_loop标志控制优化器如何使用块嵌套循环算法。默认情况下，“块嵌套”循环处于启用状态。见第8.9.2节“可切换优化”。也可以应用优化器提示；请参阅块嵌套循环和批处理密钥访问算法的优化器提示。</p><p></p><p>
                    In <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output, use of BNL
                    for a table is signified when the <code class="literal">Extra</code>
                    value contains <code class="literal">Using join buffer (Block Nested
                    Loop)</code> and the <code class="literal">type</code> value is
                    <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a>,
                    <a class="link" href="optimization.html#jointype_index"><code class="literal">index</code></a>, or
                    <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a>.
                </p><p style="color:blue;">在explain output中，当额外的值包含using join buffer（block nested loop）且类型值为all、index或range时，表示对表使用bnl。</p><p></p><p>
                    For information about semijoin strategies, see
                    <a class="xref" href="optimization.html#semijoins" title="8.2.2.1&nbsp;Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations">Section&nbsp;8.2.2.1, “Optimizing Subqueries, Derived Tables, and View References with Semijoin
                        Transformations”</a>
                </p><p style="color:blue;">有关半联接策略的信息，请参阅第8.2.2.1节“使用半联接转换优化子查询、派生表和视图引用”</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="bka-optimization"></a>Batched Key Access Joins</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286875130800"></a><a class="indexterm" name="idm140286875129344"></a><p>
                    MySQL implements a method of joining tables called the
                    Batched Key Access (BKA) join algorithm. BKA can be applied
                    when there is an index access to the table produced by the
                    second join operand. Like the BNL join algorithm, the BKA
                    join algorithm employs a join buffer to accumulate the
                    interesting columns of the rows produced by the first
                    operand of the join operation. Then the BKA algorithm builds
                    keys to access the table to be joined for all rows in the
                    buffer and submits these keys in a batch to the database
                    engine for index lookups. The keys are submitted to the
                    engine through the Multi-Range Read (MRR) interface (see
                    <a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.10&nbsp;Multi-Range Read Optimization">Section&nbsp;8.2.1.10, “Multi-Range Read Optimization”</a>). After submission of the
                    keys, the MRR engine functions perform lookups in the index
                    in an optimal way, fetching the rows of the joined table
                    found by these keys, and starts feeding the BKA join
                    algorithm with matching rows. Each matching row is coupled
                    with a reference to a row in the join buffer.
                </p><p style="color:blue;">mysql实现了一种连接表的方法，称为批处理密钥访问（bka）连接算法。当对第二个联接操作数生成的表进行索引访问时，可以应用bka。与bnl连接算法一样，bka连接算法使用连接缓冲区来累积由连接操作的第一个操作数生成的行的有趣列。然后，bka算法为缓冲区中的所有行构建访问要联接的表的键，并将这些键批量提交给数据库引擎进行索引查找。钥匙通过多量程读取（MRR）接口提交给发动机（见第8.2.1.10节“多量程读取优化”）。提交键后，mrr引擎函数以最佳方式在索引中执行查找，获取这些键找到的联接表的行，并开始向bka联接算法提供匹配的行。每个匹配的行都耦合有对连接缓冲区中某行的引用。</p><p></p><p>
                    When BKA is used, the value of
                    <a class="link" href="server-administration.html#sysvar_join_buffer_size"><code class="literal">join_buffer_size</code></a> defines
                    how large the batch of keys is in each request to the
                    storage engine. The larger the buffer, the more sequential
                    access will be to the right hand table of a join operation,
                    which can significantly improve performance.
                </p><p style="color:blue;">使用bka时，join_buffer_size的值定义对存储引擎的每个请求中的密钥批有多大。缓冲区越大，对连接操作的右边表的顺序访问就越多，这可以显著提高性能。</p><p></p><p>
                    For BKA to be used, the
                    <code class="literal">batched_key_access</code> flag of the
                    <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                    variable must be set to <code class="literal">on</code>. BKA uses MRR,
                    so the <code class="literal">mrr</code> flag must also be
                    <code class="literal">on</code>. Currently, the cost estimation for
                    MRR is too pessimistic. Hence, it is also necessary for
                    <code class="literal">mrr_cost_based</code> to be
                    <code class="literal">off</code> for BKA to be used. The following
                    setting enables BKA:
                </p><p style="color:blue;">要使用BKA，优化器开关系统变量的BATCHED U KEY U ACCESS标志必须设置为ON。bka使用mrr，因此mrr标志也必须为on。目前，mrr的成本估算过于悲观。因此，也有必要关闭基于mrr_的成本_，以便使用bka。以下设置启用BKA：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</code></strong>
</pre><p>
                    There are two scenarios by which MRR functions execute:
                </p><p style="color:blue;">mrr函数的执行有两种情况：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The first scenario is used for conventional disk-based
                            storage engines such as
                            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                            <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>. For these engines,
                            usually the keys for all rows from the join buffer are
                            submitted to the MRR interface at once. Engine-specific
                            MRR functions perform index lookups for the submitted
                            keys, get row IDs (or primary keys) from them, and then
                            fetch rows for all these selected row IDs one by one by
                            request from BKA algorithm. Every row is returned with
                            an association reference that enables access to the
                            matched row in the join buffer. The rows are fetched by
                            the MRR functions in an optimal way: They are fetched in
                            the row ID (primary key) order. This improves
                            performance because reads are in disk order rather than
                            random order.
                        </p><p style="color:blue;">第一种方案用于传统的基于磁盘的存储引擎，如innodb和myisam。对于这些引擎，通常连接缓冲区中所有行的键都会一次提交到mrr接口。引擎特定的mrr函数对提交的键执行索引查找，从中获取行id（或主键），然后根据bka算法的请求逐个获取所有这些选定行id的行。每一行都返回一个关联引用，该引用允许访问连接缓冲区中匹配的行。mrr函数以最佳方式获取行：按行id（主键）顺序获取。这提高了性能，因为读取是按磁盘顺序而不是随机顺序进行的。</p><p></p></li><li class="listitem"><p>
                            The second scenario is used for remote storage engines
                            such as <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>. A package of
                            keys for a portion of rows from the join buffer,
                            together with their associations, is sent by a MySQL
                            Server (SQL node) to NDB Cluster data nodes. In return,
                            the SQL node receives a package (or several packages) of
                            matching rows coupled with corresponding associations.
                            The BKA join algorithm takes these rows and builds new
                            joined rows. Then a new set of keys is sent to the data
                            nodes and the rows from the returned packages are used
                            to build new joined rows. The process continues until
                            the last keys from the join buffer are sent to the data
                            nodes, and the SQL node has received and joined all rows
                            matching these keys. This improves performance because
                            fewer key-bearing packages sent by the SQL node to the
                            data nodes means fewer round trips between it and the
                            data nodes to perform the join operation.
                        </p><p style="color:blue;">第二种情况用于远程存储引擎，如ndb。mysql服务器（sql节点）将连接缓冲区中一部分行的密钥包及其关联发送到ndb集群数据节点。作为回报，sql节点接收一个匹配行的包（或多个包）以及相应的关联。bka连接算法接受这些行并构建新的连接行。然后向数据节点发送一组新的键，并使用返回包中的行来构建新的连接行。该过程将继续，直到将连接缓冲区中的最后一个键发送到数据节点，并且sql节点已接收并连接与这些键匹配的所有行。这提高了性能，因为sql节点发送给数据节点的密钥包更少意味着它与数据节点之间执行连接操作的往返次数更少。</p><p></p></li></ul>
                    </div>
                    <p>
                        With the first scenario, a portion of the join buffer is
                        reserved to store row IDs (primary keys) selected by index
                        lookups and passed as a parameter to the MRR functions.
                    </p><p style="color:blue;">在第一个场景中，连接缓冲区的一部分被保留以存储由索引查找选择的行id（主键），并作为参数传递给mrr函数。</p><p></p><p>
                    There is no special buffer to store keys built for rows from
                    the join buffer. Instead, a function that builds the key for
                    the next row in the buffer is passed as a parameter to the
                    MRR functions.
                </p><p style="color:blue;">没有特殊的缓冲区来存储为连接缓冲区中的行生成的键。相反，为缓冲区中的下一行生成键的函数作为参数传递给mrr函数。</p><p></p><p>
                    In <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output, use of BKA
                    for a table is signified when the <code class="literal">Extra</code>
                    value contains <code class="literal">Using join buffer (Batched Key
                    Access)</code> and the <code class="literal">type</code> value is
                    <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> or
                    <a class="link" href="optimization.html#jointype_eq_ref"><code class="literal">eq_ref</code></a>.
                </p><p style="color:blue;">在explain output中，当额外值包含using join buffer（批处理密钥访问）且类型值为ref或eq_ref时，表示对表使用bka。</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="bnl-bka-optimizer-hints"></a>Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        In addition to using the
                        <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                        variable to control optimizer use of the BNL and BKA
                        algorithms session-wide, MySQL supports optimizer hints to
                        influence the optimizer on a per-statement basis. See
                        <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3&nbsp;Optimizer Hints">Section&nbsp;8.9.3, “Optimizer Hints”</a>.
                    </p><p style="color:blue;">除了使用optimizer_switch系统变量控制优化器在会话范围内使用bnl和bka算法之外，mysql还支持优化器提示，以便在每个语句的基础上影响优化器。参见第8.9.3节“优化器提示”。</p><p></p><p>
                    To use a BNL or BKA hint to enable join buffering for any
                    inner table of an outer join, join buffering must be enabled
                    for all inner tables of the outer join.
                </p><p style="color:blue;">要使用bnl或bka提示为外部联接的任何内部表启用联接缓冲，必须为外部联接的所有内部表启用联接缓冲。</p><p></p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="condition-filtering"></a>8.2.1.12&nbsp;Condition Filtering</h4>

                        </div>

                    </div>

                </div>
                <p>
                    In join processing, prefix rows are those rows passed from one
                    table in a join to the next. In general, the optimizer
                    attempts to put tables with low prefix counts early in the
                    join order to keep the number of row combinations from
                    increasing rapidly. To the extent that the optimizer can use
                    information about conditions on rows selected from one table
                    and passed to the next, the more accurately it can compute row
                    estimates and choose the best execution plan.
                </p><p style="color:blue;">在联接处理中，前缀行是从联接中的一个表传递到下一个表的行。通常，优化器会尝试在联接顺序的早期放置前缀计数较低的表，以防止行组合的数量快速增加。在某种程度上，优化器可以使用有关从一个表中选择并传递给下一个表的行的条件的信息，因此它可以更准确地计算行估计值并选择最佳执行计划。</p><p></p><p>
                Without condition filtering, the prefix row count for a table
                is based on the estimated number of rows selected by the
                <code class="literal">WHERE</code> clause according to whichever access
                method the optimizer chooses. Condition filtering enables the
                optimizer to use other relevant conditions in the
                <code class="literal">WHERE</code> clause not taken into account by the
                access method, and thus improve its prefix row count
                estimates. For example, even though there might be an
                index-based access method that can be used to select rows from
                the current table in a join, there might also be additional
                conditions for the table in the <code class="literal">WHERE</code>
                clause that can filter (further restrict) the estimate for
                qualifying rows passed to the next table.
            </p><p style="color:blue;">如果没有条件筛选，表的前缀行计数将基于where子句根据优化器选择的访问方法选择的估计行数。条件筛选使优化器能够在访问方法未考虑的where子句中使用其他相关条件，从而改进其前缀行计数估计。例如，即使可能有一个基于索引的访问方法可用于从联接中的当前表中选择行，但where子句中的表也可能有其他条件，可以筛选（进一步限制）传递给下一个表的限定行的估计值。</p><p></p><p>
                A condition contributes to the filtering estimate only if:
            </p><p style="color:blue;">只有在以下情况下，条件才有助于筛选估计：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        It refers to the current table.
                    </p><p style="color:blue;">它指的是当前表。</p><p></p></li><li class="listitem"><p>
                        It depends on a constant value or values from earlier
                        tables in the join sequence.
                    </p><p style="color:blue;">它取决于一个常量值或联接序列中早期表的值。</p><p></p></li><li class="listitem"><p>
                        It was not already taken into account by the access
                        method.
                    </p><p style="color:blue;">访问方法尚未将其考虑在内。</p><p></p></li></ul>
                </div>
                <p>
                    In <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output, the
                    <code class="literal">rows</code> column indicates the row estimate for
                    the chosen access method, and the <code class="literal">filtered</code>
                    column reflects the effect of condition filtering.
                    <code class="literal">filtered</code> values are expressed as
                    percentages. The maximum value is 100, which means no
                    filtering of rows occurred. Values decreasing from 100
                    indicate increasing amounts of filtering.
                </p><p style="color:blue;">在“解释输出”中，“行”列指示所选访问方法的行估计值，而“筛选”列反映条件筛选的效果。过滤值以百分比表示。最大值为100，这意味着没有发生行过滤。值从100减少表示过滤量增加。</p><p></p><p>
                The prefix row count (the number of rows estimated to be
                passed from the current table in a join to the next) is the
                product of the <code class="literal">rows</code> and
                <code class="literal">filtered</code> values. That is, the prefix row
                count is the estimated row count, reduced by the estimated
                filtering effect. For example, if <code class="literal">rows</code> is
                1000 and <code class="literal">filtered</code> is 20%, condition
                filtering reduces the estimated row count of 1000 to a prefix
                row count of 1000 × 20% = 1000 × .2 = 200.
            </p><p style="color:blue;">前缀行计数（估计要从联接中的当前表传递到下一个表的行数）是行和筛选值的乘积。也就是说，前缀行数是估计的行数，由估计的过滤效果减少。例如，如果行为1000，筛选为20%，则条件筛选将估计的行数1000减少为前缀行数1000×20%=1000×2=200。</p><p></p><p>
                Consider the following query:
            </p><p style="color:blue;">请考虑以下查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT *
  FROM employee JOIN department ON employee.dept_no = department.dept_no
  WHERE employee.first_name = 'John'
  AND employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01';
</pre><p>
                Suppose that the data set has these characteristics:
            </p><p style="color:blue;">假设数据集具有以下特征：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <code class="literal">employee</code> table has 1024 rows.
                    </p><p style="color:blue;">employee表有1024行。</p><p></p></li><li class="listitem"><p>
                        The <code class="literal">department</code> table has 12 rows.
                    </p><p style="color:blue;">department表有12行。</p><p></p></li><li class="listitem"><p>
                        Both tables have an index on <code class="literal">dept_no</code>.
                    </p><p style="color:blue;">两张表都有部门编号索引。</p><p></p></li><li class="listitem"><p>
                        The <code class="literal">employee</code> table has an index on
                        <code class="literal">first_name</code>.
                    </p><p style="color:blue;">employee表在名字上有一个索引。</p><p></p></li><li class="listitem"><p>
                        8 rows satisfy this condition on
                        <code class="literal">employee.first_name</code>:
                    </p><p style="color:blue;">对于employee.first_name，8行满足此条件：</p><p></p><pre data-lang="sql" class="programlisting">employee.first_name = 'John'
</pre></li><li class="listitem"><p>
                        150 rows satisfy this condition on
                        <code class="literal">employee.hire_date</code>:
                    </p><p style="color:blue;">150行在employee.hire_日期满足此条件：</p><p></p><pre data-lang="sql" class="programlisting">employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01'
</pre></li><li class="listitem"><p>
                        1 row satisfies both conditions:
                    </p><p style="color:blue;">一行同时满足两个条件：</p><p></p><pre data-lang="sql" class="programlisting">employee.first_name = 'John'
AND employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01'
</pre></li></ul>
                </div>
                <p>
                    Without condition filtering,
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> produces output like
                    this:
                </p><p style="color:blue;">如果没有条件过滤，explain将生成如下输出：</p><p></p><pre data-lang="none" class="programlisting">+----+------------+--------+------------------+---------+---------+------+----------+
| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
+----+------------+--------+------------------+---------+---------+------+----------+
| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 100.00   |
| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
+----+------------+--------+------------------+---------+---------+------+----------+
</pre><p>
                For <code class="literal">employee</code>, the access method on the
                <code class="literal">name</code> index picks up the 8 rows that match a
                name of <code class="literal">'John'</code>. No filtering is done
                (<code class="literal">filtered</code> is 100%), so all rows are prefix
                rows for the next table: The prefix row count is
                <code class="literal">rows</code> × <code class="literal">filtered</code> =
                8 × 100% = 8.
            </p><p style="color:blue;">对于employee，name索引上的access方法将拾取与“john”名称匹配的8行。未进行筛选（筛选为100%），因此所有行都是下一个表的前缀行：前缀行计数为rows×filtered=8×100%=8。</p><p></p><p>
                With condition filtering, the optimizer additionally takes
                into account conditions from the <code class="literal">WHERE</code>
                clause not taken into account by the access method. In this
                case, the optimizer uses heuristics to estimate a filtering
                effect of 16.31% for the <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>
                condition on <code class="literal">employee.hire_date</code>. As a
                result, <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> produces output
                like this:
            </p><p style="color:blue;">对于条件筛选，优化器还考虑了访问方法未考虑的where子句中的条件。在这种情况下，优化器使用启发式方法估计employee.hire_date上的between条件的过滤效果为16.31%。因此，explain生成如下输出：</p><p></p><pre data-lang="none" class="programlisting">+----+------------+--------+------------------+---------+---------+------+----------+
| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
+----+------------+--------+------------------+---------+---------+------+----------+
| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 16.31    |
| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
+----+------------+--------+------------------+---------+---------+------+----------+
</pre><p>
                Now the prefix row count is <code class="literal">rows</code> ×
                <code class="literal">filtered</code> = 8 × 16.31% = 1.3, which
                more closely reflects actual data set.
            </p><p style="color:blue;">现在前缀行数是rows×filtered=8×16.31%=1.3，这更能反映实际的数据集。</p><p></p><p>
                Normally, the optimizer does not calculate the condition
                filtering effect (prefix row count reduction) for the last
                joined table because there is no next table to pass rows to.
                An exception occurs for
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>: To provide more
                information, the filtering effect is calculated for all joined
                tables, including the last one.
            </p><p style="color:blue;">通常，优化器不会计算最后一个联接表的条件筛选效果（前缀行数减少），因为没有下一个要向其传递行的表。explain出现异常：为了提供更多信息，将计算所有联接表（包括最后一个表）的过滤效果。</p><p></p><p>
                To control whether the optimizer considers additional
                filtering conditions, use the
                <code class="literal">condition_fanout_filter</code> flag of the
                <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                variable (see <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>).
                This flag is enabled by default but can be disabled to
                suppress condition filtering (for example, if a particular
                query is found to yield better performance without it).
            </p><p style="color:blue;">若要控制优化器是否考虑其他筛选条件，请使用优化器开关系统变量的condition_anout_filter标志（请参阅第8.9.2节“可切换优化”）。默认情况下，此标志处于启用状态，但可以禁用以抑制条件筛选（例如，如果发现某个特定查询在没有条件筛选的情况下可以获得更好的性能）。</p><p></p><p>
                If the optimizer overestimates the effect of condition
                filtering, performance may be worse than if condition
                filtering is not used. In such cases, these techniques may
                help:
            </p><p style="color:blue;">如果优化器高估了条件过滤的效果，则性能可能会比不使用条件过滤时更差。在这种情况下，这些技术可能有助于：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If a column is not indexed, index it so that the optimizer
                        has some information about the distribution of column
                        values and can improve its row estimates.
                    </p><p style="color:blue;">如果列没有索引，则对其进行索引，以便优化器获得有关列值分布的一些信息，并可以改进其行估计。</p><p></p></li><li class="listitem"><p>
                        Change the join order. Ways to accomplish this include
                        join-order optimizer hints (see
                        <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3&nbsp;Optimizer Hints">Section&nbsp;8.9.3, “Optimizer Hints”</a>),
                        <code class="literal">STRAIGHT_JOIN</code> immediately following the
                        <code class="literal">SELECT</code>, and the
                        <code class="literal">STRAIGHT_JOIN</code> join operator.
                    </p><p style="color:blue;">更改联接顺序。实现这一点的方法包括连接顺序优化器提示（参见第8.9.3节“优化器提示”）、紧接着select的直连接和直连接操作符。</p><p></p></li><li class="listitem"><p>
                        Disable condition filtering for the session:
                    </p><p style="color:blue;">禁用会话的条件筛选：</p><p></p><pre data-lang="sql" class="programlisting">SET optimizer_switch = 'condition_fanout_filter=off';
</pre></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="is-null-optimization"></a>8.2.1.13&nbsp;IS NULL Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286875031808"></a><a class="indexterm" name="idm140286875030736"></a><p>
                MySQL can perform the same optimization on
                <em class="replaceable"><code>col_name</code></em> <a class="link" href="functions.html#operator_is-null"><code class="literal">IS
                NULL</code></a> that it can use for
                <em class="replaceable"><code>col_name</code></em> <code class="literal">=</code>
                <em class="replaceable"><code>constant_value</code></em>. For example, MySQL
                can use indexes and ranges to search for
                <code class="literal">NULL</code> with <a class="link" href="functions.html#operator_is-null"><code class="literal">IS
                NULL</code></a>.
            </p><p style="color:blue;">mysql可以对col_name is null执行与col_name=constant_value相同的优化。例如，mysql可以使用索引和范围来使用is null搜索null。</p><p></p><p>
                Examples:
            </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> IS NULL;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> &lt;=&gt; NULL;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>const1</code></em> OR <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>const2</code></em> OR <em class="replaceable"><code>key_col</code></em> IS NULL;
</pre><p>
                If a <code class="literal">WHERE</code> clause includes a
                <em class="replaceable"><code>col_name</code></em> <a class="link" href="functions.html#operator_is-null"><code class="literal">IS
                NULL</code></a> condition for a column that is declared as
                <code class="literal">NOT NULL</code>, that expression is optimized
                away. This optimization does not occur in cases when the
                column might produce <code class="literal">NULL</code> anyway (for
                example, if it comes from a table on the right side of a
                <code class="literal">LEFT JOIN</code>).
            </p><p style="color:blue;">如果where子句包含声明为非空的列的col_name is null条件，则会优化该表达式。这种优化不会发生在列可能产生空值的情况下（例如，如果它来自左联接右侧的表）。</p><p></p><p>
                MySQL can also optimize the combination
                <code class="literal"><em class="replaceable"><code>col_name</code></em> =
                    <em class="replaceable"><code>expr</code></em> OR
                    <em class="replaceable"><code>col_name</code></em> IS NULL</code>, a form
                that is common in resolved subqueries.
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> shows
                <a class="link" href="optimization.html#jointype_ref_or_null"><code class="literal">ref_or_null</code></a> when this
                optimization is used.
            </p><p style="color:blue;">mysql还可以优化col_name=expr或col_name为空的组合，这种形式在解析的子查询中很常见。explain在使用此优化时显示ref_或_null。</p><p></p><p>
                This optimization can handle one <a class="link" href="functions.html#operator_is-null"><code class="literal">IS
                NULL</code></a> for any key part.
            </p><p style="color:blue;">对于任何关键部分，此优化都可以处理一个为空。</p><p></p><p>
                Some examples of queries that are optimized, assuming that
                there is an index on columns <code class="literal">a</code> and
                <code class="literal">b</code> of table <code class="literal">t2</code>:
            </p><p style="color:blue;">假设表T2的A列和B列上有索引，则一些优化的查询示例如下：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE t1.a=<em class="replaceable"><code>expr</code></em> OR t1.a IS NULL;

SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;

SELECT * FROM t1, t2
  WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;

SELECT * FROM t1, t2
  WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);

SELECT * FROM t1, t2
  WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)
  OR (t1.a=t2.a AND t2.a IS NULL AND ...);
</pre><p>
                <a class="link" href="optimization.html#jointype_ref_or_null"><code class="literal">ref_or_null</code></a> works by first
                doing a read on the reference key, and then a separate search
                for rows with a <code class="literal">NULL</code> key value.
            </p><p style="color:blue;">ref_或_null的工作方式是首先读取引用键，然后单独搜索具有空键值的行。</p><p></p><p>
                The optimization can handle only one <a class="link" href="functions.html#operator_is-null"><code class="literal">IS
                NULL</code></a> level. In the following query, MySQL uses key
                lookups only on the expression <code class="literal">(t1.a=t2.a AND t2.a IS
                NULL)</code> and is not able to use the key part on
                <code class="literal">b</code>:
            </p><p style="color:blue;">优化只能处理一个为空级别。在下面的查询中，mysql只对表达式（t1.a=t2.a，t2.a为空）使用键查找，不能对b使用键部分：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1, t2
  WHERE (t1.a=t2.a AND t2.a IS NULL)
  OR (t1.b=t2.b AND t2.b IS NULL);
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="order-by-optimization"></a>8.2.1.14&nbsp;ORDER BY Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286874994272"></a><a class="indexterm" name="idm140286874993200"></a><p>
                This section describes when MySQL can use an index to satisfy
                an <code class="literal">ORDER BY</code> clause, the
                <code class="literal">filesort</code> operation used when an index
                cannot be used, and execution plan information available from
                the optimizer about <code class="literal">ORDER BY</code>.
            </p><p style="color:blue;">本节描述MySQL何时可以使用索引来满足ORDER BY子句、无法使用索引时使用的文件排序操作以及优化器提供的有关ORDER BY的执行计划信息。</p><p></p><p>
                An <code class="literal">ORDER BY</code> with and without
                <code class="literal">LIMIT</code> may return rows in different orders,
                as discussed in <a class="xref" href="optimization.html#limit-optimization" title="8.2.1.17&nbsp;LIMIT Query Optimization">Section&nbsp;8.2.1.17, “LIMIT Query Optimization”</a>.
            </p><p style="color:blue;">Order by with and without limit可以按不同的顺序返回行，如第8.2.1.17节“限制查询优化”中所述。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#order-by-index-use" title="Use of Indexes to Satisfy ORDER BY">Use of Indexes to Satisfy ORDER BY</a></p><p style="color:blue;">使用索引满足order by</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#order-by-filesort" title="Use of filesort to Satisfy ORDER BY">Use of filesort to Satisfy ORDER BY</a></p><p style="color:blue;">使用文件排序来满足</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#order-by-optimizer-control" title="Influencing ORDER BY Optimization">Influencing ORDER BY Optimization</a></p><p style="color:blue;">通过优化影响订单</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#order-by-diagnostic-information" title="ORDER BY Execution Plan Information Available">ORDER BY Execution Plan Information Available</a></p><p style="color:blue;">提供按执行计划排序的信息</p><p></p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="order-by-index-use"></a>Use of Indexes to Satisfy ORDER BY</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        In some cases, MySQL may use an index to satisfy an
                        <code class="literal">ORDER BY</code> clause and avoid the extra
                        sorting involved in performing a <code class="literal">filesort</code>
                        operation.
                    </p><p style="color:blue;">在某些情况下，mysql可能使用索引来满足order by子句，并避免执行文件排序操作时涉及的额外排序。</p><p></p><p>
                    The index may also be used even if the <code class="literal">ORDER
                    BY</code> does not match the index exactly, as long as
                    all unused portions of the index and all extra
                    <code class="literal">ORDER BY</code> columns are constants in the
                    <code class="literal">WHERE</code> clause. If the index does not
                    contain all columns accessed by the query, the index is used
                    only if index access is cheaper than other access methods.
                </p><p style="color:blue;">即使order by与索引不完全匹配，也可以使用索引，只要索引的所有未使用部分和所有额外的orderby列都是where子句中的常量。如果索引不包含查询访问的所有列，则仅当索引访问比其他访问方法便宜时才使用索引。</p><p></p><p>
                    Assuming that there is an index on
                    <code class="literal">(<em class="replaceable"><code>key_part1</code></em>,
                        <em class="replaceable"><code>key_part2</code></em>)</code>, the
                    following queries may use the index to resolve the
                    <code class="literal">ORDER BY</code> part. Whether the optimizer
                    actually does so depends on whether reading the index is
                    more efficient than a table scan if columns not in the index
                    must also be read.
                </p><p style="color:blue;">假设上有一个索引（key_part1，key_part2），则以下查询可以使用该索引逐个解析订单。优化器是否真的这样做取决于如果还必须读取索引中不在的列，那么读取索引是否比表扫描更有效。</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            In this query, the index on
                            <code class="literal">(<em class="replaceable"><code>key_part1</code></em>,
                                <em class="replaceable"><code>key_part2</code></em>)</code> enables
                            the optimizer to avoid sorting:
                        </p><p style="color:blue;">在此查询中，上的索引（key_part1，key_part2）使优化器能够避免排序：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  ORDER BY <em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>;
</pre><p>
                            However, the query uses <code class="literal">SELECT *</code>,
                            which may select more columns than
                            <em class="replaceable"><code>key_part1</code></em> and
                            <em class="replaceable"><code>key_part2</code></em>. In that case,
                            scanning an entire index and looking up table rows to
                            find columns not in the index may be more expensive than
                            scanning the table and sorting the results. If so, the
                            optimizer probably will not use the index. If
                            <code class="literal">SELECT *</code> selects only the index
                            columns, the index will be used and sorting avoided.
                        </p><p style="color:blue;">但是，查询使用select*，它可以选择比key_part1和key_part2更多的列。在这种情况下，扫描整个索引并查找表行以查找不在索引中的列可能比扫描表并对结果进行排序更昂贵。如果是这样，优化器可能不会使用索引。如果select*只选择索引列，则将使用索引并避免排序。</p><p></p><p>
                            If <code class="literal">t1</code> is an <code class="literal">InnoDB</code>
                            table, the table primary key is implicitly part of the
                            index, and the index can be used to resolve the
                            <code class="literal">ORDER BY</code> for this query:
                        </p><p style="color:blue;">如果T1是InnoDB表，则表主键隐式地是索引的一部分，该索引可用于解析此查询的ORDER BY：</p><p></p><pre data-lang="sql" class="programlisting">SELECT <em class="replaceable"><code>pk</code></em>, <em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em> FROM t1
  ORDER BY <em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>;
</pre></li><li class="listitem"><p>
                            In this query, <em class="replaceable"><code>key_part1</code></em> is
                            constant, so all rows accessed through the index are in
                            <em class="replaceable"><code>key_part2</code></em> order, and an index
                            on <code class="literal">(<em class="replaceable"><code>key_part1</code></em>,
                            <em class="replaceable"><code>key_part2</code></em>)</code> avoids
                            sorting if the <code class="literal">WHERE</code> clause is
                            selective enough to make an index range scan cheaper
                            than a table scan:
                        </p><p style="color:blue;">在这个查询中，key_part1是常量，因此通过索引访问的所有行都是按key_part2的顺序进行的，如果where子句的选择性足以使索引范围扫描比表扫描便宜，那么（key_part1，key_part2）上的索引可以避免排序：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part2</code></em>;
</pre></li><li class="listitem"><p>
                            In the next two queries, whether the index is used is
                            similar to the same queries without
                            <code class="literal">DESC</code> shown previously:
                        </p><p style="color:blue;">在接下来的两个查询中，是否使用索引与前面未显示desc的相同查询相似：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part2</code></em> DESC;
</pre></li><li class="listitem"><p>
                            In the next two queries,
                            <em class="replaceable"><code>key_part1</code></em> is compared to a
                            constant. The index will be used if the
                            <code class="literal">WHERE</code> clause is selective enough to
                            make an index range scan cheaper than a table scan:
                        </p><p style="color:blue;">在接下来的两个查询中，将key_part1与常量进行比较。如果where子句的选择性足以使索引范围扫描比表扫描便宜，则将使用索引：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> &gt; <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> ASC;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> &lt; <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC;
</pre></li><li class="listitem"><p>
                            In the next query, the <code class="literal">ORDER BY</code> does
                            not name <em class="replaceable"><code>key_part1</code></em>, but all
                            rows selected have a constant
                            <em class="replaceable"><code>key_part1</code></em> value, so the index
                            can still be used:
                        </p><p style="color:blue;">在下一个查询中，order by不命名key_part1，但所选的所有行都有一个常量key_part1值，因此仍然可以使用索引：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>constant1</code></em> AND <em class="replaceable"><code>key_part2</code></em> &gt; <em class="replaceable"><code>constant2</code></em>
  ORDER BY <em class="replaceable"><code>key_part2</code></em>;
</pre></li></ul>
                    </div>
                    <p>
                        In some cases, MySQL <span class="emphasis"><em>cannot</em></span> use indexes
                        to resolve the <code class="literal">ORDER BY</code>, although it may
                        still use indexes to find the rows that match the
                        <code class="literal">WHERE</code> clause. Examples:
                    </p><p style="color:blue;">在某些情况下，mysql无法使用索引来解析order by，尽管它可能仍然使用索引来查找与where子句匹配的行。示例：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The query uses <code class="literal">ORDER BY</code> on different
                            indexes:
                        </p><p style="color:blue;">查询对不同索引使用order by：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 ORDER BY <em class="replaceable"><code>key1</code></em>, <em class="replaceable"><code>key2</code></em>;
</pre></li><li class="listitem"><p>
                            The query uses <code class="literal">ORDER BY</code> on
                            nonconsecutive parts of an index:
                        </p><p style="color:blue;">查询对索引的非连续部分使用ORDER BY：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE <em class="replaceable"><code>key2</code></em>=<em class="replaceable"><code>constant</code></em> ORDER BY <em class="replaceable"><code>key1_part1</code></em>, <em class="replaceable"><code>key1_part3</code></em>;
</pre></li><li class="listitem"><p>
                            The query mixes <code class="literal">ASC</code> and
                            <code class="literal">DESC</code>:
                        </p><p style="color:blue;">查询混合了asc和desc：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> ASC;
</pre></li><li class="listitem"><p>
                            The index used to fetch the rows differs from the one
                            used in the <code class="literal">ORDER BY</code>:
                        </p><p style="color:blue;">用于获取行的索引与按顺序使用的索引的不同之处在于：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE <em class="replaceable"><code>key2</code></em>=<em class="replaceable"><code>constant</code></em> ORDER BY <em class="replaceable"><code>key1</code></em>;
</pre></li><li class="listitem"><p>
                            The query uses <code class="literal">ORDER BY</code> with an
                            expression that includes terms other than the index
                            column name:
                        </p><p style="color:blue;">查询将ORDERBY与包含除索引列名以外的其他术语的表达式一起使用：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 ORDER BY ABS(<em class="replaceable"><code>key</code></em>);
SELECT * FROM t1 ORDER BY -<em class="replaceable"><code>key</code></em>;
</pre></li><li class="listitem"><p>
                            The query joins many tables, and the columns in the
                            <code class="literal">ORDER BY</code> are not all from the first
                            nonconstant table that is used to retrieve rows. (This
                            is the first table in the
                            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output that does
                            not have a <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a> join
                            type.)
                        </p><p style="color:blue;">查询连接许多表，并且order by中的列并不都来自用于检索行的第一个非连续表。（这是explain输出中第一个没有const join类型的表。）</p><p></p></li><li class="listitem"><p>
                            The query has different <code class="literal">ORDER BY</code> and
                            <code class="literal">GROUP BY</code> expressions.
                        </p><p style="color:blue;">查询具有不同的order by和group by表达式。</p><p></p></li><li class="listitem"><p>
                            There is an index on only a prefix of a column named in
                            the <code class="literal">ORDER BY</code> clause. In this case,
                            the index cannot be used to fully resolve the sort
                            order. For example, if only the first 10 bytes of a
                            <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(20)</code></a> column are
                            indexed, the index cannot distinguish values past the
                            10th byte and a <code class="literal">filesort</code> is needed.
                        </p><p style="color:blue;">只有ORDER BY子句中名为的列的前缀上有索引。在这种情况下，索引不能用于完全解析排序顺序。例如，如果只索引char（20）列的前10个字节，则索引无法区分超过第10个字节的值，因此需要文件排序。</p><p></p></li><li class="listitem"><p>
                            The index does not store rows in order. For example,
                            this is true for a <code class="literal">HASH</code> index in a
                            <code class="literal">MEMORY</code> table.
                        </p><p style="color:blue;">索引不按顺序存储行。例如，对于内存表中的哈希索引，这是正确的。</p><p></p></li></ul>
                    </div>
                    <p>
                        Availability of an index for sorting may be affected by the
                        use of column aliases. Suppose that the column
                        <code class="literal">t1.a</code> is indexed. In this statement, the
                        name of the column in the select list is
                        <code class="literal">a</code>. It refers to <code class="literal">t1.a</code>,
                        as does the reference to <code class="literal">a</code> in the
                        <code class="literal">ORDER BY</code>, so the index on
                        <code class="literal">t1.a</code> can be used:
                    </p><p style="color:blue;">使用列别名可能会影响排序索引的可用性。假设列T1.A已被索引。在该语句中，选择列表中的列的名称是A。它引用T1.A，Order By中对A的引用也是如此，因此可以使用T1.A上的索引：</p><p></p><pre data-lang="sql" class="programlisting">SELECT a FROM t1 ORDER BY a;
</pre><p>
                    In this statement, the name of the column in the select list
                    is also <code class="literal">a</code>, but it is the alias name. It
                    refers to <code class="literal">ABS(a)</code>, as does the reference
                    to <code class="literal">a</code> in the <code class="literal">ORDER BY</code>,
                    so the index on <code class="literal">t1.a</code> cannot be used:
                </p><p style="color:blue;">在该语句中，选择列表中的列的名称也是，但它是别名。它指的是abs（a），正如order by中对a的引用一样，因此不能使用T1.a上的索引：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ABS(a) AS a FROM t1 ORDER BY a;
</pre><p>
                    In the following statement, the <code class="literal">ORDER BY</code>
                    refers to a name that is not the name of a column in the
                    select list. But there is a column in <code class="literal">t1</code>
                    named <code class="literal">a</code>, so the <code class="literal">ORDER
                    BY</code> refers to <code class="literal">t1.a</code> and the index
                    on <code class="literal">t1.a</code> can be used. (The resulting sort
                    order may be completely different from the order for
                    <code class="literal">ABS(a)</code>, of course.)
                </p><p style="color:blue;">在下面的语句中，order by引用的名称不是select列表中列的名称。但是T1中有一个名为A的列，所以ORDER BY指的是T1.A，T1.A上的索引可以使用。（当然，最终的排序顺序可能与abs（a）的顺序完全不同。）</p><p></p><pre data-lang="sql" class="programlisting">SELECT ABS(a) AS b FROM t1 ORDER BY a;
</pre><a class="indexterm" name="idm140286874884176"></a><a class="indexterm" name="idm140286874882688"></a><p>
                    By default, MySQL sorts <code class="literal">GROUP BY
                    <em class="replaceable"><code>col1</code></em>,
                    <em class="replaceable"><code>col2</code></em>, ...</code> queries as if
                    you also included <code class="literal">ORDER BY
                    <em class="replaceable"><code>col1</code></em>,
                    <em class="replaceable"><code>col2</code></em>, ...</code> in the query.
                    If you include an explicit <code class="literal">ORDER BY</code>
                    clause that contains the same column list, MySQL optimizes
                    it away without any speed penalty, although the sorting
                    still occurs.
                </p><p style="color:blue;">默认情况下，mysql按col1、col2、…查询，就好像您还包括order by col1，col2，…在查询中。如果包含一个包含相同列列表的显式ORDERBY子句，MySQL会对其进行优化，而不会造成任何速度损失，尽管排序仍会发生。</p><p></p><p>
                    If a query includes <code class="literal">GROUP BY</code> but you want
                    to avoid the overhead of sorting the result, you can
                    suppress sorting by specifying <code class="literal">ORDER BY
                    NULL</code>. For example:
                </p><p style="color:blue;">如果查询包含GROUPBY，但希望避免对结果排序的开销，则可以通过指定ORDERBY NULL来抑制排序。例如：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO foo
SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;
</pre><p>
                    The optimizer may still choose to use sorting to implement
                    grouping operations. <code class="literal">ORDER BY NULL</code>
                    suppresses sorting of the result, not prior sorting done by
                    grouping operations to determine the result.
                </p><p style="color:blue;">优化器仍然可以选择使用排序来实现分组操作。ORDER BY NULL禁止对结果进行排序，而不是通过分组操作来确定结果的先前排序。</p><p></p><a class="indexterm" name="idm140286874872240"></a><a class="indexterm" name="idm140286874870752"></a>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            <code class="literal">GROUP BY</code> implicitly sorts by default
                            (that is, in the absence of <code class="literal">ASC</code> or
                            <code class="literal">DESC</code> designators for <code class="literal">GROUP
                            BY</code> columns). However, relying on implicit
                            <code class="literal">GROUP BY</code> sorting (that is, sorting in
                            the absence of <code class="literal">ASC</code> or
                            <code class="literal">DESC</code> designators) or explicit sorting
                            for <code class="literal">GROUP BY</code> (that is, by using
                            explicit <code class="literal">ASC</code> or <code class="literal">DESC</code>
                            designators for <code class="literal">GROUP BY</code> columns) is
                            deprecated. To produce a given sort order, provide an
                            <code class="literal">ORDER BY</code> clause.
                        </p><p style="color:blue;">默认情况下，GROUPBY隐式排序（即，在没有GROUPBY列的ASC或DESC指示符的情况下）。但是，不赞成使用通过排序的隐式分组（即，在没有ASC或DESC指示符的情况下进行排序）或按分组的显式排序（即，对按列分组使用显式ASC或DESC指示符）。要生成给定的排序顺序，请提供ORDERBY子句。</p><p></p>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="order-by-filesort"></a>Use of filesort to Satisfy ORDER BY</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286874858784"></a><a class="indexterm" name="idm140286874857744"></a><p>
                    If an index cannot be used to satisfy an <code class="literal">ORDER
                    BY</code> clause, MySQL performs a
                    <code class="literal">filesort</code> operation that reads table rows
                    and sorts them. A <code class="literal">filesort</code> constitutes an
                    extra sorting phase in query execution.
                </p><p style="color:blue;">如果索引不能用于满足ORDERBY子句，MySQL将执行文件排序操作，读取表行并对其进行排序。文件排序构成查询执行中的额外排序阶段。</p><p></p><p>
                    To obtain memory for <code class="literal">filesort</code> operations,
                    the optimizer allocates a fixed amount of
                    <a class="link" href="server-administration.html#sysvar_sort_buffer_size"><code class="literal">sort_buffer_size</code></a> bytes up
                    front. Individual sessions can change the session value of
                    this variable as desired to avoid excessive memory use, or
                    to allocate more memory as necessary.
                </p><p style="color:blue;">为了获得文件排序操作的内存，优化器在前面分配固定数量的排序缓冲区字节。个别会话可以根据需要更改此变量的会话值，以避免过度使用内存，或者根据需要分配更多内存。</p><p></p><p>
                    A <code class="literal">filesort</code> operation uses temporary disk
                    files as necessary if the result set is too large to fit in
                    memory. Some types of queries are particularly suited to
                    completely in-memory <code class="literal">filesort</code> operations.
                    For example, the optimizer can use
                    <code class="literal">filesort</code> to efficiently handle in memory,
                    without temporary files, the <code class="literal">ORDER BY</code>
                    operation for queries (and subqueries) of the following
                    form:
                </p><p style="color:blue;">如果结果集太大而无法放入内存，则文件排序操作将根据需要使用临时磁盘文件。某些类型的查询特别适合于完全在内存中的文件排序操作。例如，优化器可以使用filesort有效地处理以下形式的查询（和子查询）的order by操作，而无需临时文件：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ... FROM <em class="replaceable"><code>single_table</code></em> ... ORDER BY <em class="replaceable"><code>non_index_column</code></em> [DESC] LIMIT [<em class="replaceable"><code>M</code></em>,]<em class="replaceable"><code>N</code></em>;
</pre><p>
                    Such queries are common in web applications that display
                    only a few rows from a larger result set. Examples:
                </p><p style="color:blue;">这种查询在web应用程序中很常见，这些应用程序只显示较大结果集中的几行。示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT col1, ... FROM t1 ... ORDER BY name LIMIT 10;
SELECT col1, ... FROM t1 ... ORDER BY RAND() LIMIT 15;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="order-by-optimizer-control"></a>Influencing ORDER BY Optimization</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        For slow <code class="literal">ORDER BY</code> queries for which
                        <code class="literal">filesort</code> is not used, try lowering the
                        <a class="link" href="server-administration.html#sysvar_max_length_for_sort_data"><code class="literal">max_length_for_sort_data</code></a>
                        system variable to a value that is appropriate to trigger a
                        <code class="literal">filesort</code>. (A symptom of setting the value
                        of this variable too high is a combination of high disk
                        activity and low CPU activity.)
                    </p><p style="color:blue;">对于不使用文件排序的慢排序查询，请尝试将“排序数据的最大长度”系统变量降低到适合触发文件排序的值。（将此变量的值设置得过高的一个症状是高磁盘活动性和低CPU活动性的组合。）</p><p></p><p>
                    To increase <code class="literal">ORDER BY</code> speed, check whether
                    you can get MySQL to use indexes rather than an extra
                    sorting phase. If this is not possible, try the following
                    strategies:
                </p><p style="color:blue;">要按速度增加排序，请检查是否可以让mysql使用索引，而不是额外的排序阶段。如果不可能，请尝试以下策略：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Increase the
                            <a class="link" href="server-administration.html#sysvar_sort_buffer_size"><code class="literal">sort_buffer_size</code></a>
                            variable value. Ideally, the value should be large
                            enough for the entire result set to fit in the sort
                            buffer (to avoid writes to disk and merge passes), but
                            at minimum the value must be large enough to accommodate
                            15 tuples. (Up to 15 temporary disk files are merged and
                            there must be room in memory for at least one tuple per
                            file.)
                        </p><p style="color:blue;">增加sort_buffer_size变量值。理想情况下，该值应该足够大，以使整个结果集适合排序缓冲区（以避免写入磁盘和合并过程），但该值至少必须足够大，以容纳15个元组。（最多合并15个临时磁盘文件，每个文件必须有至少一个元组的内存空间。）</p><p></p><p>
                            Take into account that the size of column values stored
                            in the sort buffer is affected by the
                            <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a> system
                            variable value. For example, if tuples store values of
                            long string columns and you increase the value of
                            <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a>, the
                            size of sort buffer tuples increases as well and may
                            require you to increase
                            <a class="link" href="server-administration.html#sysvar_sort_buffer_size"><code class="literal">sort_buffer_size</code></a>. For
                            column values calculated as a result of string
                            expressions (such as those that invoke a string-valued
                            function), the <code class="literal">filesort</code> algorithm
                            cannot tell the maximum length of expression values, so
                            it must allocate
                            <a class="link" href="server-administration.html#sysvar_max_sort_length"><code class="literal">max_sort_length</code></a> bytes
                            for each tuple.
                        </p><p style="color:blue;">考虑到存储在排序缓冲区中的列值的大小受最大排序长度系统变量值的影响。例如，如果元组存储长字符串列的值，并且您增加了max_sort_length_的值，则排序缓冲区元组的大小也会增加，并且可能需要您增加排序缓冲区的大小。对于字符串表达式（如调用字符串值函数）计算的列值，算法不能告诉表达式值的最大长度，因此它必须为每个元组分配字节数。</p><p></p><p>
                            To monitor the number of merge passes (to merge
                            temporary files), check the
                            <a class="link" href="server-administration.html#statvar_Sort_merge_passes"><code class="literal">Sort_merge_passes</code></a>
                            status variable.
                        </p><p style="color:blue;">要监视合并过程（要合并临时文件）的数目，请检查sort_merge_passes状态变量。</p><p></p></li><li class="listitem"><p>
                            Increase the
                            <a class="link" href="server-administration.html#sysvar_read_rnd_buffer_size"><code class="literal">read_rnd_buffer_size</code></a>
                            variable value so that more rows are read at a time.
                        </p><p style="color:blue;">增加read_rnd_buffer_size变量值，以便一次读取更多行。</p><p></p></li><li class="listitem"><p>
                            Change the <a class="link" href="server-administration.html#sysvar_tmpdir"><code class="literal">tmpdir</code></a>
                            system variable to point to a dedicated file system with
                            large amounts of free space. The variable value can list
                            several paths that are used in round-robin fashion; you
                            can use this feature to spread the load across several
                            directories. Separate the paths by colon characters
                            (<code class="literal">:</code>) on Unix and semicolon characters
                            (<code class="literal">;</code>) on Windows. The paths should name
                            directories in file systems located on different
                            <span class="emphasis"><em>physical</em></span> disks, not different
                            partitions on the same disk.
                        </p><p style="color:blue;">将tmpdir系统变量更改为指向具有大量可用空间的专用文件系统。变量值可以列出以循环方式使用的多个路径；您可以使用此功能将负载分散到多个目录中。在UNIX上用冒号字符（：）和在Windows上用分号字符（；）分隔路径。路径应该命名位于不同物理磁盘上的文件系统中的目录，而不是同一磁盘上的不同分区。</p><p></p></li></ul>
                    </div>

                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="order-by-diagnostic-information"></a>ORDER BY Execution Plan Information Available</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        With
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>
                        (see <a class="xref" href="optimization.html#using-explain" title="8.8.1&nbsp;Optimizing Queries with EXPLAIN">Section&nbsp;8.8.1, “Optimizing Queries with EXPLAIN”</a>), you can check whether
                        MySQL can use indexes to resolve an <code class="literal">ORDER
                        BY</code> clause:
                    </p><p style="color:blue;">使用explain（参见第8.8.1节“使用explain优化查询”），您可以检查mysql是否可以使用索引来解析order by子句：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            If the <code class="literal">Extra</code> column of
                            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output does not
                            contain <code class="literal">Using filesort</code>, the index is
                            used and a <code class="literal">filesort</code> is not performed.
                        </p><p style="color:blue;">如果explain output的额外列不包含using filesort，则使用索引且不执行文件排序。</p><p></p></li><li class="listitem"><p>
                            If the <code class="literal">Extra</code> column of
                            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output contains
                            <code class="literal">Using filesort</code>, the index is not used
                            and a <code class="literal">filesort</code> is performed.
                        </p><p style="color:blue;">如果explain output的额外列包含using filesort，则不使用索引并执行文件排序。</p><p></p></li></ul>
                    </div>
                    <p>
                        In addition, if a <code class="literal">filesort</code> is performed,
                        optimizer trace output includes a
                        <code class="literal">filesort_summary</code> block. For example:
                    </p><p style="color:blue;">此外，如果执行文件排序，优化器跟踪输出将包含一个文件排序摘要块。例如：</p><p></p><pre data-lang="json" class="programlisting">"filesort_summary": {
  "rows": 100,
  "examined_rows": 100,
  "number_of_tmp_files": 0,
  "sort_buffer_size": 25192,
  "sort_mode": "&lt;sort_key, packed_additional_fields&gt;"
}
</pre><p>
                    The <code class="literal">sort_mode</code> value provides information
                    about the contents of tuples in the sort buffer:
                </p><p style="color:blue;">sort_mode值提供有关排序缓冲区中元组的内容的信息：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">&lt;sort_key, rowid&gt;</code>: This
                            indicates that sort buffer tuples are pairs that contain
                            the sort key value and row ID of the original table row.
                            Tuples are sorted by sort key value and the row ID is
                            used to read the row from the table.
                        </p><p style="color:blue;"><sort-key，row id="">：这表示排序缓冲区元组是包含原始表行的排序键值和行id的对。元组按排序键值排序，行id用于从表中读取行。</sort-key，row></p><p></p></li><li class="listitem"><p>
                            <code class="literal">&lt;sort_key, additional_fields&gt;</code>:
                            This indicates that sort buffer tuples contain the sort
                            key value and columns referenced by the query. Tuples
                            are sorted by sort key value and column values are read
                            directly from the tuple.
                        </p><p style="color:blue;"><sort-key，additional-fields>：这表示排序缓冲区元组包含查询引用的排序键值和列。元组按排序键值排序，列值直接从元组中读取。</sort-key，additional-fields></p><p></p></li><li class="listitem"><p>
                            <code class="literal">&lt;sort_key,
                                packed_additional_fields&gt;</code>: Like the
                            previous variant, but the additional columns are packed
                            tightly together instead of using a fixed-length
                            encoding.
                        </p><p style="color:blue;"><sort_key，packed_additional_fields>：与前一个变量类似，但是附加列被紧密地打包在一起，而不是使用固定长度的编码。</sort_key，packed_additional_fields></p><p></p></li></ul>
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> does not distinguish
                        whether the optimizer does or does not perform a
                        <code class="literal">filesort</code> in memory. Use of an in-memory
                        <code class="literal">filesort</code> can be seen in optimizer trace
                        output. Look for
                        <code class="literal">filesort_priority_queue_optimization</code>. For
                        information about the optimizer trace, see
                        <a class="ulink" href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html" target="_top">MySQL
                            Internals: Tracing the Optimizer</a>.
                    </p><p style="color:blue;">explain不区分优化器是否在内存中执行文件排序。在优化器跟踪输出中可以看到内存中文件排序的使用。查找文件排序优先级队列优化。有关优化器跟踪的信息，请参阅mysql内部：跟踪优化器。</p><p></p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-by-optimization"></a>8.2.1.15&nbsp;GROUP BY Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286874788544"></a><a class="indexterm" name="idm140286874787472"></a><p>
                The most general way to satisfy a <code class="literal">GROUP BY</code>
                clause is to scan the whole table and create a new temporary
                table where all rows from each group are consecutive, and then
                use this temporary table to discover groups and apply
                aggregate functions (if any). In some cases, MySQL is able to
                do much better than that and avoid creation of temporary
                tables by using index access.
            </p><p style="color:blue;">满足GROUP BY子句的最常用方法是扫描整个表并创建一个新的临时表，其中每个组中的所有行都是连续的，然后使用此临时表来发现组并应用聚合函数（如果有的话）。在某些情况下，mysql能够做得更好，并且通过使用索引访问避免创建临时表。</p><p></p><p>
                The most important preconditions for using indexes for
                <code class="literal">GROUP BY</code> are that all <code class="literal">GROUP
                BY</code> columns reference attributes from the same index,
                and that the index stores its keys in order (as is true, for
                example, for a <code class="literal">BTREE</code> index, but not for a
                <code class="literal">HASH</code> index). Whether use of temporary
                tables can be replaced by index access also depends on which
                parts of an index are used in a query, the conditions
                specified for these parts, and the selected aggregate
                functions.
            </p><p style="color:blue;">为group by使用索引的最重要的先决条件是，所有groupby列都引用同一索引中的属性，并且索引按顺序存储其键（例如，对于btree索引，但对于散列索引，则不是这样）。临时表的使用是否可以替换为索引访问，还取决于查询中使用索引的哪些部分、为这些部分指定的条件以及选定的聚合函数。</p><p></p><p>
                There are two ways to execute a <code class="literal">GROUP BY</code>
                query through index access, as detailed in the following
                sections. The first method applies the grouping operation
                together with all range predicates (if any). The second method
                first performs a range scan, and then groups the resulting
                tuples.
            </p><p style="color:blue;">有两种方法可以通过索引访问来执行按查询分组，如下节所述。第一个方法将分组操作与所有范围谓词（如果有的话）一起应用。第二个方法首先执行范围扫描，然后对结果元组进行分组。</p><p></p><p>
                In MySQL, <code class="literal">GROUP BY</code> is used for sorting, so
                the server may also apply <code class="literal">ORDER BY</code>
                optimizations to grouping. However, relying on implicit or
                explicit <code class="literal">GROUP BY</code> sorting is deprecated.
                See <a class="xref" href="optimization.html#order-by-optimization" title="8.2.1.14&nbsp;ORDER BY Optimization">Section&nbsp;8.2.1.14, “ORDER BY Optimization”</a>.
            </p><p style="color:blue;">在mysql中，group by用于排序，因此服务器还可以对分组应用orderby优化。但是，不赞成通过排序依赖隐式或显式组。见第8.2.1.14节“按优化排序”。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#loose-index-scan" title="Loose Index Scan">Loose Index Scan</a></p><p style="color:blue;">松散索引扫描</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#tight-index-scan" title="Tight Index Scan">Tight Index Scan</a></p><p style="color:blue;">紧密索引扫描</p><p></p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="loose-index-scan"></a>Loose Index Scan</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286874772336"></a><p>
                    The most efficient way to process <code class="literal">GROUP
                    BY</code> is when an index is used to directly retrieve
                    the grouping columns. With this access method, MySQL uses
                    the property of some index types that the keys are ordered
                    (for example, <code class="literal">BTREE</code>). This property
                    enables use of lookup groups in an index without having to
                    consider all keys in the index that satisfy all
                    <code class="literal">WHERE</code> conditions. This access method
                    considers only a fraction of the keys in an index, so it is
                    called a <span class="firstterm">Loose Index
            Scan</span>. When there is no <code class="literal">WHERE</code>
                    clause, a Loose Index Scan reads as many keys as the number
                    of groups, which may be a much smaller number than that of
                    all keys. If the <code class="literal">WHERE</code> clause contains
                    range predicates (see the discussion of the
                    <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a> join type in
                    <a class="xref" href="optimization.html#using-explain" title="8.8.1&nbsp;Optimizing Queries with EXPLAIN">Section&nbsp;8.8.1, “Optimizing Queries with EXPLAIN”</a>), a Loose Index Scan looks
                    up the first key of each group that satisfies the range
                    conditions, and again reads the smallest possible number of
                    keys. This is possible under the following conditions:
                </p><p style="color:blue;">处理group by的最有效方法是使用索引直接检索分组列。通过这种访问方法，mysql使用了一些索引类型的属性，这些索引类型是按顺序排列的（例如btree）。此属性允许在索引中使用查找组，而不必考虑索引中满足所有where条件的所有键。这种访问方法只考虑索引中的一小部分键，因此称为松散索引扫描。当没有where子句时，松散索引扫描读取的键数与组数相同，组数可能比所有键的数目小得多。如果where子句包含范围谓词（请参阅第8.8.1节“使用explain优化查询”中对范围连接类型的讨论），则松散索引扫描将查找满足范围条件的每个组的第一个键，并再次读取尽可能少的键。在下列条件下，这是可能的：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The query is over a single table.
                        </p><p style="color:blue;">查询在单个表上。</p><p></p></li><li class="listitem"><p>
                            The <code class="literal">GROUP BY</code> names only columns that
                            form a leftmost prefix of the index and no other
                            columns. (If, instead of <code class="literal">GROUP BY</code>,
                            the query has a <code class="literal">DISTINCT</code> clause, all
                            distinct attributes refer to columns that form a
                            leftmost prefix of the index.) For example, if a table
                            <code class="literal">t1</code> has an index on
                            <code class="literal">(c1,c2,c3)</code>, Loose Index Scan is
                            applicable if the query has <code class="literal">GROUP BY c1,
                            c2</code>. It is not applicable if the query has
                            <code class="literal">GROUP BY c2, c3</code> (the columns are not
                            a leftmost prefix) or <code class="literal">GROUP BY c1, c2,
                            c4</code> (<code class="literal">c4</code> is not in the
                            index).
                        </p><p style="color:blue;">“按名称分组”只指定构成索引最左边前缀的列，而不指定其他列。（如果查询具有DISTINCT子句，而不是GROUP BY，则所有DISTINCT属性都引用构成索引最左边前缀的列。）例如，如果表T1在（C1、C2、C3）上有索引，则如果查询具有GROUP BY C1、C2，则可以使用松散索引扫描。如果查询具有GROUP BY C2、C3（列不是最左边的前缀）或GROUP BY C1、C2、C4（C4不在索引中），则不适用。</p><p></p></li><li class="listitem"><p>
                            The only aggregate functions used in the select list (if
                            any) are <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a> and
                            <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a>, and all of them
                            refer to the same column. The column must be in the
                            index and must immediately follow the columns in the
                            <code class="literal">GROUP BY</code>.
                        </p><p style="color:blue;">选择列表中使用的唯一聚合函数（如果有的话）是min（）和max（），它们都引用同一列。列必须在索引中，并且必须紧跟在group by中的列之后。</p><p></p></li><li class="listitem"><p>
                            Any other parts of the index than those from the
                            <code class="literal">GROUP BY</code> referenced in the query must
                            be constants (that is, they must be referenced in
                            equalities with constants), except for the argument of
                            <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a> or
                            <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a> functions.
                        </p><p style="color:blue;">除查询中引用的GROUP BY以外，索引的任何其他部分都必须是常量（即，它们必须与常量相等地引用），除了min（）或max（）函数的参数。</p><p></p></li><li class="listitem"><p>
                            For columns in the index, full column values must be
                            indexed, not just a prefix. For example, with
                            <code class="literal">c1 VARCHAR(20), INDEX (c1(10))</code>, the
                            index uses only a prefix of <code class="literal">c1</code> values
                            and cannot be used for Loose Index Scan.
                        </p><p style="color:blue;">对于索引中的列，必须索引完整的列值，而不仅仅是前缀。例如，对于c1 varchar（20），index（c1（10）），索引只使用c1值的前缀，不能用于松散索引扫描。</p><p></p></li></ul>
                    </div>
                    <p>
                        If Loose Index Scan is applicable to a query, the
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output shows
                        <code class="literal">Using index for group-by</code> in the
                        <code class="literal">Extra</code> column.
                    </p><p style="color:blue;">如果松散索引扫描适用于查询，则explain输出将在额外列中显示using index for group by。</p><p></p><p>
                    Assume that there is an index
                    <code class="literal">idx(c1,c2,c3)</code> on table
                    <code class="literal">t1(c1,c2,c3,c4)</code>. The Loose Index Scan
                    access method can be used for the following queries:
                </p><p style="color:blue;">假设表T1（C1、C2、C3、C4）上有索引idx（C1、C2、C3）。松散索引扫描访问方法可用于以下查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT c1, c2 FROM t1 GROUP BY c1, c2;
SELECT DISTINCT c1, c2 FROM t1;
SELECT c1, MIN(c2) FROM t1 GROUP BY c1;
SELECT c1, c2 FROM t1 WHERE c1 &lt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 &gt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT c2 FROM t1 WHERE c1 &lt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT c1, c2 FROM t1 WHERE c3 = <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
</pre><p>
                    The following queries cannot be executed with this quick
                    select method, for the reasons given:
                </p><p style="color:blue;">无法使用此快速选择方法执行以下查询，原因如下：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            There are aggregate functions other than
                            <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a> or
                            <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a>:
                        </p><p style="color:blue;">除了min（）或max（）之外，还有其他聚合函数：</p><p></p><pre data-lang="sql" class="programlisting">SELECT c1, SUM(c2) FROM t1 GROUP BY c1;
</pre></li><li class="listitem"><p>
                            The columns in the <code class="literal">GROUP BY</code> clause do
                            not form a leftmost prefix of the index:
                        </p><p style="color:blue;">GROUP BY子句中的列不构成索引的最左边前缀：</p><p></p><pre data-lang="sql" class="programlisting">SELECT c1, c2 FROM t1 GROUP BY c2, c3;
</pre></li><li class="listitem"><p>
                            The query refers to a part of a key that comes after the
                            <code class="literal">GROUP BY</code> part, and for which there is
                            no equality with a constant:
                        </p><p style="color:blue;">查询引用了一个键的一部分，该键位于按部分分组的后面，并且该键与常量不相等：</p><p></p><pre data-lang="sql" class="programlisting">SELECT c1, c3 FROM t1 GROUP BY c1, c2;
</pre><p>
                            Were the query to include <code class="literal">WHERE c3 =
                            <em class="replaceable"><code>const</code></em></code>, Loose Index
                            Scan could be used.
                        </p><p style="color:blue;">如果查询包含c3=const的位置，则可以使用松散索引扫描。</p><p></p></li></ul>
                    </div>
                    <p>
                        The Loose Index Scan access method can be applied to other
                        forms of aggregate function references in the select list,
                        in addition to the <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a> and
                        <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a> references already
                        supported:
                    </p><p style="color:blue;">除了已经支持的min（）和max（）引用外，松散索引扫描访问方法还可以应用于选择列表中其他形式的聚合函数引用：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="functions.html#function_avg"><code class="literal">AVG(DISTINCT)</code></a>,
                            <a class="link" href="functions.html#function_sum"><code class="literal">SUM(DISTINCT)</code></a>, and
                            <a class="link" href="functions.html#function_count"><code class="literal">COUNT(DISTINCT)</code></a> are
                            supported. <a class="link" href="functions.html#function_avg"><code class="literal">AVG(DISTINCT)</code></a>
                            and <a class="link" href="functions.html#function_sum"><code class="literal">SUM(DISTINCT)</code></a> take a
                            single argument.
                            <a class="link" href="functions.html#function_count"><code class="literal">COUNT(DISTINCT)</code></a> can have
                            more than one column argument.
                        </p><p style="color:blue;">支持AVG（DISTINCT）、SUM（DISTINCT）和COUNT（DISTINCT）。avg（distinct）和sum（distinct）采用单个参数。count（distinct）可以有多个列参数。</p><p></p></li><li class="listitem"><p>
                            There must be no <code class="literal">GROUP BY</code> or
                            <code class="literal">DISTINCT</code> clause in the query.
                        </p><p style="color:blue;">查询中不能有GROUP BY或DISTINCT子句。</p><p></p></li><li class="listitem"><p>
                            The Loose Index Scan limitations described previously
                            still apply.
                        </p><p style="color:blue;">前面描述的松散索引扫描限制仍然适用。</p><p></p></li></ul>
                    </div>
                    <p>
                        Assume that there is an index
                        <code class="literal">idx(c1,c2,c3)</code> on table
                        <code class="literal">t1(c1,c2,c3,c4)</code>. The Loose Index Scan
                        access method can be used for the following queries:
                    </p><p style="color:blue;">假设表T1（C1、C2、C3、C4）上有索引idx（C1、C2、C3）。松散索引扫描访问方法可用于以下查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT COUNT(DISTINCT c1), SUM(DISTINCT c1) FROM t1;

SELECT COUNT(DISTINCT c1, c2), COUNT(DISTINCT c2, c1) FROM t1;
</pre>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="tight-index-scan"></a>Tight Index Scan</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        A Tight Index Scan may be either a full index scan or a
                        range index scan, depending on the query conditions.
                    </p><p style="color:blue;">紧密索引扫描可以是完全索引扫描，也可以是范围索引扫描，具体取决于查询条件。</p><p></p><p>
                    When the conditions for a Loose Index Scan are not met, it
                    still may be possible to avoid creation of temporary tables
                    for <code class="literal">GROUP BY</code> queries. If there are range
                    conditions in the <code class="literal">WHERE</code> clause, this
                    method reads only the keys that satisfy these conditions.
                    Otherwise, it performs an index scan. Because this method
                    reads all keys in each range defined by the
                    <code class="literal">WHERE</code> clause, or scans the whole index if
                    there are no range conditions, it is called a
                    <span class="firstterm">Tight Index Scan</span>. With
                    a Tight Index Scan, the grouping operation is performed only
                    after all keys that satisfy the range conditions have been
                    found.
                </p><p style="color:blue;">当不满足松散索引扫描的条件时，仍然可以避免创建用于按查询分组的临时表。如果where子句中有范围条件，则此方法只读取满足这些条件的键。否则，它将执行索引扫描。由于此方法读取where子句定义的每个范围中的所有键，或者在没有范围条件的情况下扫描整个索引，因此称为紧密索引扫描。通过严格的索引扫描，只有在找到满足范围条件的所有键之后才执行分组操作。</p><p></p><p>
                    For this method to work, it is sufficient that there be a
                    constant equality condition for all columns in a query
                    referring to parts of the key coming before or in between
                    parts of the <code class="literal">GROUP BY</code> key. The constants
                    from the equality conditions fill in any <span class="quote">“<span class="quote">gaps</span>”</span>
                    in the search keys so that it is possible to form complete
                    prefixes of the index. These index prefixes then can be used
                    for index lookups. If the <code class="literal">GROUP BY</code> result
                    requires sorting, and it is possible to form search keys
                    that are prefixes of the index, MySQL also avoids extra
                    sorting operations because searching with prefixes in an
                    ordered index already retrieves all the keys in order.
                </p><p style="color:blue;">要使此方法起作用，查询中所有列都有一个常量相等条件就足够了，该条件引用键的某些部分，这些部分位于按键分组的部分之前或之间。等式条件中的常量填充搜索键中的任何“空白”，这样就可以形成索引的完整前缀。这些索引前缀可用于索引查找。如果按结果分组需要排序，并且可以形成索引前缀的搜索键，mysql还避免了额外的排序操作，因为在有序索引中使用前缀进行搜索已经按顺序检索了所有键。</p><p></p><p>
                    Assume that there is an index
                    <code class="literal">idx(c1,c2,c3)</code> on table
                    <code class="literal">t1(c1,c2,c3,c4)</code>. The following queries do
                    not work with the Loose Index Scan access method described
                    previously, but still work with the Tight Index Scan access
                    method.
                </p><p style="color:blue;">假设表T1（C1、C2、C3、C4）上有索引idx（C1、C2、C3）。以下查询不适用于前面描述的松散索引扫描访问方法，但仍适用于紧密索引扫描访问方法。</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            There is a gap in the <code class="literal">GROUP BY</code>, but
                            it is covered by the condition <code class="literal">c2 =
                            'a'</code>:
                        </p><p style="color:blue;">组中存在一个空白，但条件C2='A'覆盖了该空白：</p><p></p><pre data-lang="sql" class="programlisting">SELECT c1, c2, c3 FROM t1 WHERE c2 = 'a' GROUP BY c1, c3;
</pre></li><li class="listitem"><p>
                            The <code class="literal">GROUP BY</code> does not begin with the
                            first part of the key, but there is a condition that
                            provides a constant for that part:
                        </p><p style="color:blue;">GROUP BY不以键的第一部分开头，但有一个条件为该部分提供常量：</p><p></p><pre data-lang="sql" class="programlisting">SELECT c1, c2, c3 FROM t1 WHERE c1 = 'a' GROUP BY c2, c3;
</pre></li></ul>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="distinct-optimization"></a>8.2.1.16&nbsp;DISTINCT Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286874686720"></a><a class="indexterm" name="idm140286874685648"></a><p>
                <code class="literal">DISTINCT</code> combined with <code class="literal">ORDER
                BY</code> needs a temporary table in many cases.
            </p><p style="color:blue;">distinct与order by结合在许多情况下需要一个临时表。</p><p></p><p>
                Because <code class="literal">DISTINCT</code> may use <code class="literal">GROUP
                BY</code>, learn how MySQL works with columns in
                <code class="literal">ORDER BY</code> or <code class="literal">HAVING</code>
                clauses that are not part of the selected columns. See
                <a class="xref" href="functions.html#group-by-handling" title="12.20.3&nbsp;MySQL Handling of GROUP BY">Section&nbsp;12.20.3, “MySQL Handling of GROUP BY”</a>.
            </p><p style="color:blue;">因为DISTINCT可能使用GROUPBY，所以学习MySQL如何处理ORDERBY列或包含不属于所选列的子句。见12.20.3节，“MySQL对GROUP BY的处理”。</p><p></p><p>
                In most cases, a <code class="literal">DISTINCT</code> clause can be
                considered as a special case of <code class="literal">GROUP BY</code>.
                For example, the following two queries are equivalent:
            </p><p style="color:blue;">在大多数情况下，一个不同的子句可以被视为group by的一个特例。例如，以下两个查询是等效的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT DISTINCT c1, c2, c3 FROM t1
WHERE c1 &gt; <em class="replaceable"><code>const</code></em>;

SELECT c1, c2, c3 FROM t1
WHERE c1 &gt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2, c3;
</pre><p>
                Due to this equivalence, the optimizations applicable to
                <code class="literal">GROUP BY</code> queries can be also applied to
                queries with a <code class="literal">DISTINCT</code> clause. Thus, for
                more details on the optimization possibilities for
                <code class="literal">DISTINCT</code> queries, see
                <a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.15&nbsp;GROUP BY Optimization">Section&nbsp;8.2.1.15, “GROUP BY Optimization”</a>.
            </p><p style="color:blue;">由于这种等价性，适用于GROUPBY查询的优化也可以应用于具有DISTINCT子句的查询。因此，有关不同查询的优化可能性的更多详细信息，请参见第8.2.1.15节“按优化分组”。</p><p></p><p>
                When combining <code class="literal">LIMIT
                <em class="replaceable"><code>row_count</code></em></code> with
                <code class="literal">DISTINCT</code>, MySQL stops as soon as it finds
                <em class="replaceable"><code>row_count</code></em> unique rows.
            </p><p style="color:blue;">将限制行计数与DISTINCT结合使用时，MySQL会在找到行计数唯一行时立即停止。</p><p></p><p>
                If you do not use columns from all tables named in a query,
                MySQL stops scanning any unused tables as soon as it finds the
                first match. In the following case, assuming that
                <code class="literal">t1</code> is used before <code class="literal">t2</code>
                (which you can check with
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>), MySQL stops reading
                from <code class="literal">t2</code> (for any particular row in
                <code class="literal">t1</code>) when it finds the first row in
                <code class="literal">t2</code>:
            </p><p style="color:blue;">如果不使用查询中命名的所有表中的列，mysql会在找到第一个匹配项后立即停止扫描任何未使用的表。在以下情况下，假设T1在T2之前使用（您可以使用explain进行检查），当MySQL找到T2中的第一行时，它将停止从T2读取（对于T1中的任何特定行）：</p><p></p><pre data-lang="sql" class="programlisting">SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="limit-optimization"></a>8.2.1.17&nbsp;LIMIT Query Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286874660448"></a><a class="indexterm" name="idm140286874658992"></a><p>
                If you need only a specified number of rows from a result set,
                use a <code class="literal">LIMIT</code> clause in the query, rather
                than fetching the whole result set and throwing away the extra
                data.
            </p><p style="color:blue;">如果只需要结果集中指定的行数，请在查询中使用LIMIT子句，而不是获取整个结果集并丢弃多余的数据。</p><p></p><p>
                MySQL sometimes optimizes a query that has a <code class="literal">LIMIT
                <em class="replaceable"><code>row_count</code></em></code> clause and no
                <code class="literal">HAVING</code> clause:
            </p><p style="color:blue;">mysql有时会优化包含limit row_count子句和no having子句的查询：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If you select only a few rows with
                        <code class="literal">LIMIT</code>, MySQL uses indexes in some cases
                        when normally it would prefer to do a full table scan.
                    </p><p style="color:blue;">如果只选择有限制的几行，mysql在某些情况下会使用索引，而通常情况下，它更愿意进行全表扫描。</p><p></p></li><li class="listitem"><p>
                        If you combine <code class="literal">LIMIT
                        <em class="replaceable"><code>row_count</code></em></code> with
                        <code class="literal">ORDER BY</code>, MySQL stops sorting as soon
                        as it has found the first
                        <em class="replaceable"><code>row_count</code></em> rows of the sorted
                        result, rather than sorting the entire result. If ordering
                        is done by using an index, this is very fast. If a
                        filesort must be done, all rows that match the query
                        without the <code class="literal">LIMIT</code> clause are selected,
                        and most or all of them are sorted, before the first
                        <em class="replaceable"><code>row_count</code></em> are found. After the
                        initial rows have been found, MySQL does not sort any
                        remainder of the result set.
                    </p><p style="color:blue;">如果将“限制行计数”与“排序依据”结合起来，mysql会在找到排序结果的第一行计数行后立即停止排序，而不是对整个结果进行排序。如果使用索引进行排序，则速度非常快。如果必须执行文件排序，则在找到第一行计数之前，将选中与查询匹配但不包含LIMIT子句的所有行，并对其中的大部分或全部行进行排序。在找到初始行之后，mysql不会对结果集的任何剩余部分进行排序。</p><p></p><p>
                        One manifestation of this behavior is that an
                        <code class="literal">ORDER BY</code> query with and without
                        <code class="literal">LIMIT</code> may return rows in different
                        order, as described later in this section.
                    </p><p style="color:blue;">这种行为的一种表现是，有限制和无限制的ORDERBY查询可以按不同的顺序返回行，如本节后面所述。</p><p></p></li><li class="listitem"><p>
                        If you combine <code class="literal">LIMIT
                        <em class="replaceable"><code>row_count</code></em></code> with
                        <code class="literal">DISTINCT</code>, MySQL stops as soon as it
                        finds <em class="replaceable"><code>row_count</code></em> unique rows.
                    </p><p style="color:blue;">如果将limit row_count与distinct结合使用，mysql会在找到row_count unique rows后立即停止。</p><p></p></li><li class="listitem"><p>
                        In some cases, a <code class="literal">GROUP BY</code> can be
                        resolved by reading the index in order (or doing a sort on
                        the index), then calculating summaries until the index
                        value changes. In this case, <code class="literal">LIMIT
                        <em class="replaceable"><code>row_count</code></em></code> does not
                        calculate any unnecessary <code class="literal">GROUP BY</code>
                        values.
                    </p><p style="color:blue;">在某些情况下，可以通过按顺序读取索引（或对索引进行排序）来解析group by，然后计算摘要，直到索引值更改为止。在这种情况下，限制行计数不会计算任何不必要的GROUP BY值。</p><p></p></li><li class="listitem"><p>
                        As soon as MySQL has sent the required number of rows to
                        the client, it aborts the query unless you are using
                        <code class="literal">SQL_CALC_FOUND_ROWS</code>. In that case, the
                        number of rows can be retrieved with <code class="literal">SELECT
                        FOUND_ROWS()</code>. See
                        <a class="xref" href="functions.html#information-functions" title="12.15&nbsp;Information Functions">Section&nbsp;12.15, “Information Functions”</a>.
                    </p><p style="color:blue;">一旦mysql向客户端发送了所需的行数，它就会中止查询，除非您使用的是sql calc-found-rows。在这种情况下，可以使用select found_rows（）检索行数。见第12.15节“信息功能”。</p><p></p><a class="indexterm" name="idm140286874635840"></a></li><li class="listitem"><p>
                        <code class="literal">LIMIT 0</code> quickly returns an empty set.
                        This can be useful for checking the validity of a query.
                        It can also be employed to obtain the types of the result
                        columns within applications that use a MySQL API that
                        makes result set metadata available. With the
                        <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client program, you can use the
                        <a class="link" href="programs.html#option_mysql_column-type-info"><code class="option">--column-type-info</code></a> option to
                        display result column types.
                    </p><p style="color:blue;">limit 0快速返回空集。这对于检查查询的有效性很有用。它还可以用于在使用mysql api（使结果集元数据可用）的应用程序中获取结果列的类型。使用mysql客户机程序，可以使用--column type info选项来显示结果列类型。</p><p></p></li><li class="listitem"><p>
                        If the server uses temporary tables to resolve a query, it
                        uses the <code class="literal">LIMIT
                        <em class="replaceable"><code>row_count</code></em></code> clause to
                        calculate how much space is required.
                    </p><p style="color:blue;">如果服务器使用临时表来解析查询，则使用limit row_count子句来计算需要多少空间。</p><p></p></li><li class="listitem"><p>
                        If an index is not used for <code class="literal">ORDER BY</code>
                        but a <code class="literal">LIMIT</code> clause is also present, the
                        optimizer may be able to avoid using a merge file and sort
                        the rows in memory using an in-memory
                        <code class="literal">filesort</code> operation.
                    </p><p style="color:blue;">如果索引不用于ORDERBY，但同时存在LIMIT子句，优化器可能可以避免使用合并文件，并使用内存中的文件排序操作对内存中的行进行排序。</p><p></p></li></ul>
                </div>
                <p>
                    If multiple rows have identical values in the <code class="literal">ORDER
                    BY</code> columns, the server is free to return those rows
                    in any order, and may do so differently depending on the
                    overall execution plan. In other words, the sort order of
                    those rows is nondeterministic with respect to the nonordered
                    columns.
                </p><p style="color:blue;">如果多个行的order by列中的值相同，服务器可以按任意顺序返回这些行，并且根据总体执行计划的不同，返回的顺序可能不同。换言之，这些行的排序顺序对于非排序列是不确定的。</p><p></p><p>
                One factor that affects the execution plan is
                <code class="literal">LIMIT</code>, so an <code class="literal">ORDER BY</code>
                query with and without <code class="literal">LIMIT</code> may return
                rows in different orders. Consider this query, which is sorted
                by the <code class="literal">category</code> column but nondeterministic
                with respect to the <code class="literal">id</code> and
                <code class="literal">rating</code> columns:
            </p><p style="color:blue;">影响执行计划的一个因素是限制，因此有限制和无限制的order-by查询可能返回不同顺序的行。考虑这个查询，它是按category列排序的，但对于id列和rating列是不确定的：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  3 |        2 |    3.7 |
|  4 |        2 |    3.5 |
|  6 |        2 |    3.5 |
|  2 |        3 |    5.0 |
|  7 |        3 |    2.7 |
+----+----------+--------+
</pre><p>
                Including <code class="literal">LIMIT</code> may affect order of rows
                within each <code class="literal">category</code> value. For example,
                this is a valid query result:
            </p><p style="color:blue;">包含限制可能会影响每个类别值中行的顺序。例如，这是一个有效的查询结果：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category LIMIT 5;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  4 |        2 |    3.5 |
|  3 |        2 |    3.7 |
|  6 |        2 |    3.5 |
+----+----------+--------+
</pre><p>
                In each case, the rows are sorted by the <code class="literal">ORDER
                BY</code> column, which is all that is required by the SQL
                standard.
            </p><p style="color:blue;">在每种情况下，行都是按列的顺序排序的，这是sql标准所要求的全部内容。</p><p></p><p>
                If it is important to ensure the same row order with and
                without <code class="literal">LIMIT</code>, include additional columns
                in the <code class="literal">ORDER BY</code> clause to make the order
                deterministic. For example, if <code class="literal">id</code> values
                are unique, you can make rows for a given
                <code class="literal">category</code> value appear in
                <code class="literal">id</code> order by sorting like this:
            </p><p style="color:blue;">如果有无限制地确保行顺序相同很重要，请在ORDERBY子句中包含其他列，以使顺序具有确定性。例如，如果id值是唯一的，则可以通过如下排序使给定类别值的行按id顺序显示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category, id;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  3 |        2 |    3.7 |
|  4 |        2 |    3.5 |
|  6 |        2 |    3.5 |
|  2 |        3 |    5.0 |
|  7 |        3 |    2.7 |
+----+----------+--------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category, id LIMIT 5;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  3 |        2 |    3.7 |
|  4 |        2 |    3.5 |
|  6 |        2 |    3.5 |
+----+----------+--------+
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="function-optimization"></a>8.2.1.18&nbsp;Function Call Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286874603216"></a><a class="indexterm" name="idm140286874601744"></a><a class="indexterm" name="idm140286874600240"></a><a class="indexterm" name="idm140286874598736"></a><p>
                MySQL functions are tagged internally as deterministic or
                nondeterministic. A function is nondeterministic if, given
                fixed values for its arguments, it can return different
                results for different invocations. Examples of
                nondeterministic functions:
                <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a>,
                <a class="link" href="functions.html#function_uuid"><code class="literal">UUID()</code></a>.
            </p><p style="color:blue;">mysql函数在内部被标记为确定的或不确定的。函数是不确定的，如果给定其参数的固定值，它可以为不同的调用返回不同的结果。不确定函数的示例：rand（）、uuid（）。</p><p></p><p>
                If a function is tagged nondeterministic, a reference to it in
                a <code class="literal">WHERE</code> clause is evaluated for every row
                (when selecting from one table) or combination of rows (when
                selecting from a multiple-table join).
            </p><p style="color:blue;">如果一个函数被标记为不确定的，则在where子句中对它的引用将针对每一行（从一个表中选择时）或行组合（从多个表联接中选择时）进行求值。</p><p></p><p>
                MySQL also determines when to evaluate functions based on
                types of arguments, whether the arguments are table columns or
                constant values. A deterministic function that takes a table
                column as argument must be evaluated whenever that column
                changes value.
            </p><p style="color:blue;">mysql还根据参数类型确定何时计算函数，参数是表列还是常量值。每当表列更改值时，必须计算以表列为参数的确定函数。</p><p></p><p>
                Nondeterministic functions may affect query performance. For
                example, some optimizations may not be available, or more
                locking might be required. The following discussion uses
                <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a> but applies to other
                nondeterministic functions as well.
            </p><p style="color:blue;">不确定函数可能会影响查询性能。例如，某些优化可能不可用，或者可能需要更多的锁定。下面的讨论使用rand（）但也适用于其他不确定函数。</p><p></p><p>
                Suppose that a table <code class="literal">t</code> has this definition:
            </p><p style="color:blue;">假设表t具有以下定义：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t (id INT NOT NULL PRIMARY KEY, col_a VARCHAR(100));
</pre><p>
                Consider these two queries:
            </p><p style="color:blue;">考虑以下两个问题：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t WHERE id = POW(1,2);
SELECT * FROM t WHERE id = FLOOR(1 + RAND() * 49);
</pre><p>
                Both queries appear to use a primary key lookup because of the
                equality comparison against the primary key, but that is true
                only for the first of them:
            </p><p style="color:blue;">由于与主键的相等性比较，这两个查询似乎都使用主键查找，但这仅适用于第一个查询：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The first query always produces a maximum of one row
                        because <a class="link" href="functions.html#function_pow"><code class="literal">POW()</code></a> with constant
                        arguments is a constant value and is used for index
                        lookup.
                    </p><p style="color:blue;">第一个查询总是产生一行的最大值，因为具有常数参数的PUE（）是一个常量，用于索引查找。</p><p></p></li><li class="listitem"><p>
                        The second query contains an expression that uses the
                        nondeterministic function
                        <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a>, which is not
                        constant in the query but in fact has a new value for
                        every row of table <code class="literal">t</code>. Consequently, the
                        query reads every row of the table, evaluates the
                        predicate for each row, and outputs all rows for which the
                        primary key matches the random value. This might be zero,
                        one, or multiple rows, depending on the
                        <code class="literal">id</code> column values and the values in the
                        <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a> sequence.
                    </p><p style="color:blue;">第二个查询包含一个表达式，该表达式使用不确定函数rand（），该函数在查询中不是常量，但实际上对表t的每一行都有一个新值。因此，该查询读取表的每一行，计算每一行的谓词，并输出主键与随机值匹配的所有行。这可能是零行、一行或多行，具体取决于id列值和rand（）序列中的值。</p><p></p></li></ul>
                </div>
                <p>
                    The effects of nondeterminism are not limited to
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements. This
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement uses a
                    nondeterministic function to select rows to be modified:
                </p><p style="color:blue;">不确定性的影响不限于select语句。此UPDATE语句使用不确定函数选择要修改的行：</p><p></p><pre data-lang="sql" class="programlisting">UPDATE t SET col_a = <em class="replaceable"><code>some_expr</code></em> WHERE id = FLOOR(1 + RAND() * 49);
</pre><p>
                Presumably the intent is to update at most a single row for
                which the primary key matches the expression. However, it
                might update zero, one, or multiple rows, depending on the
                <code class="literal">id</code> column values and the values in the
                <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a> sequence.
            </p><p style="color:blue;">可能目的是最多更新主键与表达式匹配的一行。但是，它可能会更新零行、一行或多行，具体取决于id列值和rand（）序列中的值。</p><p></p><p>
                The behavior just described has implications for performance
                and replication:
            </p><p style="color:blue;">刚才描述的行为对性能和复制有影响：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Because a nondeterministic function does not produce a
                        constant value, the optimizer cannot use strategies that
                        might otherwise be applicable, such as index lookups. The
                        result may be a table scan.
                    </p><p style="color:blue;">由于不确定函数不产生常量值，优化器不能使用其他可能适用的策略，例如索引查找。结果可能是表扫描。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">InnoDB</code> might escalate to a range-key
                        lock rather than taking a single row lock for one matching
                        row.
                    </p><p style="color:blue;">innodb可能升级为范围键锁，而不是为一个匹配的行获取一个行锁。</p><p></p></li><li class="listitem"><p>
                        Updates that do not execute deterministically are unsafe
                        for replication.
                    </p><p style="color:blue;">不以确定方式执行的更新对复制是不安全的。</p><p></p></li></ul>
                </div>
                <p>
                    The difficulties stem from the fact that the
                    <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a> function is evaluated
                    once for every row of the table. To avoid multiple function
                    evaluations, use one of these techniques:
                </p><p style="color:blue;">这些困难源于这样一个事实：rand（）函数对表的每一行都求值一次。要避免多个功能评估，请使用以下技术之一：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Move the expression containing the nondeterministic
                        function to a separate statement, saving the value in a
                        variable. In the original statement, replace the
                        expression with a reference to the variable, which the
                        optimizer can treat as a constant value:
                    </p><p style="color:blue;">将包含不确定函数的表达式移到单独的语句中，将值保存在变量中。在原始语句中，将表达式替换为对变量的引用，优化器可以将其视为常量值：</p><p></p><pre data-lang="sql" class="programlisting">SET @keyval = FLOOR(1 + RAND() * 49);
UPDATE t SET col_a = <em class="replaceable"><code>some_expr</code></em> WHERE id = @keyval;
</pre></li><li class="listitem"><p>
                        Assign the random value to a variable in a derived table.
                        This technique causes the variable to be assigned a value,
                        once, prior to its use in the comparison in the
                        <code class="literal">WHERE</code> clause:
                    </p><p style="color:blue;">将随机值赋给派生表中的变量。此技术使变量在用于where子句中的比较之前被赋值一次：</p><p></p><pre data-lang="sql" class="programlisting">SET optimizer_switch = 'derived_merge=off';
UPDATE t, (SELECT @keyval := FLOOR(1 + RAND() * 49)) AS dt
SET col_a = <em class="replaceable"><code>some_expr</code></em> WHERE id = @keyval;
</pre></li></ul>
                </div>
                <p>
                    As mentioned previously, a nondeterministic expression in the
                    <code class="literal">WHERE</code> clause might prevent optimizations
                    and result in a table scan. However, it may be possible to
                    partially optimize the <code class="literal">WHERE</code> clause if
                    other expressions are deterministic. For example:
                </p><p style="color:blue;">如前所述，where子句中的不确定表达式可能会阻止优化并导致表扫描。但是，如果其他表达式是确定性的，则可以部分优化where子句。例如：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t WHERE partial_key=5 AND some_column=RAND();
</pre><p>
                If the optimizer can use <code class="literal">partial_key</code> to
                reduce the set of rows selected,
                <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a> is executed fewer times,
                which diminishes the effect of nondeterminism on optimization.
            </p><p style="color:blue;">如果优化器可以使用partial_键来减少所选行的集合，则rand（）的执行次数将减少，这将减少不确定性对优化的影响。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="row-constructor-optimization"></a>8.2.1.19&nbsp;Row Constructor Expression Optimization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286874551456"></a><a class="indexterm" name="idm140286874549968"></a><p>
                Row constructors permit simultaneous comparisons of multiple
                values. For example, these two statements are semantically
                equivalent:
            </p><p style="color:blue;">行构造函数允许同时比较多个值。例如，这两个语句在语义上是等价的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE (column1,column2) = (1,1);
SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;
</pre><p>
                In addition, the optimizer handles both expressions the same
                way.
            </p><p style="color:blue;">此外，优化器以相同的方式处理这两个表达式。</p><p></p><p>
                The optimizer is less likely to use available indexes if the
                row constructor columns do not cover the prefix of an index.
                Consider the following table, which has a primary key on
                <code class="literal">(c1, c2, c3)</code>:
            </p><p style="color:blue;">如果行构造函数列不包含索引的前缀，优化器就不太可能使用可用索引。请考虑下表，该表的主键位于（c1、c2、c3）上：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  c1 INT, c2 INT, c3 INT, c4 CHAR(100),
  PRIMARY KEY(c1,c2,c3)
);
</pre><p>
                In this query, the <code class="literal">WHERE</code> clause uses all
                columns in the index. However, the row constructor itself does
                not cover an index prefix, with the result that the optimizer
                uses only <code class="literal">c1</code> (<code class="literal">key_len=4</code>,
                the size of <code class="literal">c1</code>):
            </p><p style="color:blue;">在这个查询中，where子句使用索引中的所有列。但是，行构造函数本身不包含索引前缀，其结果是优化器只使用c1（key_len=4，c1的大小）：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1</code></strong>
       <strong class="userinput"><code>WHERE c1=1 AND (c2,c3) &gt; (1,1)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 3
     filtered: 100.00
        Extra: Using where
</pre><p>
                In such cases, rewriting the row constructor expression using
                an equivalent nonconstructor expression may result in more
                complete index use. For the given query, the row constructor
                and equivalent nonconstructor expressions are:
            </p><p style="color:blue;">在这种情况下，使用等效的非结构化表达式重写行构造函数表达式可能会导致更完整的索引使用。对于给定的查询，行构造函数和等效的非构造函数表达式是：</p><p></p><pre data-lang="sql" class="programlisting">(c2,c3) &gt; (1,1)
c2 &gt; 1 OR ((c2 = 1) AND (c3 &gt; 1))
</pre><p>
                Rewriting the query to use the nonconstructor expression
                results in the optimizer using all three columns in the index
                (<code class="literal">key_len=12</code>):
            </p><p style="color:blue;">重写查询以使用非结构化表达式将导致优化器使用索引中的所有三列（key_len=12）：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1</code></strong>
       <strong class="userinput"><code>WHERE c1 = 1 AND (c2 &gt; 1 OR ((c2 = 1) AND (c3 &gt; 1)))\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 12
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using where
</pre><p>
                Thus, for better results, avoid mixing row constructors with
                <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a>/<a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a>
                expressions. Use one or the other.
            </p><p style="color:blue;">因此，为了获得更好的结果，请避免将行构造函数与和/或表达式混合使用。用一个或另一个。</p><p></p><p>
                Under certain conditions, the optimizer can apply the range
                access method to <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a> expressions
                that have row constructor arguments. See
                <a class="xref" href="optimization.html#row-constructor-range-optimization" title="Range Optimization of Row Constructor Expressions">Range Optimization of Row Constructor Expressions</a>.
            </p><p style="color:blue;">在某些条件下，优化器可以对具有行构造函数参数的in（）表达式应用范围访问方法。请参见行构造函数表达式的范围优化。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="table-scan-avoidance"></a>8.2.1.20&nbsp;Avoiding Full Table Scans</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286874525568"></a><a class="indexterm" name="idm140286874524112"></a><a class="indexterm" name="idm140286874522624"></a><p>
                The output from <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> shows
                <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a> in the
                <code class="literal">type</code> column when MySQL uses a
                <a class="link" href="glossary.html#glos_full_table_scan" title="full table scan">full table scan</a> to
                resolve a query. This usually happens under the following
                conditions:
            </p><p style="color:blue;">当mysql使用全表扫描来解析查询时，explain的输出显示type列中的所有内容。通常在以下情况下发生：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The table is so small that it is faster to perform a table
                        scan than to bother with a key lookup. This is common for
                        tables with fewer than 10 rows and a short row length.
                    </p><p style="color:blue;">表太小了，执行表扫描比使用键查找更快。对于行数少于10行且行长度较短的表，这种情况很常见。</p><p></p></li><li class="listitem"><p>
                        There are no usable restrictions in the
                        <code class="literal">ON</code> or <code class="literal">WHERE</code> clause
                        for indexed columns.
                    </p><p style="color:blue;">对于索引列，ON或WHERE子句中没有可用的限制。</p><p></p></li><li class="listitem"><p>
                        You are comparing indexed columns with constant values and
                        MySQL has calculated (based on the index tree) that the
                        constants cover too large a part of the table and that a
                        table scan would be faster. See
                        <a class="xref" href="optimization.html#where-optimization" title="8.2.1.1&nbsp;WHERE Clause Optimization">Section&nbsp;8.2.1.1, “WHERE Clause Optimization”</a>.
                    </p><p style="color:blue;">您正在将索引列与常量值进行比较，mysql已经计算出（基于索引树）常量覆盖了表的很大一部分，并且表扫描会更快。见第8.2.1.1节，“where子句优化”。</p><p></p></li><li class="listitem"><p>
                        You are using a key with low cardinality (many rows match
                        the key value) through another column. In this case, MySQL
                        assumes that by using the key it probably will do many key
                        lookups and that a table scan would be faster.
                    </p><p style="color:blue;">您正在通过另一列使用基数较低的键（许多行与键值匹配）。在本例中，mysql假设通过使用密钥，它可能会执行许多密钥查找，并且表扫描会更快。</p><p></p></li></ul>
                </div>
                <p>
                    For small tables, a table scan often is appropriate and the
                    performance impact is negligible. For large tables, try the
                    following techniques to avoid having the optimizer incorrectly
                    choose a table scan:
                </p><p style="color:blue;">对于小表，表扫描通常是合适的，性能影响可以忽略不计。对于大型表，请尝试以下技术以避免优化器错误地选择表扫描：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Use <code class="literal">ANALYZE TABLE
                        <em class="replaceable"><code>tbl_name</code></em></code> to update
                        the key distributions for the scanned table. See
                        <a class="xref" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax">Section&nbsp;13.7.2.1, “ANALYZE TABLE Syntax”</a>.
                    </p><p style="color:blue;">使用analyze table tbl_name更新扫描表的密钥分布。见第13.7.2.1节“分析表语法”。</p><p></p></li><li class="listitem"><p>
                        Use <code class="literal">FORCE INDEX</code> for the scanned table
                        to tell MySQL that table scans are very expensive compared
                        to using the given index:
                    </p><p style="color:blue;">对扫描的表使用force index告诉mysql，与使用给定索引相比，表扫描非常昂贵：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1, t2 FORCE INDEX (<em class="replaceable"><code>index_for_column</code></em>)
  WHERE t1.<em class="replaceable"><code>col_name</code></em>=t2.<em class="replaceable"><code>col_name</code></em>;
</pre><p>
                        See <a class="xref" href="optimization.html#index-hints" title="8.9.4&nbsp;Index Hints">Section&nbsp;8.9.4, “Index Hints”</a>.
                    </p><p style="color:blue;">见第8.9.4节“索引提示”。</p><p></p></li><li class="listitem"><p>
                        Start <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with the
                        <a class="link" href="server-administration.html#sysvar_max_seeks_for_key"><code class="option">--max-seeks-for-key=1000</code></a>
                        option or use <code class="literal">SET
                        max_seeks_for_key=1000</code> to tell the optimizer to
                        assume that no key scan causes more than 1,000 key seeks.
                        See <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                    </p><p style="color:blue;">使用--max seeks for key=1000选项启动mysqld，或者使用set max_seeks_for_key=1000告诉优化器假设没有密钥扫描导致超过1000个密钥查找。见第5.1.7节“服务器系统变量”。</p><p></p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="subquery-optimization"></a>8.2.2&nbsp;Optimizing Subqueries, Derived Tables, and View References</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#semijoins">8.2.2.1 Optimizing Subqueries, Derived Tables, and View References with Semijoin
          Transformations</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-materialization">8.2.2.2 Optimizing Subqueries with Materialization</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-optimization-with-exists">8.2.2.3 Optimizing Subqueries with the EXISTS Strategy</a></span></dt><dt><span class="section"><a href="optimization.html#derived-table-optimization">8.2.2.4 Optimizing Derived Tables and View References with Merging or
Materialization</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286874495792"></a><a class="indexterm" name="idm140286874494336"></a><a class="indexterm" name="idm140286874492848"></a><a class="indexterm" name="idm140286874491360"></a><a class="indexterm" name="idm140286874489872"></a><a class="indexterm" name="idm140286874488384"></a><p>
            The MySQL query optimizer has different strategies available to
            evaluate subqueries:
        </p><p style="color:blue;">mysql查询优化器有不同的策略可用于计算子查询：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For <code class="literal">IN</code> (or <code class="literal">=ANY</code>)
                    subqueries, the optimizer has these choices:
                </p><p style="color:blue;">对于in（或=any）子查询，优化器有以下选择：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Semijoin
                        </p><p style="color:blue;">半连接</p><p></p></li><li class="listitem"><p>
                            Materialization
                        </p><p style="color:blue;">物化</p><p></p></li><li class="listitem"><p>
                            <code class="literal">EXISTS</code> strategy
                        </p><p style="color:blue;">存在的策略</p><p></p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    For <code class="literal">NOT IN</code> (or
                    <code class="literal">&lt;&gt;ALL</code>) subqueries, the optimizer
                    has these choices:
                </p><p style="color:blue;">对于不在（或&lt;&gt;全部）子查询，优化器有以下选择：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Materialization
                        </p><p style="color:blue;">物化</p><p></p></li><li class="listitem"><p>
                            <code class="literal">EXISTS</code> strategy
                        </p><p style="color:blue;">存在的策略</p><p></p></li></ul>
                    </div>
                </li></ul>
            </div>
            <p>
                For derived tables, the optimizer has these choices (which also
                apply to view references):
            </p><p style="color:blue;">对于派生表，优化器有以下选择（也适用于视图引用）：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Merge the derived table into the outer query block
                </p><p style="color:blue;">将派生表合并到外部查询块中</p><p></p></li><li class="listitem"><p>
                    Materialize the derived table to an internal temporary table
                </p><p style="color:blue;">将派生表具体化为内部临时表</p><p></p></li></ul>
            </div>
            <p>
                The following discussion provides more information about the
                preceding optimization strategies.
            </p><p style="color:blue;">下面的讨论提供了有关前面优化策略的更多信息。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    A limitation on <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> and
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements that use a
                    subquery to modify a single table is that the optimizer does
                    not use semijoin or materialization subquery optimizations. As
                    a workaround, try rewriting them as multiple-table
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> and
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements that use a
                    join rather than a subquery.
                </p><p style="color:blue;">对使用子查询修改单个表的update和delete语句的一个限制是优化器不使用半联接或物化子查询优化。作为解决方法，请尝试将它们重写为使用联接而不是子查询的多个表update和delete语句。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="semijoins"></a>8.2.2.1&nbsp;Optimizing Subqueries, Derived Tables, and View References with Semijoin
                                Transformations</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286874464832"></a><p>
                A semijoin is a preparation-time transformation that enables
                multiple execution strategies such as table pullout, duplicate
                weedout, first match, loose scan, and materialization. The
                optimizer uses semijoin strategies to improve subquery
                execution, as described in this section.
            </p><p style="color:blue;">半联接是一种准备时转换，它支持多种执行策略，如表拉出、重复weedout、第一次匹配、松散扫描和物化。优化器使用半连接策略改进子查询的执行，如本节所述。</p><p></p><p>
                For an inner join between two tables, the join returns a row
                from one table as many times as there are matches in the other
                table. But for some questions, the only information that
                matters is whether there is a match, not the number of
                matches. Suppose that there are tables named
                <code class="literal">class</code> and <code class="literal">roster</code> that
                list classes in a course curriculum and class rosters
                (students enrolled in each class), respectively. To list the
                classes that actually have students enrolled, you could use
                this join:
            </p><p style="color:blue;">对于两个表之间的内部联接，联接返回一个表中的行的次数与另一个表中的匹配次数相同。但对于一些问题，唯一重要的信息是是否存在匹配，而不是匹配的数量。假设有一个名为“班级”和“花名册”的表，分别列出了课程表和班级花名册（每个班级的学生）。要列出实际有学生注册的课程，可以使用此联接：</p><p></p><pre data-lang="sql" class="programlisting">SELECT class.class_num, class.class_name
FROM class INNER JOIN roster
WHERE class.class_num = roster.class_num;
</pre><p>
                However, the result lists each class once for each enrolled
                student. For the question being asked, this is unnecessary
                duplication of information.
            </p><p style="color:blue;">但是，结果为每个注册的学生列出每个班级一次。对于所提出的问题，这是不必要的信息重复。</p><p></p><p>
                Assuming that <code class="literal">class_num</code> is a primary key in
                the <code class="literal">class</code> table, duplicate suppression is
                possible by using
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT
                    DISTINCT</code></a>, but it is inefficient to generate all
                matching rows first only to eliminate duplicates later.
            </p><p style="color:blue;">假设类num是类表中的主键，使用select distinct可以抑制重复，但是先生成所有匹配行，然后再消除重复行是低效的。</p><p></p><p>
                The same duplicate-free result can be obtained by using a
                subquery:
            </p><p style="color:blue;">使用子查询可以获得相同的重复自由结果：</p><p></p><pre data-lang="sql" class="programlisting">SELECT class_num, class_name
FROM class
WHERE class_num IN (SELECT class_num FROM roster);
</pre><p>
                Here, the optimizer can recognize that the
                <code class="literal">IN</code> clause requires the subquery to return
                only one instance of each class number from the
                <code class="literal">roster</code> table. In this case, the query can
                use a <span class="firstterm">semijoin</span>; that is,
                an operation that returns only one instance of each row in
                <code class="literal">class</code> that is matched by rows in
                <code class="literal">roster</code>.
            </p><p style="color:blue;">在这里，优化器可以识别出in子句要求子查询只返回花名册表中每个类号的一个实例。在这种情况下，查询可以使用半联接；也就是说，只返回类中每一行的一个实例的操作，该实例与花名册中的行匹配。</p><p></p><p>
                Outer join and inner join syntax is permitted in the outer
                query specification, and table references may be base tables,
                derived tables, or view references.
            </p><p style="color:blue;">外部查询规范中允许使用外部联接和内部联接语法，表引用可以是基表、派生表或视图引用。</p><p></p><p>
                In MySQL, a subquery must satisfy these criteria to be handled
                as a semijoin:
            </p><p style="color:blue;">在mysql中，子查询必须满足以下条件才能作为半联接处理：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        It must be an <code class="literal">IN</code> (or
                        <code class="literal">=ANY</code>) subquery that appears at the top
                        level of the <code class="literal">WHERE</code> or
                        <code class="literal">ON</code> clause, possibly as a term in an
                        <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a> expression. For example:
                    </p><p style="color:blue;">它必须是出现在where或on子句顶层的in（或=any）子查询，可能是and表达式中的一个术语。例如：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ...
FROM ot1, ...
WHERE (oe1, ...) IN (SELECT ie1, ... FROM it1, ... WHERE ...);
</pre><p>
                        Here, <code class="literal">ot_<em class="replaceable"><code>i</code></em></code>
                        and <code class="literal">it_<em class="replaceable"><code>i</code></em></code>
                        represent tables in the outer and inner parts of the
                        query, and
                        <code class="literal">oe_<em class="replaceable"><code>i</code></em></code> and
                        <code class="literal">ie_<em class="replaceable"><code>i</code></em></code>
                        represent expressions that refer to columns in the outer
                        and inner tables.
                    </p><p style="color:blue;">这里，ot_i和it_i表示查询外部和内部部分的表，oe_i和ie_i表示引用外部和内部表中列的表达式。</p><p></p></li><li class="listitem"><p>
                        It must be a single <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        without <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> constructs.
                    </p><p style="color:blue;">它必须是一个没有union构造的select。</p><p></p></li><li class="listitem"><p>
                        It must not contain a <code class="literal">GROUP BY</code> or
                        <code class="literal">HAVING</code> clause.
                    </p><p style="color:blue;">它不能包含GROUP BY或HAVING子句。</p><p></p></li><li class="listitem"><p>
                        It must not be implicitly grouped (it must contain no
                        aggregate functions).
                    </p><p style="color:blue;">它不能隐式分组（它不能包含聚合函数）。</p><p></p></li><li class="listitem"><p>
                        It must not have <code class="literal">ORDER BY</code> with
                        <code class="literal">LIMIT</code>.
                    </p><p style="color:blue;">它不能有限制的命令。</p><p></p></li><li class="listitem"><p>
                        The statement must not use the
                        <code class="literal">STRAIGHT_JOIN</code> join type in the outer
                        query.
                    </p><p style="color:blue;">语句不能在外部查询中使用直联接类型。</p><p></p><a class="indexterm" name="idm140286874427984"></a></li><li class="listitem"><p>
                        The <code class="literal">STRAIGHT_JOIN</code> modifier must not be
                        present.
                    </p><p style="color:blue;">直连接修饰符不能存在。</p><p></p><a class="indexterm" name="idm140286874424928"></a></li><li class="listitem"><p>
                        The number of outer and inner tables together must be less
                        than the maximum number of tables permitted in a join.
                    </p><p style="color:blue;">外部表和内部表的总数必须小于联接中允许的最大表数。</p><p></p></li></ul>
                </div>
                <p>
                    The subquery may be correlated or uncorrelated.
                    <code class="literal">DISTINCT</code> is permitted, as is
                    <code class="literal">LIMIT</code> unless <code class="literal">ORDER BY</code> is
                    also used.
                </p><p style="color:blue;">子查询可以是相关的或不相关的。允许使用DISTINCT，也允许使用LIMIT，除非还使用ORDER BY。</p><p></p><p>
                If a subquery meets the preceding criteria, MySQL converts it
                to a semijoin and makes a cost-based choice from these
                strategies:
            </p><p style="color:blue;">如果子查询满足上述条件，mysql会将其转换为半联接，并从以下策略中进行基于成本的选择：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Convert the subquery to a join, or use table pullout and
                        run the query as an inner join between subquery tables and
                        outer tables. Table pullout pulls a table out from the
                        subquery to the outer query.
                    </p><p style="color:blue;">将子查询转换为联接，或使用table pullout将查询作为子查询表和外部表之间的内部联接运行。table pullout将表从子查询中拉出到外部查询。</p><p></p><a class="indexterm" name="idm140286874417824"></a></li><li class="listitem"><p>
                        Duplicate Weedout: Run the semijoin as if it was a join
                        and remove duplicate records using a temporary table.
                    </p><p style="color:blue;">Duplicate WeedOut：将半联接当作联接运行，并使用临时表删除重复记录。</p><p></p><a class="indexterm" name="idm140286874415408"></a></li><li class="listitem"><p>
                        FirstMatch: When scanning the inner tables for row
                        combinations and there are multiple instances of a given
                        value group, choose one rather than returning them all.
                        This "shortcuts" scanning and eliminates production of
                        unnecessary rows.
                    </p><p style="color:blue;">FirstMatch：当扫描内部表以查找行组合时，如果给定值组有多个实例，请选择一个，而不是全部返回。这种“快捷方式”扫描可以消除不必要的行。</p><p></p><a class="indexterm" name="idm140286874412816"></a></li><li class="listitem"><p>
                        LooseScan: Scan a subquery table using an index that
                        enables a single value to be chosen from each subquery's
                        value group.
                    </p><p style="color:blue;">loosescan：使用索引扫描子查询表，该索引允许从每个子查询的值组中选择单个值。</p><p></p><a class="indexterm" name="idm140286874410368"></a></li><li class="listitem"><p>
                        Materialize the subquery into an indexed temporary table
                        that is used to perform a join, where the index is used to
                        remove duplicates. The index might also be used later for
                        lookups when joining the temporary table with the outer
                        tables; if not, the table is scanned. For more information
                        about materialization, see
                        <a class="xref" href="optimization.html#subquery-materialization" title="8.2.2.2&nbsp;Optimizing Subqueries with Materialization">Section&nbsp;8.2.2.2, “Optimizing Subqueries with Materialization”</a>.
                    </p><p style="color:blue;">将子查询具体化为用于执行联接的索引临时表，其中索引用于删除重复项。在将临时表与外部表连接时，该索引也可以用于以后的查找；如果没有，则扫描该表。有关物化的更多信息，请参见第8.2.2.2节“使用物化优化子查询”。</p><p></p><a class="indexterm" name="idm140286874406816"></a></li></ul>
                </div>
                <p>
                    Each of these strategies can be enabled or disabled using the
                    following <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a>
                    system variable flags:
                </p><p style="color:blue;">可以使用以下优化器开关系统变量标志启用或禁用这些策略：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <code class="literal">semijoin</code> flag controls whether
                        semijoins are used.
                    </p><p style="color:blue;">半联接标志控制是否使用半联接。</p><p></p></li><li class="listitem"><p>
                        If <code class="literal">semijoin</code> is enabled, the
                        <code class="literal">firstmatch</code>,
                        <code class="literal">loosescan</code>,
                        <code class="literal">duplicateweedout</code>, and
                        <code class="literal">materialization</code> flags enable finer
                        control over the permitted semijoin strategies.
                    </p><p style="color:blue;">如果启用了半联接，则firstmatch、loosescan、duplicateweedout和物化标志可以更好地控制允许的半联接策略。</p><p></p></li><li class="listitem"><p>
                        If the <code class="literal">duplicateweedout</code> semijoin
                        strategy is disabled, it is not used unless all other
                        applicable strategies are also disabled.
                    </p><p style="color:blue;">如果DuplicateWeedOutOut半联接策略被禁用，则除非所有其他适用策略也被禁用，否则不会使用该策略。</p><p></p></li><li class="listitem"><p>
                        If <code class="literal">duplicateweedout</code> is disabled, on
                        occasion the optimizer may generate a query plan that is
                        far from optimal. This occurs due to heuristic pruning
                        during greedy search, which can be avoided by setting
                        <a class="link" href="server-administration.html#sysvar_optimizer_prune_level"><code class="literal">optimizer_prune_level=0</code></a>.
                    </p><p style="color:blue;">如果禁用了duplicateWeedOut，优化器有时可能会生成一个远远不是最优的查询计划。这是由于贪婪搜索期间的启发式修剪造成的，可以通过设置优化器修剪级别=0来避免。</p><p></p></li></ul>
                </div>
                <p>
                    These flags are enabled by default. See
                    <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>.
                </p><p style="color:blue;">默认情况下，这些标志处于启用状态。见第8.9.2节“可切换优化”。</p><p></p><p>
                The optimizer minimizes differences in handling of views and
                derived tables. This affects queries that use the
                <code class="literal">STRAIGHT_JOIN</code> modifier and a view with an
                <code class="literal">IN</code> subquery that can be converted to a
                semijoin. The following query illustrates this because the
                change in processing causes a change in transformation, and
                thus a different execution strategy:
            </p><p style="color:blue;">优化器将视图和派生表的处理差异最小化。这会影响使用直联接修饰符的查询和具有可转换为半联接的in子查询的视图。以下查询说明了这一点，因为处理中的更改会导致转换的更改，从而导致不同的执行策略：</p><p></p><pre data-lang="sql" class="programlisting">CREATE VIEW v AS
SELECT *
FROM t1
WHERE a IN (SELECT b
           FROM t2);

SELECT STRAIGHT_JOIN *
FROM t3 JOIN v ON t3.x = v.a;
</pre><p>
                The optimizer first looks at the view and converts the
                <code class="literal">IN</code> subquery to a semijoin, then checks
                whether it is possible to merge the view into the outer query.
                Because the <code class="literal">STRAIGHT_JOIN</code> modifier in the
                outer query prevents semijoin, the optimizer refuses the
                merge, causing derived table evaluation using a materialized
                table.
            </p><p style="color:blue;">优化器首先查看视图并将in子查询转换为半联接，然后检查是否可以将视图合并到外部查询中。由于外部查询中的直连接修饰符防止半连接，优化器拒绝合并，从而导致使用物化表计算派生表。</p><p></p><p>
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output indicates the
                use of semijoin strategies as follows:
            </p><p style="color:blue;">explain output指示半联接策略的使用，如下所示：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Semijoined tables show up in the outer select. For
                        extended <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output,
                        the text displayed by a following
                        <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> shows the
                        rewritten query, which displays the semijoin structure.
                        (See <a class="xref" href="optimization.html#explain-extended" title="8.8.3&nbsp;Extended EXPLAIN Output Format">Section&nbsp;8.8.3, “Extended EXPLAIN Output Format”</a>.) From this you
                        can get an idea about which tables were pulled out of the
                        semijoin. If a subquery was converted to a semijoin, you
                        will see that the subquery predicate is gone and its
                        tables and <code class="literal">WHERE</code> clause were merged
                        into the outer query join list and
                        <code class="literal">WHERE</code> clause.
                    </p><p style="color:blue;">半联接表显示在外部选择中。对于扩展的explain输出，以下show warnings显示的文本显示重写的查询，该查询显示半联接结构。（参见第8.8.3节，“扩展解释输出格式”。）从中可以了解哪些表是从半联接中拉出的。如果子查询已转换为半联接，您将看到子查询谓词已消失，其表和where子句已合并到外部查询联接列表和where子句中。</p><p></p></li><li class="listitem"><p>
                        Temporary table use for Duplicate Weedout is indicated by
                        <code class="literal">Start temporary</code> and <code class="literal">End
                        temporary</code> in the <code class="literal">Extra</code>
                        column. Tables that were not pulled out and are in the
                        range of <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output
                        rows covered by <code class="literal">Start temporary</code> and
                        <code class="literal">End temporary</code> have their
                        <code class="literal">rowid</code> in the temporary table.
                    </p><p style="color:blue;">用于重复weedout的临时表由额外列中的start temporary和end temporary指示。未被拉出且在start temporary和end temporary覆盖的explain output行范围内的表的rowid位于临时表中。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">FirstMatch(<em class="replaceable"><code>tbl_name</code></em>)</code>
                        in the <code class="literal">Extra</code> column indicates join
                        shortcutting.
                    </p><p style="color:blue;">额外列中的firstmatch（tbl_name）表示连接快捷方式。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">LooseScan(<em class="replaceable"><code>m</code></em>..<em class="replaceable"><code>n</code></em>)</code>
                        in the <code class="literal">Extra</code> column indicates use of
                        the LooseScan strategy. <em class="replaceable"><code>m</code></em> and
                        <em class="replaceable"><code>n</code></em> are key part numbers.
                    </p><p style="color:blue;">额外列中的loosscan（m..n）表示使用loosscan策略。M和N是关键零件号。</p><p></p></li><li class="listitem"><p>
                        Temporary table use for materialization is indicated by
                        rows with a <code class="literal">select_type</code> value of
                        <code class="literal">MATERIALIZED</code> and rows with a
                        <code class="literal">table</code> value of
                        <code class="literal">&lt;subquery<em class="replaceable"><code>N</code></em>&gt;</code>.
                    </p><p style="color:blue;">用于物化的临时表由select_type值为物化的行和表值为<subqueryn>的行指示。</subqueryn></p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="subquery-materialization"></a>8.2.2.2&nbsp;Optimizing Subqueries with Materialization</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286874359040"></a><a class="indexterm" name="idm140286874358000"></a><a class="indexterm" name="idm140286874356512"></a><p>
                The optimizer uses materialization to enable more efficient
                subquery processing. Materialization speeds up query execution
                by generating a subquery result as a temporary table, normally
                in memory. The first time MySQL needs the subquery result, it
                materializes that result into a temporary table. Any
                subsequent time the result is needed, MySQL refers again to
                the temporary table. The optimizer may index the table with a
                hash index to make lookups fast and inexpensive. The index
                contains unique values to eliminate duplicates and make the
                table smaller.
            </p><p style="color:blue;">优化器使用物化来实现更高效的子查询处理。物化通过将子查询结果生成为临时表（通常在内存中）来加快查询执行。mysql第一次需要子查询结果时，它将该结果具体化为一个临时表。任何后续需要结果的时候，mysql都会再次引用临时表。优化器可以用散列索引对表进行索引，以便快速而廉价地查找。索引包含唯一值以消除重复项并使表变小。</p><p></p><p>
                Subquery materialization uses an in-memory temporary table
                when possible, falling back to on-disk storage if the table
                becomes too large. See
                <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4&nbsp;Internal Temporary Table Use in MySQL">Section&nbsp;8.4.4, “Internal Temporary Table Use in MySQL”</a>.
            </p><p style="color:blue;">子查询物化尽可能使用内存中的临时表，如果表太大，则返回到磁盘存储。见8.4.4节，“MySQL中的内部临时表使用”。</p><p></p><p>
                If materialization is not used, the optimizer sometimes
                rewrites a noncorrelated subquery as a correlated subquery.
                For example, the following <code class="literal">IN</code> subquery is
                noncorrelated (<em class="replaceable"><code>where_condition</code></em>
                involves only columns from <code class="literal">t2</code> and not
                <code class="literal">t1</code>):
            </p><p style="color:blue;">如果不使用物化，优化器有时会将非相关子查询重写为相关子查询。例如，子查询中的以下内容是非相关的（其中，条件只涉及来自t2的列，而不涉及t1的列）：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
WHERE t1.a IN (SELECT t2.b FROM t2 WHERE <em class="replaceable"><code>where_condition</code></em>);
</pre><p>
                The optimizer might rewrite this as an
                <code class="literal">EXISTS</code> correlated subquery:
            </p><p style="color:blue;">优化器可能会将其重写为已存在的关联子查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
WHERE EXISTS (SELECT t2.b FROM t2 WHERE <em class="replaceable"><code>where_condition</code></em> AND t1.a=t2.b);
</pre><p>
                Subquery materialization using a temporary table avoids such
                rewrites and makes it possible to execute the subquery only
                once rather than once per row of the outer query.
            </p><p style="color:blue;">使用临时表的子查询物化避免了这样的重写，并使外部查询的每行只执行一次而不是一次成为可能。</p><p></p><p>
                For subquery materialization to be used in MySQL, the
                <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                variable <code class="literal">materialization</code> flag must be
                enabled. (See <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>.)
                With the <code class="literal">materialization</code> flag enabled,
                materialization applies to subquery predicates that appear
                anywhere (in the select list, <code class="literal">WHERE</code>,
                <code class="literal">ON</code>, <code class="literal">GROUP BY</code>,
                <code class="literal">HAVING</code>, or <code class="literal">ORDER BY</code>),
                for predicates that fall into any of these use cases:
            </p><p style="color:blue;">要在mysql中使用子查询物化，必须启用优化器交换系统变量物化标志。（参见第8.9.2节“可切换优化”）在启用物化标志的情况下，物化应用于出现在任意位置（在选择列表中，其中，on，group by，having，or order by）的子查询谓词，以获取属于这些用例中任何一个的谓词：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The predicate has this form, when no outer expression
                        <em class="replaceable"><code>oe_i</code></em> or inner expression
                        <em class="replaceable"><code>ie_i</code></em> is nullable.
                        <em class="replaceable"><code>N</code></em> is 1 or larger.
                    </p><p style="color:blue;">当没有外部表达式或内部表达式可以为空时，谓词具有这种形式。n等于或大于1。</p><p></p><pre data-lang="sql" class="programlisting">(<em class="replaceable"><code>oe_1</code></em>, <em class="replaceable"><code>oe_2</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) [NOT] IN (SELECT <em class="replaceable"><code>ie_1</code></em>, <em class="replaceable"><code>i_2</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> ...)
</pre></li><li class="listitem"><p>
                        The predicate has this form, when there is a single outer
                        expression <em class="replaceable"><code>oe</code></em> and inner
                        expression <em class="replaceable"><code>ie</code></em>. The expressions
                        can be nullable.
                    </p><p style="color:blue;">当有一个外部表达式oe和内部表达式ie时，谓词具有这种形式。表达式可以为空。</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>oe</code></em> [NOT] IN (SELECT <em class="replaceable"><code>ie</code></em> ...)
</pre></li><li class="listitem"><p>
                        The predicate is <code class="literal">IN</code> or <code class="literal">NOT
                        IN</code> and a result of <code class="literal">UNKNOWN</code>
                        (<code class="literal">NULL</code>) has the same meaning as a result
                        of <code class="literal">FALSE</code>.
                    </p><p style="color:blue;">谓词是in还是not in，结果为unknown（null）与结果为false具有相同的含义。</p><p></p></li></ul>
                </div>
                <p>
                    The following examples illustrate how the requirement for
                    equivalence of <code class="literal">UNKNOWN</code> and
                    <code class="literal">FALSE</code> predicate evaluation affects whether
                    subquery materialization can be used. Assume that
                    <em class="replaceable"><code>where_condition</code></em> involves columns
                    only from <code class="literal">t2</code> and not <code class="literal">t1</code>
                    so that the subquery is noncorrelated.
                </p><p style="color:blue;">下面的示例说明了未知谓词和假谓词求值的等价性要求如何影响子查询物化是否可以使用。假设where_条件只涉及来自t2而不是t1的列，这样子查询就不相关了。</p><p></p><p>
                This query is subject to materialization:
            </p><p style="color:blue;">此查询以物化为准：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
WHERE t1.a IN (SELECT t2.b FROM t2 WHERE <em class="replaceable"><code>where_condition</code></em>);
</pre><p>
                Here, it does not matter whether the <code class="literal">IN</code>
                predicate returns <code class="literal">UNKNOWN</code> or
                <code class="literal">FALSE</code>. Either way, the row from
                <code class="literal">t1</code> is not included in the query result.
            </p><p style="color:blue;">在这里，in谓词返回unknown还是false并不重要。不管怎样，T1中的行都不包含在查询结果中。</p><p></p><p>
                An example where subquery materialization is not used is the
                following query, where <code class="literal">t2.b</code> is a nullable
                column:
            </p><p style="color:blue;">不使用子查询物化的一个示例是以下查询，其中t2.b是一个可为空列：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
WHERE (t1.a,t1.b) NOT IN (SELECT t2.a,t2.b FROM t2
                          WHERE <em class="replaceable"><code>where_condition</code></em>);
</pre><p>
                The following restrictions apply to the use of subquery
                materialization:
            </p><p style="color:blue;">以下限制适用于子查询物化的使用：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The types of the inner and outer expressions must match.
                        For example, the optimizer might be able to use
                        materialization if both expressions are integer or both
                        are decimal, but cannot if one expression is integer and
                        the other is decimal.
                    </p><p style="color:blue;">内部表达式和外部表达式的类型必须匹配。例如，如果两个表达式都是整数或都是十进制的，优化器可能可以使用物化，但如果一个表达式是整数，另一个是十进制的，则不能使用物化。</p><p></p></li><li class="listitem"><p>
                        The inner expression cannot be a
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>.
                    </p><p style="color:blue;">内部表达式不能是blob。</p><p></p></li></ul>
                </div>
                <p>
                    Use of <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> with a query
                    provides some indication of whether the optimizer uses
                    subquery materialization:
                </p><p style="color:blue;">对查询使用explain提供了优化器是否使用子查询物化的一些指示：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Compared to query execution that does not use
                        materialization, <code class="literal">select_type</code> may change
                        from <code class="literal">DEPENDENT SUBQUERY</code> to
                        <code class="literal">SUBQUERY</code>. This indicates that, for a
                        subquery that would be executed once per outer row,
                        materialization enables the subquery to be executed just
                        once.
                    </p><p style="color:blue;">与不使用物化的查询执行相比，select_type可能会从从属子查询更改为子查询。这表示，对于每个外部行执行一次的子查询，物化使该子查询只执行一次。</p><p></p></li><li class="listitem"><p>
                        For extended <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>
                        output, the text displayed by a following
                        <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> includes
                        <code class="literal">materialize</code> and
                        <code class="literal">materialized-subquery</code>.
                    </p><p style="color:blue;">对于扩展解释输出，由以下show警告显示的文本包括物化子查询和物化子查询。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="subquery-optimization-with-exists"></a>8.2.2.3&nbsp;Optimizing Subqueries with the EXISTS Strategy</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286874295856"></a><a class="indexterm" name="idm140286874294368"></a><p>
                Certain optimizations are applicable to comparisons that use
                the <code class="literal">IN</code> (or <code class="literal">=ANY</code>)
                operator to test subquery results. This section discusses
                these optimizations, particularly with regard to the
                challenges that <code class="literal">NULL</code> values present. The
                last part of the discussion suggests how you can help the
                optimizer.
            </p><p style="color:blue;">某些优化适用于使用in（或=any）运算符测试子查询结果的比较。本节讨论这些优化，特别是针对空值带来的挑战。讨论的最后一部分建议如何帮助优化器。</p><p></p><p>
                Consider the following subquery comparison:
            </p><p style="color:blue;">考虑以下子查询比较：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
                MySQL evaluates queries <span class="quote">“<span class="quote">from outside to inside.</span>”</span>
                That is, it first obtains the value of the outer expression
                <em class="replaceable"><code>outer_expr</code></em>, and then runs the
                subquery and captures the rows that it produces.
            </p><p style="color:blue;">mysql“从外向内”计算查询，即首先获取外部表达式outer_expr的值，然后运行子查询并捕获它生成的行。</p><p></p><p>
                A very useful optimization is to <span class="quote">“<span class="quote">inform</span>”</span> the
                subquery that the only rows of interest are those where the
                inner expression <em class="replaceable"><code>inner_expr</code></em> is
                equal to <em class="replaceable"><code>outer_expr</code></em>. This is done
                by pushing down an appropriate equality into the subquery's
                <code class="literal">WHERE</code> clause to make it more restrictive.
                The converted comparison looks like this:
            </p><p style="color:blue;">一个非常有用的优化是“通知”子查询，唯一感兴趣的行是那些内部表达式inner_expr等于outer_expr的行。这是通过将适当的等式下推到子查询的where子句中来实现的，以使其更具限制性。转换后的比较如下：</p><p></p><pre data-lang="sql" class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND <em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>)
</pre><p>
                After the conversion, MySQL can use the pushed-down equality
                to limit the number of rows it must examine to evaluate the
                subquery.
            </p><p style="color:blue;">转换之后，mysql可以使用下推等式来限制必须检查的行数，以便计算子查询。</p><p></p><p>
                More generally, a comparison of <em class="replaceable"><code>N</code></em>
                values to a subquery that returns
                <em class="replaceable"><code>N</code></em>-value rows is subject to the same
                conversion. If <em class="replaceable"><code>oe_i</code></em> and
                <em class="replaceable"><code>ie_i</code></em> represent corresponding outer
                and inner expression values, this subquery comparison:
            </p><p style="color:blue;">更一般地说，将n个值与返回n个值行的子查询进行比较时，需要进行相同的转换。如果oe_i和ie_i表示对应的外部和内部表达式值，则此子查询比较：</p><p></p><pre data-lang="sql" class="programlisting">(<em class="replaceable"><code>oe_1</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) IN
  (SELECT <em class="replaceable"><code>ie_1</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
                Becomes:
            </p><p style="color:blue;">变成：</p><p></p><pre data-lang="sql" class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND <em class="replaceable"><code>oe_1</code></em> = <em class="replaceable"><code>ie_1</code></em>
                          AND ...
                          AND <em class="replaceable"><code>oe_N</code></em> = <em class="replaceable"><code>ie_N</code></em>)
</pre><p>
                For simplicity, the following discussion assumes a single pair
                of outer and inner expression values.
            </p><p style="color:blue;">为了简单起见，下面的讨论假设一对外部和内部表达式值。</p><p></p><p>
                The conversion just described has its limitations. It is valid
                only if we ignore possible <code class="literal">NULL</code> values.
                That is, the <span class="quote">“<span class="quote">pushdown</span>”</span> strategy works as long as
                both of these conditions are true:
            </p><p style="color:blue;">刚才描述的转换有其局限性。只有忽略可能的空值时，它才有效。也就是说，只要这两个条件都是真的，“向下推”策略就可以工作：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <em class="replaceable"><code>outer_expr</code></em> and
                        <em class="replaceable"><code>inner_expr</code></em> cannot be
                        <code class="literal">NULL</code>.
                    </p><p style="color:blue;">外部表达式和内部表达式不能为空。</p><p></p></li><li class="listitem"><p>
                        You need not distinguish <code class="literal">NULL</code> from
                        <code class="literal">FALSE</code> subquery results. If the subquery
                        is a part of an <a class="link" href="functions.html#operator_or"><code class="literal">OR</code></a> or
                        <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a> expression in the
                        <code class="literal">WHERE</code> clause, MySQL assumes that you do
                        not care. Another instance where the optimizer notices
                        that <code class="literal">NULL</code> and <code class="literal">FALSE</code>
                        subquery results need not be distinguished is this
                        construct:
                    </p><p style="color:blue;">不需要区分空和假子查询结果。如果子查询是where子句中的or和表达式的一部分，mysql假设您不在乎。优化器注意到不需要区分空和假子查询结果的另一个实例是此构造：</p><p></p><pre data-lang="sql" class="programlisting">... WHERE <em class="replaceable"><code>outer_expr</code></em> IN (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
                        In this case, the <code class="literal">WHERE</code> clause rejects
                        the row whether <code class="literal">IN
                        (<em class="replaceable"><code>subquery</code></em>)</code> returns
                        <code class="literal">NULL</code> or <code class="literal">FALSE</code>.
                    </p><p style="color:blue;">在这种情况下，where子句拒绝行，无论in（subquery）返回null还是false。</p><p></p></li></ul>
                </div>
                <p>
                    When either or both of those conditions do not hold,
                    optimization is more complex.
                </p><p style="color:blue;">当其中一个或两个条件都不成立时，优化就更复杂了。</p><p></p><p>
                Suppose that <em class="replaceable"><code>outer_expr</code></em> is known to
                be a non-<code class="literal">NULL</code> value but the subquery does
                not produce a row such that
                <em class="replaceable"><code>outer_expr</code></em> =
                <em class="replaceable"><code>inner_expr</code></em>. Then
                <code class="literal"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT
                    ...)</code> evaluates as follows:
            </p><p style="color:blue;">假设已知outer_expr是非空值，但子查询不生成这样的行：outer_expr=inner_expr。然后外部表达式in（select…）计算如下：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">NULL</code>, if the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> produces any row
                        where <em class="replaceable"><code>inner_expr</code></em> is
                        <code class="literal">NULL</code>
                    </p><p style="color:blue;">空，如果select生成任何内部表达式为空的行</p><p></p></li><li class="listitem"><p>
                        <code class="literal">FALSE</code>, if the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> produces only
                        non-<code class="literal">NULL</code> values or produces nothing
                    </p><p style="color:blue;">如果select只生成非空值或不生成任何值，则为false</p><p></p></li></ul>
                </div>
                <p>
                    In this situation, the approach of looking for rows with
                    <code class="literal"><em class="replaceable"><code>outer_expr</code></em> =
                        <em class="replaceable"><code>inner_expr</code></em></code> is no longer
                    valid. It is necessary to look for such rows, but if none are
                    found, also look for rows where
                    <em class="replaceable"><code>inner_expr</code></em> is
                    <code class="literal">NULL</code>. Roughly speaking, the subquery can be
                    converted to something like this:
                </p><p style="color:blue;">在这种情况下，查找外部表达式=内部表达式的行的方法不再有效。有必要查找这样的行，但如果没有找到，也可以查找内部表达式为空的行。粗略地说，子查询可以转换为如下内容：</p><p></p><pre data-lang="sql" class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND
        (<em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em> OR <em class="replaceable"><code>inner_expr</code></em> IS NULL))
</pre><p>
                The need to evaluate the extra <a class="link" href="functions.html#operator_is-null"><code class="literal">IS
                NULL</code></a> condition is why MySQL has the
                <a class="link" href="optimization.html#jointype_ref_or_null"><code class="literal">ref_or_null</code></a> access method:
            </p><p style="color:blue;">需要评估额外的is null条件，这就是为什么mysql有ref_或_null访问方法：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN</code></strong>
       <strong class="userinput"><code>SELECT <em class="replaceable"><code>outer_expr</code></em> IN (SELECT t2.maybe_null_key</code></strong>
                             <strong class="userinput"><code>FROM t2, t3 WHERE ...)</code></strong>
       <strong class="userinput"><code>FROM t1;</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: ref_or_null
possible_keys: maybe_null_key
          key: maybe_null_key
      key_len: 5
          ref: func
         rows: 2
        Extra: Using where; Using index
...
</pre><p>
                The <a class="link" href="optimization.html#jointype_unique_subquery"><code class="literal">unique_subquery</code></a> and
                <a class="link" href="optimization.html#jointype_index_subquery"><code class="literal">index_subquery</code></a>
                subquery-specific access methods also have <span class="quote">“<span class="quote">or
          <code class="literal">NULL</code></span>”</span> variants.
            </p><p style="color:blue;">unique_subquery和index_subquery子查询特定的访问方法也有“或空”变量。</p><p></p><p>
                The additional <code class="literal">OR ... IS NULL</code> condition
                makes query execution slightly more complicated (and some
                optimizations within the subquery become inapplicable), but
                generally this is tolerable.
            </p><p style="color:blue;">附加或…is null条件使查询执行稍微复杂一些（子查询中的一些优化变得不适用），但通常这是可以容忍的。</p><p></p><p>
                The situation is much worse when
                <em class="replaceable"><code>outer_expr</code></em> can be
                <code class="literal">NULL</code>. According to the SQL interpretation
                of <code class="literal">NULL</code> as <span class="quote">“<span class="quote">unknown value,</span>”</span>
                <code class="literal">NULL IN (SELECT <em class="replaceable"><code>inner_expr</code></em>
                    ...)</code> should evaluate to:
            </p><p style="color:blue;">当外部表达式可以为空时，情况更糟。根据将null解释为“未知值”的sql解释，null in（选择inner_expr…）的值应为：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">NULL</code>, if the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> produces any rows
                    </p><p style="color:blue;">空，如果select生成任何行</p><p></p></li><li class="listitem"><p>
                        <code class="literal">FALSE</code>, if the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> produces no rows
                    </p><p style="color:blue;">如果select不产生行，则返回false</p><p></p></li></ul>
                </div>
                <p>
                    For proper evaluation, it is necessary to be able to check
                    whether the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> has produced
                    any rows at all, so
                    <code class="literal"><em class="replaceable"><code>outer_expr</code></em> =
                        <em class="replaceable"><code>inner_expr</code></em></code> cannot be
                    pushed down into the subquery. This is a problem because many
                    real world subqueries become very slow unless the equality can
                    be pushed down.
                </p><p style="color:blue;">为了进行正确的计算，必须能够检查select是否生成了任何行，因此不能将outer_expr=inner_expr下推到子查询中。这是一个问题，因为许多真实世界的子查询变得非常慢，除非可以向下推等式。</p><p></p><p>
                Essentially, there must be different ways to execute the
                subquery depending on the value of
                <em class="replaceable"><code>outer_expr</code></em>.
            </p><p style="color:blue;">本质上，根据外部表达式的值，必须有不同的方法来执行子查询。</p><p></p><p>
                The optimizer chooses SQL compliance over speed, so it
                accounts for the possibility that
                <em class="replaceable"><code>outer_expr</code></em> might be
                <code class="literal">NULL</code>:
            </p><p style="color:blue;">优化器选择SQL遵从性而不是速度，因此它考虑了外部表达式可能为空的可能性：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If <em class="replaceable"><code>outer_expr</code></em> is
                        <code class="literal">NULL</code>, to evaluate the following
                        expression, it is necessary to execute the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> to determine whether
                        it produces any rows:
                    </p><p style="color:blue;">如果outer_expr为空，则要计算以下表达式，必须执行select以确定它是否生成任何行：</p><p></p><pre data-lang="sql" class="programlisting">NULL IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
                        It is necessary to execute the original
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> here, without any
                        pushed-down equalities of the kind mentioned previously.
                    </p><p style="color:blue;">必须在这里执行原始select，而不必使用前面提到的那种向下推的等式。</p><p></p></li><li class="listitem"><p>
                        On the other hand, when
                        <em class="replaceable"><code>outer_expr</code></em> is not
                        <code class="literal">NULL</code>, it is absolutely essential that
                        this comparison:
                    </p><p style="color:blue;">另一方面，当outer_expr不为空时，绝对必须进行以下比较：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
                        Be converted to this expression that uses a pushed-down
                        condition:
                    </p><p style="color:blue;">转换为使用下推条件的表达式：</p><p></p><pre data-lang="sql" class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND <em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>)
</pre><p>
                        Without this conversion, subqueries will be slow.
                    </p><p style="color:blue;">没有这种转换，子查询将很慢。</p><p></p></li></ul>
                </div>
                <p>
                    To solve the dilemma of whether or not to push down conditions
                    into the subquery, the conditions are wrapped within
                    <span class="quote">“<span class="quote">trigger</span>”</span> functions. Thus, an expression of the
                    following form:
                </p><p style="color:blue;">为了解决是否将条件下推到子查询中的难题，这些条件被包装在“触发器”函数中。因此，以下形式的表达式：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
                Is converted into:
            </p><p style="color:blue;">转换为：</p><p></p><pre data-lang="sql" class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND trigcond(<em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>))
</pre><p>
                More generally, if the subquery comparison is based on several
                pairs of outer and inner expressions, the conversion takes
                this comparison:
            </p><p style="color:blue;">更一般地，如果子查询比较基于多对外部表达式和内部表达式，则转换采用以下比较：</p><p></p><pre data-lang="sql" class="programlisting">(<em class="replaceable"><code>oe_1</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) IN (SELECT <em class="replaceable"><code>ie_1</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
                And converts it to this expression:
            </p><p style="color:blue;">并将其转换为以下表达式：</p><p></p><pre data-lang="sql" class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND trigcond(<em class="replaceable"><code>oe_1</code></em>=<em class="replaceable"><code>ie_1</code></em>)
                          AND ...
                          AND trigcond(<em class="replaceable"><code>oe_N</code></em>=<em class="replaceable"><code>ie_N</code></em>)
       )
</pre><p>
                Each <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>)</code>
                is a special function that evaluates to the following values:
            </p><p style="color:blue;">每个trigcond（x）是一个特殊函数，其计算结果如下：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <em class="replaceable"><code>X</code></em> when the
                        <span class="quote">“<span class="quote">linked</span>”</span> outer expression
                        <em class="replaceable"><code>oe_i</code></em> is not
                        <code class="literal">NULL</code>
                    </p><p style="color:blue;">当“linked”外部表达式oE_i不为空时</p><p></p></li><li class="listitem"><p>
                        <code class="literal">TRUE</code> when the <span class="quote">“<span class="quote">linked</span>”</span>
                        outer expression <em class="replaceable"><code>oe_i</code></em> is
                        <code class="literal">NULL</code>
                    </p><p style="color:blue;">当“linked”外部表达式oE_i为空时为真</p><p></p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Trigger functions are <span class="emphasis"><em>not</em></span> triggers of
                        the kind that you create with <a class="link" href="sql-syntax.html#create-trigger" title="13.1.20&nbsp;CREATE TRIGGER Syntax"><code class="literal">CREATE
                        TRIGGER</code></a>.
                    </p><p style="color:blue;">触发器函数不是用create trigger创建的那种触发器。</p><p></p>
                </div>
                <p>
                    Equalities that are wrapped within
                    <code class="literal">trigcond()</code> functions are not first class
                    predicates for the query optimizer. Most optimizations cannot
                    deal with predicates that may be turned on and off at query
                    execution time, so they assume any
                    <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>)</code> to
                    be an unknown function and ignore it. Triggered equalities can
                    be used by those optimizations:
                </p><p style="color:blue;">trigcond（）函数中包装的等式不是查询优化器的第一类谓词。大多数优化无法处理查询执行时可能打开和关闭的谓词，因此它们假定任何trigcond（x）都是未知函数，并忽略它。这些优化可以使用触发的均衡：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Reference optimizations:
                        <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>=<em class="replaceable"><code>Y</code></em>
                            [OR <em class="replaceable"><code>Y</code></em> IS NULL])</code> can
                        be used to construct
                        <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a>,
                        <a class="link" href="optimization.html#jointype_eq_ref"><code class="literal">eq_ref</code></a>, or
                        <a class="link" href="optimization.html#jointype_ref_or_null"><code class="literal">ref_or_null</code></a> table
                        accesses.
                    </p><p style="color:blue;">引用优化：trigcond（x=y[或y为空]）可用于构造ref、eq-ref或ref-u或unull表访问。</p><p></p></li><li class="listitem"><p>
                        Index lookup-based subquery execution engines:
                        <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>=<em class="replaceable"><code>Y</code></em>)</code>
                        can be used to construct
                        <a class="link" href="optimization.html#jointype_unique_subquery"><code class="literal">unique_subquery</code></a> or
                        <a class="link" href="optimization.html#jointype_index_subquery"><code class="literal">index_subquery</code></a>
                        accesses.
                    </p><p style="color:blue;">基于索引查找的子查询执行引擎：trigcond（x=y）可用于构造唯一的子查询或索引子查询访问。</p><p></p></li><li class="listitem"><p>
                        Table-condition generator: If the subquery is a join of
                        several tables, the triggered condition is checked as soon
                        as possible.
                    </p><p style="color:blue;">表条件生成器：如果子查询是多个表的联接，则尽快检查触发的条件。</p><p></p></li></ul>
                </div>
                <p>
                    When the optimizer uses a triggered condition to create some
                    kind of index lookup-based access (as for the first two items
                    of the preceding list), it must have a fallback strategy for
                    the case when the condition is turned off. This fallback
                    strategy is always the same: Do a full table scan. In
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output, the fallback
                    shows up as <code class="literal">Full scan on NULL key</code> in the
                    <code class="literal">Extra</code> column:
                </p><p style="color:blue;">当优化器使用触发的条件创建某种基于索引查找的访问时（对于前一个列表的前两个项），当条件关闭时，优化器必须具有针对该情况的回退策略。此回退策略始终相同：执行完整表扫描。在explain output中，备用显示为对额外列中的空键进行完全扫描：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT t1.col1,</code></strong>
       <strong class="userinput"><code>t1.col1 IN (SELECT t2.key1 FROM t2 WHERE t2.col2=t1.col2) FROM t1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
        ...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: index_subquery
possible_keys: key1
          key: key1
      key_len: 5
          ref: func
         rows: 2
        Extra: Using where; Full scan on NULL key
</pre><p>
                If you run <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> followed by
                <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a>, you can see the
                triggered condition:
            </p><p style="color:blue;">如果先运行explain，然后运行show warnings，则可以看到触发的条件：</p><p></p><pre data-lang="none" class="programlisting">*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: select `test`.`t1`.`col1` AS `col1`,
         &lt;in_optimizer&gt;(`test`.`t1`.`col1`,
         &lt;exists&gt;(&lt;index_lookup&gt;(&lt;cache&gt;(`test`.`t1`.`col1`) in t2
         on key1 checking NULL
         where (`test`.`t2`.`col2` = `test`.`t1`.`col2`) having
         trigcond(&lt;is_not_null_test&gt;(`test`.`t2`.`key1`))))) AS
         `t1.col1 IN (select t2.key1 from t2 where t2.col2=t1.col2)`
         from `test`.`t1`
</pre><p>
                The use of triggered conditions has some performance
                implications. A <code class="literal">NULL IN (SELECT ...)</code>
                expression now may cause a full table scan (which is slow)
                when it previously did not. This is the price paid for correct
                results (the goal of the trigger-condition strategy is to
                improve compliance, not speed).
            </p><p style="color:blue;">触发条件的使用对性能有一些影响。空in（select…）表达式现在可能会导致完整表扫描（速度很慢），而以前没有。这是为获得正确结果而付出的代价（触发条件策略的目标是提高遵从性，而不是速度）。</p><p></p><p>
                For multiple-table subqueries, execution of <code class="literal">NULL IN
                (SELECT ...)</code> is particularly slow because the join
                optimizer does not optimize for the case where the outer
                expression is <code class="literal">NULL</code>. It assumes that
                subquery evaluations with <code class="literal">NULL</code> on the left
                side are very rare, even if there are statistics that indicate
                otherwise. On the other hand, if the outer expression might be
                <code class="literal">NULL</code> but never actually is, there is no
                performance penalty.
            </p><p style="color:blue;">对于多个表子查询，在（select…）中执行null的速度特别慢，因为联接优化器不会针对外部表达式为null的情况进行优化。它假设左侧为空的子查询求值非常罕见，即使有统计数据表明不是这样。另一方面，如果外部表达式可能为空，但实际上从未为空，则不存在性能惩罚。</p><p></p><p>
                To help the query optimizer better execute your queries, use
                these suggestions:
            </p><p style="color:blue;">要帮助查询优化器更好地执行查询，请使用以下建议：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Declare a column as <code class="literal">NOT NULL</code> if it
                        really is. This also helps other aspects of the optimizer
                        by simplifying condition testing for the column.
                    </p><p style="color:blue;">如果列真的为空，则将其声明为不为空。这还通过简化列的条件测试来帮助优化器的其他方面。</p><p></p></li><li class="listitem"><p>
                        If you need not distinguish a <code class="literal">NULL</code> from
                        <code class="literal">FALSE</code> subquery result, you can easily
                        avoid the slow execution path. Replace a comparison that
                        looks like this:
                    </p><p style="color:blue;">如果不需要区分空子查询结果和假子查询结果，则可以轻松避免执行路径缓慢。替换如下所示的比较：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...)
</pre><p>
                        with this expression:
                    </p><p style="color:blue;">用这个表达式：</p><p></p><pre data-lang="sql" class="programlisting">(<em class="replaceable"><code>outer_expr</code></em> IS NOT NULL) AND (<em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...))
</pre><p>
                        Then <code class="literal">NULL IN (SELECT ...)</code> is never
                        evaluated because MySQL stops evaluating
                        <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a> parts as soon as the
                        expression result is clear.
                    </p><p style="color:blue;">然后从不计算（select…）中的null，因为mysql会停止计算，并在表达式结果清除后立即分离。</p><p></p><p>
                        Another possible rewrite:
                    </p><p style="color:blue;">另一个可能的重写：</p><p></p><pre data-lang="sql" class="programlisting">EXISTS (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...
        WHERE <em class="replaceable"><code>inner_expr</code></em>=<em class="replaceable"><code>outer_expr</code></em>)
</pre><p>
                        This would apply when you need not distinguish
                        <code class="literal">NULL</code> from <code class="literal">FALSE</code>
                        subquery results, in which case you may actually want
                        <code class="literal">EXISTS</code>.
                    </p><p style="color:blue;">当您不需要区分空和假子查询结果时，这将适用，在这种情况下，您可能实际上希望存在空子查询结果。</p><p></p></li></ul>
                </div>
                <p>
                    The <code class="literal">subquery_materialization_cost_based</code>
                    flag of the <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a>
                    system variable enables control over the choice between
                    subquery materialization and
                    <code class="literal">IN</code>-to-<code class="literal">EXISTS</code> subquery
                    transformation. See
                    <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>.
                </p><p style="color:blue;">优化器开关系统变量的基于子查询物化和基于成本的标志可以控制子查询物化和in到现有子查询转换之间的选择。见第8.9.2节“可切换优化”。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="derived-table-optimization"></a>8.2.2.4&nbsp;Optimizing Derived Tables and View References with Merging or
                                Materialization</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286874113696"></a><a class="indexterm" name="idm140286874112208"></a><a class="indexterm" name="idm140286874110720"></a><a class="indexterm" name="idm140286874109232"></a><a class="indexterm" name="idm140286874107744"></a><a class="indexterm" name="idm140286874106256"></a><p>
                The optimizer can handle derived table references using two
                strategies (which also apply to view references):
            </p><p style="color:blue;">优化器可以使用两种策略（也适用于视图引用）处理派生表引用：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Merge the derived table into the outer query block
                    </p><p style="color:blue;">将派生表合并到外部查询块中</p><p></p></li><li class="listitem"><p>
                        Materialize the derived table to an internal temporary
                        table
                    </p><p style="color:blue;">将派生表具体化为内部临时表</p><p></p></li></ul>
                </div>
                <p>
                    Example 1:
                </p><p style="color:blue;">例1：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM (SELECT * FROM t1) AS derived_t1;
</pre><p>
                With merging of the derived table
                <code class="literal">derived_t1</code>, that query is executed similar
                to:
            </p><p style="color:blue;">合并派生表derived_T1时，执行该查询的方式类似于：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1;
</pre><p>
                Example 2:
            </p><p style="color:blue;">例2：</p><p></p><pre data-lang="sql" class="programlisting">SELECT *
  FROM t1 JOIN (SELECT t2.f1 FROM t2) AS derived_t2 ON t1.f2=derived_t2.f1
  WHERE t1.f1 &gt; 0;
</pre><p>
                With merging of the derived table
                <code class="literal">derived_t2</code>, that query is executed similar
                to:
            </p><p style="color:blue;">合并派生表derived_t2时，执行该查询的方式类似于：</p><p></p><pre data-lang="sql" class="programlisting">SELECT t1.*, t2.f1
  FROM t1 JOIN t2 ON t1.f2=t2.f1
  WHERE t1.f1 &gt; 0;
</pre><p>
                With materialization, <code class="literal">derived_t1</code> and
                <code class="literal">derived_t2</code> are each treated as a separate
                table within their respective queries.
            </p><p style="color:blue;">通过物化，派生的T1和派生的T2在各自的查询中都被视为单独的表。</p><p></p><p>
                The optimizer handles derived tables and view references the
                same way: It avoids unnecessary materialization whenever
                possible, which enables pushing down conditions from the outer
                query to derived tables and produces more efficient execution
                plans. (For an example, see
                <a class="xref" href="optimization.html#subquery-materialization" title="8.2.2.2&nbsp;Optimizing Subqueries with Materialization">Section&nbsp;8.2.2.2, “Optimizing Subqueries with Materialization”</a>.)
            </p><p style="color:blue;">优化器处理派生表和视图引用的方式相同：它尽可能避免不必要的物化，这使得可以将条件从外部查询下推到派生表，并生成更高效的执行计划。（例如，请参见第8.2.2.2节“使用物化优化子查询”。）</p><p></p><p>
                If merging would result in an outer query block that
                references more than 61 base tables, the optimizer chooses
                materialization instead.
            </p><p style="color:blue;">如果合并将导致外部查询块引用超过61个基表，优化器将选择物化。</p><p></p><p>
                The optimizer propagates an <code class="literal">ORDER BY</code> clause
                in a derived table or view reference to the outer query block
                if these conditions are all true:
            </p><p style="color:blue;">如果这些条件都为真，优化器将派生表或视图引用中的ORDER BY子句传播到外部查询块：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The outer query is not grouped or aggregated.
                    </p><p style="color:blue;">外部查询未分组或聚合。</p><p></p></li><li class="listitem"><p>
                        The outer query does not specify
                        <code class="literal">DISTINCT</code>, <code class="literal">HAVING</code>, or
                        <code class="literal">ORDER BY</code>.
                    </p><p style="color:blue;">外部查询未指定DISTINCT、HAVING或ORDERBY。</p><p></p></li><li class="listitem"><p>
                        The outer query has this derived table or view reference
                        as the only source in the <code class="literal">FROM</code> clause.
                    </p><p style="color:blue;">外部查询将此派生表或视图引用作为from子句中的唯一源。</p><p></p></li></ul>
                </div>
                <p>
                    Otherwise, the optimizer ignores the <code class="literal">ORDER
                    BY</code> clause.
                </p><p style="color:blue;">否则，优化器将忽略ORDERBY子句。</p><p></p><p>
                The following means are available to influence whether the
                optimizer attempts to merge derived tables and view references
                into the outer query block:
            </p><p style="color:blue;">以下方法可用于影响优化器是否尝试将派生表和视图引用合并到外部查询块中：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <code class="literal">derived_merge</code> flag of the
                        <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                        variable can be used, assuming that no other rule prevents
                        merging. See <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>.
                        By default, the flag is enabled to permit merging.
                        Disabling the flag prevents merging and avoids
                        <a class="link" href="error-handling.html#error_er_update_table_used"><code class="literal">ER_UPDATE_TABLE_USED</code></a>
                        errors.
                    </p><p style="color:blue;">如果没有其他规则阻止合并，则可以使用优化器开关系统变量的派生合并标志。见第8.9.2节“可切换优化”。默认情况下，启用标志以允许合并。禁用该标志可防止合并并避免使用er_update_table_used错误。</p><p></p><p>
                        The <code class="literal">derived_merge</code> flag also applies to
                        views that contain no <code class="literal">ALGORITHM</code> clause.
                        Thus, if an
                        <a class="link" href="error-handling.html#error_er_update_table_used"><code class="literal">ER_UPDATE_TABLE_USED</code></a> error
                        occurs for a view reference that uses an expression
                        equivalent to the subquery, adding
                        <code class="literal">ALGORITHM=TEMPTABLE</code> to the view
                        definition prevents merging and takes precedence over the
                        <code class="literal">derived_merge</code> value.
                    </p><p style="color:blue;">派生的合并标志也适用于不包含算法子句的视图。因此，如果对使用与子查询等效的表达式的视图引用发生er_update_table_used错误，则向视图定义添加algorithm=t将阻止合并并优先于派生的_merge值。</p><p></p></li><li class="listitem"><p>
                        It is possible to disable merging by using in the subquery
                        any constructs that prevent merging, although these are
                        not as explicit in their effect on materialization.
                        Constructs that prevent merging are the same for derived
                        tables and view references:
                    </p><p style="color:blue;">可以通过在子查询中使用任何阻止合并的构造来禁用合并，尽管这些构造对物化的影响并没有那么明显。对于派生表和视图引用，防止合并的构造是相同的：</p><p></p>
                        <div class="itemizedlist">
                            <a class="indexterm" name="idm140286874070608"></a><a class="indexterm" name="idm140286874069152"></a><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Aggregate functions
                            (<a class="link" href="functions.html#function_sum"><code class="literal">SUM()</code></a>,
                            <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a>,
                            <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a>,
                            <a class="link" href="functions.html#function_count"><code class="literal">COUNT()</code></a>, and so forth)
                        </p><p style="color:blue;">聚合函数（sum（）、min（）、max（）、count（）等等）</p><p></p></li><li class="listitem"><p>
                            <code class="literal">DISTINCT</code>
                        </p><p style="color:blue;">明显的</p><p></p></li><li class="listitem"><p>
                            <code class="literal">GROUP BY</code>
                        </p><p style="color:blue;">分组依据</p><p></p></li><li class="listitem"><p>
                            <code class="literal">HAVING</code>
                        </p><p style="color:blue;">有</p><p></p></li><li class="listitem"><p>
                            <code class="literal">LIMIT</code>
                        </p><p style="color:blue;">限制</p><p></p></li><li class="listitem"><p>
                            <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> or
                            <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION
                                ALL</code></a>
                        </p><p style="color:blue;">联合或全部联合</p><p></p></li><li class="listitem"><p>
                            Subqueries in the select list
                        </p><p style="color:blue;">选择列表中的子查询</p><p></p></li><li class="listitem"><p>
                            Assignments to user variables
                        </p><p style="color:blue;">分配给用户变量</p><p></p></li><li class="listitem"><p>
                            Refererences only to literal values (in this case,
                            there is no underlying table)
                        </p><p style="color:blue;">只引用文本值（在本例中，没有基础表）</p><p></p></li></ul>
                        </div>
                    </li></ul>
                </div>
                <p>
                    The <code class="literal">derived_merge</code> flag also applies to
                    views that contain no <code class="literal">ALGORITHM</code> clause.
                    Thus, if an
                    <a class="link" href="error-handling.html#error_er_update_table_used"><code class="literal">ER_UPDATE_TABLE_USED</code></a> error
                    occurs for a view reference that uses an expression equivalent
                    to the subquery, adding <code class="literal">ALGORITHM=TEMPTABLE</code>
                    to the view definition prevents merging and takes precedence
                    over the current <code class="literal">derived_merge</code> value.
                </p><p style="color:blue;">派生的合并标志也适用于不包含算法子句的视图。因此，如果对使用与子查询等效的表达式的视图引用发生er_update_table_used错误，则向视图定义添加algorithm=tuntable将阻止合并并优先于当前派生的_merge值。</p><p></p><p>
                If the optimizer chooses the materialization strategy rather
                than merging for a derived table, it handles the query as
                follows:
            </p><p style="color:blue;">如果优化器为派生表选择物化策略而不是合并，它将按如下方式处理查询：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The optimizer postpones derived table materialization
                        until its contents are needed during query execution. This
                        improves performance because delaying materialization may
                        result in not having to do it at all. Consider a query
                        that joins the result of a derived table to another table:
                        If the optimizer processes that other table first and
                        finds that it returns no rows, the join need not be
                        carried out further and the optimizer can completely skip
                        materializing the derived table.
                    </p><p style="color:blue;">优化器推迟派生表的具体化，直到查询执行期间需要其内容为止。这提高了性能，因为延迟物化可能会导致根本不必这样做。考虑一个将派生表的结果联接到另一个表的查询：如果优化器首先处理该另一个表，发现它没有返回行，则不需要进一步执行联接，优化器可以完全跳过派生表的具体化。</p><p></p></li><li class="listitem"><p>
                        During query execution, the optimizer may add an index to
                        a derived table to speed up row retrieval from it.
                    </p><p style="color:blue;">在查询执行期间，优化器可以向派生表添加索引，以加快从派生表检索行的速度。</p><p></p></li></ul>
                </div>
                <p>
                    Consider the following <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>
                    statement, for a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> query
                    that contains a derived table:
                </p><p style="color:blue;">对于包含派生表的select查询，请考虑以下explain语句：</p><p></p><pre data-lang="sql" class="programlisting">EXPLAIN SELECT * FROM (SELECT * FROM t1) AS derived_t1;
</pre><p>
                The optimizer avoids materializing the derived table by
                delaying it until the result is needed during
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> execution. In this case,
                the query is not executed (because it occurs in an
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement), so the
                result is never needed.
            </p><p style="color:blue;">优化器通过延迟派生表直到在select执行期间需要结果，从而避免将其具体化。在这种情况下，查询不会执行（因为它出现在explain语句中），因此永远不需要结果。</p><p></p><p>
                Even for queries that are executed, delay of derived table
                materialization may enable the optimizer to avoid
                materialization entirely. When this happens, query execution
                is quicker by the time needed to perform materialization.
                Consider the following query, which joins the result of a
                derived table to another table:
            </p><p style="color:blue;">即使对于执行的查询，派生表物化的延迟也可能使优化器能够完全避免物化。当这种情况发生时，查询执行会在执行物化所需的时间内更快。考虑以下查询，它将派生表的结果连接到另一个表：</p><p></p><pre data-lang="sql" class="programlisting">SELECT *
  FROM t1 JOIN (SELECT t2.f1 FROM t2) AS derived_t2
          ON t1.f2=derived_t2.f1
  WHERE t1.f1 &gt; 0;
</pre><p>
                If the optimization processes <code class="literal">t1</code> first and
                the <code class="literal">WHERE</code> clause produces an empty result,
                the join must necessarily be empty and the derived table need
                not be materialized.
            </p><p style="color:blue;">如果优化首先处理T1，并且WHERE子句产生空结果，则联接必须为空，并且不必具体化派生表。</p><p></p><p>
                For cases when a derived table requires materialization, the
                optimizer may add an index to the materialized table to speed
                up access to it. If such an index enables
                <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> access to the table, it
                can greatly reduce amount of data read during query execution.
                Consider the following query:
            </p><p style="color:blue;">对于派生表需要物化的情况，优化器可以向物化表添加索引以加快对它的访问。如果这样的索引允许对表的ref访问，那么它可以大大减少查询执行期间读取的数据量。请考虑以下查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT *
 FROM t1 JOIN (SELECT DISTINCT f1 FROM t2) AS derived_t2
         ON t1.f1=derived_t2.f1;
</pre><p>
                The optimizer constructs an index over column
                <code class="literal">f1</code> from <code class="literal">derived_t2</code> if
                doing so would enable use of
                <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> access for the lowest
                cost execution plan. After adding the index, the optimizer can
                treat the materialized derived table the same as a regular
                table with an index, and it benefits similarly from the
                generated index. The overhead of index creation is negligible
                compared to the cost of query execution without the index. If
                <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> access would result in
                higher cost than some other access method, the optimizer
                creates no index and loses nothing.
            </p><p style="color:blue;">优化器从派生的T2构造列F1上的索引，如果这样做将启用对最低成本执行计划的ref访问。添加索引后，优化器可以将物化派生表视为具有索引的常规表，并且它从生成的索引中获得类似的好处。与没有索引的查询执行成本相比，创建索引的开销可以忽略不计。如果ref访问将导致比其他访问方法更高的成本，优化器将不会创建索引，也不会丢失任何内容。</p><p></p><p>
                For optimizer trace output, a merged derived table or view
                reference is not shown as a node. Only its underlying tables
                appear in the top query's plan.
            </p><p style="color:blue;">对于优化器跟踪输出，合并的派生表或视图引用不显示为节点。顶部查询的计划中只显示其基础表。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="information-schema-optimization"></a>8.2.3&nbsp;Optimizing INFORMATION_SCHEMA Queries</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286874020928"></a><a class="indexterm" name="idm140286874019424"></a><p>
            Applications that monitor databases may make frequent use of
            <code class="literal">INFORMATION_SCHEMA</code> tables. Certain types of
            queries for <code class="literal">INFORMATION_SCHEMA</code> tables can be
            optimized to execute more quickly. The goal is to minimize file
            operations (for example, scanning a directory or opening a table
            file) to collect the information that makes up these dynamic
            tables.
        </p><p style="color:blue;">监视数据库的应用程序可能经常使用信息架构表。某些类型的信息模式表查询可以优化以更快地执行。目标是最小化文件操作（例如，扫描目录或打开表文件），以收集构成这些动态表的信息。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Comparison behavior for database and table names in
                    <code class="literal">INFORMATION_SCHEMA</code> queries might differ
                    from what you expect. For details, see
                    <a class="xref" href="charset.html#charset-collation-information-schema" title="10.8.7&nbsp;Using Collation in INFORMATION_SCHEMA Searches">Section&nbsp;10.8.7, “Using Collation in INFORMATION_SCHEMA Searches”</a>.
                </p><p style="color:blue;">信息架构查询中数据库和表名的比较行为可能与预期的不同。有关详细信息，请参见第10.8.7节“在信息模式搜索中使用排序规则”。</p><p></p>
            </div>
            <p>
        <span class="bold"><strong>1) Try to use constant lookup values for
        database and table names in the <code class="literal">WHERE</code>
        clause</strong></span>
            </p><p style="color:blue;">1）尝试在where子句中对数据库和表名使用常量查找值</p><p></p><p>
            You can take advantage of this principle as follows:
        </p><p style="color:blue;">您可以利用以下原则：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To look up databases or tables, use expressions that
                    evaluate to a constant, such as literal values, functions
                    that return a constant, or scalar subqueries.
                </p><p style="color:blue;">要查找数据库或表，请使用计算为常量的表达式，例如文字值、返回常量的函数或标量子查询。</p><p></p></li><li class="listitem"><p>
                    Avoid queries that use a nonconstant database name lookup
                    value (or no lookup value) because they require a scan of
                    the data directory to find matching database directory
                    names.
                </p><p style="color:blue;">避免使用非常量数据库名称查找值（或不使用查找值）的查询，因为它们需要扫描数据目录才能找到匹配的数据库目录名称。</p><p></p></li><li class="listitem"><p>
                    Within a database, avoid queries that use a nonconstant
                    table name lookup value (or no lookup value) because they
                    require a scan of the database directory to find matching
                    table files.
                </p><p style="color:blue;">在数据库中，避免使用非常量表名查找值（或不使用查找值）的查询，因为它们需要扫描数据库目录才能找到匹配的表文件。</p><p></p></li></ul>
            </div>
            <p>
                This principle applies to the
                <code class="literal">INFORMATION_SCHEMA</code> tables shown in the
                following table, which shows the columns for which a constant
                lookup value enables the server to avoid a directory scan. For
                example, if you are selecting from
                <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">TABLES</code></a>, using a constant lookup
                value for <code class="literal">TABLE_SCHEMA</code> in the
                <code class="literal">WHERE</code> clause enables a data directory scan to
                be avoided.
            </p><p style="color:blue;">此原则适用于下表中所示的信息架构表，该表显示了使用常量查找值使服务器能够避免目录扫描的列。例如，如果要从表中进行选择，则在where子句中使用表模式的常量查找值可以避免数据目录扫描。</p><p></p>
            <div class="informaltable">
                <table summary="INFORMATION_SCHEMA tables and table columns for which a constant lookup value enables the server to avoid directory scans."><colgroup><col width="34%"><col width="33%"><col width="33%"></colgroup><thead><tr>
                    <th scope="col">Table</th>
                    <th scope="col">Column to specify to avoid data directory scan</th>
                    <th scope="col">Column to specify to avoid database directory scan</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><a class="link" href="information-schema.html#columns-table" title="24.5&nbsp;The INFORMATION_SCHEMA COLUMNS Table"><code class="literal">COLUMNS</code></a></td>
                    <td><code class="literal">TABLE_SCHEMA</code></td>
                    <td><code class="literal">TABLE_NAME</code></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="information-schema.html#key-column-usage-table" title="24.12&nbsp;The INFORMATION_SCHEMA KEY_COLUMN_USAGE Table"><code class="literal">KEY_COLUMN_USAGE</code></a></td>
                    <td><code class="literal">TABLE_SCHEMA</code></td>
                    <td><code class="literal">TABLE_NAME</code></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="information-schema.html#partitions-table" title="24.16&nbsp;The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">PARTITIONS</code></a></td>
                    <td><code class="literal">TABLE_SCHEMA</code></td>
                    <td><code class="literal">TABLE_NAME</code></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="information-schema.html#referential-constraints-table" title="24.20&nbsp;The INFORMATION_SCHEMA REFERENTIAL_CONSTRAINTS Table"><code class="literal">REFERENTIAL_CONSTRAINTS</code></a></td>
                    <td><code class="literal">CONSTRAINT_SCHEMA</code></td>
                    <td><code class="literal">TABLE_NAME</code></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="information-schema.html#statistics-table" title="24.24&nbsp;The INFORMATION_SCHEMA STATISTICS Table"><code class="literal">STATISTICS</code></a></td>
                    <td><code class="literal">TABLE_SCHEMA</code></td>
                    <td><code class="literal">TABLE_NAME</code></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">TABLES</code></a></td>
                    <td><code class="literal">TABLE_SCHEMA</code></td>
                    <td><code class="literal">TABLE_NAME</code></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="information-schema.html#table-constraints-table" title="24.27&nbsp;The INFORMATION_SCHEMA TABLE_CONSTRAINTS Table"><code class="literal">TABLE_CONSTRAINTS</code></a></td>
                    <td><code class="literal">TABLE_SCHEMA</code></td>
                    <td><code class="literal">TABLE_NAME</code></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="information-schema.html#triggers-table" title="24.29&nbsp;The INFORMATION_SCHEMA TRIGGERS Table"><code class="literal">TRIGGERS</code></a></td>
                    <td><code class="literal">EVENT_OBJECT_SCHEMA</code></td>
                    <td><code class="literal">EVENT_OBJECT_TABLE</code></td>
                </tr><tr>
                    <td scope="row"><a class="link" href="information-schema.html#views-table" title="24.31&nbsp;The INFORMATION_SCHEMA VIEWS Table"><code class="literal">VIEWS</code></a></td>
                    <td><code class="literal">TABLE_SCHEMA</code></td>
                    <td><code class="literal">TABLE_NAME</code></td>
                </tr></tbody></table>
            </div>
            <p>
                The benefit of a query that is limited to a specific constant
                database name is that checks need be made only for the named
                database directory. Example:
            </p><p style="color:blue;">仅限于特定常量数据库名称的查询的好处是，只需要对指定的数据库目录进行检查。例子：</p><p></p><pre data-lang="sql" class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test';
</pre><p>
            Use of the literal database name <code class="literal">test</code> enables
            the server to check only the <code class="literal">test</code> database
            directory, regardless of how many databases there might be. By
            contrast, the following query is less efficient because it
            requires a scan of the data directory to determine which
            database names match the pattern <code class="literal">'test%'</code>:
        </p><p style="color:blue;">使用文字数据库名称测试使服务器能够只检查测试数据库目录，而不管可能有多少数据库。相比之下，以下查询效率较低，因为它需要扫描数据目录以确定哪些数据库名称与模式“test%”匹配：</p><p></p><pre data-lang="sql" class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA LIKE 'test%';
</pre><p>
            For a query that is limited to a specific constant table name,
            checks need be made only for the named table within the
            corresponding database directory. Example:
        </p><p style="color:blue;">对于限制为特定常量表名的查询，只需要对相应数据库目录中的命名表进行检查。例子：</p><p></p><pre data-lang="sql" class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 't1';
</pre><p>
            Use of the literal table name <code class="literal">t1</code> enables the
            server to check only the files for the <code class="literal">t1</code>
            table, regardless of how many tables there might be in the
            <code class="literal">test</code> database. By contrast, the following
            query requires a scan of the <code class="literal">test</code> database
            directory to determine which table names match the pattern
            <code class="literal">'t%'</code>:
        </p><p style="color:blue;">使用文本表名T1使服务器能够只检查T1表的文件，而不管测试数据库中可能有多少表。相反，以下查询需要扫描测试数据库目录以确定哪些表名与模式“t%”匹配：</p><p></p><pre data-lang="sql" class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME LIKE 't%';
</pre><p>
            The following query requires a scan of the database directory to
            determine matching database names for the pattern
            <code class="literal">'test%'</code>, and for each matching database, it
            requires a scan of the database directory to determine matching
            table names for the pattern <code class="literal">'t%'</code>:
        </p><p style="color:blue;">以下查询需要扫描数据库目录以确定模式“test%”的匹配数据库名称，而对于每个匹配的数据库，则需要扫描数据库目录以确定模式“t%”的匹配表名称：</p><p></p><pre data-lang="sql" class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test%' AND TABLE_NAME LIKE 't%';
</pre><p>
        <span class="bold"><strong>2) Write queries that minimize the number
        of table files that must be opened</strong></span>
        </p><p style="color:blue;">2）编写查询以最小化必须打开的表文件的数量</p><p></p><p>
            For queries that refer to certain
            <code class="literal">INFORMATION_SCHEMA</code> table columns, several
            optimizations are available that minimize the number of table
            files that must be opened. Example:
        </p><p style="color:blue;">对于引用某些信息架构表列的查询，可以使用一些优化来最小化必须打开的表文件的数量。例子：</p><p></p><pre data-lang="sql" class="programlisting">SELECT TABLE_NAME, ENGINE FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test';
</pre><p>
            In this case, after the server has scanned the database
            directory to determine the names of the tables in the database,
            those names become available with no further file system
            lookups. Thus, <code class="literal">TABLE_NAME</code> requires no files
            to be opened. The <code class="literal">ENGINE</code> (storage engine)
            value can be determined by opening the table's
            <code class="filename">.frm</code> file, without touching other table
            files such as the <code class="filename">.MYD</code> or
            <code class="filename">.MYI</code> file.
        </p><p style="color:blue;">在这种情况下，在服务器扫描数据库目录以确定数据库中表的名称之后，这些名称就不再需要进一步的文件系统查找了。因此，表名不需要打开任何文件。可以通过打开表的.frm文件来确定引擎（存储引擎）值，而不必接触其他表文件，如.myd或.myi文件。</p><p></p><p>
            Some values, such as <code class="literal">INDEX_LENGTH</code> for
            <code class="literal">MyISAM</code> tables, require opening the
            <code class="filename">.MYD</code> or <code class="filename">.MYI</code> file as
            well.
        </p><p style="color:blue;">某些值（例如myisam表的index_length）也需要打开.myd或.myi文件。</p><p></p><p>
            The file-opening optimization types are denoted thus:
        </p><p style="color:blue;">文件打开优化类型如下所示：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">SKIP_OPEN_TABLE</code>: Table files do not need
                    to be opened. The information has already become available
                    within the query by scanning the database directory.
                </p><p style="color:blue;">skip_open_table：不需要打开表文件。通过扫描数据库目录，该信息已在查询中可用。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">OPEN_FRM_ONLY</code>: Only the table's
                    <code class="filename">.frm</code> file need be opened.
                </p><p style="color:blue;">open_frm_only：只需要打开表的.frm文件。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">OPEN_TRIGGER_ONLY</code>: Only the table's
                    <code class="filename">.TRG</code> file need be opened.
                </p><p style="color:blue;">仅打开触发器：只需要打开表的.trg文件。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">OPEN_FULL_TABLE</code>: The unoptimized
                    information lookup. The <code class="filename">.frm</code>,
                    <code class="filename">.MYD</code>, and <code class="filename">.MYI</code>
                    files must be opened.
                </p><p style="color:blue;">打开完整表：未优化的信息查找。必须打开.frm、.myd和.myi文件。</p><p></p></li></ul>
            </div>
            <a class="indexterm" name="idm140286873912624"></a><a class="indexterm" name="idm140286873911120"></a><p>
            The following list indicates how the preceding optimization
            types apply to <code class="literal">INFORMATION_SCHEMA</code> table
            columns. For tables and columns not named, none of the
            optimizations apply.
        </p><p style="color:blue;">下表说明了上述优化类型如何应用于信息架构表列。对于未命名的表和列，不应用任何优化。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="information-schema.html#columns-table" title="24.5&nbsp;The INFORMATION_SCHEMA COLUMNS Table"><code class="literal">COLUMNS</code></a>:
                    <code class="literal">OPEN_FRM_ONLY</code> applies to all columns
                </p><p style="color:blue;">列：open_frm_仅适用于所有列</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#key-column-usage-table" title="24.12&nbsp;The INFORMATION_SCHEMA KEY_COLUMN_USAGE Table"><code class="literal">KEY_COLUMN_USAGE</code></a>:
                    <code class="literal">OPEN_FULL_TABLE</code> applies to all columns
                </p><p style="color:blue;">key_column_用法：open_full_表适用于所有列</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#partitions-table" title="24.16&nbsp;The INFORMATION_SCHEMA PARTITIONS Table"><code class="literal">PARTITIONS</code></a>:
                    <code class="literal">OPEN_FULL_TABLE</code> applies to all columns
                </p><p style="color:blue;">分区：OpenJulfFixTabl适用于所有列</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#referential-constraints-table" title="24.20&nbsp;The INFORMATION_SCHEMA REFERENTIAL_CONSTRAINTS Table"><code class="literal">REFERENTIAL_CONSTRAINTS</code></a>:
                    <code class="literal">OPEN_FULL_TABLE</code> applies to all columns
                </p><p style="color:blue;">引用限制：open_full_表适用于所有列</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#statistics-table" title="24.24&nbsp;The INFORMATION_SCHEMA STATISTICS Table"><code class="literal">STATISTICS</code></a>:
                </p><p style="color:blue;">统计：</p><p></p>
                    <div class="informaltable">
                        <table summary="Optimization types that apply to INFORMATION_SCHEMA STATISTICS table columns."><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Optimization type</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">TABLE_CATALOG</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_SCHEMA</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_NAME</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">NON_UNIQUE</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">INDEX_SCHEMA</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">INDEX_NAME</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SEQ_IN_INDEX</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">COLUMN_NAME</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">COLLATION</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">CARDINALITY</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SUB_PART</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">PACKED</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">NULLABLE</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">INDEX_TYPE</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">COMMENT</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr></tbody></table>
                    </div>
                </li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#tables-table" title="24.25&nbsp;The INFORMATION_SCHEMA TABLES Table"><code class="literal">TABLES</code></a>:
                </p><p style="color:blue;">桌子：</p><p></p>
                    <div class="informaltable">
                        <table summary="Optimization types that apply to INFORMATION_SCHEMA TABLES table columns."><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Optimization type</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">TABLE_CATALOG</code></td>
                            <td><code class="literal">SKIP_OPEN_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_SCHEMA</code></td>
                            <td><code class="literal">SKIP_OPEN_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_NAME</code></td>
                            <td><code class="literal">SKIP_OPEN_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_TYPE</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ENGINE</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">VERSION</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">ROW_FORMAT</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_ROWS</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">AVG_ROW_LENGTH</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">DATA_LENGTH</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">MAX_DATA_LENGTH</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">INDEX_LENGTH</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">DATA_FREE</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">AUTO_INCREMENT</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">CREATE_TIME</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">UPDATE_TIME</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">CHECK_TIME</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_COLLATION</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">CHECKSUM</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">CREATE_OPTIONS</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_COMMENT</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr></tbody></table>
                    </div>
                </li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#table-constraints-table" title="24.27&nbsp;The INFORMATION_SCHEMA TABLE_CONSTRAINTS Table"><code class="literal">TABLE_CONSTRAINTS</code></a>:
                    <code class="literal">OPEN_FULL_TABLE</code> applies to all columns
                </p><p style="color:blue;">table_约束：open_full_table应用于所有列</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#triggers-table" title="24.29&nbsp;The INFORMATION_SCHEMA TRIGGERS Table"><code class="literal">TRIGGERS</code></a>:
                    <code class="literal">OPEN_TRIGGER_ONLY</code> applies to all columns
                </p><p style="color:blue;">触发器：打开触发器仅适用于所有列</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="information-schema.html#views-table" title="24.31&nbsp;The INFORMATION_SCHEMA VIEWS Table"><code class="literal">VIEWS</code></a>:
                </p><p style="color:blue;">意见：</p><p></p>
                    <div class="informaltable">
                        <table summary="Optimization types that apply to INFORMATION_SCHEMA VIEWS table columns."><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">Optimization type</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><code class="literal">TABLE_CATALOG</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_SCHEMA</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">TABLE_NAME</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">VIEW_DEFINITION</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">CHECK_OPTION</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">IS_UPDATABLE</code></td>
                            <td><code class="literal">OPEN_FULL_TABLE</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">DEFINER</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">SECURITY_TYPE</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">CHARACTER_SET_CLIENT</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr><tr>
                            <td scope="row"><code class="literal">COLLATION_CONNECTION</code></td>
                            <td><code class="literal">OPEN_FRM_ONLY</code></td>
                        </tr></tbody></table>
                    </div>
                </li></ul>
            </div>
            <p>
        <span class="bold"><strong>3) Use
        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to determine whether the
        server can use <code class="literal">INFORMATION_SCHEMA</code>
        optimizations for a query</strong></span>
            </p><p style="color:blue;">3）使用explain确定服务器是否可以对查询使用信息架构优化</p><p></p><p>
            This applies particularly for
            <code class="literal">INFORMATION_SCHEMA</code> queries that search for
            information from more than one database, which might take a long
            time and impact performance. The <code class="literal">Extra</code> value
            in <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output indicates
            which, if any, of the optimizations described earlier the server
            can use to evaluate <code class="literal">INFORMATION_SCHEMA</code>
            queries. The following examples demonstrate the kinds of
            information you can expect to see in the
            <code class="literal">Extra</code> value.
        </p><p style="color:blue;">这尤其适用于从多个数据库中搜索信息的信息架构查询，这可能需要很长时间并影响性能。explain output中的额外值指示服务器可以使用前面描述的任何优化来评估信息架构查询。下面的示例演示了您可以在附加值中看到的信息类型。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS WHERE</code></strong>
       <strong class="userinput"><code>TABLE_SCHEMA = 'test' AND TABLE_NAME = 'v1'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: VIEWS
         type: ALL
possible_keys: NULL
          key: TABLE_SCHEMA,TABLE_NAME
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Open_frm_only; Scanned 0 databases
</pre><p>
            Use of constant database and table lookup values enables the
            server to avoid directory scans. For references to
            <code class="literal">VIEWS.TABLE_NAME</code>, only the
            <code class="filename">.frm</code> file need be opened.
        </p><p style="color:blue;">使用常量数据库和表查找值可以使服务器避免目录扫描。对于views.table_name的引用，只需要打开.frm文件。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT TABLE_NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.TABLES\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: TABLES
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Open_full_table; Scanned all databases
</pre><p>
            No lookup values are provided (there is no
            <code class="literal">WHERE</code> clause), so the server must scan the
            data directory and each database directory. For each table thus
            identified, the table name and row format are selected.
            <code class="literal">TABLE_NAME</code> requires no further table files to
            be opened (the <code class="literal">SKIP_OPEN_TABLE</code> optimization
            applies). <code class="literal">ROW_FORMAT</code> requires all table files
            to be opened (<code class="literal">OPEN_FULL_TABLE</code> applies).
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> reports
            <code class="literal">OPEN_FULL_TABLE</code> because it is more expensive
            than <code class="literal">SKIP_OPEN_TABLE</code>.
        </p><p style="color:blue;">没有提供查找值（没有where子句），因此服务器必须扫描数据目录和每个数据库目录。对于这样标识的每个表，选择表名和行格式。table_name不需要打开更多的表文件（应用skip_open_table优化）。row_格式要求打开所有表文件（open_full_table适用）。解释打开完整表的报告，因为它比跳过打开表更贵。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT TABLE_NAME, TABLE_TYPE FROM INFORMATION_SCHEMA.TABLES</code></strong>
       <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'test'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: TABLES
         type: ALL
possible_keys: NULL
          key: TABLE_SCHEMA
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Open_frm_only; Scanned 1 database
</pre><p>
            No table name lookup value is provided, so the server must scan
            the <code class="literal">test</code> database directory. For the
            <code class="literal">TABLE_NAME</code> and <code class="literal">TABLE_TYPE</code>
            columns, the <code class="literal">SKIP_OPEN_TABLE</code> and
            <code class="literal">OPEN_FRM_ONLY</code> optimizations apply,
            respectively. <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> reports
            <code class="literal">OPEN_FRM_ONLY</code> because it is more expensive.
        </p><p style="color:blue;">未提供表名查找值，因此服务器必须扫描测试数据库目录。对于table_name和table_type列，分别应用skip_open_table和open_frm_only优化。解释报告打开只是因为它更贵。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT B.TABLE_NAME</code></strong>
       <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES AS A, INFORMATION_SCHEMA.COLUMNS AS B</code></strong>
       <strong class="userinput"><code>WHERE A.TABLE_SCHEMA = 'test'</code></strong>
       <strong class="userinput"><code>AND A.TABLE_NAME = 't1'</code></strong>
       <strong class="userinput"><code>AND B.TABLE_NAME = A.TABLE_NAME\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: A
         type: ALL
possible_keys: NULL
          key: TABLE_SCHEMA,TABLE_NAME
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Skip_open_table; Scanned 0 databases
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: B
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Open_frm_only; Scanned all databases;
               Using join buffer
</pre><p>
            For the first <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output row:
            Constant database and table lookup values enable the server to
            avoid directory scans for <code class="literal">TABLES</code> values.
            References to <code class="literal">TABLES.TABLE_NAME</code> require no
            further table files.
        </p><p style="color:blue;">对于第一个解释输出行：常量数据库和表查找值使服务器能够避免对表值进行目录扫描。对tables.table_name的引用不需要其他表文件。</p><p></p><p>
            For the second <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output
            row: All <a class="link" href="information-schema.html#columns-table" title="24.5&nbsp;The INFORMATION_SCHEMA COLUMNS Table"><code class="literal">COLUMNS</code></a> table values are
            <code class="literal">OPEN_FRM_ONLY</code> lookups, so
            <code class="literal">COLUMNS.TABLE_NAME</code> requires the
            <code class="filename">.frm</code> file to be opened.
        </p><p style="color:blue;">对于第二个解释输出行：所有列表值都是打开的，所以columns.table_name要求打开.frm文件。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM INFORMATION_SCHEMA.COLLATIONS\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: COLLATIONS
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra:
</pre><p>
            In this case, no optimizations apply because
            <a class="link" href="information-schema.html#collations-table" title="24.3&nbsp;The INFORMATION_SCHEMA COLLATIONS Table"><code class="literal">COLLATIONS</code></a> is not one of the
            <code class="literal">INFORMATION_SCHEMA</code> tables for which
            optimizations are available.
        </p><p style="color:blue;">在这种情况下，不会应用优化，因为排序规则不是可用于优化的信息架构表之一。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="data-change-optimization"></a>8.2.4&nbsp;Optimizing Data Change Statements</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#insert-optimization">8.2.4.1 Optimizing INSERT Statements</a></span></dt><dt><span class="section"><a href="optimization.html#update-optimization">8.2.4.2 Optimizing UPDATE Statements</a></span></dt><dt><span class="section"><a href="optimization.html#delete-optimization">8.2.4.3 Optimizing DELETE Statements</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286873670880"></a><p>
            This section explains how to speed up data change statements:
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>. Traditional OLTP
            applications and modern web applications typically do many small
            data change operations, where concurrency is vital. Data
            analysis and reporting applications typically run data change
            operations that affect many rows at once, where the main
            considerations is the I/O to write large amounts of data and
            keep indexes up-to-date. For inserting and updating large
            volumes of data (known in the industry as ETL, for
            <span class="quote">“<span class="quote">extract-transform-load</span>”</span>), sometimes you use other
            SQL statements or external commands, that mimic the effects of
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements.
        </p><p style="color:blue;">本节介绍如何加快数据更改语句的速度：插入、更新和删除。传统的oltp应用程序和现代的web应用程序通常执行许多小的数据更改操作，其中并发性至关重要。数据分析和报告应用程序通常会同时运行影响许多行的数据更改操作，其中主要考虑的是写入大量数据和保持索引最新的I/O。为了插入和更新大量数据（在行业中称为etl，用于“提取转换加载”），有时您会使用其他sql语句或外部命令，它们模拟insert、update和delete语句的效果。</p><p></p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="insert-optimization"></a>8.2.4.1&nbsp;Optimizing INSERT Statements</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286873659344"></a><a class="indexterm" name="idm140286873658304"></a><a class="indexterm" name="idm140286873656816"></a><a class="indexterm" name="idm140286873655328"></a><p>
                To optimize insert speed, combine many small operations into a
                single large operation. Ideally, you make a single connection,
                send the data for many new rows at once, and delay all index
                updates and consistency checking until the very end.
            </p><p style="color:blue;">要优化插入速度，请将多个小操作合并为一个大操作。理想情况下，只建立一个连接，一次发送多个新行的数据，并将所有索引更新和一致性检查延迟到最后。</p><p></p><p>
                The time required for inserting a row is determined by the
                following factors, where the numbers indicate approximate
                proportions:
            </p><p style="color:blue;">插入行所需的时间由下列因素决定，其中的数字表示近似的比例：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Connecting: (3)
                    </p><p style="color:blue;">连接：（3）</p><p></p></li><li class="listitem"><p>
                        Sending query to server: (2)
                    </p><p style="color:blue;">向服务器发送查询：（2）</p><p></p></li><li class="listitem"><p>
                        Parsing query: (2)
                    </p><p style="color:blue;">正在分析查询：（2）</p><p></p></li><li class="listitem"><p>
                        Inserting row: (1 × size of row)
                    </p><p style="color:blue;">插入行：（1×行大小）</p><p></p></li><li class="listitem"><p>
                        Inserting indexes: (1 × number of indexes)
                    </p><p style="color:blue;">插入索引：（1×索引数）</p><p></p></li><li class="listitem"><p>
                        Closing: (1)
                    </p><p style="color:blue;">结束：（1）</p><p></p></li></ul>
                </div>
                <p>
                    This does not take into consideration the initial overhead to
                    open tables, which is done once for each concurrently running
                    query.
                </p><p style="color:blue;">这不考虑打开表的初始开销，对于每个并发运行的查询，打开表只需一次。</p><p></p><p>
                The size of the table slows down the insertion of indexes by
                log <em class="replaceable"><code>N</code></em>, assuming B-tree indexes.
            </p><p style="color:blue;">表的大小减慢了log n插入索引的速度，假设是b树索引。</p><p></p><p>
                You can use the following methods to speed up inserts:
            </p><p style="color:blue;">可以使用以下方法加快插入速度：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        If you are inserting many rows from the same client at the
                        same time, use <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                        statements with multiple <code class="literal">VALUES</code> lists
                        to insert several rows at a time. This is considerably
                        faster (many times faster in some cases) than using
                        separate single-row <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                        statements. If you are adding data to a nonempty table,
                        you can tune the
                        <a class="link" href="server-administration.html#sysvar_bulk_insert_buffer_size"><code class="literal">bulk_insert_buffer_size</code></a>
                        variable to make data insertion even faster. See
                        <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                    </p><p style="color:blue;">如果同时从同一客户端插入多行，请使用带有多个值列表的INSERT语句一次插入多行。这比使用单独的单行insert语句要快得多（在某些情况下要快很多倍）。如果要将数据添加到非空表中，可以调整bulk_insert_buffer_size变量，使数据插入更快。见第5.1.7节“服务器系统变量”。</p><p></p></li><li class="listitem"><p>
                        When loading a table from a text file, use
                        <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>. This is usually
                        20 times faster than using
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements. See
                        <a class="xref" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax">Section&nbsp;13.2.6, “LOAD DATA Syntax”</a>.
                    </p><p style="color:blue;">从文本文件加载表时，请使用“加载数据”。这通常比使用insert语句快20倍。见第13.2.6节“加载数据语法”。</p><p></p></li><li class="listitem"><p>
                        Take advantage of the fact that columns have default
                        values. Insert values explicitly only when the value to be
                        inserted differs from the default. This reduces the
                        parsing that MySQL must do and improves the insert speed.
                    </p><p style="color:blue;">利用列具有默认值这一事实。仅当要插入的值与默认值不同时才显式插入值。这减少了mysql必须进行的解析，提高了插入速度。</p><p></p></li><li class="listitem"><p>
                        See <a class="xref" href="optimization.html#optimizing-innodb-bulk-data-loading" title="8.5.5&nbsp;Bulk Data Loading for InnoDB Tables">Section&nbsp;8.5.5, “Bulk Data Loading for InnoDB Tables”</a>
                        for tips specific to <code class="literal">InnoDB</code> tables.
                    </p><p style="color:blue;">请参阅第8.5.5节“InnoDB表的批量数据加载”，了解InnoDB表的特定提示。</p><p></p></li><li class="listitem"><p>
                        See <a class="xref" href="optimization.html#optimizing-myisam-bulk-data-loading" title="8.6.2&nbsp;Bulk Data Loading for MyISAM Tables">Section&nbsp;8.6.2, “Bulk Data Loading for MyISAM Tables”</a>
                        for tips specific to <code class="literal">MyISAM</code> tables.
                    </p><p style="color:blue;">有关myisam表的特定提示，请参阅第8.6.2节“myisam表的批量数据加载”。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="update-optimization"></a>8.2.4.2&nbsp;Optimizing UPDATE Statements</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286873627152"></a><p>
                An update statement is optimized like a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> query with the
                additional overhead of a write. The speed of the write depends
                on the amount of data being updated and the number of indexes
                that are updated. Indexes that are not changed do not get
                updated.
            </p><p style="color:blue;">update语句像select查询一样经过优化，但会增加写操作的开销。写入速度取决于要更新的数据量和要更新的索引数。不会更新未更改的索引。</p><p></p><p>
                Another way to get fast updates is to delay updates and then
                do many updates in a row later. Performing multiple updates
                together is much quicker than doing one at a time if you lock
                the table.
            </p><p style="color:blue;">获取快速更新的另一种方法是延迟更新，然后在以后连续执行多个更新。如果锁定表，一起执行多个更新比一次执行一个更新快得多。</p><p></p><p>
                For a <code class="literal">MyISAM</code> table that uses dynamic row
                format, updating a row to a longer total length may split the
                row. If you do this often, it is very important to use
                <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a> occasionally.
                See <a class="xref" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax">Section&nbsp;13.7.2.4, “OPTIMIZE TABLE Syntax”</a>.
            </p><p style="color:blue;">对于使用动态行格式的myisam表，将行更新为更长的总长度可能会拆分行。如果您经常这样做，那么偶尔使用optimize table是非常重要的。见第13.7.2.4节“优化表语法”。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="delete-optimization"></a>8.2.4.3&nbsp;Optimizing DELETE Statements</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286873618576"></a><p>
                The time required to delete individual rows in a
                <code class="literal">MyISAM</code> table is exactly proportional to the
                number of indexes. To delete rows more quickly, you can
                increase the size of the key cache by increasing the
                <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> system
                variable. See <a class="xref" href="server-administration.html#server-configuration" title="5.1.1&nbsp;Configuring the Server">Section&nbsp;5.1.1, “Configuring the Server”</a>.
            </p><p style="color:blue;">在myisam表中删除单个行所需的时间与索引数成正比。要更快速地删除行，可以通过增加KEY U BUFFER U SIZE系统变量来增加密钥缓存的大小。参见第5.1.1节“配置服务器”。</p><p></p><p>
                To delete all rows from a <code class="literal">MyISAM</code> table,
                <code class="literal">TRUNCATE TABLE
                    <em class="replaceable"><code>tbl_name</code></em></code> is faster than
                <code class="literal">DELETE FROM
                    <em class="replaceable"><code>tbl_name</code></em></code>. Truncate
                operations are not transaction-safe; an error occurs when
                attempting one in the course of an active transaction or
                active table lock. See <a class="xref" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax">Section&nbsp;13.1.34, “TRUNCATE TABLE Syntax”</a>.
            </p><p style="color:blue;">要从myisam表中删除所有行，truncate table tbl_name比delete from tbl_name快。truncate操作不是事务安全的；在活动事务或活动表锁过程中尝试执行某个操作时出错。参见第13.1.34节“截断表语法”。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="permission-optimization"></a>8.2.5&nbsp;Optimizing Database Privileges</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286873608368"></a><a class="indexterm" name="idm140286873606912"></a><p>
            The more complex your privilege setup, the more overhead applies
            to all SQL statements. Simplifying the privileges established by
            <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a> statements enables MySQL to
            reduce permission-checking overhead when clients execute
            statements. For example, if you do not grant any table-level or
            column-level privileges, the server need not ever check the
            contents of the <code class="literal">tables_priv</code> and
            <code class="literal">columns_priv</code> tables. Similarly, if you place
            no resource limits on any accounts, the server does not have to
            perform resource counting. If you have a very high
            statement-processing load, consider using a simplified grant
            structure to reduce permission-checking overhead.
        </p><p style="color:blue;">权限设置越复杂，应用于所有sql语句的开销就越多。通过简化grant语句所建立的特权，mysql可以减少客户端执行语句时的权限检查开销。例如，如果不授予任何表级或列级权限，则服务器永远不需要检查tables_priv和columns_priv表的内容。类似地，如果对任何帐户没有资源限制，则服务器不必执行资源计数。如果语句处理负载很高，请考虑使用简化的授予结构来减少权限检查开销。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="miscellaneous-optimization-tips"></a>8.2.6&nbsp;Other Optimization Tips</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286873600304"></a><a class="indexterm" name="idm140286873598816"></a><p>
            This section lists a number of miscellaneous tips for improving
            query processing speed:
        </p><p style="color:blue;">本节列出了一些提高查询处理速度的其他技巧：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If your application makes several database requests to
                    perform related updates, combining the statements into a
                    stored routine can help performance. Similarly, if your
                    application computes a single result based on several column
                    values or large volumes of data, combining the computation
                    into a UDF (user-defined function) can help performance. The
                    resulting fast database operations are then available to be
                    reused by other queries, applications, and even code written
                    in different programming languages. See
                    <a class="xref" href="stored-objects.html#stored-routines" title="23.2&nbsp;Using Stored Routines">Section&nbsp;23.2, “Using Stored Routines”</a> and
                    <a class="xref" href="extending-mysql.html#adding-functions" title="28.4&nbsp;Adding Functions to MySQL">Section&nbsp;28.4, “Adding Functions to MySQL”</a> for more information.
                </p><p style="color:blue;">如果应用程序发出多个数据库请求以执行相关更新，则将语句合并到存储例程中可以帮助提高性能。类似地，如果应用程序基于多个列值或大量数据计算单个结果，则将计算合并到UDF（用户定义函数）中可以帮助提高性能。由此产生的快速数据库操作可供其他查询、应用程序甚至用不同编程语言编写的代码重用。有关详细信息，请参阅第23.2节“使用存储例程”和第28.4节“向mysql添加函数”。</p><p></p></li><li class="listitem"><p>
                    To fix any compression issues that occur with
                    <code class="literal">ARCHIVE</code> tables, use
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>. See
                    <a class="xref" href="storage-engines.html#archive-storage-engine" title="15.5&nbsp;The ARCHIVE Storage Engine">Section&nbsp;15.5, “The ARCHIVE Storage Engine”</a>.
                </p><p style="color:blue;">若要修复存档表中出现的任何压缩问题，请使用“优化表”。参见第15.5节“存档存储引擎”。</p><p></p></li><li class="listitem"><p>
                    If possible, classify reports as <span class="quote">“<span class="quote">live</span>”</span> or as
                    <span class="quote">“<span class="quote">statistical</span>”</span>, where data needed for
                    statistical reports is created only from summary tables that
                    are generated periodically from the live data.
                </p><p style="color:blue;">如果可能，将报告分类为“实时”或“统计”，其中统计报告所需的数据仅从实时数据定期生成的汇总表中创建。</p><p></p></li><li class="listitem"><p>
                    If you have data that does not conform well to a
                    rows-and-columns table structure, you can pack and store
                    data into a <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> column. In
                    this case, you must provide code in your application to pack
                    and unpack information, but this might save I/O operations
                    to read and write the sets of related values.
                </p><p style="color:blue;">如果数据与行和列表结构不完全一致，则可以将数据打包并存储到blob列中。在这种情况下，必须在应用程序中提供代码来打包和解包信息，但这可能会保存读取和写入相关值集的I/O操作。</p><p></p></li><li class="listitem"><p>
                    With Web servers, store images and other binary assets as
                    files, with the path name stored in the database rather than
                    the file itself. Most Web servers are better at caching
                    files than database contents, so using files is generally
                    faster. (Although you must handle backups and storage issues
                    yourself in this case.)
                </p><p style="color:blue;">使用web服务器，将图像和其他二进制资产存储为文件，路径名存储在数据库中，而不是文件本身。大多数web服务器都比数据库内容更擅长缓存文件，因此使用文件通常更快。（尽管在这种情况下，您必须自己处理备份和存储问题。）</p><p></p></li><li class="listitem"><p>
                    If you need really high speed, look at the low-level MySQL
                    interfaces. For example, by accessing the MySQL
                    <code class="literal">InnoDB</code> or <code class="literal">MyISAM</code>
                    storage engine directly, you could get a substantial speed
                    increase compared to using the SQL interface.
                </p><p style="color:blue;">如果你真的需要很高的速度，看看底层的mysql接口。例如，通过直接访问mysql innodb或myisam存储引擎，与使用sql接口相比，您可以获得显著的速度提升。</p><p></p></li><li class="listitem"><p>
                    Replication can provide a performance benefit for some
                    operations. You can distribute client retrievals among
                    replication servers to split up the load. To avoid slowing
                    down the master while making backups, you can make backups
                    using a slave server. See <a class="xref" href="replication.html" title="Chapter&nbsp;16&nbsp;Replication">Chapter&nbsp;16, <i>Replication</i></a>.
                </p><p style="color:blue;">复制可以为某些操作提供性能优势。您可以在复制服务器之间分发客户端检索以分割负载。为了避免在备份时减慢主服务器的速度，可以使用从属服务器进行备份。见第16章，复制。</p><p></p></li></ul>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="optimization-indexes"></a>8.3&nbsp;Optimization and Indexes</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#mysql-indexes">8.3.1 How MySQL Uses Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#primary-key-optimization">8.3.2 Primary Key Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#foreign-key-optimization">8.3.3 Foreign Key Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#column-indexes">8.3.4 Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">8.3.5 Multiple-Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#verifying-index-usage">8.3.6 Verifying Index Usage</a></span></dt><dt><span class="section"><a href="optimization.html#index-statistics">8.3.7 InnoDB and MyISAM Index Statistics Collection</a></span></dt><dt><span class="section"><a href="optimization.html#index-btree-hash">8.3.8 Comparison of B-Tree and Hash Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#index-extensions">8.3.9 Use of Index Extensions</a></span></dt><dt><span class="section"><a href="optimization.html#generated-column-index-optimizations">8.3.10 Optimizer Use of Generated Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#timestamp-lookups">8.3.11 Indexed Lookups from TIMESTAMP Columns</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286873579056"></a><p>
        The best way to improve the performance of
        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> operations is to create
        indexes on one or more of the columns that are tested in the
        query. The index entries act like pointers to the table rows,
        allowing the query to quickly determine which rows match a
        condition in the <code class="literal">WHERE</code> clause, and retrieve the
        other column values for those rows. All MySQL data types can be
        indexed.
    </p><p style="color:blue;">提高select操作性能的最佳方法是在查询中测试的一个或多个列上创建索引。索引项的作用类似于指向表行的指针，允许查询快速确定哪些行与where子句中的条件匹配，并检索这些行的其他列值。所有mysql数据类型都可以被索引。</p><p></p><p>
        Although it can be tempting to create an indexes for every
        possible column used in a query, unnecessary indexes waste space
        and waste time for MySQL to determine which indexes to use.
        Indexes also add to the cost of inserts, updates, and deletes
        because each index must be updated. You must find the right
        balance to achieve fast queries using the optimal set of indexes.
    </p><p style="color:blue;">尽管为查询中使用的每个可能的列创建索引很有诱惑力，但不必要的索引会浪费mysql确定要使用哪些索引的空间和时间。索引还增加了插入、更新和删除的成本，因为每个索引都必须更新。必须找到正确的平衡点，才能使用最佳索引集实现快速查询。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="mysql-indexes"></a>8.3.1&nbsp;How MySQL Uses Indexes</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286873572928"></a><p>
            Indexes are used to find rows with specific column values
            quickly. Without an index, MySQL must begin with the first row
            and then read through the entire table to find the relevant
            rows. The larger the table, the more this costs. If the table
            has an index for the columns in question, MySQL can quickly
            determine the position to seek to in the middle of the data file
            without having to look at all the data. This is much faster than
            reading every row sequentially.
        </p><p style="color:blue;">索引用于快速查找具有特定列值的行。如果没有索引，mysql必须从第一行开始，然后读取整个表以查找相关行。桌子越大，费用就越高。如果表中有相关列的索引，mysql可以快速确定要在数据文件中间查找的位置，而不必查看所有数据。这比按顺序读取每一行快得多。</p><p></p><p>
            Most MySQL indexes (<code class="literal">PRIMARY KEY</code>,
            <code class="literal">UNIQUE</code>, <code class="literal">INDEX</code>, and
            <code class="literal">FULLTEXT</code>) are stored in
            <a class="link" href="glossary.html#glos_b_tree" title="B-tree">B-trees</a>. Exceptions: Indexes
            on spatial data types use R-trees; <code class="literal">MEMORY</code>
            tables also support <a class="link" href="glossary.html#glos_hash_index" title="hash index">hash
            indexes</a>; <code class="literal">InnoDB</code> uses inverted lists
            for <code class="literal">FULLTEXT</code> indexes.
        </p><p style="color:blue;">大多数mysql索引（主键、唯一、索引和全文）都存储在b树中。例外情况：空间数据类型的索引使用r树；内存表也支持哈希索引；innodb使用倒排列表作为全文索引。</p><p></p><p>
            In general, indexes are used as described in the following
            discussion. Characteristics specific to hash indexes (as used in
            <code class="literal">MEMORY</code> tables) are described in
            <a class="xref" href="optimization.html#index-btree-hash" title="8.3.8&nbsp;Comparison of B-Tree and Hash Indexes">Section&nbsp;8.3.8, “Comparison of B-Tree and Hash Indexes”</a>.
        </p><p style="color:blue;">一般来说，索引的使用如下所述。第8.3.8节“B-树和哈希索引的比较”描述了特定于哈希索引（如在内存表中使用的）的特性。</p><p></p><p>
            MySQL uses indexes for these operations:
        </p><p style="color:blue;">mysql对这些操作使用索引：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To find the rows matching a <code class="literal">WHERE</code> clause
                    quickly.
                </p><p style="color:blue;">快速查找与where子句匹配的行。</p><p></p></li><li class="listitem"><p>
                    To eliminate rows from consideration. If there is a choice
                    between multiple indexes, MySQL normally uses the index that
                    finds the smallest number of rows (the most
                    <a class="link" href="glossary.html#glos_selectivity" title="selectivity">selective</a> index).
                </p><p style="color:blue;">从考虑中排除行。如果在多个索引之间有一个选择，mysql通常使用查找最小行数（最具选择性的索引）的索引。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286873556064"></a>

                    <a class="indexterm" name="idm140286873554576"></a>

                    If the table has a multiple-column index, any leftmost
                    prefix of the index can be used by the optimizer to look up
                    rows. For example, if you have a three-column index on
                    <code class="literal">(col1, col2, col3)</code>, you have indexed
                    search capabilities on <code class="literal">(col1)</code>,
                    <code class="literal">(col1, col2)</code>, and <code class="literal">(col1, col2,
                    col3)</code>. For more information, see
                    <a class="xref" href="optimization.html#multiple-column-indexes" title="8.3.5&nbsp;Multiple-Column Indexes">Section&nbsp;8.3.5, “Multiple-Column Indexes”</a>.
                </p><p style="color:blue;">如果表具有多列索引，优化器可以使用索引的任何最左边的前缀来查找行。例如，如果在（col1、col2、col3）上有三列索引，则在（col1）、col1、col2和（col1、col2、col3）上有索引搜索功能。有关详细信息，请参见第8.3.5节“多列索引”。</p><p></p></li><li class="listitem"><p>
                    To retrieve rows from other tables when performing joins.
                    MySQL can use indexes on columns more efficiently if they
                    are declared as the same type and size. In this context,
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> and
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> are considered the same
                    if they are declared as the same size. For example,
                    <code class="literal">VARCHAR(10)</code> and
                    <code class="literal">CHAR(10)</code> are the same size, but
                    <code class="literal">VARCHAR(10)</code> and
                    <code class="literal">CHAR(15)</code> are not.
                </p><p style="color:blue;">在执行联接时从其他表检索行。如果列声明为相同的类型和大小，mysql可以更有效地对它们使用索引。在这个上下文中，如果varchar和char声明为相同的大小，则它们被认为是相同的。例如，varchar（10）和char（10）大小相同，但varchar（10）和char（15）大小不同。</p><p></p><p>
                    For comparisons between nonbinary string columns, both
                    columns should use the same character set. For example,
                    comparing a <code class="literal">utf8</code> column with a
                    <code class="literal">latin1</code> column precludes use of an index.
                </p><p style="color:blue;">对于非二进制字符串列之间的比较，两列应使用相同的字符集。例如，将utf8列与latin1列进行比较就不允许使用索引。</p><p></p><p>
                    Comparison of dissimilar columns (comparing a string column
                    to a temporal or numeric column, for example) may prevent
                    use of indexes if values cannot be compared directly without
                    conversion. For a given value such as <code class="literal">1</code>
                    in the numeric column, it might compare equal to any number
                    of values in the string column such as
                    <code class="literal">'1'</code>, <code class="literal">'&nbsp;1'</code>,
                    <code class="literal">'00001'</code>, or <code class="literal">'01.e1'</code>.
                    This rules out use of any indexes for the string column.
                </p><p style="color:blue;">如果在不进行转换的情况下无法直接比较值，则比较不同列（例如，将字符串列与时态列或数值列进行比较）可能会阻止索引的使用。对于给定的值（如数字列中的1），它可以与字符串列中的任意数量的值（如“1”、“1”、“00001”或“01.e1”）进行比较。这就排除了对字符串列使用任何索引的可能性。</p><p></p></li><li class="listitem"><p>
                    To find the <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a> or
                    <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a> value for a specific
                    indexed column <em class="replaceable"><code>key_col</code></em>. This is
                    optimized by a preprocessor that checks whether you are
                    using <code class="literal">WHERE <em class="replaceable"><code>key_part_N</code></em> =
                    <em class="replaceable"><code>constant</code></em></code> on all key
                    parts that occur before <em class="replaceable"><code>key_col</code></em>
                    in the index. In this case, MySQL does a single key lookup
                    for each <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a> or
                    <a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a> expression and replaces
                    it with a constant. If all expressions are replaced with
                    constants, the query returns at once. For example:
                </p><p style="color:blue;">查找特定索引列键列的min（）或max（）值。这是由一个预处理器优化的，该预处理器检查是否在索引中键列之前发生的所有键部分上使用where key_part_n=常量。在本例中，mysql对每个min（）或max（）表达式执行单键查找，并将其替换为常量。如果所有表达式都替换为常量，则查询将立即返回。例如：</p><p></p><pre data-lang="sql" class="programlisting">SELECT MIN(<em class="replaceable"><code>key_part2</code></em>),MAX(<em class="replaceable"><code>key_part2</code></em>)
  FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_part1</code></em>=10;
</pre></li><li class="listitem"><p>
                    To sort or group a table if the sorting or grouping is done
                    on a leftmost prefix of a usable index (for example,
                    <code class="literal">ORDER BY <em class="replaceable"><code>key_part1</code></em>,
                        <em class="replaceable"><code>key_part2</code></em></code>). If all key
                    parts are followed by <code class="literal">DESC</code>, the key is
                    read in reverse order. See
                    <a class="xref" href="optimization.html#order-by-optimization" title="8.2.1.14&nbsp;ORDER BY Optimization">Section&nbsp;8.2.1.14, “ORDER BY Optimization”</a>, and
                    <a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.15&nbsp;GROUP BY Optimization">Section&nbsp;8.2.1.15, “GROUP BY Optimization”</a>.
                </p><p style="color:blue;">如果排序或分组是在可用索引的最左边前缀上完成的（例如，ORDER BY KEY PART1，KEY PART2），则对表进行排序或分组。如果所有关键部分后面都跟着DESC，则按相反的顺序读取键。参见第8.2.1.14节“按优化排序”，以及第8.2.1.15节“按优化分组”。</p><p></p></li><li class="listitem"><p>
                    In some cases, a query can be optimized to retrieve values
                    without consulting the data rows. (An index that provides
                    all the necessary results for a query is called a
                    <a class="link" href="glossary.html#glos_covering_index" title="covering index">covering index</a>.)
                    If a query uses from a table only columns that are included
                    in some index, the selected values can be retrieved from the
                    index tree for greater speed:
                </p><p style="color:blue;">在某些情况下，可以优化查询以检索值，而无需查询数据行。（为查询提供所有必要结果的索引称为覆盖索引。）如果查询仅从某个表中使用某些索引中包含的列，则可以从索引树中检索选定的值以获得更快的速度：</p><p></p><pre data-lang="sql" class="programlisting">SELECT <em class="replaceable"><code>key_part3</code></em> FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=1
</pre></li></ul>
            </div>
            <p>
                Indexes are less important for queries on small tables, or big
                tables where report queries process most or all of the rows.
                When a query needs to access most of the rows, reading
                sequentially is faster than working through an index. Sequential
                reads minimize disk seeks, even if not all the rows are needed
                for the query. See <a class="xref" href="optimization.html#table-scan-avoidance" title="8.2.1.20&nbsp;Avoiding Full Table Scans">Section&nbsp;8.2.1.20, “Avoiding Full Table Scans”</a> for
                details.
            </p><p style="color:blue;">索引对于小表或报表查询处理大部分或所有行的大表上的查询不太重要。当查询需要访问大多数行时，按顺序读取比通过索引读取要快。顺序读取使磁盘查找最小化，即使查询不需要所有行。详见第8.2.1.20节“避免全表扫描”。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="primary-key-optimization"></a>8.3.2&nbsp;Primary Key Optimization</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286873513280"></a><p>
            The primary key for a table represents the column or set of
            columns that you use in your most vital queries. It has an
            associated index, for fast query performance. Query performance
            benefits from the <code class="literal">NOT NULL</code> optimization,
            because it cannot include any <code class="literal">NULL</code> values.
            With the <code class="literal">InnoDB</code> storage engine, the table
            data is physically organized to do ultra-fast lookups and sorts
            based on the primary key column or columns.
        </p><p style="color:blue;">表的主键表示在最重要的查询中使用的列或列集。它有一个相关的索引，用于快速查询性能。查询性能得益于非空优化，因为它不能包含任何空值。使用innodb存储引擎，表数据在物理上被组织成基于主键列的超快速查找和排序。</p><p></p><p>
            If your table is big and important, but does not have an obvious
            column or set of columns to use as a primary key, you might
            create a separate column with auto-increment values to use as
            the primary key. These unique IDs can serve as pointers to
            corresponding rows in other tables when you join tables using
            foreign keys.
        </p><p style="color:blue;">如果表很大且很重要，但没有一个明显的列或一组列用作主键，则可以创建一个单独的列，并使用自动增量值作为主键。当您使用外键联接表时，这些唯一的id可以用作指向其他表中相应行的指针。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="foreign-key-optimization"></a>8.3.3&nbsp;Foreign Key Optimization</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286873506784"></a><p>
            If a table has many columns, and you query many different
            combinations of columns, it might be efficient to split the
            less-frequently used data into separate tables with a few
            columns each, and relate them back to the main table by
            duplicating the numeric ID column from the main table. That way,
            each small table can have a primary key for fast lookups of its
            data, and you can query just the set of columns that you need
            using a join operation. Depending on how the data is
            distributed, the queries might perform less I/O and take up less
            cache memory because the relevant columns are packed together on
            disk. (To maximize performance, queries try to read as few data
            blocks as possible from disk; tables with only a few columns can
            fit more rows in each data block.)
        </p><p style="color:blue;">如果一个表有许多列，并且您查询了许多不同的列组合，那么将不常用的数据拆分为单独的表，每个表有几列，并通过从主表中复制数字id列将它们与主表关联起来，可能会更有效。这样，每个小表都可以有一个主键来快速查找其数据，并且您可以使用join操作只查询所需的一组列。根据数据的分布方式，查询可能执行更少的I/O并占用更少的缓存，因为相关列被打包在磁盘上。（为了使性能最大化，查询尽量从磁盘读取尽可能少的数据块；只有几个列的表可以在每个数据块中拟合更多的行。）</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="column-indexes"></a>8.3.4&nbsp;Column Indexes</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286873501904"></a><a class="indexterm" name="idm140286873500416"></a><a class="indexterm" name="idm140286873498928"></a><p>
            The most common type of index involves a single column, storing
            copies of the values from that column in a data structure,
            allowing fast lookups for the rows with the corresponding column
            values. The B-tree data structure lets the index quickly find a
            specific value, a set of values, or a range of values,
            corresponding to operators such as <code class="literal">=</code>,
            <code class="literal">&gt;</code>, <code class="literal">≤</code>,
            <code class="literal">BETWEEN</code>, <code class="literal">IN</code>, and so on, in
            a <code class="literal">WHERE</code> clause.
        </p><p style="color:blue;">最常见的索引类型涉及一个列，它将该列中的值的副本存储在数据结构中，允许快速查找具有相应列值的行。b树数据结构允许索引快速查找特定值、一组值或一系列值，这些值对应于where子句中的运算符，如=、&gt;、≤、between、in等。</p><p></p><p>
            The maximum number of indexes per table and the maximum index
            length is defined per storage engine. See
            <a class="xref" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine">Chapter&nbsp;14, <i>The InnoDB Storage Engine</i></a>, and
            <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>. All storage engines support
            at least 16 indexes per table and a total index length of at
            least 256 bytes. Most storage engines have higher limits.
        </p><p style="color:blue;">每个存储引擎定义了每个表的最大索引数和最大索引长度。参见第14章，InnoDB存储引擎和第15章，替代存储引擎。所有存储引擎都支持每个表至少16个索引，索引总长度至少为256字节。大多数存储引擎都有更高的限制。</p><p></p><p>
            For additional information about column indexes, see
            <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>.
        </p><p style="color:blue;">有关列索引的其他信息，请参阅第13.1.14节“创建索引语法”。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#column-indexes-prefix" title="Index Prefixes">Index Prefixes</a></p><p style="color:blue;">索引前缀</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#column-indexes-fulltext" title="FULLTEXT Indexes">FULLTEXT Indexes</a></p><p style="color:blue;">全文索引</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#column-indexes-spatial" title="Spatial Indexes">Spatial Indexes</a></p><p style="color:blue;">空间索引</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#column-indexes-memory-storage-engine" title="Indexes in the MEMORY Storage Engine">Indexes in the MEMORY Storage Engine</a></p><p style="color:blue;">内存存储引擎中的索引</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="column-indexes-prefix"></a>Index Prefixes</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286873483968"></a><a class="indexterm" name="idm140286873482480"></a><a class="indexterm" name="idm140286873480992"></a><a class="indexterm" name="idm140286873479504"></a><a class="indexterm" name="idm140286873478016"></a><p>
                With
                <code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>N</code></em>)</code>
                syntax in an index specification for a string column, you can
                create an index that uses only the first
                <em class="replaceable"><code>N</code></em> characters of the column.
                Indexing only a prefix of column values in this way can make
                the index file much smaller. When you index a
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column, you
                <span class="emphasis"><em>must</em></span> specify a prefix length for the
                index. For example:
            </p><p style="color:blue;">使用字符串列的索引规范中的col_name（n）语法，可以创建只使用列的前n个字符的索引。以这种方式只索引列值的前缀可以使索引文件小得多。索引blob或文本列时，必须指定索引的前缀长度。例如：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</pre><p>
                Prefixes can be up to 1000 bytes long (767 bytes for
                <code class="literal">InnoDB</code> tables, unless you have
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix"><code class="literal">innodb_large_prefix</code></a> set).
            </p><p style="color:blue;">前缀最长可达1000字节（innodb表为767字节，除非设置了innodb_large_前缀）。</p><p></p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        Prefix limits are measured in bytes, whereas the prefix
                        length in <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>,
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>, and
                        <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a> statements is
                        interpreted as number of characters for nonbinary string
                        types (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>) and number of bytes for
                        binary string types (<a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">BINARY</code></a>,
                        <a class="link" href="data-types.html#binary-varbinary" title="11.4.2&nbsp;The BINARY and VARBINARY Types"><code class="literal">VARBINARY</code></a>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>). Take this into account
                        when specifying a prefix length for a nonbinary string
                        column that uses a multibyte character set.
                    </p><p style="color:blue;">前缀限制以字节为单位，而CREATE TABLE、ALTER TABLE和CREATE INDEX语句中的前缀长度被解释为非二进制字符串类型（char、varchar、text）的字符数和二进制字符串类型（binary、varbinary、blob）的字节数。在为使用多字节字符集的非二进制字符串列指定前缀长度时，请考虑此问题。</p><p></p>
                </div>
                <p>
                    If a search term exceeds the index prefix length, the index is
                    used to exclude non-matching rows, and the remaining rows are
                    examined for possible matches.
                </p><p style="color:blue;">如果搜索项超过索引前缀长度，则索引用于排除不匹配的行，并检查其余行是否可能匹配。</p><p></p><p>
                For additional information about index prefixes, see
                <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>.
            </p><p style="color:blue;">有关索引前缀的其他信息，请参见第13.1.14节“创建索引语法”。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="column-indexes-fulltext"></a>FULLTEXT Indexes</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286873452544"></a><a class="indexterm" name="idm140286873451056"></a><p>
                <code class="literal">FULLTEXT</code> indexes are used for full-text
                searches. Only the <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> and
                <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> storage engines support
                <code class="literal">FULLTEXT</code> indexes and only for
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a>,
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>, and
                <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns. Indexing always
                takes place over the entire column and column prefix indexing
                is not supported. For details, see
                <a class="xref" href="functions.html#fulltext-search" title="12.9&nbsp;Full-Text Search Functions">Section&nbsp;12.9, “Full-Text Search Functions”</a>.
            </p><p style="color:blue;">全文索引用于全文搜索。只有innodb和myisam存储引擎支持全文索引，并且只支持char、varchar和text列。索引始终在整个列上进行，并且不支持列前缀索引。有关详细信息，请参见第12.9节“全文搜索功能”。</p><p></p><p>
                Optimizations are applied to certain kinds of
                <code class="literal">FULLTEXT</code> queries against single
                <code class="literal">InnoDB</code> tables. Queries with these
                characteristics are particularly efficient:
            </p><p style="color:blue;">优化应用于针对单个innodb表的某些类型的全文查询。具有这些特征的查询特别有效：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">FULLTEXT</code> queries that only return the
                        document ID, or the document ID and the search rank.
                    </p><p style="color:blue;">只返回文档ID、文档ID和搜索列组的全文查询。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">FULLTEXT</code> queries that sort the matching
                        rows in descending order of score and apply a
                        <code class="literal">LIMIT</code> clause to take the top N matching
                        rows. For this optimization to apply, there must be no
                        <code class="literal">WHERE</code> clauses and only a single
                        <code class="literal">ORDER BY</code> clause in descending order.
                    </p><p style="color:blue;">按分数降序排列匹配行并应用LIMIT子句获取前n个匹配行的全文查询。要应用此优化，不能有where子句，并且只能有一个降序的order by子句。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">FULLTEXT</code> queries that retrieve only the
                        <code class="literal">COUNT(*)</code> value of rows matching a
                        search term, with no additional <code class="literal">WHERE</code>
                        clauses. Code the <code class="literal">WHERE</code> clause as
                        <code class="literal">WHERE MATCH(<em class="replaceable"><code>text</code></em>)
                            AGAINST
                            ('<em class="replaceable"><code>other_text</code></em>')</code>,
                        without any <code class="literal">&gt; 0</code> comparison operator.
                    </p><p style="color:blue;">全文查询，只检索与搜索词匹配的行的count（*）值，不检索其他where子句。将where子句编码为where match（text）对（'other_text'），不使用任何&gt;0的比较运算符。</p><p></p></li></ul>
                </div>
                <p>
                    For queries that contain full-text expressions, MySQL
                    evaluates those expressions during the optimization phase of
                    query execution. The optimizer does not just look at full-text
                    expressions and make estimates, it actually evaluates them in
                    the process of developing an execution plan.
                </p><p style="color:blue;">对于包含全文表达式的查询，mysql在查询执行的优化阶段计算这些表达式。优化器不只是查看全文表达式并进行估算，它实际上是在开发执行计划的过程中对它们进行估算的。</p><p></p><p>
                An implication of this behavior is that
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> for full-text queries
                is typically slower than for non-full-text queries for which
                no expression evaluation occurs during the optimization phase.
            </p><p style="color:blue;">这种行为的一个含义是，对于全文查询，explain通常比对于优化阶段不进行表达式求值的非全文查询要慢。</p><p></p><p>
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> for full-text queries
                may show <code class="literal">Select tables optimized away</code> in
                the <code class="literal">Extra</code> column due to matching occurring
                during optimization; in this case, no table access need occur
                during later execution.
            </p><p style="color:blue;">explain for full-text查询可能会在额外的列中显示经过优化的select表，因为在优化过程中发生匹配；在这种情况下，在以后的执行过程中不需要进行表访问。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="column-indexes-spatial"></a>Spatial Indexes</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286873419424"></a><a class="indexterm" name="idm140286873417936"></a><p>
                You can create indexes on spatial data types.
                <code class="literal">MyISAM</code> and <code class="literal">InnoDB</code>
                support R-tree indexes on spatial types. Other storage engines
                use B-trees for indexing spatial types (except for
                <code class="literal">ARCHIVE</code>, which does not support spatial
                type indexing).
            </p><p style="color:blue;">可以在空间数据类型上创建索引。myisam和innodb支持空间类型的r树索引。其他存储引擎使用B-树索引空间类型（除了存档，不支持空间类型索引）。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="column-indexes-memory-storage-engine"></a>Indexes in the MEMORY Storage Engine</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286873412368"></a><a class="indexterm" name="idm140286873410880"></a><p>
                The <code class="literal">MEMORY</code> storage engine uses
                <code class="literal">HASH</code> indexes by default, but also supports
                <code class="literal">BTREE</code> indexes.
            </p><p style="color:blue;">默认情况下，内存存储引擎使用哈希索引，但也支持btree索引。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="multiple-column-indexes"></a>8.3.5&nbsp;Multiple-Column Indexes</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286873405472"></a><a class="indexterm" name="idm140286873404400"></a><a class="indexterm" name="idm140286873402912"></a><p>
            MySQL can create composite indexes (that is, indexes on multiple
            columns). An index may consist of up to 16 columns. For certain
            data types, you can index a prefix of the column (see
            <a class="xref" href="optimization.html#column-indexes" title="8.3.4&nbsp;Column Indexes">Section&nbsp;8.3.4, “Column Indexes”</a>).
        </p><p style="color:blue;">mysql可以创建复合索引（即多个列上的索引）。索引最多可包含16列。对于某些数据类型，可以为列的前缀编制索引（请参阅8.3.4节，“列索引”）。</p><p></p><p>
            MySQL can use multiple-column indexes for queries that test all
            the columns in the index, or queries that test just the first
            column, the first two columns, the first three columns, and so
            on. If you specify the columns in the right order in the index
            definition, a single composite index can speed up several kinds
            of queries on the same table.
        </p><p style="color:blue;">mysql可以对测试索引中所有列的查询使用多列索引，也可以对只测试第一列、前两列、前三列等的查询使用多列索引。如果在索引定义中按正确的顺序指定列，则单个组合索引可以加快对同一表的多种查询。</p><p></p><p>
            A multiple-column index can be considered a sorted array, the
            rows of which contain values that are created by concatenating
            the values of the indexed columns.
        </p><p style="color:blue;">多列索引可以被视为排序数组，其中的行包含通过连接索引列的值而创建的值。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    As an alternative to a composite index, you can introduce a
                    column that is <span class="quote">“<span class="quote">hashed</span>”</span> based on information from
                    other columns. If this column is short, reasonably unique, and
                    indexed, it might be faster than a <span class="quote">“<span class="quote">wide</span>”</span> index
                    on many columns. In MySQL, it is very easy to use this extra
                    column:
                </p><p style="color:blue;">作为复合索引的替代，可以引入基于其他列的信息进行“散列”的列。如果此列较短、相当唯一且已编制索引，则它可能比许多列上的“宽”索引快。在mysql中，很容易使用这个额外的列：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>hash_col</code></em>=MD5(CONCAT(<em class="replaceable"><code>val1</code></em>,<em class="replaceable"><code>val2</code></em>))
  AND <em class="replaceable"><code>col1</code></em>=<em class="replaceable"><code>val1</code></em> AND <em class="replaceable"><code>col2</code></em>=<em class="replaceable"><code>val2</code></em>;
</pre>
            </div>
            <p>
                Suppose that a table has the following specification:
            </p><p style="color:blue;">假设一个表具有以下规范：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE test (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
</pre><p>
            The <code class="literal">name</code> index is an index over the
            <code class="literal">last_name</code> and <code class="literal">first_name</code>
            columns. The index can be used for lookups in queries that
            specify values in a known range for combinations of
            <code class="literal">last_name</code> and <code class="literal">first_name</code>
            values. It can also be used for queries that specify just a
            <code class="literal">last_name</code> value because that column is a
            leftmost prefix of the index (as described later in this
            section). Therefore, the <code class="literal">name</code> index is used
            for lookups in the following queries:
        </p><p style="color:blue;">名称索引是“姓氏”和“名字”列上的索引。索引可用于查询中的查找，这些查询为姓氏和姓氏值的组合指定已知范围内的值。它还可以用于仅指定姓氏值的查询，因为该列是索引的最左边前缀（如本节后面所述）。因此，名称索引用于以下查询中的查找：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM test WHERE last_name='Jones';

SELECT * FROM test
  WHERE last_name='Jones' AND first_name='John';

SELECT * FROM test
  WHERE last_name='Jones'
  AND (first_name='John' OR first_name='Jon');

SELECT * FROM test
  WHERE last_name='Jones'
  AND first_name &gt;='M' AND first_name &lt; 'N';
</pre><p>
            However, the <code class="literal">name</code> index is
            <span class="emphasis"><em>not</em></span> used for lookups in the following
            queries:
        </p><p style="color:blue;">但是，名称索引不用于以下查询中的查找：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM test WHERE first_name='John';

SELECT * FROM test
  WHERE last_name='Jones' OR first_name='John';
</pre><p>
            Suppose that you issue the following
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement:
        </p><p style="color:blue;">假设您发出以下select语句：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE col1=<em class="replaceable"><code>val1</code></em> AND col2=<em class="replaceable"><code>val2</code></em>;
</pre><p>
            If a multiple-column index exists on <code class="literal">col1</code> and
            <code class="literal">col2</code>, the appropriate rows can be fetched
            directly. If separate single-column indexes exist on
            <code class="literal">col1</code> and <code class="literal">col2</code>, the
            optimizer attempts to use the Index Merge optimization (see
            <a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3&nbsp;Index Merge Optimization">Section&nbsp;8.2.1.3, “Index Merge Optimization”</a>), or attempts to find
            the most restrictive index by deciding which index excludes more
            rows and using that index to fetch the rows.
        </p><p style="color:blue;">如果在COL1和COL2上存在多个列索引，则可以直接获取适当的行。如果在COL1和COL2上存在单独的单列索引，则优化器尝试使用索引合并优化（参见节82.1.3，“索引合并优化”），或者尝试通过确定哪个索引排除更多行并使用该索引来获取行来找到最有限制性的索引。</p><p></p><a class="indexterm" name="idm140286873372528"></a><a class="indexterm" name="idm140286873371040"></a><p>
            If the table has a multiple-column index, any leftmost prefix of
            the index can be used by the optimizer to look up rows. For
            example, if you have a three-column index on <code class="literal">(col1,
            col2, col3)</code>, you have indexed search capabilities on
            <code class="literal">(col1)</code>, <code class="literal">(col1, col2)</code>, and
            <code class="literal">(col1, col2, col3)</code>.
        </p><p style="color:blue;">如果表具有多列索引，优化器可以使用索引的任何最左边的前缀来查找行。例如，如果在（col1、col2、col3）上有三列索引，则在（col1）、col1、col2和（col1、col2、col3）上有索引搜索功能。</p><p></p><p>
            MySQL cannot use the index to perform lookups if the columns do
            not form a leftmost prefix of the index. Suppose that you have
            the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements shown here:
        </p><p style="color:blue;">如果列不构成索引最左边的前缀，mysql将无法使用索引执行查找。假设这里显示了select语句：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col1=<em class="replaceable"><code>val1</code></em>;
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col1=<em class="replaceable"><code>val1</code></em> AND col2=<em class="replaceable"><code>val2</code></em>;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col2=<em class="replaceable"><code>val2</code></em>;
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col2=<em class="replaceable"><code>val2</code></em> AND col3=<em class="replaceable"><code>val3</code></em>;
</pre><p>
            If an index exists on <code class="literal">(col1, col2, col3)</code>,
            only the first two queries use the index. The third and fourth
            queries do involve indexed columns, but do not use an index to
            perform lookups because <code class="literal">(col2)</code> and
            <code class="literal">(col2, col3)</code> are not leftmost prefixes of
            <code class="literal">(col1, col2, col3)</code>.
        </p><p style="color:blue;">如果索引存在于（COL1，COL2，COL3），则只有前两个查询使用索引。第三个和第四个查询确实涉及索引列，但不使用索引来执行查找，因为（col2）和（col2，col3）不是（col1，col2，col3）最左边的前缀。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="verifying-index-usage"></a>8.3.6&nbsp;Verifying Index Usage</h3>

                    </div>

                </div>

            </div>
            <p>
                Always check whether all your queries really use the indexes
                that you have created in the tables. Use the
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement, as described
                in <a class="xref" href="optimization.html#using-explain" title="8.8.1&nbsp;Optimizing Queries with EXPLAIN">Section&nbsp;8.8.1, “Optimizing Queries with EXPLAIN”</a>.
            </p><p style="color:blue;">始终检查所有查询是否真正使用了在表中创建的索引。使用explain语句，如第8.8.1节“使用explain优化查询”所述。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="index-statistics"></a>8.3.7&nbsp;InnoDB and MyISAM Index Statistics Collection</h3>

                    </div>

                </div>

            </div>
            <p>
                Storage engines collect statistics about tables for use by the
                optimizer. Table statistics are based on value groups, where a
                value group is a set of rows with the same key prefix value. For
                optimizer purposes, an important statistic is the average value
                group size.
            </p><p style="color:blue;">存储引擎收集有关表的统计信息，供优化器使用。表统计基于值组，其中值组是具有相同键前缀值的一组行。对于优化器，一个重要的统计数据是平均值组大小。</p><p></p><p>
            MySQL uses the average value group size in the following ways:
        </p><p style="color:blue;">mysql使用平均值组大小的方式如下：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To estimate how many rows must be read for each
                    <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> access
                </p><p style="color:blue;">估计每个ref访问必须读取多少行</p><p></p></li><li class="listitem"><p>
                    To estimate how many rows a partial join will produce; that
                    is, the number of rows that an operation of this form will
                    produce:
                </p><p style="color:blue;">估计一个部分联接将产生多少行；即，此窗体的操作将产生的行数：</p><p></p><pre data-lang="sql" class="programlisting">(...) JOIN <em class="replaceable"><code>tbl_name</code></em> ON <em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>key</code></em> = <em class="replaceable"><code>expr</code></em>
</pre></li></ul>
            </div>
            <p>
                As the average value group size for an index increases, the
                index is less useful for those two purposes because the average
                number of rows per lookup increases: For the index to be good
                for optimization purposes, it is best that each index value
                target a small number of rows in the table. When a given index
                value yields a large number of rows, the index is less useful
                and MySQL is less likely to use it.
            </p><p style="color:blue;">随着索引的平均值组大小的增加，索引对于这两个目的的用处较小，因为每次查找的平均行数会增加：为了使索引有利于优化，最好每个索引值针对表中的少量行。当给定的索引值产生大量行时，该索引就不那么有用，mysql也不太可能使用它。</p><p></p><p>
            The average value group size is related to table cardinality,
            which is the number of value groups. The
            <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> statement displays a
            cardinality value based on <em class="replaceable"><code>N/S</code></em>, where
            <em class="replaceable"><code>N</code></em> is the number of rows in the table
            and <em class="replaceable"><code>S</code></em> is the average value group
            size. That ratio yields an approximate number of value groups in
            the table.
        </p><p style="color:blue;">平均值组大小与表基数有关，表基数是值组的数目。show index语句显示基于n/s的基数值，其中n是表中的行数，s是平均值组大小。该比率在表中产生近似数量的值组。</p><p></p><p>
            For a join based on the <code class="literal">&lt;=&gt;</code> comparison
            operator, <code class="literal">NULL</code> is not treated differently
            from any other value: <code class="literal">NULL &lt;=&gt; NULL</code>,
            just as <code class="literal"><em class="replaceable"><code>N</code></em> &lt;=&gt;
            <em class="replaceable"><code>N</code></em></code> for any other
            <em class="replaceable"><code>N</code></em>.
        </p><p style="color:blue;">对于基于&lt;=&gt;比较运算符的联接，对null的处理与对任何其他值的处理没有区别：null&lt;=&gt;null，就像对任何其他n的n&lt;=&gt;n一样。</p><p></p><p>
            However, for a join based on the <code class="literal">=</code> operator,
            <code class="literal">NULL</code> is different from
            non-<code class="literal">NULL</code> values:
            <code class="literal"><em class="replaceable"><code>expr1</code></em> =
                <em class="replaceable"><code>expr2</code></em></code> is not true when
            <em class="replaceable"><code>expr1</code></em> or
            <em class="replaceable"><code>expr2</code></em> (or both) are
            <code class="literal">NULL</code>. This affects
            <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> accesses for comparisons
            of the form <code class="literal"><em class="replaceable"><code>tbl_name.key</code></em> =
            <em class="replaceable"><code>expr</code></em></code>: MySQL will not access
            the table if the current value of
            <em class="replaceable"><code>expr</code></em> is <code class="literal">NULL</code>,
            because the comparison cannot be true.
        </p><p style="color:blue;">但是，对于基于=运算符的联接，空值与非空值不同：当expr1或expr2（或两者）为空时，expr1=expr2不为真。这会影响tbl_name.key=expr格式比较的ref访问：如果expr的当前值为空，mysql将不访问表，因为比较不能为真。</p><p></p><p>
            For <code class="literal">=</code> comparisons, it does not matter how
            many <code class="literal">NULL</code> values are in the table. For
            optimization purposes, the relevant value is the average size of
            the non-<code class="literal">NULL</code> value groups. However, MySQL
            does not currently enable that average size to be collected or
            used.
        </p><p style="color:blue;">对于=比较，表中有多少空值并不重要。出于优化目的，相关值是非空值组的平均大小。但是，mysql目前不支持收集或使用该平均大小。</p><p></p><p>
            For <code class="literal">InnoDB</code> and <code class="literal">MyISAM</code>
            tables, you have some control over collection of table
            statistics by means of the
            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method"><code class="literal">innodb_stats_method</code></a> and
            <a class="link" href="server-administration.html#sysvar_myisam_stats_method"><code class="literal">myisam_stats_method</code></a> system
            variables, respectively. These variables have three possible
            values, which differ as follows:
        </p><p style="color:blue;">对于innodb和myisam表，可以分别通过innodb_stats_方法和myisam_stats_方法系统变量来控制表统计信息的收集。这些变量有三个可能的值，它们的区别如下：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    When the variable is set to <code class="literal">nulls_equal</code>,
                    all <code class="literal">NULL</code> values are treated as identical
                    (that is, they all form a single value group).
                </p><p style="color:blue;">当变量设置为nulls_equal时，所有的空值都被视为相同的（即，它们都形成一个值组）。</p><p></p><p>
                    If the <code class="literal">NULL</code> value group size is much
                    higher than the average non-<code class="literal">NULL</code> value
                    group size, this method skews the average value group size
                    upward. This makes index appear to the optimizer to be less
                    useful than it really is for joins that look for
                    non-<code class="literal">NULL</code> values. Consequently, the
                    <code class="literal">nulls_equal</code> method may cause the
                    optimizer not to use the index for
                    <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> accesses when it
                    should.
                </p><p style="color:blue;">如果空值组大小远高于平均非空值组大小，则此方法会将平均值组大小向上倾斜。这使得在优化器看来，索引的用处比查找非空值的联接的用处要小。因此，nulls_equal方法可能会导致优化器在需要时不使用索引进行ref访问。</p><p></p></li><li class="listitem"><p>
                    When the variable is set to
                    <code class="literal">nulls_unequal</code>, <code class="literal">NULL</code>
                    values are not considered the same. Instead, each
                    <code class="literal">NULL</code> value forms a separate value group
                    of size 1.
                </p><p style="color:blue;">当变量设置为nulls_不等时，将不认为空值相同。相反，每个空值形成一个大小为1的单独值组。</p><p></p><p>
                    If you have many <code class="literal">NULL</code> values, this method
                    skews the average value group size downward. If the average
                    non-<code class="literal">NULL</code> value group size is large,
                    counting <code class="literal">NULL</code> values each as a group of
                    size 1 causes the optimizer to overestimate the value of the
                    index for joins that look for non-<code class="literal">NULL</code>
                    values. Consequently, the <code class="literal">nulls_unequal</code>
                    method may cause the optimizer to use this index for
                    <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> lookups when other
                    methods may be better.
                </p><p style="color:blue;">如果有许多空值，此方法会向下倾斜平均值组大小。如果平均非空值组大小较大，将每个空值作为大小为1的组进行计数会导致优化器高估查找非空值的联接的索引值。因此，当其他方法可能更好时，nulls_不等的方法可能会导致优化器使用此索引进行ref查找。</p><p></p></li><li class="listitem"><p>
                    When the variable is set to
                    <code class="literal">nulls_ignored</code>, <code class="literal">NULL</code>
                    values are ignored.
                </p><p style="color:blue;">当变量设置为nulls_ignored时，将忽略空值。</p><p></p></li></ul>
            </div>
            <p>
                If you tend to use many joins that use
                <code class="literal">&lt;=&gt;</code> rather than <code class="literal">=</code>,
                <code class="literal">NULL</code> values are not special in comparisons
                and one <code class="literal">NULL</code> is equal to another. In this
                case, <code class="literal">nulls_equal</code> is the appropriate
                statistics method.
            </p><p style="color:blue;">如果您倾向于使用多个使用&lt;=&gt;而不是=的连接，那么空值在比较中并不特殊，一个空值等于另一个空值。在这种情况下，nulls_equal是适当的统计方法。</p><p></p><p>
            The <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method"><code class="literal">innodb_stats_method</code></a> system
            variable has a global value; the
            <a class="link" href="server-administration.html#sysvar_myisam_stats_method"><code class="literal">myisam_stats_method</code></a> system
            variable has both global and session values. Setting the global
            value affects statistics collection for tables from the
            corresponding storage engine. Setting the session value affects
            statistics collection only for the current client connection.
            This means that you can force a table's statistics to be
            regenerated with a given method without affecting other clients
            by setting the session value of
            <a class="link" href="server-administration.html#sysvar_myisam_stats_method"><code class="literal">myisam_stats_method</code></a>.
        </p><p style="color:blue;">innodb_stats_method系统变量具有全局值；myisam_stats_method系统变量具有全局值和会话值。设置全局值会影响来自相应存储引擎的表的统计信息收集。设置会话值仅影响当前客户端连接的统计信息收集。这意味着您可以通过设置myisam_stats_方法的会话值，强制使用给定方法重新生成表的统计信息，而不影响其他客户机。</p><p></p><p>
            To regenerate <code class="literal">MyISAM</code> table statistics, you
            can use any of the following methods:
        </p><p style="color:blue;">要重新生成myisam表统计信息，可以使用以下任何方法：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Execute <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk
            --stats_method=<em class="replaceable"><code>method_name</code></em>
            --analyze</strong></span></a>
                </p><p style="color:blue;">执行myisamchk--stats_method=method_name--analyze</p><p></p></li><li class="listitem"><p>
                    Change the table to cause its statistics to go out of date
                    (for example, insert a row and then delete it), and then set
                    <a class="link" href="server-administration.html#sysvar_myisam_stats_method"><code class="literal">myisam_stats_method</code></a> and
                    issue an <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>
                    statement
                </p><p style="color:blue;">更改表以使其统计信息过期（例如，插入一行，然后删除它），然后设置myisam_stats_方法并发出analyze table语句</p><p></p></li></ul>
            </div>
            <p>
                Some caveats regarding the use of
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method"><code class="literal">innodb_stats_method</code></a> and
                <a class="link" href="server-administration.html#sysvar_myisam_stats_method"><code class="literal">myisam_stats_method</code></a>:
            </p><p style="color:blue;">关于使用innodb_stats_方法和myisam_stats_方法的一些注意事项：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    You can force table statistics to be collected explicitly,
                    as just described. However, MySQL may also collect
                    statistics automatically. For example, if during the course
                    of executing statements for a table, some of those
                    statements modify the table, MySQL may collect statistics.
                    (This may occur for bulk inserts or deletes, or some
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> statements, for
                    example.) If this happens, the statistics are collected
                    using whatever value
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method"><code class="literal">innodb_stats_method</code></a> or
                    <a class="link" href="server-administration.html#sysvar_myisam_stats_method"><code class="literal">myisam_stats_method</code></a> has at
                    the time. Thus, if you collect statistics using one method,
                    but the system variable is set to the other method when a
                    table's statistics are collected automatically later, the
                    other method will be used.
                </p><p style="color:blue;">如前所述，可以强制显式收集表统计信息。不过，mysql也可以自动收集统计数据。例如，如果在执行表语句的过程中，其中一些语句修改了表，mysql可能会收集统计信息。（例如，这可能发生在大容量插入或删除，或某些alter table语句中。）如果发生这种情况，则使用innodb_stats_method或myisam_stats_method当时的任何值来收集统计信息。因此，如果使用一种方法收集统计信息，但在以后自动收集表的统计信息时，系统变量设置为另一种方法，则将使用另一种方法。</p><p></p></li><li class="listitem"><p>
                    There is no way to tell which method was used to generate
                    statistics for a given table.
                </p><p style="color:blue;">无法判断哪个方法用于生成给定表的统计信息。</p><p></p></li><li class="listitem"><p>
                    These variables apply only to <code class="literal">InnoDB</code> and
                    <code class="literal">MyISAM</code> tables. Other storage engines have
                    only one method for collecting table statistics. Usually it
                    is closer to the <code class="literal">nulls_equal</code> method.
                </p><p style="color:blue;">这些变量仅适用于innodb和myisam表。其他存储引擎只有一种收集表统计信息的方法。通常它更接近于nulls_equal方法。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="index-btree-hash"></a>8.3.8&nbsp;Comparison of B-Tree and Hash Indexes</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286873269680"></a><a class="indexterm" name="idm140286873268640"></a><p>
            Understanding the B-tree and hash data structures can help
            predict how different queries perform on different storage
            engines that use these data structures in their indexes,
            particularly for the <code class="literal">MEMORY</code> storage engine
            that lets you choose B-tree or hash indexes.
        </p><p style="color:blue;">了解b树和散列数据结构有助于预测在索引中使用这些数据结构的不同存储引擎上不同查询的执行情况，特别是对于允许您选择b树或散列索引的内存存储引擎。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#btree-index-characteristics" title="B-Tree Index Characteristics">B-Tree Index Characteristics</a></p><p style="color:blue;">b-树索引特征</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#hash-index-characteristics" title="Hash Index Characteristics">Hash Index Characteristics</a></p><p style="color:blue;">哈希索引特性</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="btree-index-characteristics"></a>B-Tree Index Characteristics</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286873262608"></a><a class="indexterm" name="idm140286873261120"></a><a class="indexterm" name="idm140286873259632"></a><a class="indexterm" name="idm140286873258144"></a><p>
                A B-tree index can be used for column comparisons in
                expressions that use the
                <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a>,
                <a class="link" href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
                <a class="link" href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
                <a class="link" href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
                <a class="link" href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
                or <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a> operators. The index
                also can be used for <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a>
                comparisons if the argument to
                <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> is a constant string that
                does not start with a wildcard character. For example, the
                following <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements use
                indexes:
            </p><p style="color:blue;">B树索引可用于使用=、&gt;、&gt;=、&lt;、&lt;=、或运算符之间的表达式中的列比较。如果LIKE的参数是不以通配符开头的常量字符串，则该索引也可用于LIKE比较。例如，以下select语句使用索引：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'Patrick%';
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'Pat%_ck%';
</pre><p>
                In the first statement, only rows with <code class="literal">'Patrick'
                &lt;= <em class="replaceable"><code>key_col</code></em> &lt;
                'Patricl'</code> are considered. In the second statement,
                only rows with <code class="literal">'Pat' &lt;=
                <em class="replaceable"><code>key_col</code></em> &lt; 'Pau'</code> are
                considered.
            </p><p style="color:blue;">在第一个语句中，只考虑“patrick”&lt;=键列&lt;'patricl'的行。在第二条语句中，只考虑“pat”&lt;=键列&lt;'pau'的行。</p><p></p><p>
                The following <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements
                do not use indexes:
            </p><p style="color:blue;">以下select语句不使用索引：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE '%Patrick%';
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE <em class="replaceable"><code>other_col</code></em>;
</pre><p>
                In the first statement, the <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a>
                value begins with a wildcard character. In the second
                statement, the <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a> value is not
                a constant.
            </p><p style="color:blue;">在第一条语句中，like值以通配符开头。在第二个语句中，like值不是常量。</p><p></p><p>
                If you use <code class="literal">... LIKE
                '%<em class="replaceable"><code>string</code></em>%'</code> and
                <em class="replaceable"><code>string</code></em> is longer than three
                characters, MySQL uses the <span class="firstterm">Turbo
          Boyer-Moore algorithm</span> to initialize the pattern for
                the string and then uses this pattern to perform the search
                more quickly.
            </p><p style="color:blue;">如果你用…像'%string%'和string超过三个字符一样，mysql使用turboyer-moore算法初始化字符串的模式，然后使用此模式更快地执行搜索。</p><p></p><a class="indexterm" name="idm140286873228352"></a><a class="indexterm" name="idm140286873226864"></a><p>
                A search using <code class="literal"><em class="replaceable"><code>col_name</code></em> IS
                NULL</code> employs indexes if
                <em class="replaceable"><code>col_name</code></em> is indexed.
            </p><p style="color:blue;">如果对col_name进行索引，则使用col_name的搜索为空将使用索引。</p><p></p><p>
                Any index that does not span all
                <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a> levels in the
                <code class="literal">WHERE</code> clause is not used to optimize the
                query. In other words, to be able to use an index, a prefix of
                the index must be used in every
                <a class="link" href="functions.html#operator_and"><code class="literal">AND</code></a> group.
            </p><p style="color:blue;">不跨越where子句中所有和级别的任何索引都不用于优化查询。换句话说，要能够使用索引，必须在every和group中使用索引的前缀。</p><p></p><p>
                The following <code class="literal">WHERE</code> clauses use indexes:
            </p><p style="color:blue;">以下where子句使用索引：</p><p></p><pre data-lang="sql" class="programlisting">... WHERE <em class="replaceable"><code>index_part1</code></em>=1 AND <em class="replaceable"><code>index_part2</code></em>=2 AND <em class="replaceable"><code>other_column</code></em>=3

    /* <em class="replaceable"><code>index</code></em> = 1 OR <em class="replaceable"><code>index</code></em> = 2 */
... WHERE <em class="replaceable"><code>index</code></em>=1 OR A=10 AND <em class="replaceable"><code>index</code></em>=2

    /* optimized like "<em class="replaceable"><code>index_part1</code></em>='hello'" */
... WHERE <em class="replaceable"><code>index_part1</code></em>='hello' AND <em class="replaceable"><code>index_part3</code></em>=5

    /* Can use index on <em class="replaceable"><code>index1</code></em> but not on <em class="replaceable"><code>index2</code></em> or <em class="replaceable"><code>index3</code></em> */
... WHERE <em class="replaceable"><code>index1</code></em>=1 AND <em class="replaceable"><code>index2</code></em>=2 OR <em class="replaceable"><code>index1</code></em>=3 AND <em class="replaceable"><code>index3</code></em>=3;
</pre><p>
                These <code class="literal">WHERE</code> clauses do
                <span class="emphasis"><em>not</em></span> use indexes:
            </p><p style="color:blue;">这些where子句不使用索引：</p><p></p><pre data-lang="sql" class="programlisting">    /* <em class="replaceable"><code>index_part1</code></em> is not used */
... WHERE <em class="replaceable"><code>index_part2</code></em>=1 AND <em class="replaceable"><code>index_part3</code></em>=2

    /*  Index is not used in both parts of the WHERE clause  */
... WHERE <em class="replaceable"><code>index</code></em>=1 OR A=10

    /* No index spans all rows  */
... WHERE <em class="replaceable"><code>index_part1</code></em>=1 OR <em class="replaceable"><code>index_part2</code></em>=10
</pre><p>
                Sometimes MySQL does not use an index, even if one is
                available. One circumstance under which this occurs is when
                the optimizer estimates that using the index would require
                MySQL to access a very large percentage of the rows in the
                table. (In this case, a table scan is likely to be much faster
                because it requires fewer seeks.) However, if such a query
                uses <code class="literal">LIMIT</code> to retrieve only some of the
                rows, MySQL uses an index anyway, because it can much more
                quickly find the few rows to return in the result.
            </p><p style="color:blue;">有时mysql不使用索引，即使索引是可用的。出现这种情况的一种情况是，优化器估计使用索引将需要mysql访问表中很大一部分行。（在这种情况下，表扫描可能要快得多，因为它需要更少的seek。）但是，如果这样的查询只使用limit来检索某些行，mysql无论如何都会使用索引，因为它可以更快地找到返回结果中的几行。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="hash-index-characteristics"></a>Hash Index Characteristics</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286873201712"></a><p>
                Hash indexes have somewhat different characteristics from
                those just discussed:
            </p><p style="color:blue;">哈希索引与刚才讨论的有些不同：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        They are used only for equality comparisons that use the
                        <code class="literal">=</code> or <code class="literal">&lt;=&gt;</code>
                        operators (but are <span class="emphasis"><em>very</em></span> fast). They
                        are not used for comparison operators such as
                        <code class="literal">&lt;</code> that find a range of values.
                        Systems that rely on this type of single-value lookup are
                        known as <span class="quote">“<span class="quote">key-value stores</span>”</span>; to use MySQL for
                        such applications, use hash indexes wherever possible.
                    </p><p style="color:blue;">它们仅用于使用=或&lt;=&gt;运算符的等式比较（但速度非常快）。它们不用于查找值范围的比较运算符，如&lt;。依赖这种单值查找的系统被称为“键值存储”；要将mysql用于此类应用程序，请尽可能使用散列索引。</p><p></p></li><li class="listitem"><p>
                        The optimizer cannot use a hash index to speed up
                        <code class="literal">ORDER BY</code> operations. (This type of
                        index cannot be used to search for the next entry in
                        order.)
                    </p><p style="color:blue;">优化器不能使用哈希索引来加速按顺序操作。（此类型的索引不能用于按顺序搜索下一个条目。）</p><p></p></li><li class="listitem"><p>
                        MySQL cannot determine approximately how many rows there
                        are between two values (this is used by the range
                        optimizer to decide which index to use). This may affect
                        some queries if you change a <code class="literal">MyISAM</code> or
                        <code class="literal">InnoDB</code> table to a hash-indexed
                        <code class="literal">MEMORY</code> table.
                    </p><p style="color:blue;">mysql无法确定两个值之间大约有多少行（范围优化器使用这来决定要使用哪个索引）。如果将myisam或innodb表更改为哈希索引内存表，这可能会影响某些查询。</p><p></p></li><li class="listitem"><p>
                        Only whole keys can be used to search for a row. (With a
                        B-tree index, any leftmost prefix of the key can be used
                        to find rows.)
                    </p><p style="color:blue;">只能使用整个键来搜索行。（对于b树索引，可以使用键的最左边的前缀来查找行。）</p><p></p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="index-extensions"></a>8.3.9&nbsp;Use of Index Extensions</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286873188288"></a><p>
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> automatically extends each
            secondary index by appending the primary key columns to it.
            Consider this table definition:
        </p><p style="color:blue;">innodb通过向每个二级索引追加主键列来自动扩展它。考虑下这个表定义：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
  i1 INT NOT NULL DEFAULT 0,
  i2 INT NOT NULL DEFAULT 0,
  d DATE DEFAULT NULL,
  PRIMARY KEY (i1, i2),
  INDEX k_d (d)
) ENGINE = InnoDB;
</pre><p>
            This table defines the primary key on columns <code class="literal">(i1,
            i2)</code>. It also defines a secondary index
            <code class="literal">k_d</code> on column <code class="literal">(d)</code>, but
            internally <code class="literal">InnoDB</code> extends this index and
            treats it as columns <code class="literal">(d, i1, i2)</code>.
        </p><p style="color:blue;">此表定义列（I1、I2）上的主键。它还在列（d）上定义了一个二级索引k_d，但在内部innodb扩展了这个索引并将其视为列（d，i1，i2）。</p><p></p><p>
            The optimizer takes into account the primary key columns of the
            extended secondary index when determining how and whether to use
            that index. This can result in more efficient query execution
            plans and better performance.
        </p><p style="color:blue;">优化器在确定如何以及是否使用扩展的辅助索引时，会考虑扩展的辅助索引的主键列。这将导致更高效的查询执行计划和更好的性能。</p><p></p><p>
            The optimizer can use extended secondary indexes for
            <code class="literal">ref</code>, <code class="literal">range</code>, and
            <code class="literal">index_merge</code> index access, for Loose Index
            Scan access, for join and sorting optimization, and for
            <a class="link" href="functions.html#function_min"><code class="literal">MIN()</code></a>/<a class="link" href="functions.html#function_max"><code class="literal">MAX()</code></a>
            optimization.
        </p><p style="color:blue;">优化器可以对ref、range和index_merge索引访问、松散索引扫描访问、连接和排序优化以及min（）/max（）优化使用扩展的辅助索引。</p><p></p><p>
            The following example shows how execution plans are affected by
            whether the optimizer uses extended secondary indexes. Suppose
            that <code class="literal">t1</code> is populated with these rows:
        </p><p style="color:blue;">下面的示例演示了优化器是否使用扩展的辅助索引对执行计划的影响。假设T1填充了这些行：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO t1 VALUES
(1, 1, '1998-01-01'), (1, 2, '1999-01-01'),
(1, 3, '2000-01-01'), (1, 4, '2001-01-01'),
(1, 5, '2002-01-01'), (2, 1, '1998-01-01'),
(2, 2, '1999-01-01'), (2, 3, '2000-01-01'),
(2, 4, '2001-01-01'), (2, 5, '2002-01-01'),
(3, 1, '1998-01-01'), (3, 2, '1999-01-01'),
(3, 3, '2000-01-01'), (3, 4, '2001-01-01'),
(3, 5, '2002-01-01'), (4, 1, '1998-01-01'),
(4, 2, '1999-01-01'), (4, 3, '2000-01-01'),
(4, 4, '2001-01-01'), (4, 5, '2002-01-01'),
(5, 1, '1998-01-01'), (5, 2, '1999-01-01'),
(5, 3, '2000-01-01'), (5, 4, '2001-01-01'),
(5, 5, '2002-01-01');
</pre><p>
            Now consider this query:
        </p><p style="color:blue;">现在考虑这个查询：</p><p></p><pre data-lang="sql" class="programlisting">EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'
</pre><p>
            The execution plan depends on whether the extended index is
            used.
        </p><p style="color:blue;">执行计划取决于是否使用扩展索引。</p><p></p><p>
            When the optimizer does not consider index extensions, it treats
            the index <code class="literal">k_d</code> as only <code class="literal">(d)</code>.
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> for the query produces
            this result:
        </p><p style="color:blue;">当优化器不考虑索引扩展时，它只将索引k_d视为（d）。解释查询将生成以下结果：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ref
possible_keys: PRIMARY,k_d
          key: k_d
      key_len: 4
          ref: const
         rows: 5
        Extra: Using where; Using index
</pre><p>
            When the optimizer takes index extensions into account, it
            treats <code class="literal">k_d</code> as <code class="literal">(d, i1, i2)</code>.
            In this case, it can use the leftmost index prefix <code class="literal">(d,
            i1)</code> to produce a better execution plan:
        </p><p style="color:blue;">当优化器考虑索引扩展时，它将k_d视为（d，i1，i2）。在这种情况下，它可以使用最左边的索引前缀（d，i1）来生成更好的执行计划：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ref
possible_keys: PRIMARY,k_d
          key: k_d
      key_len: 8
          ref: const,const
         rows: 1
        Extra: Using index
</pre><p>
            In both cases, <code class="literal">key</code> indicates that the
            optimizer will use secondary index <code class="literal">k_d</code> but
            the <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output shows these
            improvements from using the extended index:
        </p><p style="color:blue;">在这两种情况下，key表示优化器将使用辅助索引k_d，但是explain输出显示了使用扩展索引的这些改进：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">key_len</code> goes from 4 bytes to 8 bytes,
                    indicating that key lookups use columns <code class="literal">d</code>
                    and <code class="literal">i1</code>, not just <code class="literal">d</code>.
                </p><p style="color:blue;">key_len从4字节变为8字节，表示键查找使用列d和i1，而不仅仅是d。</p><p></p></li><li class="listitem"><p>
                    The <code class="literal">ref</code> value changes from
                    <code class="literal">const</code> to <code class="literal">const,const</code>
                    because the key lookup uses two key parts, not one.
                </p><p style="color:blue;">ref值从const更改为const，const，因为密钥查找使用两个密钥部分，而不是一个。</p><p></p></li><li class="listitem"><p>
                    The <code class="literal">rows</code> count decreases from 5 to 1,
                    indicating that <code class="literal">InnoDB</code> should need to
                    examine fewer rows to produce the result.
                </p><p style="color:blue;">行数从5减少到1，这表明innodb需要检查更少的行才能产生结果。</p><p></p></li><li class="listitem"><p>
                    The <code class="literal">Extra</code> value changes from
                    <code class="literal">Using where; Using index</code> to
                    <code class="literal">Using index</code>. This means that rows can be
                    read using only the index, without consulting columns in the
                    data row.
                </p><p style="color:blue;">额外的值从使用where；使用index改为使用index。这意味着只能使用索引读取行，而不必查询数据行中的列。</p><p></p></li></ul>
            </div>
            <p>
                Differences in optimizer behavior for use of extended indexes
                can also be seen with <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW
                STATUS</code></a>:
            </p><p style="color:blue;">使用扩展索引时优化器行为的差异也可以通过show status看到：</p><p></p><pre data-lang="sql" class="programlisting">FLUSH TABLE t1;
FLUSH STATUS;
SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01';
SHOW STATUS LIKE 'handler_read%'
</pre><p>
            The preceding statements include <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH
            TABLES</code></a> and <a class="link" href="sql-syntax.html#flush-status"><code class="literal">FLUSH STATUS</code></a>
            to flush the table cache and clear the status counters.
        </p><p style="color:blue;">前面的语句包括flush tables和flush status以刷新表缓存并清除状态计数器。</p><p></p><p>
            Without index extensions, <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW
            STATUS</code></a> produces this result:
        </p><p style="color:blue;">如果没有索引扩展名，“显示状态”将生成以下结果：</p><p></p><pre data-lang="none" class="programlisting">+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 0     |
| Handler_read_key      | 1     |
| Handler_read_last     | 0     |
| Handler_read_next     | 5     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 0     |
+-----------------------+-------+
</pre><p>
            With index extensions, <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW
            STATUS</code></a> produces this result. The
            <a class="link" href="server-administration.html#statvar_Handler_read_next"><code class="literal">Handler_read_next</code></a> value
            decreases from 5 to 1, indicating more efficient use of the
            index:
        </p><p style="color:blue;">使用索引扩展名，“显示状态”将生成此结果。handler_read_next值从5减小到1，表示索引的使用效率更高：</p><p></p><pre data-lang="none" class="programlisting">+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 0     |
| Handler_read_key      | 1     |
| Handler_read_last     | 0     |
| Handler_read_next     | 1     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 0     |
+-----------------------+-------+
</pre><p>
            The <code class="literal">use_index_extensions</code> flag of the
            <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
            variable permits control over whether the optimizer takes the
            primary key columns into account when determining how to use an
            <code class="literal">InnoDB</code> table's secondary indexes. By default,
            <code class="literal">use_index_extensions</code> is enabled. To check
            whether disabling use of index extensions will improve
            performance, use this statement:
        </p><p style="color:blue;">optimizer_switch系统变量的use_index_extensions标志允许控制优化器在确定如何使用innodb表的辅助索引时是否考虑主键列。默认情况下，启用“使用索引扩展”。要检查禁用索引扩展是否会提高性能，请使用以下语句：</p><p></p><pre data-lang="sql" class="programlisting">SET optimizer_switch = 'use_index_extensions=off';
</pre><p>
            Use of index extensions by the optimizer is subject to the usual
            limits on the number of key parts in an index (16) and the
            maximum key length (3072 bytes).
        </p><p style="color:blue;">优化器使用索引扩展通常受到索引（16）中的关键部件数量和最大密钥长度（3072字节）的限制。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="generated-column-index-optimizations"></a>8.3.10&nbsp;Optimizer Use of Generated Column Indexes</h3>

                    </div>

                </div>

            </div>
            <p>
                MySQL supports indexes on generated columns. For example:
            </p><p style="color:blue;">mysql支持对生成的列进行索引。例如：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (f1 INT, gc INT AS (f1 + 1) STORED, INDEX (gc));
</pre><p>
            The generated column, <code class="literal">gc</code>, is defined as the
            expression <code class="literal">f1 + 1</code>. The column is also indexed
            and the optimizer can take that index into account during
            execution plan construction. In the following query, the
            <code class="literal">WHERE</code> clause refers to <code class="literal">gc</code>
            and the optimizer considers whether the index on that column
            yields a more efficient plan:
        </p><p style="color:blue;">生成的列gc被定义为表达式f1+1。列也被索引，优化器可以在执行计划构造期间考虑该索引。在下面的查询中，where子句引用gc，优化器考虑该列上的索引是否产生更有效的计划：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE gc &gt; 9;
</pre><p>
            The optimizer can use indexes on generated columns to generate
            execution plans, even in the absence of direct references in
            queries to those columns by name. This occurs if the
            <code class="literal">WHERE</code>, <code class="literal">ORDER BY</code>, or
            <code class="literal">GROUP BY</code> clause refers to an expression that
            matches the definition of some indexed generated column. The
            following query does not refer directly to <code class="literal">gc</code>
            but does use an expression that matches the definition of
            <code class="literal">gc</code>:
        </p><p style="color:blue;">优化器可以对生成的列使用索引来生成执行计划，即使查询中没有按名称直接引用这些列。如果where、order by或group by子句引用的表达式与某个索引生成列的定义匹配，则会发生这种情况。以下查询不直接引用GC，但使用的表达式与GC的定义匹配：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 WHERE f1 + 1 &gt; 9;
</pre><p>
            The optimizer recognizes that the expression <code class="literal">f1 +
            1</code> matches the definition of <code class="literal">gc</code> and
            that <code class="literal">gc</code> is indexed, so it considers that
            index during execution plan construction. You can see this using
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>:
        </p><p style="color:blue;">优化器识别出表达式f1+1与gc的定义匹配，并且gc被索引，因此它在执行计划构造期间考虑该索引。您可以使用explain:</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1 WHERE f1 + 1 &gt; 9\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: range
possible_keys: gc
          key: gc
      key_len: 5
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using index condition
</pre><p>
            In effect, the optimizer has replaced the expression <code class="literal">f1
            + 1</code> with the name of the generated column that matches
            the expression. That is also apparent in the rewritten query
            available in the extended <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>
            information displayed by <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
            WARNINGS</code></a>:
        </p><p style="color:blue;">实际上，优化器已经用生成的与表达式匹配的列的名称替换了表达式f1+1。这在“显示警告”显示的扩展解释信息中的重写查询中也很明显：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc`
         AS `gc` from `test`.`t1` where (`test`.`t1`.`gc` &gt; 9)
</pre><p>
            The following restrictions and conditions apply to the
            optimizer's use of generated column indexes:
        </p><p style="color:blue;">以下限制和条件适用于优化器使用生成的列索引：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For a query expression to match a generated column
                    definition, the expression must be identical and it must
                    have the same result type. For example, if the generated
                    column expression is <code class="literal">f1 + 1</code>, the
                    optimizer will not recognize a match if the query uses
                    <code class="literal">1 + f1</code>, or if <code class="literal">f1 + 1</code>
                    (an integer expression) is compared with a string.
                </p><p style="color:blue;">要使查询表达式与生成的列定义匹配，该表达式必须相同，并且必须具有相同的结果类型。例如，如果生成的列表达式是f1+1，则如果查询使用1+f1，或者如果f1+1（整数表达式）与字符串进行比较，优化器将无法识别匹配项。</p><p></p></li><li class="listitem"><p>
                    The optimization applies to these operators:
                    <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a>,
                    <a class="link" href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
                    <a class="link" href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
                    <a class="link" href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
                    <a class="link" href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
                    <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>, and
                    <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a>.
                </p><p style="color:blue;">优化适用于以下运算符：=，&lt;，&lt;=，&gt;，&gt;=，between，and in（）。</p><p></p><p>
                    For operators other than
                    <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a> and
                    <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a>, either operand can be
                    replaced by a matching generated column. For
                    <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a> and
                    <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a>, only the first argument
                    can be replaced by a matching generated column, and the
                    other arguments must have the same result type.
                    <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a> and
                    <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a> are not yet supported for
                    comparisons involving JSON values.
                </p><p style="color:blue;">对于除between和in（）之外的运算符，任何一个操作数都可以替换为匹配的生成列。对于between和in（），只有第一个参数可以替换为匹配的生成列，其他参数必须具有相同的结果类型。对于涉及json值的比较，还不支持between和in（）。</p><p></p></li><li class="listitem"><p>
                    The generated column must be defined as an expression that
                    contains at least a function call or one of the operators
                    mentioned in the preceding item. The expression cannot
                    consist of a simple reference to another column. For
                    example, <code class="literal">gc INT AS (f1) STORED</code> consists
                    only of a column reference, so indexes on
                    <code class="literal">gc</code> are not considered.
                </p><p style="color:blue;">生成的列必须定义为至少包含函数调用或上一项中提到的运算符之一的表达式。表达式不能包含对另一列的简单引用。例如，存储的gc int as（f1）只包含一个列引用，因此不考虑gc上的索引。</p><p></p></li><li class="listitem"><p>
                    For comparisons of strings to indexed generated columns that
                    compute a value from a JSON function that returns a quoted
                    string, <a class="link" href="functions.html#function_json-unquote"><code class="literal">JSON_UNQUOTE()</code></a> is
                    needed in the column definition to remove the extra quotes
                    from the function value. (For direct comparison of a string
                    to the function result, the JSON comparator handles quote
                    removal, but this does not occur for index lookups.) For
                    example, instead of writing a column definition like this:
                </p><p style="color:blue;">要将字符串与从返回带引号字符串的json函数计算值的索引生成列进行比较，需要在列定义中使用json_unquote（）从函数值中删除多余的引号。（为了将字符串直接与函数结果进行比较，json比较器处理引号的删除，但索引查找时不会发生这种情况。）例如，不要编写这样的列定义：</p><p></p><pre data-lang="sql" class="programlisting">doc_name TEXT AS (JSON_EXTRACT(jdoc, '$.name')) STORED
</pre><p>
                    Write it like this:
                </p><p style="color:blue;">这样写：</p><p></p><pre data-lang="sql" class="programlisting">doc_name TEXT AS (JSON_UNQUOTE(JSON_EXTRACT(jdoc, '$.name'))) STORED
</pre><p>
                    With the latter definition, the optimizer can detect a match
                    for both of these comparisons:
                </p><p style="color:blue;">使用后一种定义，优化器可以检测这两种比较的匹配：</p><p></p><pre data-lang="sql" class="programlisting">... WHERE JSON_EXTRACT(jdoc, '$.name') = '<em class="replaceable"><code>some_string</code></em>' ...
... WHERE JSON_UNQUOTE(JSON_EXTRACT(jdoc, '$.name')) = '<em class="replaceable"><code>some_string</code></em>' ...
</pre><p>
                    Without <a class="link" href="functions.html#function_json-unquote"><code class="literal">JSON_UNQUOTE()</code></a> in the
                    column definition, the optimizer detects a match only for
                    the first of those comparisons.
                </p><p style="color:blue;">如果列定义中没有json_unquote（），优化器只会在第一次比较中检测到匹配项。</p><p></p></li><li class="listitem"><p>
                    If the optimizer fails to choose the desired index, an index
                    hint can be used to force the optimizer to make a different
                    choice.
                </p><p style="color:blue;">如果优化器未能选择所需的索引，则可以使用索引提示来强制优化器做出不同的选择。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="timestamp-lookups"></a>8.3.11&nbsp;Indexed Lookups from TIMESTAMP Columns</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286873065472"></a><a class="indexterm" name="idm140286873064016"></a><p>
            Temporal values are stored in
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns as UTC values,
            and values inserted into and retrieved from
            <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> columns are converted
            between the session time zone and UTC. (This is the same type of
            conversion performed by the
            <a class="link" href="functions.html#function_convert-tz"><code class="literal">CONVERT_TZ()</code></a> function. If the
            session time zone is UTC, there is effectively no time zone
            conversion.)
        </p><p style="color:blue;">时间值作为UTC值存储在时间戳列中，插入时间戳列和从时间戳列中检索的值在会话时区和UTC之间转换。（这与convert_tz（）函数执行的转换类型相同。如果会话时区是UTC，则实际上没有时区转换。）</p><p></p><a class="indexterm" name="idm140286873058096"></a><p>
            Due to conventions for local time zone changes such as Daylight
            Saving Time (DST), conversions between UTC and non-UTC time
            zones are not one-to-one in both directions. UTC values that are
            distinct may not be distinct in another time zone. The following
            example shows distinct UTC values that become identical in a
            non-UTC time zone:
        </p><p style="color:blue;">由于本地时区更改（如夏令时（DST））的约定，UTC时区和非UTC时区之间的转换在两个方向上不是一对一的。不同的UTC值在另一时区可能不不同。以下示例显示在非UTC时区中变得相同的不同UTC值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE tstable (ts TIMESTAMP);</code></strong>
mysql&gt; <strong class="userinput"><code>SET time_zone = 'UTC'; -- insert UTC values</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO tstable VALUES</code></strong>
       <strong class="userinput"><code>('2018-10-28 00:30:00'),</code></strong>
       <strong class="userinput"><code>('2018-10-28 01:30:00');</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable;</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 00:30:00 |
| 2018-10-28 01:30:00 |
+---------------------+
mysql&gt; <strong class="userinput"><code>SET time_zone = 'MET'; -- retrieve non-UTC values</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable;</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
</pre>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    To use named time zones such as <code class="literal">'MET'</code> or
                    <code class="literal">'Europe/Amsterdam'</code>, the time zone tables
                    must be properly set up. For instructions, see
                    <a class="xref" href="server-administration.html#time-zone-support" title="5.1.12&nbsp;MySQL Server Time Zone Support">Section&nbsp;5.1.12, “MySQL Server Time Zone Support”</a>.
                </p><p style="color:blue;">要使用命名时区，如“met”或“europe/amsterdam”，必须正确设置时区表。有关说明，请参阅第5.1.12节“MySQL服务器时区支持”。</p><p></p>
            </div>
            <p>
                You can see that the two distinct UTC values are the same when
                converted to the <code class="literal">'MET'</code> time zone. This
                phenomenon can lead to different results for a given
                <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column query, depending
                on whether the optimizer uses an index to execute the query.
            </p><p style="color:blue;">您可以看到，当转换到“met”时区时，两个不同的UTC值是相同的。根据优化器是否使用索引执行查询，这种现象可能导致给定时间戳列查询的不同结果。</p><p></p><p>
            Suppose that a query selects values from the table shown earlier
            using a <code class="literal">WHERE</code> clause to search the
            <code class="literal">ts</code> column for a single specific value such as
            a user-provided timestamp literal:
        </p><p style="color:blue;">假设查询使用where子句从前面显示的表中选择值，以便在ts列中搜索单个特定值，例如用户提供的时间戳文本：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ts FROM tstable
WHERE ts = '<em class="replaceable"><code>literal</code></em>';
</pre><p>
            Suppose further that the query executes under these conditions:
        </p><p style="color:blue;">进一步假设查询在以下条件下执行：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The session time zone is not UTC and has a DST shift. For
                    example:
                </p><p style="color:blue;">会话时区不是UTC，并且具有DST移位。例如：</p><p></p><pre data-lang="sql" class="programlisting">SET time_zone = 'MET';
</pre></li><li class="listitem"><p>
                    Unique UTC values stored in the
                    <a class="link" href="data-types.html#datetime" title="11.3.1&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">TIMESTAMP</code></a> column are not
                    unique in the session time zone due to DST shifts. (The
                    example shown earlier illustrates how this can occur.)
                </p><p style="color:blue;">由于DST移位，存储在“时间戳”列中的唯一UTC值在会话时区中不唯一。（前面显示的示例说明了这是如何发生的。）</p><p></p></li><li class="listitem"><p>
                    The query specifies a search value that is within the hour
                    of entry into DST in the session time zone.
                </p><p style="color:blue;">查询指定在会话时区中进入DST的小时内的搜索值。</p><p></p></li></ul>
            </div>
            <p>
                Under those conditions, the comparison in the
                <code class="literal">WHERE</code> clause occurs in different ways for
                nonindexed and indexed lookups and leads to different results:
            </p><p style="color:blue;">在这些条件下，where子句中的比较以不同的方式出现在非索引和索引查找中，并导致不同的结果：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If there is no index or the optimizer cannot use it,
                    comparisons occur in the session time zone. The optimizer
                    performs a table scan in which it retrieves each
                    <code class="literal">ts</code> column value, converts it from UTC to
                    the session time zone, and compares it to the search value
                    (also interpreted in the session time zone):
                </p><p style="color:blue;">如果没有索引或优化器无法使用它，则会在会话时区中进行比较。优化器执行表扫描，在扫描中检索每个ts列值，将其从utc转换为会话时区，并将其与搜索值（也在会话时区中解释）进行比较：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable</code></strong>
       <strong class="userinput"><code>WHERE ts = '2018-10-28 02:30:00';</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
</pre><p>
                    Because the stored <code class="literal">ts</code> values are
                    converted to the session time zone, it is possible for the
                    query to return two timestamp values that are distinct as
                    UTC values but equal in the session time zone: One value
                    that occurs before the DST shift when clocks are changed,
                    and one value that was occurs after the DST shift.
                </p><p style="color:blue;">由于存储的ts值被转换为会话时区，查询可以返回两个不同于utc值但在会话时区中相等的时间戳值：一个值在更改时钟时发生在dst移位之前，另一个值在dst移位之后。</p><p></p></li><li class="listitem"><p>
                    If there is a usable index, comparisons occur in UTC. The
                    optimizer performs an index scan, first converting the
                    search value from the session time zone to UTC, then
                    comparing the result to the UTC index entries:
                </p><p style="color:blue;">如果有可用的索引，则以UTC格式进行比较。优化器执行索引扫描，首先将搜索值从会话时区转换为UTC，然后将结果与UTC索引项进行比较：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tstable ADD INDEX (ts);</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable</code></strong>
       <strong class="userinput"><code>WHERE ts = '2018-10-28 02:30:00';</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
+---------------------+
</pre><p>
                    In this case, the (converted) search value is matched only
                    to index entries, and because the index entries for the
                    distinct stored UTC values are also distinct, the search
                    value can match only one of them.
                </p><p style="color:blue;">在这种情况下，（转换的）搜索值仅与索引项匹配，并且由于不同存储的UTC值的索引项也不同，因此搜索值只能与其中一个匹配。</p><p></p></li></ul>
            </div>
            <p>
                Due to different optimizer operation for nonindexed and indexed
                lookups, the query produces different results in each case. The
                result from the nonindexed lookup returns all values that match
                in the session time zone. The indexed lookup cannot do so:
            </p><p style="color:blue;">由于针对无索引和索引查找的优化器操作不同，查询在每种情况下都会产生不同的结果。非索引查找的结果返回会话时区中匹配的所有值。索引查找无法执行此操作：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    It is performed within the storage engine, which knows only
                    about UTC values.
                </p><p style="color:blue;">它在存储引擎中执行，存储引擎只知道UTC值。</p><p></p></li><li class="listitem"><p>
                    For the two distinct session time zone values that map to
                    the same UTC value, the indexed lookup matches only the
                    corresponding UTC index entry and returns only a single row.
                </p><p style="color:blue;">对于映射到同一UTC值的两个不同会话时区值，索引查找只匹配相应的UTC索引项，并且只返回一行。</p><p></p></li></ul>
            </div>
            <p>
                In the preceding discussion, the data set stored in
                <code class="literal">tstable</code> happens to consist of distinct UTC
                values. In such cases, all index-using queries of the form shown
                match at most one index entry.
            </p><p style="color:blue;">在前面的讨论中，存储在tstable中的数据集碰巧由不同的utc值组成。在这种情况下，使用所示表单查询的所有索引最多只能匹配一个索引项。</p><p></p><p>
            If the index is not <code class="literal">UNIQUE</code>, it is possible
            for the table (and the index) to store multiple instances of a
            given UTC value. For example, the <code class="literal">ts</code> column
            might contain multiple instances of the UTC value
            <code class="literal">'2018-10-28 00:30:00'</code>. In this case, the
            index-using query would return each of them (converted to the
            MET value <code class="literal">'2018-10-28 02:30:00'</code> in the result
            set). It remains true that index-using queries match the
            converted search value to a single value in the UTC index
            entries, rather than matching multiple UTC values that convert
            to the search value in the session time zone.
        </p><p style="color:blue;">如果索引不唯一，则表（和索引）可以存储给定UTC值的多个实例。例如，TS列可能包含多个UTC值“2018-10-28 00:30:00”的实例。在这种情况下，使用query的索引将返回它们中的每一个（转换为结果集中的met值“2018-10-28 02:30:00”）。使用查询的索引将转换后的搜索值与utc索引项中的单个值匹配，而不是与会话时区中转换为搜索值的多个utc值匹配，这仍然是正确的。</p><p></p><p>
            If it is important to return all <code class="literal">ts</code> values
            that match in the session time zone, the workaround is to
            suppress use of the index with an <code class="literal">IGNORE
            INDEX</code> hint:
        </p><p style="color:blue;">如果必须返回会话时区中匹配的所有ts值，则解决方法是禁止使用带有忽略索引提示的索引：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ts FROM tstable</code></strong>
       <strong class="userinput"><code>IGNORE INDEX (ts)</code></strong>
       <strong class="userinput"><code>WHERE ts = '2018-10-28 02:30:00';</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
</pre><p>
            The same lack of one-to-one mapping for time zone conversions in
            both directions occurs in other contexts as well, such as
            conversions performed with the
            <a class="link" href="functions.html#function_from-unixtime"><code class="literal">FROM_UNIXTIME()</code></a> and
            <a class="link" href="functions.html#function_unix-timestamp"><code class="literal">UNIX_TIMESTAMP()</code></a> functions. See
            <a class="xref" href="functions.html#date-and-time-functions" title="12.7&nbsp;Date and Time Functions">Section&nbsp;12.7, “Date and Time Functions”</a>.
        </p><p style="color:blue;">在其他上下文中，也同样缺少双向时区转换的一对一映射，例如使用from_unix time（）和unix_timestamp（）函数执行的转换。见第12.7节“日期和时间功能”。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="optimizing-database-structure"></a>8.4&nbsp;Optimizing Database Structure</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#data-size">8.4.1 Optimizing Data Size</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-data-types">8.4.2 Optimizing MySQL Data Types</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-multi-tables">8.4.3 Optimizing for Many Tables</a></span></dt><dt><span class="section"><a href="optimization.html#internal-temporary-tables">8.4.4 Internal Temporary Table Use in MySQL</a></span></dt><dt><span class="section"><a href="optimization.html#database-count-limit">8.4.5 Limits on Number of Databases and Tables</a></span></dt><dt><span class="section"><a href="optimization.html#table-size-limit">8.4.6 Limits on Table Size</a></span></dt><dt><span class="section"><a href="optimization.html#column-count-limit">8.4.7 Limits on Table Column Count and Row Size</a></span></dt></dl>
        </div>
        <p>
            In your role as a database designer, look for the most efficient
            way to organize your schemas, tables, and columns. As when tuning
            application code, you minimize I/O, keep related items together,
            and plan ahead so that performance stays high as the data volume
            increases. Starting with an efficient database design makes it
            easier for team members to write high-performing application code,
            and makes the database likely to endure as applications evolve and
            are rewritten.
        </p><p style="color:blue;">作为数据库设计器，请寻找最有效的方式来组织架构、表和列。与优化应用程序代码一样，您可以最小化I/O，将相关项放在一起，并提前计划，以便随着数据量的增加，性能保持在较高的水平。从高效的数据库设计开始，团队成员可以更容易地编写高性能的应用程序代码，并且随着应用程序的发展和重写，数据库可能会一直存在。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="data-size"></a>8.4.1&nbsp;Optimizing Data Size</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286873001360"></a><a class="indexterm" name="idm140286872999872"></a><a class="indexterm" name="idm140286872998384"></a><a class="indexterm" name="idm140286872996896"></a><a class="indexterm" name="idm140286872995408"></a><p>
            Design your tables to minimize their space on the disk. This can
            result in huge improvements by reducing the amount of data
            written to and read from disk. Smaller tables normally require
            less main memory while their contents are being actively
            processed during query execution. Any space reduction for table
            data also results in smaller indexes that can be processed
            faster.
        </p><p style="color:blue;">设计表以最小化它们在磁盘上的空间。这可以通过减少写入和读取磁盘的数据量而带来巨大的改进。较小的表通常需要较少的主内存，而它们的内容在查询执行期间正被积极处理。表数据的任何空间缩减也会导致更小的索引，这些索引可以更快地处理。</p><p></p><p>
            MySQL supports many different storage engines (table types) and
            row formats. For each table, you can decide which storage and
            indexing method to use. Choosing the proper table format for
            your application can give you a big performance gain. See
            <a class="xref" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine">Chapter&nbsp;14, <i>The InnoDB Storage Engine</i></a>, and
            <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>.
        </p><p style="color:blue;">mysql支持许多不同的存储引擎（表类型）和行格式。对于每个表，您可以决定使用哪种存储和索引方法。为应用程序选择适当的表格式可以给您带来很大的性能提升。参见第14章，InnoDB存储引擎和第15章，替代存储引擎。</p><p></p><p>
            You can get better performance for a table and minimize storage
            space by using the techniques listed here:
        </p><p style="color:blue;">使用下面列出的技术，可以获得更好的表性能并最小化存储空间：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#data-size-table-columns" title="Table Columns">Table Columns</a></p><p style="color:blue;">表列</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#data-size-row-format" title="Row Format">Row Format</a></p><p style="color:blue;">行格式</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#data-size-indexes" title="Indexes">Indexes</a></p><p style="color:blue;">索引</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#data-size-joins" title="Joins">Joins</a></p><p style="color:blue;">连接</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#data-size-normalization" title="Normalization">Normalization</a></p><p style="color:blue;">标准化</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="data-size-table-columns"></a>Table Columns</h4>

                        </div>

                    </div>

                </div>

                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Use the most efficient (smallest) data types possible.
                        MySQL has many specialized types that save disk space and
                        memory. For example, use the smaller integer types if
                        possible to get smaller tables.
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a> is often a better
                        choice than <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">INT</code></a> because a
                        <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a> column uses 25%
                        less space.
                    </p><p style="color:blue;">尽可能使用最有效（最小）的数据类型。mysql有许多专门的类型，可以节省磁盘空间和内存。例如，如果可能，可以使用较小的整数类型来获取较小的表。mediumint通常是比int更好的选择，因为mediumint列使用的空间减少了25%。</p><p></p></li><li class="listitem"><p>
                        Declare columns to be <code class="literal">NOT NULL</code> if
                        possible. It makes SQL operations faster, by enabling
                        better use of indexes and eliminating overhead for testing
                        whether each value is <code class="literal">NULL</code>. You also
                        save some storage space, one bit per column. If you really
                        need <code class="literal">NULL</code> values in your tables, use
                        them. Just avoid the default setting that allows
                        <code class="literal">NULL</code> values in every column.
                    </p><p style="color:blue;">尽可能声明列不为空。它通过更好地使用索引和消除测试每个值是否为空的开销，使sql操作更快。您还节省了一些存储空间，每列一位。如果表中确实需要空值，请使用它们。只需避免在每一列中允许空值的默认设置。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="data-size-row-format"></a>Row Format</h4>

                        </div>

                    </div>

                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">InnoDB</code> tables are created using the
                        <code class="literal">DYNAMIC</code> row format by default. To use a
                        row format other than <code class="literal">DYNAMIC</code>,
                        configure
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_default_row_format"><code class="literal">innodb_default_row_format</code></a>,
                        or specify the <code class="literal">ROW_FORMAT</code> option
                        explicitly in a <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
                        TABLE</code></a> or <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                        TABLE</code></a> statement.
                    </p><p style="color:blue;">默认情况下，innodb表是使用动态行格式创建的。要使用动态以外的行格式，请配置innodb_default_row_format，或者在create table或alter table语句中显式指定row_format选项。</p><p></p><p>
                        The compact family of row formats, which includes
                        <code class="literal">COMPACT</code>, <code class="literal">DYNAMIC</code>,
                        and <code class="literal">COMPRESSED</code>, decreases row storage
                        space at the cost of increasing CPU use for some
                        operations. If your workload is a typical one that is
                        limited by cache hit rates and disk speed it is likely to
                        be faster. If it is a rare case that is limited by CPU
                        speed, it might be slower.
                    </p><p style="color:blue;">紧凑的行格式系列，包括紧凑、动态和压缩，以增加某些操作的CPU使用为代价减少行存储空间。如果您的工作负载是受缓存命中率和磁盘速度限制的典型工作负载，那么它可能更快。如果这是一个罕见的情况，受到CPU速度的限制，可能会比较慢。</p><p></p><p>
                        The compact family of row formats also optimizes
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> column storage when
                        using a variable-length character set such as
                        <code class="literal">utf8mb3</code> or <code class="literal">utf8mb4</code>.
                        With <code class="literal">ROW_FORMAT=REDUNDANT</code>,
                        <code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code>
                        occupies <em class="replaceable"><code>N</code></em> × the maximum
                        byte length of the character set. Many languages can be
                        written primarily using single-byte
                        <code class="literal">utf8</code> characters, so a fixed storage
                        length often wastes space. With the compact family of rows
                        formats, <code class="literal">InnoDB</code> allocates a variable
                        amount of storage in the range of
                        <em class="replaceable"><code>N</code></em> to
                        <em class="replaceable"><code>N</code></em> × the maximum byte
                        length of the character set for these columns by stripping
                        trailing spaces. The minimum storage length is
                        <em class="replaceable"><code>N</code></em> bytes to facilitate in-place
                        updates in typical cases. For more information, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                    </p><p style="color:blue;">当使用可变长度字符集（如utf8mb3或utf8mb4）时，压缩行格式系列还优化了字符列存储。使用RoWiFrase=冗余，CHAR（n）占用n×字符集的最大字节长度。许多语言可以主要使用单字节utf8字符来编写，因此固定的存储长度通常会浪费空间。使用紧凑的行族格式，YNODB通过剥离尾随空间，在N到N×的范围内分配可变量的存储，这些列的字符集的最大字节长度。最小存储长度为n字节，以便于在典型情况下进行就地更新。有关更多信息，请参阅14.11节，“InnoDB行格式”。</p><p></p></li><li class="listitem"><p>
                        To minimize space even further by storing table data in
                        compressed form, specify
                        <code class="literal">ROW_FORMAT=COMPRESSED</code> when creating
                        <code class="literal">InnoDB</code> tables, or run the
                        <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> command on an existing
                        <code class="literal">MyISAM</code> table.
                        (<code class="literal">InnoDB</code> compressed tables are readable
                        and writable, while <code class="literal">MyISAM</code> compressed
                        tables are read-only.)
                    </p><p style="color:blue;">通过以压缩形式存储表数据，可以进一步减小空间，在创建NYNDB表时指定RoWiFrase=压缩，或者在现有的MyISAM表上运行MyISAMPACK命令。（innodb压缩表是可读写的，myisam压缩表是只读的。）</p><p></p></li><li class="listitem"><p>
                        For <code class="literal">MyISAM</code> tables, if you do not have
                        any variable-length columns
                        (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>, or
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns), a fixed-size
                        row format is used. This is faster but may waste some
                        space. See <a class="xref" href="storage-engines.html#myisam-table-formats" title="15.2.3&nbsp;MyISAM Table Storage Formats">Section&nbsp;15.2.3, “MyISAM Table Storage Formats”</a>. You can
                        hint that you want to have fixed length rows even if you
                        have <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns with
                        the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> option
                        <code class="literal">ROW_FORMAT=FIXED</code>.
                    </p><p style="color:blue;">对于myisam表，如果没有任何可变长度的列（varchar、text或blob列），则使用固定大小的行格式。这样更快，但可能会浪费一些空间。见第15.2.3节，“myisam表存储格式”。您可以提示您希望有固定长度的行，即使您有带有create table选项row_format=fixed的varchar列。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="data-size-indexes"></a>Indexes</h4>

                        </div>

                    </div>

                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The primary index of a table should be as short as
                        possible. This makes identification of each row easy and
                        efficient. For <code class="literal">InnoDB</code> tables, the
                        primary key columns are duplicated in each secondary index
                        entry, so a short primary key saves considerable space if
                        you have many secondary indexes.
                    </p><p style="color:blue;">表的主索引应尽可能短。这使得每一行的标识变得简单高效。对于innodb表，主键列在每个二级索引项中都是重复的，因此如果有许多二级索引，一个短主键可以节省相当大的空间。</p><p></p></li><li class="listitem"><p>
                        Create only the indexes that you need to improve query
                        performance. Indexes are good for retrieval, but slow down
                        insert and update operations. If you access a table mostly
                        by searching on a combination of columns, create a single
                        composite index on them rather than a separate index for
                        each column. The first part of the index should be the
                        column most used. If you <span class="emphasis"><em>always</em></span> use
                        many columns when selecting from the table, the first
                        column in the index should be the one with the most
                        duplicates, to obtain better compression of the index.
                    </p><p style="color:blue;">只创建提高查询性能所需的索引。索引有利于检索，但会减慢插入和更新操作。如果主要通过搜索列的组合来访问表，请在这些列上创建单个组合索引，而不是为每一列创建单独的索引。索引的第一部分应该是最常用的列。如果从表中进行选择时总是使用许多列，则索引中的第一列应该是重复项最多的列，以获得更好的索引压缩。</p><p></p></li><li class="listitem"><p>
                        If it is very likely that a long string column has a
                        unique prefix on the first number of characters, it is
                        better to index only this prefix, using MySQL's support
                        for creating an index on the leftmost part of the column
                        (see <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>). Shorter indexes are
                        faster, not only because they require less disk space, but
                        because they also give you more hits in the index cache,
                        and thus fewer disk seeks. See
                        <a class="xref" href="server-administration.html#server-configuration" title="5.1.1&nbsp;Configuring the Server">Section&nbsp;5.1.1, “Configuring the Server”</a>.
                    </p><p style="color:blue;">如果很可能长字符串列在第一个字符数上有一个唯一的前缀，那么最好只对该前缀进行索引，使用mysql对在列最左侧创建索引的支持（请参阅第13.1.14节“创建索引语法”）。更短的索引更快，不仅因为它们需要更少的磁盘空间，还因为它们在索引缓存中提供了更多的命中率，从而减少了磁盘查找。参见第5.1.1节“配置服务器”。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="data-size-joins"></a>Joins</h4>

                        </div>

                    </div>

                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        In some circumstances, it can be beneficial to split into
                        two a table that is scanned very often. This is especially
                        true if it is a dynamic-format table and it is possible to
                        use a smaller static format table that can be used to find
                        the relevant rows when scanning the table.
                    </p><p style="color:blue;">在某些情况下，将经常扫描的表分成两部分是有益的。如果它是动态格式表，并且可以使用较小的静态格式表，以便在扫描表时查找相关行，则尤其如此。</p><p></p></li><li class="listitem"><p>
                        Declare columns with identical information in different
                        tables with identical data types, to speed up joins based
                        on the corresponding columns.
                    </p><p style="color:blue;">在具有相同数据类型的不同表中声明具有相同信息的列，以加快基于相应列的联接。</p><p></p></li><li class="listitem"><p>
                        Keep column names simple, so that you can use the same
                        name across different tables and simplify join queries.
                        For example, in a table named <code class="literal">customer</code>,
                        use a column name of <code class="literal">name</code> instead of
                        <code class="literal">customer_name</code>. To make your names
                        portable to other SQL servers, consider keeping them
                        shorter than 18 characters.
                    </p><p style="color:blue;">保持列名简单，以便在不同的表中使用相同的名称并简化联接查询。例如，在名为customer的表中，使用name的列名而不是customer_name。要使您的名称可移植到其他SQL服务器，请考虑将它们保持在18个字符以下。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="data-size-normalization"></a>Normalization</h4>

                        </div>

                    </div>

                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Normally, try to keep all data nonredundant (observing
                        what is referred to in database theory as
                        <span class="firstterm">third normal form</span>).
                        Instead of repeating lengthy values such as names and
                        addresses, assign them unique IDs, repeat these IDs as
                        needed across multiple smaller tables, and join the tables
                        in queries by referencing the IDs in the join clause.
                    </p><p style="color:blue;">通常，尝试保持所有数据都是非冗余的（观察数据库理论中称为第三种标准形式的内容）。不要重复冗长的值（如名称和地址），而是为它们分配唯一的id，根据需要在多个较小的表中重复这些id，并通过引用join子句中的id来连接查询中的表。</p><p></p></li><li class="listitem"><p>
                        If speed is more important than disk space and the
                        maintenance costs of keeping multiple copies of data, for
                        example in a business intelligence scenario where you
                        analyze all the data from large tables, you can relax the
                        normalization rules, duplicating information or creating
                        summary tables to gain more speed.
                    </p><p style="color:blue;">如果速度比磁盘空间和保留多个数据副本的维护成本更重要，例如在分析来自大型表的所有数据的商业智能场景中，可以放宽规范化规则、复制信息或创建摘要表以获得更高的速度。</p><p></p></li></ul>
                </div>

            </div>

        </div>

        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimize-data-types"></a>8.4.2&nbsp;Optimizing MySQL Data Types</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#optimize-numeric">8.4.2.1 Optimizing for Numeric Data</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-character">8.4.2.2 Optimizing for Character and String Types</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-blob">8.4.2.3 Optimizing for BLOB Types</a></span></dt><dt><span class="section"><a href="optimization.html#procedure-analyse">8.4.2.4 Using PROCEDURE ANALYSE</a></span></dt></dl>
            </div>

            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="optimize-numeric"></a>8.4.2.1&nbsp;Optimizing for Numeric Data</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286872914816"></a>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For unique IDs or other values that can be represented as
                        either strings or numbers, prefer numeric columns to
                        string columns. Since large numeric values can be stored
                        in fewer bytes than the corresponding strings, it is
                        faster and takes less memory to transfer and compare them.
                    </p><p style="color:blue;">对于可以表示为字符串或数字的唯一id或其他值，首选数字列而不是字符串列。由于大数值可以存储在比相应字符串更少的字节中，因此传输和比较它们的速度更快，占用的内存更少。</p><p></p></li><li class="listitem"><p>
                        If you are using numeric data, it is faster in many cases
                        to access information from a database (using a live
                        connection) than to access a text file. Information in the
                        database is likely to be stored in a more compact format
                        than in the text file, so accessing it involves fewer disk
                        accesses. You also save code in your application because
                        you can avoid parsing the text file to find line and
                        column boundaries.
                    </p><p style="color:blue;">如果使用的是数字数据，在许多情况下，从数据库访问信息（使用实时连接）比访问文本文件快。数据库中的信息可能以比文本文件更紧凑的格式存储，因此访问它需要更少的磁盘访问。还可以将代码保存在应用程序中，因为可以避免分析文本文件以查找行和列边界。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="optimize-character"></a>8.4.2.2&nbsp;Optimizing for Character and String Types</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286872909200"></a><p>
                For character and string columns, follow these guidelines:
            </p><p style="color:blue;">对于字符和字符串列，请遵循以下准则：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Use binary collation order for fast comparison and sort
                        operations, when you do not need language-specific
                        collation features. You can use the
                        <a class="link" href="functions.html#operator_binary"><code class="literal">BINARY</code></a> operator to use binary
                        collation within a particular query.
                    </p><p style="color:blue;">当不需要特定于语言的排序功能时，使用二进制排序顺序进行快速比较和排序操作。可以使用二进制运算符在特定查询中使用二进制排序规则。</p><p></p></li><li class="listitem"><p>
                        When comparing values from different columns, declare
                        those columns with the same character set and collation
                        wherever possible, to avoid string conversions while
                        running the query.
                    </p><p style="color:blue;">在比较来自不同列的值时，尽可能使用相同的字符集和排序规则声明这些列，以避免在运行查询时进行字符串转换。</p><p></p></li><li class="listitem"><p>
                        For column values less than 8KB in size, use binary
                        <code class="literal">VARCHAR</code> instead of
                        <code class="literal">BLOB</code>. The <code class="literal">GROUP BY</code>
                        and <code class="literal">ORDER BY</code> clauses can generate
                        temporary tables, and these temporary tables can use the
                        <code class="literal">MEMORY</code> storage engine if the original
                        table does not contain any <code class="literal">BLOB</code>
                        columns.
                    </p><p style="color:blue;">对于大小小于8KB的列值，请使用binary varchar而不是blob。GROUPBY和ORDERBY子句可以生成临时表，如果原始表不包含任何BLOB列，则这些临时表可以使用内存存储引擎。</p><p></p></li><li class="listitem"><p>
                        If a table contains string columns such as name and
                        address, but many queries do not retrieve those columns,
                        consider splitting the string columns into a separate
                        table and using join queries with a foreign key when
                        necessary. When MySQL retrieves any value from a row, it
                        reads a data block containing all the columns of that row
                        (and possibly other adjacent rows). Keeping each row
                        small, with only the most frequently used columns, allows
                        more rows to fit in each data block. Such compact tables
                        reduce disk I/O and memory usage for common queries.
                    </p><p style="color:blue;">如果表包含字符串列（如名称和地址），但许多查询不检索这些列，请考虑将字符串列拆分为单独的表，并在必要时使用带外键的联接查询。当mysql从一行中检索任何值时，它会读取包含该行所有列（可能还有其他相邻行）的数据块。保持每一行很小，只有最常用的列，可以在每个数据块中容纳更多的行。这样的压缩表减少了常见查询的磁盘I/O和内存使用。</p><p></p></li><li class="listitem"><p>
                        When you use a randomly generated value as a primary key
                        in an <code class="literal">InnoDB</code> table, prefix it with an
                        ascending value such as the current date and time if
                        possible. When consecutive primary values are physically
                        stored near each other, <code class="literal">InnoDB</code> can
                        insert and retrieve them faster.
                    </p><p style="color:blue;">在innodb表中使用随机生成的值作为主键时，如果可能的话，在它前面加上一个升序值，例如当前日期和时间。当连续的主值物理存储在彼此附近时，innodb可以更快地插入和检索它们。</p><p></p></li><li class="listitem"><p>
                        See <a class="xref" href="optimization.html#optimize-numeric" title="8.4.2.1&nbsp;Optimizing for Numeric Data">Section&nbsp;8.4.2.1, “Optimizing for Numeric Data”</a> for reasons why a
                        numeric column is usually preferable to an equivalent
                        string column.
                    </p><p style="color:blue;">参见第8.4.2.1节“数值数据优化”，了解数值列通常比等效字符串列更可取的原因。</p><p></p></li></ul>
                </div>

            </div>

            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="optimize-blob"></a>8.4.2.3&nbsp;Optimizing for BLOB Types</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286872891136"></a>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        When storing a large blob containing textual data,
                        consider compressing it first. Do not use this technique
                        when the entire table is compressed by
                        <code class="literal">InnoDB</code> or <code class="literal">MyISAM</code>.
                    </p><p style="color:blue;">存储包含文本数据的大blob时，请考虑先压缩它。当innodb或myisam压缩整个表时，不要使用此技术。</p><p></p></li><li class="listitem"><p>
                        For a table with several columns, to reduce memory
                        requirements for queries that do not use the BLOB column,
                        consider splitting the BLOB column into a separate table
                        and referencing it with a join query when needed.
                    </p><p style="color:blue;">对于具有多个列的表，若要减少不使用blob列的查询的内存需求，请考虑将blob列拆分为单独的表，并在需要时使用联接查询引用它。</p><p></p></li><li class="listitem"><p>
                        Since the performance requirements to retrieve and display
                        a BLOB value might be very different from other data
                        types, you could put the BLOB-specific table on a
                        different storage device or even a separate database
                        instance. For example, to retrieve a BLOB might require a
                        large sequential disk read that is better suited to a
                        traditional hard drive than to an
                        <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD device</a>.
                    </p><p style="color:blue;">由于检索和显示blob值的性能要求可能与其他数据类型非常不同，因此可以将blob特定的表放在不同的存储设备上，甚至放在单独的数据库实例上。例如，要检索blob，可能需要一个大的顺序磁盘读取，这比ssd设备更适合于传统硬盘驱动器。</p><p></p></li><li class="listitem"><p>
                        See <a class="xref" href="optimization.html#optimize-character" title="8.4.2.2&nbsp;Optimizing for Character and String Types">Section&nbsp;8.4.2.2, “Optimizing for Character and String Types”</a> for reasons why a
                        binary <code class="literal">VARCHAR</code> column is sometimes
                        preferable to an equivalent BLOB column.
                    </p><p style="color:blue;">请参阅8.4.2.2节，“字符和字符串类型优化”，了解为什么二进制varchar列有时比等效blob列更可取。</p><p></p></li><li class="listitem"><p>
                        Rather than testing for equality against a very long text
                        string, you can store a hash of the column value in a
                        separate column, index that column, and test the hashed
                        value in queries. (Use the <code class="literal">MD5()</code> or
                        <code class="literal">CRC32()</code> function to produce the hash
                        value.) Since hash functions can produce duplicate results
                        for different inputs, you still include a clause
                        <code class="literal">AND <em class="replaceable"><code>blob_column</code></em> =
                            <em class="replaceable"><code>long_string_value</code></em></code> in
                        the query to guard against false matches; the performance
                        benefit comes from the smaller, easily scanned index for
                        the hashed values.
                    </p><p style="color:blue;">您可以将列值的哈希值存储在单独的列中，为该列编制索引，并在查询中测试哈希值，而不是针对非常长的文本字符串测试是否相等。（使用md5（）或crc32（）函数生成散列值。）由于散列函数可以为不同的输入生成重复的结果，因此仍然在查询中包含子句和blob_column=long_string_value，以防止错误匹配；性能优势来自于对散列值进行较小且易于扫描的索引。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="procedure-analyse"></a>8.4.2.4&nbsp;Using PROCEDURE ANALYSE</h4>

                        </div>

                    </div>

                </div>
                <p>
                    <code class="literal">ANALYSE([<em class="replaceable"><code>max_elements</code></em>[,<em class="replaceable"><code>max_memory</code></em>]])</code>
                </p><p style="color:blue;">分析（[max_elements[，max_memory]]）</p><p></p><a class="indexterm" name="idm140286872869696"></a><a class="indexterm" name="idm140286872868624"></a>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        <code class="literal">PROCEDURE ANALYSE()</code> is deprecated as of
                        MySQL 5.7.18, and is removed in MySQL 8.0.
                    </p><p style="color:blue;">从MySQL5.7.18开始，过程analyze（）被弃用，并在MySQL8.0中被删除。</p><p></p>
                </div>
                <p>
                    <code class="literal">ANALYSE()</code> examines the result from a query
                    and returns an analysis of the results that suggests optimal
                    data types for each column that may help reduce table sizes.
                    To obtain this analysis, append <code class="literal">PROCEDURE
                    ANALYSE</code> to the end of a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement:
                </p><p style="color:blue;">analyze（）检查查询的结果，并返回对结果的分析，该分析为可能有助于减小表大小的每一列建议最佳数据类型。要获得此分析，请将过程分析附加到select语句的末尾：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ... FROM ... WHERE ... PROCEDURE ANALYSE([<em class="replaceable"><code>max_elements</code></em>,[<em class="replaceable"><code>max_memory</code></em>]])
</pre><p>
                For example:
            </p><p style="color:blue;">例如：</p><p></p><pre data-lang="sql" class="programlisting">SELECT col1, col2 FROM table1 PROCEDURE ANALYSE(10, 2000);
</pre><p>
                The results show some statistics for the values returned by
                the query, and propose an optimal data type for the columns.
                This can be helpful for checking your existing tables, or
                after importing new data. You may need to try different
                settings for the arguments so that <code class="literal">PROCEDURE
                ANALYSE()</code> does not suggest the
                <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> data type when it is not
                appropriate.
            </p><p style="color:blue;">结果显示了查询返回值的一些统计信息，并为列提出了一个最佳的数据类型。这将有助于检查现有表，或导入新数据之后。您可能需要尝试不同的参数设置，以便过程analyze（）在枚举数据类型不合适时不建议使用它。</p><p></p><p>
                The arguments are optional and are used as follows:
            </p><p style="color:blue;">参数是可选的，使用方法如下：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <em class="replaceable"><code>max_elements</code></em> (default 256) is
                        the maximum number of distinct values that
                        <code class="literal">ANALYSE()</code> notices per column. This is
                        used by <code class="literal">ANALYSE()</code> to check whether the
                        optimal data type should be of type
                        <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a>; if there are more
                        than <em class="replaceable"><code>max_elements</code></em> distinct
                        values, then <a class="link" href="data-types.html#enum" title="11.4.4&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> is not a
                        suggested type.
                    </p><p style="color:blue;">Max元素（默认值256）是分析（或）每列通知的最大值的最大数目。analyze（）使用此函数检查最佳数据类型是否应为enum类型；如果有超过max_elements的不同值，则enum不是建议的类型。</p><p></p></li><li class="listitem"><p>
                        <em class="replaceable"><code>max_memory</code></em> (default 8192) is
                        the maximum amount of memory that
                        <code class="literal">ANALYSE()</code> should allocate per column
                        while trying to find all distinct values.
                    </p><p style="color:blue;">Max内存（默认值8192）是在试图找到所有不同的值时，分析（）应分配给每个列的最大内存量。</p><p></p></li></ul>
                </div>
                <p>
                    A <code class="literal">PROCEDURE</code> clause is not permitted in a
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> statement.
                </p><p style="color:blue;">union语句中不允许使用过程子句。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimize-multi-tables"></a>8.4.3&nbsp;Optimizing for Many Tables</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#table-cache">8.4.3.1 How MySQL Opens and Closes Tables</a></span></dt><dt><span class="section"><a href="optimization.html#creating-many-tables">8.4.3.2 Disadvantages of Creating Many Tables in the Same Database</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286872843136"></a><p>
            Some techniques for keeping individual queries fast involve
            splitting data across many tables. When the number of tables
            runs into the thousands or even millions, the overhead of
            dealing with all these tables becomes a new performance
            consideration.
        </p><p style="color:blue;">一些保持单个查询快速的技术涉及跨多个表拆分数据。当表的数量达到数千甚至数百万时，处理所有这些表的开销就成为一个新的性能考虑因素。</p><p></p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="table-cache"></a>8.4.3.1&nbsp;How MySQL Opens and Closes Tables</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286872839824"></a><a class="indexterm" name="idm140286872838784"></a><a class="indexterm" name="idm140286872837296"></a><a class="indexterm" name="idm140286872835808"></a><a class="indexterm" name="idm140286872834320"></a><a class="indexterm" name="idm140286872832832"></a><a class="indexterm" name="idm140286872831760"></a><a class="indexterm" name="idm140286872830272"></a><p>
                When you execute a <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin status</strong></span></a>
                command, you should see something like this:
            </p><p style="color:blue;">当您执行mysqladmin status命令时，应该会看到如下内容：</p><p></p><pre data-lang="none" class="programlisting">Uptime: 426 Running threads: 1 Questions: 11082
Reloads: 1 Open tables: 12
</pre><p>
                The <code class="literal">Open tables</code> value of 12 can be somewhat
                puzzling if you have fewer than 12 tables.
            </p><p style="color:blue;">如果少于12个表，那么open tables的值12可能会有些令人费解。</p><p></p><p>
                MySQL is multithreaded, so there may be many clients issuing
                queries for a given table simultaneously. To minimize the
                problem with multiple client sessions having different states
                on the same table, the table is opened independently by each
                concurrent session. This uses additional memory but normally
                increases performance. With <code class="literal">MyISAM</code> tables,
                one extra file descriptor is required for the data file for
                each client that has the table open. (By contrast, the index
                file descriptor is shared between all sessions.)
            </p><p style="color:blue;">mysql是多线程的，因此可能有许多客户机同时对给定的表发出查询。为了最小化多个客户端会话在同一个表上具有不同状态的问题，该表由每个并发会话独立打开。这会使用额外的内存，但通常会提高性能。对于myisam表，每个打开表的客户机的数据文件都需要一个额外的文件描述符。（相比之下，索引文件描述符在所有会话之间共享。）</p><p></p><p>
                The <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> and
                <a class="link" href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a> system
                variables affect the maximum number of files the server keeps
                open. If you increase one or both of these values, you may run
                up against a limit imposed by your operating system on the
                per-process number of open file descriptors. Many operating
                systems permit you to increase the open-files limit, although
                the method varies widely from system to system. Consult your
                operating system documentation to determine whether it is
                possible to increase the limit and how to do so.
            </p><p style="color:blue;">Table OpenOPECH和Max连接系统变量影响服务器保持打开的文件的最大数量。如果增加其中一个或两个值，则可能会遇到操作系统对打开的文件描述符的每个进程数所施加的限制。许多操作系统允许您增加打开文件的限制，尽管方法因系统而异。请参阅操作系统文档，以确定是否可以增加限制以及如何增加限制。</p><p></p><p>
                <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> is related
                to <a class="link" href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a>. For
                example, for 200 concurrent running connections, specify a
                table cache size of at least <code class="literal">200 *
                <em class="replaceable"><code>N</code></em></code>, where
                <em class="replaceable"><code>N</code></em> is the maximum number of tables
                per join in any of the queries which you execute. You must
                also reserve some extra file descriptors for temporary tables
                and files.
            </p><p style="color:blue;">表打开缓存与最大连接数有关。例如，对于200个并发运行的连接，指定至少200×N的表缓存大小，其中n是您执行的任何查询中每个连接的最大表数。您还必须为临时表和文件保留一些额外的文件描述符。</p><p></p><p>
                Make sure that your operating system can handle the number of
                open file descriptors implied by the
                <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> setting. If
                <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> is set too
                high, MySQL may run out of file descriptors and exhibit
                symptoms such as refusing connections or failing to perform
                queries.
            </p><p style="color:blue;">请确保您的操作系统能够处理table_open_cache设置所暗示的打开文件描述符的数量。如果table_open_cache设置得太高，mysql可能会耗尽文件描述符，并出现拒绝连接或无法执行查询等症状。</p><p></p><p>
                Also take into account that the <code class="literal">MyISAM</code>
                storage engine needs two file descriptors for each unique open
                table. For a partitioned <code class="literal">MyISAM</code> table, two
                file descriptors are required for each partition of the opened
                table. (When <code class="literal">MyISAM</code> opens a partitioned
                table, it opens every partition of this table, whether or not
                a given partition is actually used. See
                <a class="xref" href="partitioning.html#partitioning-limitations-myisam-file-descriptors" title="MyISAM and partition file descriptor usage">MyISAM and partition file descriptor usage</a>.)
                To increase the number of file descriptors available to MySQL,
                set the <a class="link" href="server-administration.html#sysvar_open_files_limit"><code class="literal">open_files_limit</code></a>
                system variable. See
                <a class="xref" href="error-handling.html#not-enough-file-handles" title="B.4.2.17&nbsp;File Not Found and Similar Errors">Section&nbsp;B.4.2.17, “File Not Found and Similar Errors”</a>.
            </p><p style="color:blue;">还要考虑到myisam存储引擎需要为每个唯一的打开表提供两个文件描述符。对于分区的myisam表，打开的表的每个分区都需要两个文件描述符。（当myisam打开一个分区表时，它将打开该表的每个分区，不管是否实际使用了给定的分区。请参阅myisam和分区文件描述符用法。）若要增加mysql可用的文件描述符数，请设置open_files_limit系统变量。见第B.4.2.17节，“未找到文件和类似错误”。</p><p></p><p>
                The cache of open tables is kept at a level of
                <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> entries. The
                server autosizes the cache size at startup. To set the size
                explicitly, set the
                <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> system
                variable at startup. MySQL may temporarily open more tables
                than this to execute queries, as described later in this
                section.
            </p><p style="color:blue;">打开的表的缓存保持在table_open_缓存项的级别。服务器在启动时自动调整缓存大小。要显式设置大小，请在启动时设置table_open_cache系统变量。mysql可能会临时打开更多的表来执行查询，如本节后面所述。</p><p></p><p>
                MySQL closes an unused table and removes it from the table
                cache under the following circumstances:
            </p><p style="color:blue;">在以下情况下，mysql关闭未使用的表并将其从表缓存中移除：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        When the cache is full and a thread tries to open a table
                        that is not in the cache.
                    </p><p style="color:blue;">当缓存已满且线程试图打开不在缓存中的表时。</p><p></p></li><li class="listitem"><p>
                        When the cache contains more than
                        <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> entries
                        and a table in the cache is no longer being used by any
                        threads.
                    </p><p style="color:blue;">当缓存包含多个table_open_缓存项并且缓存中的表不再被任何线程使用时。</p><p></p></li><li class="listitem"><p>
                        When a table-flushing operation occurs. This happens when
                        someone issues a <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH
                        TABLES</code></a> statement or executes a
                        <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin flush-tables</strong></span></a> or
                        <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin refresh</strong></span></a> command.
                    </p><p style="color:blue;">当执行表刷新操作时。当有人发出flush tables语句或执行mysqladmin flush tables或mysqladmin refresh命令时，就会发生这种情况。</p><p></p></li></ul>
                </div>
                <p>
                    When the table cache fills up, the server uses the following
                    procedure to locate a cache entry to use:
                </p><p style="color:blue;">当表缓存填满时，服务器使用以下过程来定位要使用的缓存条目：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Tables not currently in use are released, beginning with
                        the table least recently used.
                    </p><p style="color:blue;">将释放当前未使用的表，从最近最少使用的表开始。</p><p></p></li><li class="listitem"><p>
                        If a new table must be opened, but the cache is full and
                        no tables can be released, the cache is temporarily
                        extended as necessary. When the cache is in a temporarily
                        extended state and a table goes from a used to unused
                        state, the table is closed and released from the cache.
                    </p><p style="color:blue;">如果必须打开新表，但缓存已满且无法释放任何表，则根据需要临时扩展缓存。当缓存处于临时扩展状态并且表从使用状态变为未使用状态时，将关闭该表并从缓存中释放该表。</p><p></p></li></ul>
                </div>
                <p>
                    A <code class="literal">MyISAM</code> table is opened for each
                    concurrent access. This means the table needs to be opened
                    twice if two threads access the same table or if a thread
                    accesses the table twice in the same query (for example, by
                    joining the table to itself). Each concurrent open requires an
                    entry in the table cache. The first open of any
                    <code class="literal">MyISAM</code> table takes two file descriptors:
                    one for the data file and one for the index file. Each
                    additional use of the table takes only one file descriptor for
                    the data file. The index file descriptor is shared among all
                    threads.
                </p><p style="color:blue;">为每个并发访问打开一个myisam表。这意味着如果两个线程访问同一个表，或者如果一个线程在同一个查询中访问表两次（例如，通过将表连接到自身），则需要打开表两次。每次并发打开都需要表缓存中的一个条目。任何myisam表的第一次打开都需要两个文件描述符：一个用于数据文件，一个用于索引文件。表的每一次额外使用只需要数据文件的一个文件描述符。索引文件描述符在所有线程之间共享。</p><p></p><p>
                If you are opening a table with the <code class="literal">HANDLER
                <em class="replaceable"><code>tbl_name</code></em> OPEN</code> statement,
                a dedicated table object is allocated for the thread. This
                table object is not shared by other threads and is not closed
                until the thread calls <code class="literal">HANDLER
                <em class="replaceable"><code>tbl_name</code></em> CLOSE</code> or the
                thread terminates. When this happens, the table is put back in
                the table cache (if the cache is not full). See
                <a class="xref" href="sql-syntax.html#handler" title="13.2.4&nbsp;HANDLER Syntax">Section&nbsp;13.2.4, “HANDLER Syntax”</a>.
            </p><p style="color:blue;">如果使用处理程序tbl_name open语句打开表，则会为线程分配一个专用表对象。此表对象不由其他线程共享，在线程调用处理程序tbl_name close或线程终止之前不会关闭。发生这种情况时，表将放回表缓存（如果缓存未满）。参见第13.2.4节“处理程序语法”。</p><p></p><p>
                To determine whether your table cache is too small, check the
                <a class="link" href="server-administration.html#statvar_Opened_tables"><code class="literal">Opened_tables</code></a> status
                variable, which indicates the number of table-opening
                operations since the server started:
            </p><p style="color:blue;">要确定表缓存是否太小，请检查opened_tables status变量，该变量指示自服务器启动以来打开表的操作数：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GLOBAL STATUS LIKE 'Opened_tables';</code></strong>
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 2741  |
+---------------+-------+
</pre><p>
                If the value is very large or increases rapidly, even when you
                have not issued many <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH
                TABLES</code></a> statements, increase the
                <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> value at
                server startup.
            </p><p style="color:blue;">如果该值非常大或增长很快，即使您没有发出许多flush tables语句，也可以在服务器启动时增加table_open_cache值。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="creating-many-tables"></a>8.4.3.2&nbsp;Disadvantages of Creating Many Tables in the Same Database</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286872777536"></a><p>
                If you have many <code class="literal">MyISAM</code> tables in the same
                database directory, open, close, and create operations are
                slow. If you execute <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                statements on many different tables, there is a little
                overhead when the table cache is full, because for every table
                that has to be opened, another must be closed. You can reduce
                this overhead by increasing the number of entries permitted in
                the table cache.
            </p><p style="color:blue;">如果在同一个数据库目录中有许多myisam表，则打开、关闭和创建操作会很慢。如果在许多不同的表上执行select语句，那么当表缓存已满时会有一点开销，因为对于必须打开的每个表，都必须关闭另一个表。可以通过增加表缓存中允许的条目数来减少此开销。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="internal-temporary-tables"></a>8.4.4&nbsp;Internal Temporary Table Use in MySQL</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286872771936"></a><p>
            In some cases, the server creates internal temporary tables
            while processing statements. Users have no direct control over
            when this occurs.
        </p><p style="color:blue;">在某些情况下，服务器在处理语句时创建内部临时表。用户无法直接控制何时发生这种情况。</p><p></p><p>
            The server creates temporary tables under conditions such as
            these:
        </p><p style="color:blue;">服务器在以下条件下创建临时表：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Evaluation of <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>
                    statements, with some exceptions described later.
                </p><p style="color:blue;">联合语句的求值，但后面描述的一些例外情况除外。</p><p></p></li><li class="listitem"><p>
                    Evaluation of some views, such those that use the
                    <code class="literal">TEMPTABLE</code> algorithm,
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>, or aggregation.
                </p><p style="color:blue;">对某些视图的求值，例如使用可试探算法、联合或聚合的视图。</p><p></p></li><li class="listitem"><p>
                    Evaluation of derived tables (see
                    <a class="xref" href="sql-syntax.html#derived-tables" title="13.2.10.8&nbsp;Derived Tables">Section&nbsp;13.2.10.8, “Derived Tables”</a>).
                </p><p style="color:blue;">派生表的评估（见第13.2.10.8节“派生表”）。</p><p></p></li><li class="listitem"><p>
                    Tables created for subquery or semijoin materialization (see
                    <a class="xref" href="optimization.html#subquery-optimization" title="8.2.2&nbsp;Optimizing Subqueries, Derived Tables, and View References">Section&nbsp;8.2.2, “Optimizing Subqueries, Derived Tables, and View References”</a>).
                </p><p style="color:blue;">为子查询或半联接物化创建的表（请参阅第8.2.2节“优化子查询、派生表和视图引用”）。</p><p></p></li><li class="listitem"><p>
                    Evaluation of statements that contain an <code class="literal">ORDER
                    BY</code> clause and a different <code class="literal">GROUP
                    BY</code> clause, or for which the <code class="literal">ORDER
                    BY</code> or <code class="literal">GROUP BY</code> contains columns
                    from tables other than the first table in the join queue.
                </p><p style="color:blue;">对包含ORDER BY子句和其他GROUP BY子句的语句的求值，或者对于这些语句，ORDER BY或GROUP BY包含来自联接队列中第一个表以外的表的列。</p><p></p></li><li class="listitem"><p>
                    Evaluation of <code class="literal">DISTINCT</code> combined with
                    <code class="literal">ORDER BY</code> may require a temporary table.
                </p><p style="color:blue;">对DISTINCT和ORDER BY的求值可能需要临时表。</p><p></p></li><li class="listitem"><p>
                    For queries that use the <code class="literal">SQL_SMALL_RESULT</code>
                    modifier, MySQL uses an in-memory temporary table, unless
                    the query also contains elements (described later) that
                    require on-disk storage.
                </p><p style="color:blue;">对于使用sql_small_result修饰符的查询，mysql使用内存中的临时表，除非该查询还包含需要磁盘存储的元素（稍后介绍）。</p><p></p></li><li class="listitem"><p>
                    To evaluate
                    <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                        SELECT</code></a> statements that select from and insert into
                    the same table, MySQL creates an internal temporary table to
                    hold the rows from the
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, then inserts those
                    rows into the target table. See
                    <a class="xref" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax">Section&nbsp;13.2.5.1, “INSERT ... SELECT Syntax”</a>.
                </p><p style="color:blue;">要计算插入…select from语句插入到同一个表中，mysql创建一个内部临时表来保存select中的行，然后将这些行插入到目标表中。见第13.2.5.1节，“插入……选择“语法”。</p><p></p></li><li class="listitem"><p>
                    Evaluation of multiple-table
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements.
                </p><p style="color:blue;">多个表更新语句的计算。</p><p></p></li><li class="listitem"><p>
                    Evaluation of <a class="link" href="functions.html#function_group-concat"><code class="literal">GROUP_CONCAT()</code></a>
                    or <a class="link" href="functions.html#function_count"><code class="literal">COUNT(DISTINCT)</code></a>
                    expressions.
                </p><p style="color:blue;">对组concat（）或count（distinct）表达式的求值。</p><p></p></li></ul>
            </div>
            <p>
                To determine whether a statement requires a temporary table, use
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> and check the
                <code class="literal">Extra</code> column to see whether it says
                <code class="literal">Using temporary</code> (see
                <a class="xref" href="optimization.html#using-explain" title="8.8.1&nbsp;Optimizing Queries with EXPLAIN">Section&nbsp;8.8.1, “Optimizing Queries with EXPLAIN”</a>). <code class="literal">EXPLAIN</code>
                will not necessarily say <code class="literal">Using temporary</code> for
                derived or materialized temporary tables.
            </p><p style="color:blue;">要确定语句是否需要临时表，请使用explain并检查额外的列，以查看它是否表示使用临时表（请参阅8.8.1节“使用explain优化查询”）。explain不一定会说对派生的或具体化的临时表使用临时表。</p><p></p><p>
            When the server creates an internal temporary table (either in
            memory or on disk), it increments the
            <a class="link" href="server-administration.html#statvar_Created_tmp_tables"><code class="literal">Created_tmp_tables</code></a> status
            variable. If the server creates the table on disk (either
            initially or by converting an in-memory table) it increments the
            <a class="link" href="server-administration.html#statvar_Created_tmp_disk_tables"><code class="literal">Created_tmp_disk_tables</code></a> status
            variable.
        </p><p style="color:blue;">当服务器创建一个内部临时表（在内存或磁盘上）时，它会增加已创建的\u tmp\u tables状态变量。如果服务器在磁盘上创建表（最初或通过转换内存中的表），则会增加created_tmp_disk_tables状态变量。</p><p></p><p>
            Some query conditions prevent the use of an in-memory temporary
            table, in which case the server uses an on-disk table instead:
        </p><p style="color:blue;">某些查询条件阻止使用内存中的临时表，在这种情况下，服务器将使用磁盘上的表：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Presence of a <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column in the table.
                    This includes user-defined variables having a string value
                    because they are treated as
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns, depending on
                    whether their value is a binary or nonbinary string,
                    respectively.
                </p><p style="color:blue;">表中存在blob或文本列。这包括具有字符串值的用户定义变量，因为它们被视为blob列或文本列，具体取决于它们的值分别是二进制字符串还是非二进制字符串。</p><p></p></li><li class="listitem"><p>
                    Presence of any string column with a maximum length larger
                    than 512 (bytes for binary strings, characters for nonbinary
                    strings) in the <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> list,
                    if <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> or
                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION ALL</code></a>
                    is used.
                </p><p style="color:blue;">在选择列表中，如果使用UNION或UNIONALL，则存在长度大于512的任何字符串列（二进制字符串的字节，非二进制字符串的字符）。</p><p></p></li><li class="listitem"><p>
                    The <a class="link" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax"><code class="literal">SHOW COLUMNS</code></a> and
                    <a class="link" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax"><code class="literal">DESCRIBE</code></a> statements use
                    <code class="literal">BLOB</code> as the type for some columns, thus
                    the temporary table used for the results is an on-disk
                    table.
                </p><p style="color:blue;">show columns和describe语句使用blob作为某些列的类型，因此用于结果的临时表是磁盘上的表。</p><p></p></li></ul>
            </div>
            <p>
                The server does not use a temporary table for
                <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> statements that meet
                certain qualifications. Instead, it retains from temporary table
                creation only the data structures necessary to perform result
                column typecasting. The table is not fully instantiated and no
                rows are written to or read from it; rows are sent directly to
                the client. The result is reduced memory and disk requirements,
                and smaller delay before the first row is sent to the client
                because the server need not wait until the last query block is
                executed. <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> and optimizer
                trace output reflects this execution strategy: The
                <code class="literal">UNION RESULT</code> query block is not present
                because that block corresponds to the part that reads from the
                temporary table.
            </p><p style="color:blue;">对于满足某些条件的union语句，服务器不使用临时表。相反，它从临时表创建中只保留执行结果列类型转换所需的数据结构。表没有完全实例化，没有行被写入或读取；行被直接发送到客户端。结果是减少了内存和磁盘需求，并且在第一行发送到客户机之前的延迟更小，因为服务器不需要等到执行最后一个查询块。explain和optimizer跟踪输出反映了这种执行策略：union result查询块不存在，因为该块对应于从临时表读取的部分。</p><p></p><p>
            These conditions qualify a <code class="literal">UNION</code> for
            evaluation without a temporary table:
        </p><p style="color:blue;">这些条件使工会有资格在没有临时表的情况下进行评估：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The union is <code class="literal">UNION ALL</code>, not
                    <code class="literal">UNION</code> or <code class="literal">UNION
                    DISTINCT</code>.
                </p><p style="color:blue;">工会是全体工会，而不是工会或工会。</p><p></p></li><li class="listitem"><p>
                    There is no global <code class="literal">ORDER BY</code> clause.
                </p><p style="color:blue;">没有全局ORDER BY子句。</p><p></p></li><li class="listitem"><p>
                    The union is not the top-level query block of an
                    <code class="literal">{INSERT | REPLACE} ... SELECT ...</code>
                    statement.
                </p><p style="color:blue;">联合不是{insert replace}的顶级查询块…选择…陈述。</p><p></p></li></ul>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="internal-temporary-tables-engines"></a>Internal Temporary Table Storage Engine</h4>

                        </div>

                    </div>

                </div>
                <p>
                    An internal temporary table can be held in memory and
                    processed by the <code class="literal">MEMORY</code> storage engine, or
                    stored on disk by the <code class="literal">InnoDB</code> or
                    <code class="literal">MyISAM</code> storage engine.
                </p><p style="color:blue;">内部临时表可以保存在内存中，由内存存储引擎处理，也可以由innodb或myisam存储引擎存储在磁盘上。</p><p></p><p>
                If an internal temporary table is created as an in-memory
                table but becomes too large, MySQL automatically converts it
                to an on-disk table. The maximum size for in-memory temporary
                tables is defined by the
                <a class="link" href="server-administration.html#sysvar_tmp_table_size"><code class="literal">tmp_table_size</code></a> or
                <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> value,
                whichever is smaller. This differs from
                <code class="literal">MEMORY</code> tables explicitly created with
                <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>. For such tables,
                only the <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a>
                variable determines how large a table can grow, and there is
                no conversion to on-disk format.
            </p><p style="color:blue;">如果内部临时表作为内存表创建，但变得太大，mysql会自动将其转换为磁盘表。内存临时表的最大大小由TMPYTable大小或Max HeAPPaTable大小值定义，以较小的值为准。这与使用create table显式创建的内存表不同。对于这样的表，只有max_heap_table_size变量确定表可以增长多大，并且不转换为磁盘格式。</p><p></p><p>
                The
                <a class="link" href="server-administration.html#sysvar_internal_tmp_disk_storage_engine"><code class="literal">internal_tmp_disk_storage_engine</code></a>
                variable defines the storage engine the server uses to manage
                on-disk internal temporary tables. Permitted values are
                <code class="literal">INNODB</code> (the default) and
                <code class="literal">MYISAM</code>.
            </p><p style="color:blue;">internal_tmp_disk_storage_engine变量定义服务器用于管理磁盘上内部临时表的存储引擎。允许的值是innodb（默认值）和myisam。</p><p></p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        When using
                        <a class="link" href="server-administration.html#sysvar_internal_tmp_disk_storage_engine"><code class="literal">internal_tmp_disk_storage_engine=INNODB</code></a>,
                        queries that generate on-disk internal temporary tables that
                        exceed
                        <a class="link" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables"><code class="literal">InnoDB</code>
                            row or column limits</a> return <span class="errortext">Row size too
            large</span> or <span class="errortext">Too many columns</span>
                        errors. The workaround is to set
                        <a class="link" href="server-administration.html#sysvar_internal_tmp_disk_storage_engine"><code class="literal">internal_tmp_disk_storage_engine</code></a>
                        to <code class="literal">MYISAM</code>.
                    </p><p style="color:blue;">使用internal_tmp_disk_storage_engine=innodb时，如果在磁盘上生成的内部临时表超过innodb行或列限制，则返回行大小太大或列太多错误。解决方法是将内部磁盘存储引擎设置为myisam。</p><p></p>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="internal-temporary-tables-storage"></a>Internal Temporary Table Storage Format</h4>

                        </div>

                    </div>

                </div>
                <p>
                    In-memory temporary tables are managed by the
                    <code class="literal">MEMORY</code> storage engine, which uses
                    fixed-length row format. <code class="literal">VARCHAR</code> and
                    <code class="literal">VARBINARY</code> column values are padded to the
                    maximum column length, in effect storing them as
                    <code class="literal">CHAR</code> and <code class="literal">BINARY</code> columns.
                </p><p style="color:blue;">内存中的临时表由内存存储引擎管理，该引擎使用固定长度的行格式。将VARCHAR和VARDION列值填充到最大列长度，实际上将它们存储为char和二进制列。</p><p></p><p>
                On-disk temporary tables are managed by the
                <code class="literal">InnoDB</code> or <code class="literal">MyISAM</code> storage
                engine (depending on the
                <a class="link" href="server-administration.html#sysvar_internal_tmp_disk_storage_engine"><code class="literal">internal_tmp_disk_storage_engine</code></a>
                setting). Both engines store temporary tables using
                dynamic-width row format. Columns take only as much storage as
                needed, which reduces disk I/O, space requirements, and
                processing time compared to on-disk tables that use
                fixed-length rows.
            </p><p style="color:blue;">磁盘上的临时表由innodb或myisam存储引擎管理（取决于内部的磁盘存储引擎设置）。两个引擎都使用动态宽度行格式存储临时表。与使用固定长度行的磁盘表相比，列只占用所需的存储空间，这减少了磁盘I/O、空间需求和处理时间。</p><p></p><p>
                For statements that initially create an internal temporary
                table in memory, then convert it to an on-disk table, better
                performance might be achieved by skipping the conversion step
                and creating the table on disk to begin with. The
                <a class="link" href="server-administration.html#sysvar_big_tables"><code class="literal">big_tables</code></a> variable can be
                used to force disk storage of internal temporary tables.
            </p><p style="color:blue;">对于最初在内存中创建内部临时表，然后将其转换为磁盘上表的语句，可以通过跳过转换步骤并首先在磁盘上创建表来获得更好的性能。big_tables变量可用于强制内部临时表的磁盘存储。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="database-count-limit"></a>8.4.5&nbsp;Limits on Number of Databases and Tables</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286872674144"></a><a class="indexterm" name="idm140286872672672"></a><a class="indexterm" name="idm140286872671168"></a><a class="indexterm" name="idm140286872669664"></a><p>
            MySQL has no limit on the number of databases. The underlying
            file system may have a limit on the number of directories.
        </p><p style="color:blue;">mysql对数据库的数量没有限制。基础文件系统可能对目录数量有限制。</p><p></p><p>
            MySQL has no limit on the number of tables. The underlying file
            system may have a limit on the number of files that represent
            tables. Individual storage engines may impose engine-specific
            constraints. <code class="literal">InnoDB</code> permits up to 4 billion
            tables.
        </p><p style="color:blue;">mysql对表的数量没有限制。底层文件系统可能对表示表的文件数有限制。单个存储引擎可能会施加特定于引擎的约束。InnoDB允许多达40亿个表。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="table-size-limit"></a>8.4.6&nbsp;Limits on Table Size</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286872664944"></a><a class="indexterm" name="idm140286872663456"></a><a class="indexterm" name="idm140286872661968"></a><a class="indexterm" name="idm140286872660480"></a><a class="indexterm" name="idm140286872659408"></a><a class="indexterm" name="idm140286872657920"></a><a class="indexterm" name="idm140286872656432"></a><p>
            The effective maximum table size for MySQL databases is usually
            determined by operating system constraints on file sizes, not by
            MySQL internal limits. For up-to-date information operating
            system file size limits, refer to the documentation specific to
            your operating system.
        </p><p style="color:blue;">MySQL数据库的有效最大表大小通常取决于操作系统对文件大小的限制，而不是MySQL内部限制。有关操作系统文件大小限制的最新信息，请参阅特定于您的操作系统的文档。</p><p></p><p>
            Windows users, please note that FAT and VFAT (FAT32) are
            <span class="emphasis"><em>not</em></span> considered suitable for production use
            with MySQL. Use NTFS instead.
        </p><p style="color:blue;">windows用户，请注意fat和vfat（fat32）不适合与mysql一起使用。改用ntfs。</p><p></p><p>
            If you encounter a full-table error, there are several reasons
            why it might have occurred:
        </p><p style="color:blue;">如果遇到完整表错误，可能有以下几个原因：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The disk might be full.
                </p><p style="color:blue;">磁盘可能已满。</p><p></p></li><li class="listitem"><p>
                    You are using <code class="literal">InnoDB</code> tables and have run
                    out of room in an <code class="literal">InnoDB</code> tablespace file.
                    The maximum tablespace size is also the maximum size for a
                    table. For tablespace size limits, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables">Section&nbsp;14.6.1.6, “Limits on InnoDB Tables”</a>.
                </p><p style="color:blue;">您正在使用innodb表，并且innodb表空间文件空间不足。最大表空间大小也是表的最大大小。有关表空间大小限制，请参阅14.6.1.6节“innodb tables的限制”。</p><p></p><p>
                    Generally, partitioning of tables into multiple tablespace
                    files is recommended for tables larger than 1TB in size.
                </p><p style="color:blue;">通常，对于大小大于1TB的表，建议将表分区为多个表空间文件。</p><p></p></li><li class="listitem"><p>
                    You have hit an operating system file size limit. For
                    example, you are using <code class="literal">MyISAM</code> tables on
                    an operating system that supports files only up to 2GB in
                    size and you have hit this limit for the data file or index
                    file.
                </p><p style="color:blue;">您已达到操作系统文件大小限制。例如，您正在一个操作系统上使用myisam表，该操作系统只支持大小不超过2gb的文件，并且您已经达到了数据文件或索引文件的此限制。</p><p></p></li><li class="listitem"><p>
                    You are using a <code class="literal">MyISAM</code> table and the
                    space required for the table exceeds what is permitted by
                    the internal pointer size. <code class="literal">MyISAM</code> permits
                    data and index files to grow up to 256TB by default, but
                    this limit can be changed up to the maximum permissible size
                    of 65,536TB (256<sup>7</sup> − 1
                    bytes).
                </p><p style="color:blue;">您使用的是myisam表，该表所需的空间超过了内部指针大小所允许的空间。MyISAM允许数据和索引文件在默认情况下增长到256TB，但是这个限制可以被改变到最大允许大小65636TB（2567到1字节）。</p><p></p><p>
                    If you need a <code class="literal">MyISAM</code> table that is larger
                    than the default limit and your operating system supports
                    large files, the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>
                    statement supports <code class="literal">AVG_ROW_LENGTH</code> and
                    <code class="literal">MAX_ROWS</code> options. See
                    <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>. The server uses these
                    options to determine how large a table to permit.
                </p><p style="color:blue;">如果需要大于默认限制的myisam表，并且操作系统支持大文件，则create table语句支持avg_row_length和max_rows选项。参见第13.1.18节“创建表语法”。服务器使用这些选项来确定表允许的大小。</p><p></p><p>
                    If the pointer size is too small for an existing table, you
                    can change the options with <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> to increase a table's maximum permissible
                    size. See <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>.
                </p><p style="color:blue;">如果指针大小对于现有表太小，则可以使用ALTE表更改选项，以增加表的最大允许大小。见第13.1.8节“更改表语法”。</p><p></p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> MAX_ROWS=1000000000 AVG_ROW_LENGTH=<em class="replaceable"><code>nnn</code></em>;
</pre><p>
                    You have to specify <code class="literal">AVG_ROW_LENGTH</code> only
                    for tables with <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns; in this case,
                    MySQL can't optimize the space required based only on the
                    number of rows.
                </p><p style="color:blue;">必须仅为具有blob列或文本列的表指定avg_row_length；在这种情况下，mysql无法仅基于行数优化所需的空间。</p><p></p><p>
                    To change the default size limit for
                    <code class="literal">MyISAM</code> tables, set the
                    <a class="link" href="server-administration.html#sysvar_myisam_data_pointer_size"><code class="literal">myisam_data_pointer_size</code></a>,
                    which sets the number of bytes used for internal row
                    pointers. The value is used to set the pointer size for new
                    tables if you do not specify the <code class="literal">MAX_ROWS</code>
                    option. The value of
                    <a class="link" href="server-administration.html#sysvar_myisam_data_pointer_size"><code class="literal">myisam_data_pointer_size</code></a>
                    can be from 2 to 7. A value of 4 permits tables up to 4GB; a
                    value of 6 permits tables up to 256TB.
                </p><p style="color:blue;">要更改myisam表的默认大小限制，请设置myisam数据指针大小，该大小设置用于内部行指针的字节数。如果未指定“最大行数”选项，则该值用于设置新表的指针大小。myisam_data_pointer_size的值可以是2到7。值为4允许表高达4GB；值为6允许表高达256TB。</p><p></p><p>
                    You can check the maximum data and index sizes by using this
                    statement:
                </p><p style="color:blue;">您可以通过使用此语句检查最大数据和索引大小：</p><p></p><pre data-lang="sql" class="programlisting">SHOW TABLE STATUS FROM <em class="replaceable"><code>db_name</code></em> LIKE '<em class="replaceable"><code>tbl_name</code></em>';
</pre><p>
                    You also can use <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -dv
            /path/to/table-index-file</strong></span></a>. See
                    <a class="xref" href="sql-syntax.html#show" title="13.7.5&nbsp;SHOW Syntax">Section&nbsp;13.7.5, “SHOW Syntax”</a>, or <a class="xref" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility">Section&nbsp;4.6.3, “<span class="command"><strong>myisamchk</strong></span> — MyISAM Table-Maintenance Utility”</a>.
                </p><p style="color:blue;">您也可以使用myisamchk-dv/path/to/table索引文件。参见第13.7.5节“显示语法”，或第4.6.3节“myisamchk-myisam表维护实用程序”。</p><p></p><p>
                    Other ways to work around file-size limits for
                    <code class="literal">MyISAM</code> tables are as follows:
                </p><p style="color:blue;">解决myisam表的文件大小限制的其他方法如下：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            If your large table is read only, you can use
                            <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> to compress it.
                            <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> usually compresses a table
                            by at least 50%, so you can have, in effect, much bigger
                            tables. <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> also can merge
                            multiple tables into a single table. See
                            <a class="xref" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables">Section&nbsp;4.6.5, “<span class="command"><strong>myisampack</strong></span> — Generate Compressed, Read-Only MyISAM Tables”</a>.
                        </p><p style="color:blue;">如果您的大表是只读的，可以使用myiscompack压缩它。myisampack通常会压缩至少50%的表，所以实际上可以有更大的表。myisampack还可以将多个表合并为一个表。请参阅4.6.5节，“myisampack-生成压缩的只读myisam表”。</p><p></p></li><li class="listitem"><p>
                            MySQL includes a <code class="literal">MERGE</code> library that
                            enables you to handle a collection of
                            <code class="literal">MyISAM</code> tables that have identical
                            structure as a single <code class="literal">MERGE</code> table.
                            See <a class="xref" href="storage-engines.html#merge-storage-engine" title="15.7&nbsp;The MERGE Storage Engine">Section&nbsp;15.7, “The MERGE Storage Engine”</a>.
                        </p><p style="color:blue;">mysql包含一个合并库，使您能够处理与单个合并表具有相同结构的myisam表的集合。见第15.7节“合并存储引擎”。</p><p></p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    You are using the <code class="literal">MEMORY</code>
                    (<code class="literal">HEAP</code>) storage engine; in this case you
                    need to increase the value of the
                    <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a> system
                    variable. See <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>.
                </p><p style="color:blue;">您正在使用内存（堆）存储引擎；在这种情况下，需要增加max_heap_table_size系统变量的值。见第5.1.7节“服务器系统变量”。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="column-count-limit"></a>8.4.7&nbsp;Limits on Table Column Count and Row Size</h3>

                    </div>

                </div>

            </div>
            <p>
                This section describes limits on the number of columns in tables
                and the size of individual rows.
            </p><p style="color:blue;">本节介绍表中列数和单个行大小的限制。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#column-count-limits" title="Column Count Limits">Column Count Limits</a></p><p style="color:blue;">列计数限制</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#row-size-limits" title="Row Size Limits">Row Size Limits</a></p><p style="color:blue;">行大小限制</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="column-count-limits"></a>Column Count Limits</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286872599808"></a><a class="indexterm" name="idm140286872598304"></a><a class="indexterm" name="idm140286872596800"></a><p>
                MySQL has hard limit of 4096 columns per table, but the
                effective maximum may be less for a given table. The exact
                column limit depends on several factors:
            </p><p style="color:blue;">MySQL对每个表具有4096列的硬限制，但对于给定表而言，有效最大值可能较小。精确的列限制取决于以下几个因素：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The maximum row size for a table constrains the number
                        (and possibly size) of columns because the total length of
                        all columns cannot exceed this size. See
                        <a class="xref" href="optimization.html#row-size-limits" title="Row Size Limits">Row Size Limits</a>.
                    </p><p style="color:blue;">表的最大行大小限制列的数目（可能大小），因为所有列的总长度不能超过此大小。请参见行大小限制。</p><p></p></li><li class="listitem"><p>
                        The storage requirements of individual columns constrain
                        the number of columns that fit within a given maximum row
                        size. Storage requirements for some data types depend on
                        factors such as storage engine, storage format, and
                        character set. See <a class="xref" href="data-types.html#storage-requirements" title="11.8&nbsp;Data Type Storage Requirements">Section&nbsp;11.8, “Data Type Storage Requirements”</a>.
                    </p><p style="color:blue;">单个列的存储要求限制了在给定的最大行大小内可容纳的列数。某些数据类型的存储要求取决于存储引擎、存储格式和字符集等因素。见第11.8节“数据类型存储要求”。</p><p></p></li><li class="listitem"><p>
                        Storage engines may impose additional restrictions that
                        limit table column count. For example,
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> has a limit of 1017
                        columns per table. See
                        <a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables">Section&nbsp;14.6.1.6, “Limits on InnoDB Tables”</a>. For information
                        about other storage engines, see
                        <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>.
                    </p><p style="color:blue;">存储引擎可能会施加限制表列计数的附加限制。例如，innodb对每个表有1017列的限制。见第14.6.1.6节，“InnoDB表的限制”。有关其他存储引擎的信息，请参阅第15章“替代存储引擎”。</p><p></p></li><li class="listitem"><p>
                        Each table has an <code class="filename">.frm</code> file that
                        contains the table definition. The definition affects the
                        content of this file in ways that may affect the number of
                        columns permitted in the table. See
                        <a class="xref" href="sql-syntax.html#limits-frm-file" title="Limits Imposed by .frm File Structure">Limits Imposed by .frm File Structure</a>.
                    </p><p style="color:blue;">每个表都有一个包含表定义的.frm文件。定义以可能影响表中允许的列数的方式影响此文件的内容。请参见.frm文件结构施加的限制。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="row-size-limits"></a>Row Size Limits</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286872583440"></a><a class="indexterm" name="idm140286872581952"></a><a class="indexterm" name="idm140286872580464"></a><p>
                The maximum row size for a given table is determined by
                several factors:
            </p><p style="color:blue;">给定表的最大行大小由以下几个因素决定：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The internal representation of a MySQL table has a maximum
                        row size limit of 65,535 bytes, even if the storage engine
                        is capable of supporting larger rows.
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns only
                        contribute 9 to 12 bytes toward the row size limit because
                        their contents are stored separately from the rest of the
                        row.
                    </p><p style="color:blue;">MySQL表的内部表示最大的行大小限制为65535字节，即使存储引擎能够支持较大行。blob列和text列只向行大小限制贡献9到12个字节，因为它们的内容与行的其余部分分开存储。</p><p></p></li><li class="listitem"><p>
                        The maximum row size for an <code class="literal">InnoDB</code>
                        table, which applies to data stored locally within a
                        database page, is slightly less than half a page for 4KB,
                        8KB, 16KB, and 32KB
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>
                        settings. For example, the maximum row size is slightly
                        less than 8KB for the default 16KB
                        <code class="literal">InnoDB</code> page size. For 64KB pages, the
                        maximum row size is slightly less than 16KB. See
                        <a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.1.6&nbsp;Limits on InnoDB Tables">Section&nbsp;14.6.1.6, “Limits on InnoDB Tables”</a>.
                    </p><p style="color:blue;">表的最大行大小适用于数据库页面中本地存储的数据，它的大小略小于半页的页、页、页和子页设置。例如，默认页面大小的最大行大小略小于0。对于64KB页，最大行大小略小于16KB。见第14.6.1.6节，“InnoDB表的限制”。</p><p></p><p>
                        If a row containing
                        <a class="link" href="glossary.html#glos_variable_length_type" title="variable-length type">variable-length
                            columns</a> exceeds the <code class="literal">InnoDB</code>
                        maximum row size, <code class="literal">InnoDB</code> selects
                        variable-length columns for external off-page storage
                        until the row fits within the <code class="literal">InnoDB</code>
                        row size limit. The amount of data stored locally for
                        variable-length columns that are stored off-page differs
                        by row format. For more information, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                    </p><p style="color:blue;">如果包含可变长度列的行超过innodb的最大行大小，innodb将选择可变长度列作为外部页外存储，直到该行符合innodb的行大小限制。对于存储在页外的可变长度列，本地存储的数据量因行格式而异。有关更多信息，请参阅14.11节，“InnoDB行格式”。</p><p></p></li><li class="listitem"><p>
                        Different storage formats use different amounts of page
                        header and trailer data, which affects the amount of
                        storage available for rows.
                    </p><p style="color:blue;">不同的存储格式使用不同数量的页眉和尾部数据，这会影响行可用的存储量。</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                For information about <code class="literal">InnoDB</code> row
                                formats, see <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                            </p><p style="color:blue;">有关InnoDB行格式的信息，请参阅第14.11节“InnoDB行格式”。</p><p></p></li><li class="listitem"><p>
                                For information about <code class="literal">MyISAM</code>
                                storage formats, see
                                <a class="xref" href="storage-engines.html#myisam-table-formats" title="15.2.3&nbsp;MyISAM Table Storage Formats">Section&nbsp;15.2.3, “MyISAM Table Storage Formats”</a>.
                            </p><p style="color:blue;">有关myisam存储格式的信息，请参阅第15.2.3节“myisam表存储格式”。</p><p></p></li></ul>
                        </div>
                    </li></ul>
                </div>
                <h5><a name="idm140286872559376"></a>Row Size Limit Examples</h5>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The MySQL maximum row size limit of 65,535 bytes is
                        demonstrated in the following <code class="literal">InnoDB</code>
                        and <code class="literal">MyISAM</code> examples. The limit is
                        enforced regardless of storage engine, even though the
                        storage engine may be capable of supporting larger rows.
                    </p><p style="color:blue;">MySQL最大行大小限制为65535字节，在下面的NYNDB和MyISAM示例中演示。不管存储引擎如何，都会强制执行该限制，即使存储引擎可以支持更大的行。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>f VARCHAR(10000), g VARCHAR(6000)) ENGINE=InnoDB CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the used
table type, not counting BLOBs, is 65535. This includes storage overhead,
check the manual. You have to change some columns to TEXT or BLOBs
</pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>f VARCHAR(10000), g VARCHAR(6000)) ENGINE=MyISAM CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the used
table type, not counting BLOBs, is 65535. This includes storage overhead,
check the manual. You have to change some columns to TEXT or BLOBs
</pre><p>
                        In the following <code class="literal">MyISAM</code> example,
                        changing a column to <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>
                        avoids the 65,535-byte row size limit and permits the
                        operation to succeed because
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> and
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> columns only
                        contribute 9 to 12 bytes toward the row size.
                    </p><p style="color:blue;">在下面的myisam示例中，将列更改为文本避免了65535字节的行大小限制，并允许操作成功，因为blob列和文本列只对行大小贡献9到12字节。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>f VARCHAR(10000), g TEXT(6000)) ENGINE=MyISAM CHARACTER SET latin1;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre><p>
                        The operation succeeds for an <code class="literal">InnoDB</code>
                        table because changing a column to
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> avoids the MySQL
                        65,535-byte row size limit, and <code class="literal">InnoDB</code>
                        off-page storage of variable-length columns avoids the
                        <code class="literal">InnoDB</code> row size limit.
                    </p><p style="color:blue;">对于innodb表，该操作成功，因为将列更改为文本避免了mysql 65535字节的行大小限制，而innodb对可变长度列的页外存储避免了innodb行大小限制。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
       <strong class="userinput"><code>f VARCHAR(10000), g TEXT(6000)) ENGINE=InnoDB CHARACTER SET latin1;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre></li><li class="listitem"><p>
                        Storage for variable-length columns includes length bytes,
                        which are counted toward the row size. For example, a
                        <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR(255)
                            CHARACTER SET utf8mb3</code></a> column takes two bytes to
                        store the length of the value, so each value can take up
                        to 767 bytes.
                    </p><p style="color:blue;">可变长度列的存储包括长度字节，这些字节按行大小计算。例如，varchar（255）字符集utf8mb3列需要两个字节来存储值的长度，因此每个值最多可以占用767个字节。</p><p></p><p>
                        The statement to create table <code class="literal">t1</code>
                        succeeds because the columns require 32,765 + 2 bytes and
                        32,766 + 2 bytes, which falls within the maximum row size
                        of 65,535 bytes:
                    </p><p style="color:blue;">创建表T1的语句成功，因为列需要32765+2字节和32766+2字节，这在65535字节的最大行大小范围内：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1</code></strong>
       <strong class="userinput"><code>(c1 VARCHAR(32765) NOT NULL, c2 VARCHAR(32766) NOT NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = InnoDB CHARACTER SET latin1;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre><p>
                        The statement to create table <code class="literal">t2</code> fails
                        because, although the column length is within the maximum
                        length of 65,535 bytes, two additional bytes are required
                        to record the length, which causes the row size to exceed
                        65,535 bytes:
                    </p><p style="color:blue;">创建表t2的语句失败，因为尽管列长度在65535字节的最大长度范围内，但记录该长度需要另外两个字节，这将导致行大小超过65535字节：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2</code></strong>
       <strong class="userinput"><code>(c1 VARCHAR(65535) NOT NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = InnoDB CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the used
table type, not counting BLOBs, is 65535. This includes storage overhead,
check the manual. You have to change some columns to TEXT or BLOBs
</pre><p>
                        Reducing the column length to 65,533 or less permits the
                        statement to succeed.
                    </p><p style="color:blue;">将列长度减少到65533或更少允许语句成功。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2</code></strong>
       <strong class="userinput"><code>(c1 VARCHAR(65533) NOT NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = InnoDB CHARACTER SET latin1;</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre></li><li class="listitem"><p>
                        For <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables,
                        <code class="literal">NULL</code> columns require additional space
                        in the row to record whether their values are
                        <code class="literal">NULL</code>. Each <code class="literal">NULL</code>
                        column takes one bit extra, rounded up to the nearest
                        byte.
                    </p><p style="color:blue;">对于myisam表，空列需要行中的额外空间来记录其值是否为空。每个空列需要额外一位，四舍五入到最接近的字节。</p><p></p><p>
                        The statement to create table <code class="literal">t3</code> fails
                        because <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> requires space
                        for <code class="literal">NULL</code> columns in addition to the
                        space required for variable-length column length bytes,
                        causing the row size to exceed 65,535 bytes:
                    </p><p style="color:blue;">创建表t3的语句失败，因为除了可变长度列长度字节所需的空间外，myisam还需要空列空间，从而导致行大小超过65535字节：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t3</code></strong>
       <strong class="userinput"><code>(c1 VARCHAR(32765) NULL, c2 VARCHAR(32766) NULL)</code></strong>
       <strong class="userinput"><code>ENGINE = MyISAM CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the used
table type, not counting BLOBs, is 65535. This includes storage overhead,
check the manual. You have to change some columns to TEXT or BLOBs
</pre><p>
                        For information about <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>
                        <code class="literal">NULL</code> column storage, see
                        <a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.11&nbsp;InnoDB Row Formats">Section&nbsp;14.11, “InnoDB Row Formats”</a>.
                    </p><p style="color:blue;">有关innodb空列存储的信息，请参阅14.11节，“innodb行格式”。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">InnoDB</code> restricts row size (for data
                        stored locally within the database page) to slightly less
                        than half a database page for 4KB, 8KB, 16KB, and 32KB
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>
                        settings, and to slightly less than 16KB for 64KB pages.
                    </p><p style="color:blue;">对于4KB、8KB、16KB和32KB的InnoDB页面大小设置，InnoDB将行大小（对于存储在数据库页面内的本地数据）限制为略小于半个数据库页面，对于64KB的页面，限制为略小于16KB。</p><p></p><p>
                        The statement to create table <code class="literal">t4</code> fails
                        because the defined columns exceed the row size limit for
                        a 16KB <code class="literal">InnoDB</code> page.
                    </p><p style="color:blue;">创建表t4的语句失败，因为定义的列超过了16kb innodb页的行大小限制。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t4 (</code></strong>
       <strong class="userinput"><code>c1 CHAR(255),c2 CHAR(255),c3 CHAR(255),</code></strong>
       <strong class="userinput"><code>c4 CHAR(255),c5 CHAR(255),c6 CHAR(255),</code></strong>
       <strong class="userinput"><code>c7 CHAR(255),c8 CHAR(255),c9 CHAR(255),</code></strong>
       <strong class="userinput"><code>c10 CHAR(255),c11 CHAR(255),c12 CHAR(255),</code></strong>
       <strong class="userinput"><code>c13 CHAR(255),c14 CHAR(255),c15 CHAR(255),</code></strong>
       <strong class="userinput"><code>c16 CHAR(255),c17 CHAR(255),c18 CHAR(255),</code></strong>
       <strong class="userinput"><code>c19 CHAR(255),c20 CHAR(255),c21 CHAR(255),</code></strong>
       <strong class="userinput"><code>c22 CHAR(255),c23 CHAR(255),c24 CHAR(255),</code></strong>
       <strong class="userinput"><code>c25 CHAR(255),c26 CHAR(255),c27 CHAR(255),</code></strong>
       <strong class="userinput"><code>c28 CHAR(255),c29 CHAR(255),c30 CHAR(255),</code></strong>
       <strong class="userinput"><code>c31 CHAR(255),c32 CHAR(255),c33 CHAR(255)</code></strong>
       <strong class="userinput"><code>) ENGINE=InnoDB ROW_FORMAT=COMPACT DEFAULT CHARSET latin1;</code></strong>
ERROR 1118 (42000): Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB or using
ROW_FORMAT=DYNAMIC or ROW_FORMAT=COMPRESSED may help. In current row format, BLOB prefix of 768
bytes is stored inline.
</pre></li></ul>
                </div>

            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="optimizing-innodb"></a>8.5&nbsp;Optimizing for InnoDB Tables</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#optimizing-innodb-storage-layout">8.5.1 Optimizing Storage Layout for InnoDB Tables</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-transaction-management">8.5.2 Optimizing InnoDB Transaction Management</a></span></dt><dt><span class="section"><a href="optimization.html#innodb-performance-ro-txn">8.5.3 Optimizing InnoDB Read-Only Transactions</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-logging">8.5.4 Optimizing InnoDB Redo Logging</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-bulk-data-loading">8.5.5 Bulk Data Loading for InnoDB Tables</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-queries">8.5.6 Optimizing InnoDB Queries</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-ddl-operations">8.5.7 Optimizing InnoDB DDL Operations</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-diskio">8.5.8 Optimizing InnoDB Disk I/O</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-configuration-variables">8.5.9 Optimizing InnoDB Configuration Variables</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-many-tables">8.5.10 Optimizing InnoDB for Systems with Many Tables</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286872487536"></a><a class="indexterm" name="idm140286872485664"></a><p>
        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> is the storage engine that
        MySQL customers typically use in production databases where
        reliability and concurrency are important.
        <code class="literal">InnoDB</code> is the default storage engine in MySQL.
        This section explains how to optimize database operations for
        <code class="literal">InnoDB</code> tables.
    </p><p style="color:blue;">innodb是mysql客户通常在生产数据库中使用的存储引擎，其中可靠性和并发性非常重要。InnoDB是MySQL中的默认存储引擎。本节介绍如何为innodb表优化数据库操作。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-innodb-storage-layout"></a>8.5.1&nbsp;Optimizing Storage Layout for InnoDB Tables</h3>
                    </div>
                </div>
            </div>

            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Once your data reaches a stable size, or a growing table has
                    increased by tens or some hundreds of megabytes, consider
                    using the <code class="literal">OPTIMIZE TABLE</code> statement to
                    reorganize the table and compact any wasted space. The
                    reorganized tables require less disk I/O to perform full
                    table scans. This is a straightforward technique that can
                    improve performance when other techniques such as improving
                    index usage or tuning application code are not practical.
                </p><p style="color:blue;">一旦数据达到稳定的大小，或者一个不断增长的表增加了几十或几百兆字节，请考虑使用optimize table语句重新组织该表，并压缩任何浪费的空间。重新组织的表执行完整表扫描所需的磁盘I/O更少。这是一种直接的技术，当其他技术（如提高索引使用率或优化应用程序代码）不实用时，它可以提高性能。</p><p></p><p>
                    <code class="literal">OPTIMIZE TABLE</code> copies the data part of
                    the table and rebuilds the indexes. The benefits come from
                    improved packing of data within indexes, and reduced
                    fragmentation within the tablespaces and on disk. The
                    benefits vary depending on the data in each table. You may
                    find that there are significant gains for some and not for
                    others, or that the gains decrease over time until you next
                    optimize the table. This operation can be slow if the table
                    is large or if the indexes being rebuilt do not fit into the
                    buffer pool. The first run after adding a lot of data to a
                    table is often much slower than later runs.
                </p><p style="color:blue;">优化表复制表的数据部分并重建索引。这些好处来自于改进了索引中的数据打包，减少了表空间和磁盘上的碎片。收益因每个表中的数据而异。您可能会发现，对于某些人而不是其他人来说，会有显著的收益，或者收益会随着时间的推移而减少，直到您下一次优化表。如果表很大或者重建的索引不适合缓冲池，则此操作可能会很慢。向表中添加大量数据后的第一次运行通常比以后的运行慢得多。</p><p></p></li><li class="listitem"><p>
                    In <code class="literal">InnoDB</code>, having a long <code class="literal">PRIMARY
                    KEY</code> (either a single column with a lengthy value,
                    or several columns that form a long composite value) wastes
                    a lot of disk space. The primary key value for a row is
                    duplicated in all the secondary index records that point to
                    the same row. (See <a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.6.2.1&nbsp;Clustered and Secondary Indexes">Section&nbsp;14.6.2.1, “Clustered and Secondary Indexes”</a>.)
                    Create an <code class="literal">AUTO_INCREMENT</code> column as the
                    primary key if your primary key is long, or index a prefix
                    of a long <code class="literal">VARCHAR</code> column instead of the
                    entire column.
                </p><p style="color:blue;">在innodb中，拥有一个长主键（一列有一个长值，或者有几列组成一个长组合值）会浪费大量的磁盘空间。行的主键值在指向同一行的所有辅助索引记录中重复。（请参阅14.6.2.1节，“聚集索引和辅助索引”。）如果主键是长的，则创建一个自动递增列作为主键，或者索引一个长varchar列的前缀，而不是整个列。</p><p></p></li><li class="listitem"><p>
                    Use the <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> data type
                    instead of <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> to store
                    variable-length strings or for columns with many
                    <code class="literal">NULL</code> values. A
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code></a>
                    column always takes <em class="replaceable"><code>N</code></em> characters
                    to store data, even if the string is shorter or its value is
                    <code class="literal">NULL</code>. Smaller tables fit better in the
                    buffer pool and reduce disk I/O.
                </p><p style="color:blue;">使用varchar数据类型（而不是char）存储可变长度字符串或具有许多空值的列。char（n）列总是使用n个字符来存储数据，即使字符串较短或其值为空。较小的表更适合缓冲池并减少磁盘I/O。</p><p></p><p>
                    When using <code class="literal">COMPACT</code> row format (the
                    default <code class="literal">InnoDB</code> format) and
                    variable-length character sets, such as
                    <code class="literal">utf8</code> or <code class="literal">sjis</code>,
                    <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code></a>
                    columns occupy a variable amount of space, but still at
                    least <em class="replaceable"><code>N</code></em> bytes.
                </p><p style="color:blue;">当使用压缩行格式（默认innodb格式）和可变长度字符集（如utf8或sjis）时，char（n）列占用可变的空间量，但至少仍占用n个字节。</p><p></p></li><li class="listitem"><p>
                    For tables that are big, or contain lots of repetitive text
                    or numeric data, consider using
                    <code class="literal">COMPRESSED</code> row format. Less disk I/O is
                    required to bring data into the buffer pool, or to perform
                    full table scans. Before making a permanent decision,
                    measure the amount of compression you can achieve by using
                    <code class="literal">COMPRESSED</code> versus
                    <code class="literal">COMPACT</code> row format.
                </p><p style="color:blue;">对于大型表或包含大量重复文本或数字数据的表，请考虑使用压缩行格式。将数据引入缓冲池或执行全表扫描所需的磁盘I/O更少。在做一个永久性的决定之前，测量使用压缩行格式和压缩行格式可以实现的压缩量。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-innodb-transaction-management"></a>8.5.2&nbsp;Optimizing InnoDB Transaction Management</h3>

                    </div>

                </div>

            </div>
            <p>
                To optimize <code class="literal">InnoDB</code> transaction processing,
                find the ideal balance between the performance overhead of
                transactional features and the workload of your server. For
                example, an application might encounter performance issues if it
                commits thousands of times per second, and different performance
                issues if it commits only every 2-3 hours.
            </p><p style="color:blue;">要优化innodb事务处理，请在事务特性的性能开销和服务器的工作负载之间找到理想的平衡点。例如，如果应用程序每秒提交数千次，则可能会遇到性能问题；如果应用程序仅每2-3小时提交一次，则可能会遇到不同的性能问题。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The default MySQL setting <code class="literal">AUTOCOMMIT=1</code>
                    can impose performance limitations on a busy database
                    server. Where practical, wrap several related data change
                    operations into a single transaction, by issuing
                    <code class="literal">SET AUTOCOMMIT=0</code> or a <code class="literal">START
                    TRANSACTION</code> statement, followed by a
                    <code class="literal">COMMIT</code> statement after making all the
                    changes.
                </p><p style="color:blue;">默认的mysql设置autocommit=1可以对繁忙的数据库服务器施加性能限制。在实际情况下，通过发出set autocommit=0或start transaction语句，然后在进行所有更改后发出commit语句，将几个相关的数据更改操作包装成一个事务。</p><p></p><p>
                    <code class="literal">InnoDB</code> must flush the log to disk at each
                    transaction commit if that transaction made modifications to
                    the database. When each change is followed by a commit (as
                    with the default autocommit setting), the I/O throughput of
                    the storage device puts a cap on the number of potential
                    operations per second.
                </p><p style="color:blue;">如果事务对数据库进行了修改，innodb必须在每次事务提交时刷新日志到磁盘。当每次更改后都执行提交（与默认的自动提交设置一样）时，存储设备的I/O吞吐量会限制每秒可能执行的操作数。</p><p></p></li><li class="listitem"><p>
                    Alternatively, for transactions that consist only of a
                    single <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement,
                    turning on <code class="literal">AUTOCOMMIT</code> helps
                    <code class="literal">InnoDB</code> to recognize read-only
                    transactions and optimize them. See
                    <a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3&nbsp;Optimizing InnoDB Read-Only Transactions">Section&nbsp;8.5.3, “Optimizing InnoDB Read-Only Transactions”</a> for
                    requirements.
                </p><p style="color:blue;">或者，对于只包含一个select语句的事务，打开autocommit有助于innodb识别只读事务并优化它们。有关需求，请参阅第8.5.3节“优化InnoDB只读事务”。</p><p></p></li><li class="listitem"><p>
                    Avoid performing rollbacks after inserting, updating, or
                    deleting huge numbers of rows. If a big transaction is
                    slowing down server performance, rolling it back can make
                    the problem worse, potentially taking several times as long
                    to perform as the original data change operations. Killing
                    the database process does not help, because the rollback
                    starts again on server startup.
                </p><p style="color:blue;">避免在插入、更新或删除大量行后执行回滚。如果一个大事务正在降低服务器性能，那么回滚可能会使问题变得更糟，执行原始数据更改操作可能需要几倍的时间。终止数据库进程没有帮助，因为回滚在服务器启动时再次启动。</p><p></p><p>
                    To minimize the chance of this issue occurring:
                </p><p style="color:blue;">要将此问题发生的可能性降至最低：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Increase the size of the
                            <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a> so
                            that all the data change changes can be cached rather
                            than immediately written to disk.
                        </p><p style="color:blue;">增加缓冲池的大小，以便可以缓存所有数据更改，而不是立即写入磁盘。</p><p></p></li><li class="listitem"><p>
                            Set
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering"><code class="literal">innodb_change_buffering=all</code></a>
                            so that update and delete operations are buffered in
                            addition to inserts.
                        </p><p style="color:blue;">设置innodb_change_buffering=all，以便除了插入操作之外，还缓冲更新和删除操作。</p><p></p></li><li class="listitem"><p>
                            Consider issuing <code class="literal">COMMIT</code> statements
                            periodically during the big data change operation,
                            possibly breaking a single delete or update into
                            multiple statements that operate on smaller numbers of
                            rows.
                        </p><p style="color:blue;">考虑在大数据更改操作期间周期性地发出commit语句，可能会将单个delete或update分为多个操作较少行的语句。</p><p></p></li></ul>
                    </div>
                    <p>
                        To get rid of a runaway rollback once it occurs, increase
                        the buffer pool so that the rollback becomes CPU-bound and
                        runs fast, or kill the server and restart with
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery"><code class="literal">innodb_force_recovery=3</code></a>, as
                        explained in <a class="xref" href="innodb-storage-engine.html#innodb-recovery" title="14.18.2&nbsp;InnoDB Recovery">Section&nbsp;14.18.2, “InnoDB Recovery”</a>.
                    </p><p style="color:blue;">要消除失控的回滚，请增加缓冲池，使回滚成为CPU绑定并快速运行，或者终止服务器并使用innodb force_recovery=3重新启动，如第14.18.2节“innodb recovery”所述。</p><p></p><p>
                        This issue is expected to be infrequent with the default
                        setting
                        <a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering"><code class="literal">innodb_change_buffering=all</code></a>,
                        which allows update and delete operations to be cached in
                        memory, making them faster to perform in the first place,
                        and also faster to roll back if needed. Make sure to use
                        this parameter setting on servers that process long-running
                        transactions with many inserts, updates, or deletes.
                    </p><p style="color:blue;">在默认设置innodb_change_buffering=all时，这个问题可能很少出现，它允许将更新和删除操作缓存在内存中，使它们在第一时间执行起来更快，并且在需要时回滚也更快。请确保在处理包含许多插入、更新或删除的长时间运行事务的服务器上使用此参数设置。</p><p></p></li><li class="listitem"><p>
                    If you can afford the loss of some of the latest committed
                    transactions if a crash occurs, you can set the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit"><code class="literal">innodb_flush_log_at_trx_commit</code></a>
                    parameter to 0. <code class="literal">InnoDB</code> tries to flush the
                    log once per second anyway, although the flush is not
                    guaranteed. Also, set the value of
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa"><code class="literal">innodb_support_xa</code></a> to 0,
                    which will reduce the number of disk flushes due to
                    synchronizing on disk data and the binary log.
                </p><p style="color:blue;">如果发生崩溃时，您能够承受最新提交的一些事务的丢失，那么可以将innodb_flush_log_at_trx_commit参数设置为0。无论如何，innodb尝试每秒刷新一次日志，尽管刷新是不保证的。另外，将innodb_support_xa的值设置为0，这将减少由于同步磁盘数据和二进制日志而导致的磁盘刷新次数。</p><p></p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa"><code class="literal">innodb_support_xa</code></a> is
                            deprecated and will be removed in a future release. As of
                            MySQL 5.7.10, <code class="literal">InnoDB</code> support for
                            two-phase commit in XA transactions is always enabled and
                            disabling
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa"><code class="literal">innodb_support_xa</code></a> is no
                            longer permitted.
                        </p><p style="color:blue;">innodb_support_xa已弃用，将在将来的版本中删除。从mysql 5.7.10开始，innodb对xa事务中的两阶段提交的支持一直处于启用状态，并且不再允许禁用innodb_support_xa。</p><p></p>
                    </div>
                </li><li class="listitem"><p>
                    When rows are modified or deleted, the rows and associated
                    <a class="link" href="glossary.html#glos_undo_log" title="undo log">undo logs</a> are not
                    physically removed immediately, or even immediately after
                    the transaction commits. The old data is preserved until
                    transactions that started earlier or concurrently are
                    finished, so that those transactions can access the previous
                    state of modified or deleted rows. Thus, a long-running
                    transaction can prevent <code class="literal">InnoDB</code> from
                    purging data that was changed by a different transaction.
                </p><p style="color:blue;">修改或删除行时，不会立即或甚至在事务提交后立即物理删除行和关联的撤消日志。旧数据将一直保留到较早或同时启动的事务完成，以便这些事务可以访问已修改或已删除行的先前状态。因此，长时间运行的事务可以防止innodb清除由不同事务更改的数据。</p><p></p></li><li class="listitem"><p>
                    When rows are modified or deleted within a long-running
                    transaction, other transactions using the
                    <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a> and
                    <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE READ</code></a> isolation
                    levels have to do more work to reconstruct the older data if
                    they read those same rows.
                </p><p style="color:blue;">当在长时间运行的事务中修改或删除行时，使用“已提交读取”和“可重复读取”隔离级别的其他事务如果读取了相同的行，则必须做更多的工作来重建旧数据。</p><p></p></li><li class="listitem"><p>
                    When a long-running transaction modifies a table, queries
                    against that table from other transactions do not make use
                    of the <a class="link" href="glossary.html#glos_covering_index" title="covering index">covering
                    index</a> technique. Queries that normally could retrieve
                    all the result columns from a secondary index, instead look
                    up the appropriate values from the table data.
                </p><p style="color:blue;">当一个长时间运行的事务修改一个表时，来自其他事务的对该表的查询不会使用覆盖索引技术。通常可以从辅助索引检索所有结果列的查询，而不是从表数据中查找适当的值。</p><p></p><p>
                    If secondary index pages are found to have a
                    <code class="literal">PAGE_MAX_TRX_ID</code> that is too new, or if
                    records in the secondary index are delete-marked,
                    <code class="literal">InnoDB</code> may need to look up records using
                    a clustered index.
                </p><p style="color:blue;">如果发现二级索引页的page_max_trx_id太新，或者二级索引中的记录被标记为delete，innodb可能需要使用聚集索引查找记录。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-performance-ro-txn"></a>8.5.3&nbsp;Optimizing InnoDB Read-Only Transactions</h3>

                    </div>

                </div>

            </div>
            <p>
                <code class="literal">InnoDB</code> can avoid the overhead associated with
                setting up the <a class="link" href="glossary.html#glos_transaction_id" title="transaction ID">transaction
                ID</a> (<code class="literal">TRX_ID</code> field) for transactions
                that are known to be read-only. A transaction ID is only needed
                for a <a class="link" href="glossary.html#glos_transaction" title="transaction">transaction</a> that
                might perform write operations or
                <a class="link" href="glossary.html#glos_locking_read" title="locking read">locking reads</a> such as
                <code class="literal">SELECT ... FOR UPDATE</code>. Eliminating
                unnecessary transaction IDs reduces the size of internal data
                structures that are consulted each time a query or data change
                statement constructs a <a class="link" href="glossary.html#glos_read_view" title="read view">read
                view</a>.
            </p><p style="color:blue;">innodb可以避免为已知为只读的事务设置事务id（trx_id字段）的相关开销。事务ID仅对可能执行写操作或锁定读取（如选择）的事务需要。更新。消除不必要的事务id会减少每次查询或数据更改语句构造读取视图时所参考的内部数据结构的大小。</p><p></p><p>
            <code class="literal">InnoDB</code> detects read-only transactions when:
        </p><p style="color:blue;">InnoDB在以下情况下检测只读事务：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The transaction is started with the
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START TRANSACTION
                        READ ONLY</code></a> statement. In this case, attempting to
                    make changes to the database (for <code class="literal">InnoDB</code>,
                    <code class="literal">MyISAM</code>, or other types of tables) causes
                    an error, and the transaction continues in read-only state:
                </p><p style="color:blue;">事务是用start transaction只读语句启动的。在这种情况下，试图更改数据库（对于innodb、myisam或其他类型的表）会导致错误，并且事务继续处于只读状态：</p><p></p><pre data-lang="none" class="programlisting">ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.
</pre><p>
                    You can still make changes to session-specific temporary
                    tables in a read-only transaction, or issue locking queries
                    for them, because those changes and locks are not visible to
                    any other transaction.
                </p><p style="color:blue;">您仍然可以对只读事务中特定于会话的临时表进行更改，或者对它们发出锁定查询，因为这些更改和锁定对任何其他事务都不可见。</p><p></p></li><li class="listitem"><p>
                    The <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a> setting is
                    turned on, so that the transaction is guaranteed to be a
                    single statement, and the single statement making up the
                    transaction is a <span class="quote">“<span class="quote">non-locking</span>”</span>
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. That is, a
                    <code class="literal">SELECT</code> that does not use a <code class="literal">FOR
                    UPDATE</code> or <code class="literal">LOCK IN SHARED MODE</code>
                    clause.
                </p><p style="color:blue;">autocommit设置被打开，这样事务就保证是单个语句，而组成事务的单个语句是一个“非锁定”select语句。也就是说，不使用for update或lock in shared mode子句的select。</p><p></p></li><li class="listitem"><p>
                    The transaction is started without the <code class="literal">READ
                    ONLY</code> option, but no updates or statements that
                    explicitly lock rows have been executed yet. Until updates
                    or explicit locks are required, a transaction stays in
                    read-only mode.
                </p><p style="color:blue;">事务在没有只读选项的情况下启动，但尚未执行显式锁定行的更新或语句。在需要更新或显式锁之前，事务保持只读模式。</p><p></p></li></ul>
            </div>
            <p>
                Thus, for a read-intensive application such as a report
                generator, you can tune a sequence of <code class="literal">InnoDB</code>
                queries by grouping them inside
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START TRANSACTION READ
                    ONLY</code></a> and
                <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a>, or by
                turning on the <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a>
                setting before running the <code class="literal">SELECT</code> statements,
                or simply by avoiding any data change statements interspersed
                with the queries.
            </p><p style="color:blue;">因此，对于像报表生成器这样的读密集型应用程序，您可以通过将innodb查询分组到start transaction read only and commit中，或者在运行select语句之前打开autocommit设置，或者通过避免任何数据更改语句散布在查询中，来优化innodb查询序列。</p><p></p><p>
            For information about
            <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">START
                TRANSACTION</code></a> and
            <a class="link" href="server-administration.html#sysvar_autocommit"><code class="literal">autocommit</code></a>, see
            <a class="xref" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax">Section&nbsp;13.3.1, “START TRANSACTION, COMMIT, and ROLLBACK Syntax”</a>.
        </p><p style="color:blue;">有关启动事务和自动提交的信息，请参阅第13.3.1节“启动事务、提交和回滚语法”。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Transactions that qualify as auto-commit, non-locking, and
                    read-only (AC-NL-RO) are kept out of certain internal
                    <code class="literal">InnoDB</code> data structures and are therefore
                    not listed in
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB STATUS</code></a> output.
                </p><p style="color:blue;">符合自动提交、非锁定和只读（ac-nl-ro）条件的事务不在某些内部innodb数据结构中，因此不在show engine innodb status output中列出。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-innodb-logging"></a>8.5.4&nbsp;Optimizing InnoDB Redo Logging</h3>

                    </div>

                </div>

            </div>
            <p>
                Consider the following guidelines for optimizing redo logging:
            </p><p style="color:blue;">请考虑以下优化重做日志记录的准则：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Make your redo log files big, even as big as the
                    <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>. When
                    <code class="literal">InnoDB</code> has written the redo log files
                    full, it must write the modified contents of the buffer pool
                    to disk in a
                    <a class="link" href="glossary.html#glos_checkpoint" title="checkpoint">checkpoint</a>. Small
                    redo log files cause many unnecessary disk writes. Although
                    historically big redo log files caused lengthy recovery
                    times, recovery is now much faster and you can confidently
                    use large redo log files.
                </p><p style="color:blue;">使重做日志文件变大，甚至与缓冲池一样大。当innodb将重做日志文件写满时，它必须将修改后的缓冲池内容写入检查点中的磁盘。小的重做日志文件会导致许多不必要的磁盘写入。尽管历史上较大的重做日志文件会导致较长的恢复时间，但现在恢复速度要快得多，您可以放心地使用较大的重做日志文件。</p><p></p><p>
                    The size and number of redo log files are configured using
                    the <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a>
                    and
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group"><code class="literal">innodb_log_files_in_group</code></a>
                    configuration options. For information about modifying an
                    existing redo log file configuration, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-redo-log-file-reconfigure" title="Changing the Number or Size of InnoDB Redo Log Files">Changing the Number or Size of InnoDB Redo Log Files</a>.
                </p><p style="color:blue;">重做日志文件的大小和数量是使用innodb_log_file_size和innodb_log_files_in_group configuration选项配置的。有关修改现有重做日志文件配置的信息，请参阅更改YNODB重做日志文件的数量或大小。</p><p></p></li><li class="listitem"><p>
                    Consider increasing the size of the
                    <a class="link" href="glossary.html#glos_log_buffer" title="log buffer">log buffer</a>. A large
                    log buffer enables large
                    <a class="link" href="glossary.html#glos_transaction" title="transaction">transactions</a> to run
                    without a need to write the log to disk before the
                    transactions <a class="link" href="glossary.html#glos_commit" title="commit">commit</a>.
                    Thus, if you have transactions that update, insert, or
                    delete many rows, making the log buffer larger saves disk
                    I/O. Log buffer size is configured using the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size"><code class="literal">innodb_log_buffer_size</code></a>
                    configuration option.
                </p><p style="color:blue;">考虑增大日志缓冲区的大小。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将日志写入磁盘。因此，如果您有更新、插入或删除许多行的事务，那么增大日志缓冲区可以保存磁盘I/O。日志缓冲区大小是使用innodb_log_buffer_size配置选项配置的。</p><p></p></li><li class="listitem"><p>
                    Configure the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    configuration option to avoid <span class="quote">“<span class="quote">read-on-write</span>”</span>.
                    This option defines the write-ahead block size for the redo
                    log. Set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    to match the operating system or file system cache block
                    size. Read-on-write occurs when redo log blocks are not
                    entirely cached to the operating system or file system due
                    to a mismatch between write-ahead block size for the redo
                    log and operating system or file system cache block size.
                </p><p style="color:blue;">配置innodb_log_write_ahead_size配置选项以避免“读写”。此选项定义重做日志的预写块大小。将innodb_log_write_ahead_size设置为与操作系统或文件系统缓存块大小匹配。当由于重做日志的预写块大小与操作系统或文件系统缓存块大小不匹配，重做日志块未完全缓存到操作系统或文件系统时，会发生读写操作。</p><p></p><p>
                    Valid values for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    are multiples of the <code class="literal">InnoDB</code> log file
                    block size (2<sup>n</sup>). The minimum
                    value is the <code class="literal">InnoDB</code> log file block size
                    (512). Write-ahead does not occur when the minimum value is
                    specified. The maximum value is equal to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value. If
                    you specify a value for
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    that is larger than the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value, the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    setting is truncated to the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a> value.
                </p><p style="color:blue;">innodb_log_write_ahead_size的有效值是innodb日志文件块大小（2n）的倍数。最小值是innodb日志文件块大小（512）。指定最小值时，不会发生提前写入。最大值等于NoNdByPaGig.Stand值。如果为innodb_log_write_ahead_size指定的值大于innodb_page_size值，则innodb_log_write_ahead_size设置将被截断为innodb_page_size值。</p><p></p><p>
                    Setting the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_write_ahead_size"><code class="literal">innodb_log_write_ahead_size</code></a>
                    value too low in relation to the operating system or file
                    system cache block size results in read-on-write. Setting
                    the value too high may have a slight impact on
                    <code class="literal">fsync</code> performance for log file writes due
                    to several blocks being written at once.
                </p><p style="color:blue;">将innodb_log_write_ahead_size值相对于操作系统或文件系统缓存块大小设置得过低会导致读写操作。由于一次写入多个块，将该值设置得太高可能会对fsync日志文件写入性能产生轻微影响。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-innodb-bulk-data-loading"></a>8.5.5&nbsp;Bulk Data Loading for InnoDB Tables</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286872340944"></a><p>
            These performance tips supplement the general guidelines for
            fast inserts in <a class="xref" href="optimization.html#insert-optimization" title="8.2.4.1&nbsp;Optimizing INSERT Statements">Section&nbsp;8.2.4.1, “Optimizing INSERT Statements”</a>.
        </p><p style="color:blue;">这些性能提示补充了第8.2.4.1节“优化插入语句”中有关快速插入的一般指南。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    When importing data into <code class="literal">InnoDB</code>, turn off
                    autocommit mode, because it performs a log flush to disk for
                    every insert. To disable autocommit during your import
                    operation, surround it with
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">SET
                        autocommit</code></a> and
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> statements:
                </p><p style="color:blue;">当将数据导入innodb时，关闭autocommit模式，因为它对每次插入执行日志刷新到磁盘。要在导入操作期间禁用自动提交，请使用SET AUTOcommit和commit语句将其括起来：</p><p></p><pre data-lang="sql" class="programlisting">SET autocommit=0;
<em class="replaceable"><code>... SQL import statements ...</code></em>
COMMIT;
</pre><p>
                    The <a class="link" href="programs.html#mysqldump" title="4.5.4&nbsp;mysqldump — A Database Backup Program"><span class="command"><strong>mysqldump</strong></span></a> option
                    <a class="link" href="programs.html#option_mysqldump_opt"><code class="option">--opt</code></a> creates dump files
                    that are fast to import into an <code class="literal">InnoDB</code>
                    table, even without wrapping them with the
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">SET
                        autocommit</code></a> and
                    <a class="link" href="sql-syntax.html#commit" title="13.3.1&nbsp;START TRANSACTION, COMMIT, and ROLLBACK Syntax"><code class="literal">COMMIT</code></a> statements.
                </p><p style="color:blue;">mysqldump选项--opt创建的转储文件可以快速导入到innodb表中，即使不使用set autocommit和commit语句包装它们。</p><p></p></li><li class="listitem"><p>
                    If you have <code class="literal">UNIQUE</code> constraints on
                    secondary keys, you can speed up table imports by
                    temporarily turning off the uniqueness checks during the
                    import session:
                </p><p style="color:blue;">如果对次关键字有唯一约束，则可以通过在导入会话期间临时关闭唯一性检查来加快表导入：</p><p></p><pre data-lang="sql" class="programlisting">SET unique_checks=0;
<em class="replaceable"><code>... SQL import statements ...</code></em>
SET unique_checks=1;
</pre><p>
                    For big tables, this saves a lot of disk I/O because
                    <code class="literal">InnoDB</code> can use its change buffer to write
                    secondary index records in a batch. Be certain that the data
                    contains no duplicate keys.
                </p><p style="color:blue;">对于大表，这节省了大量的磁盘I/O，因为InnoDB可以使用它的更改缓冲区在批处理中写入辅助索引记录。确保数据不包含重复的键。</p><p></p></li><li class="listitem"><p>
                    If you have <code class="literal">FOREIGN KEY</code> constraints in
                    your tables, you can speed up table imports by turning off
                    the foreign key checks for the duration of the import
                    session:
                </p><p style="color:blue;">如果表中有外键约束，则可以通过在导入会话期间关闭外键检查来加快表导入：</p><p></p><pre data-lang="sql" class="programlisting">SET foreign_key_checks=0;
<em class="replaceable"><code>... SQL import statements ...</code></em>
SET foreign_key_checks=1;
</pre><p>
                    For big tables, this can save a lot of disk I/O.
                </p><p style="color:blue;">对于大型表，这可以节省大量磁盘I/O。</p><p></p></li><li class="listitem"><p>
                    Use the multiple-row <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                    syntax to reduce communication overhead between the client
                    and the server if you need to insert many rows:
                </p><p style="color:blue;">如果需要插入多行，请使用多行插入语法来减少客户端和服务器之间的通信开销：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO yourtable VALUES (1,2), (5,5), ...;
</pre><p>
                    This tip is valid for inserts into any table, not just
                    <code class="literal">InnoDB</code> tables.
                </p><p style="color:blue;">这个技巧对插入任何表都有效，而不仅仅是innodb表。</p><p></p></li><li class="listitem"><p>
                    When doing bulk inserts into tables with auto-increment
                    columns, set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode"><code class="literal">innodb_autoinc_lock_mode</code></a> to
                    2 instead of the default value 1. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="14.6.1.4&nbsp;AUTO_INCREMENT Handling in InnoDB">Section&nbsp;14.6.1.4, “AUTO_INCREMENT Handling in InnoDB”</a> for
                    details.
                </p><p style="color:blue;">在对具有自动递增列的表执行大容量插入时，将innodb_autoinc_lock_mode设置为2，而不是默认值1。详见14.6.1.4节“InnoDB中的自动增量处理”。</p><p></p></li><li class="listitem"><p>
                    When performing bulk inserts, it is faster to insert rows in
                    <code class="literal">PRIMARY KEY</code> order.
                    <code class="literal">InnoDB</code> tables use a
                    <a class="link" href="glossary.html#glos_clustered_index" title="clustered index">clustered index</a>,
                    which makes it relatively fast to use data in the order of
                    the <code class="literal">PRIMARY KEY</code>. Performing bulk inserts
                    in <code class="literal">PRIMARY KEY</code> order is particularly
                    important for tables that do not fit entirely within the
                    buffer pool.
                </p><p style="color:blue;">执行大容量插入时，按主键顺序插入行更快。innodb表使用聚集索引，这使得按照主键的顺序使用数据相对更快。对于不完全适合缓冲池的表，按主键顺序执行大容量插入尤其重要。</p><p></p></li><li class="listitem"><p>
                    For optimal performance when loading data into an
                    <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> index,
                    follow this set of steps:
                </p><p style="color:blue;">为了在将数据加载到innodb全文索引中时获得最佳性能，请执行以下步骤：</p><p></p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Define a column <code class="literal">FTS_DOC_ID</code> at table
                            creation time, of type <code class="literal">BIGINT UNSIGNED NOT
                            NULL</code>, with a unique index named
                            <code class="literal">FTS_DOC_ID_INDEX</code>. For example:
                        </p><p style="color:blue;">在表创建时定义一个类型为bigint unsigned not null的列fts_doc_id，其唯一索引名为fts_doc_index。例如：</p><p></p><pre data-lang="sql" class="programlisting">CREATE TABLE t1 (
FTS_DOC_ID BIGINT unsigned NOT NULL AUTO_INCREMENT,
title varchar(255) NOT NULL DEFAULT '',
text mediumtext NOT NULL,
PRIMARY KEY (`FTS_DOC_ID`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on t1(FTS_DOC_ID);
</pre></li><li class="listitem"><p>
                            Load the data into the table.
                        </p><p style="color:blue;">将数据加载到表中。</p><p></p></li><li class="listitem"><p>
                            Create the <code class="literal">FULLTEXT</code> index after the
                            data is loaded.
                        </p><p style="color:blue;">加载数据后创建全文索引。</p><p></p></li></ol>
                    </div>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            When adding <code class="literal">FTS_DOC_ID</code> column at table
                            creation time, ensure that the
                            <code class="literal">FTS_DOC_ID</code> column is updated when the
                            <code class="literal">FULLTEXT</code> indexed column is updated, as
                            the <code class="literal">FTS_DOC_ID</code> must increase
                            monotonically with each
                            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
                            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>. If you choose not
                            to add the <code class="literal">FTS_DOC_ID</code> at table creation
                            time and have <code class="literal">InnoDB</code> manage DOC IDs for
                            you, <code class="literal">InnoDB</code> will add the
                            <code class="literal">FTS_DOC_ID</code> as a hidden column with the
                            next <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE
                            FULLTEXT INDEX</code></a> call. This approach, however,
                            requires a table rebuild which will impact performance.
                        </p><p style="color:blue;">在表创建时添加fts_doc_id列时，请确保在更新全文索引列时更新fts_doc_id列，因为每次插入或更新时fts_doc_id必须单调增加。如果您选择在创建表时不添加fts_doc_id，并且有innodb manage doc id，innodb将在下一个create fulltext索引调用中将fts_doc_id添加为隐藏列。但是，这种方法需要重建表，这将影响性能。</p><p></p>
                    </div>
                </li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-innodb-queries"></a>8.5.6&nbsp;Optimizing InnoDB Queries</h3>

                    </div>

                </div>

            </div>
            <p>
                To tune queries for <code class="literal">InnoDB</code> tables, create an
                appropriate set of indexes on each table. See
                <a class="xref" href="optimization.html#mysql-indexes" title="8.3.1&nbsp;How MySQL Uses Indexes">Section&nbsp;8.3.1, “How MySQL Uses Indexes”</a> for details. Follow these
                guidelines for <code class="literal">InnoDB</code> indexes:
            </p><p style="color:blue;">要优化innodb表的查询，请在每个表上创建一组适当的索引。详见8.3.1节“MySQL如何使用索引”。对于innodb索引，请遵循以下准则：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Because each <code class="literal">InnoDB</code> table has a
                    <a class="link" href="glossary.html#glos_primary_key" title="primary key">primary key</a> (whether
                    you request one or not), specify a set of primary key
                    columns for each table, columns that are used in the most
                    important and time-critical queries.
                </p><p style="color:blue;">因为每个innodb表都有一个主键（无论您是否请求主键），所以为每个表指定一组主键列，这些列用于最重要和最关键的查询。</p><p></p></li><li class="listitem"><p>
                    Do not specify too many or too long columns in the primary
                    key, because these column values are duplicated in each
                    secondary index. When an index contains unnecessary data,
                    the I/O to read this data and memory to cache it reduce the
                    performance and scalability of the server.
                </p><p style="color:blue;">不要在主键中指定太多或太长的列，因为这些列值在每个辅助索引中都是重复的。当索引包含不必要的数据时，读取该数据的I/O和缓存该数据的内存会降低服务器的性能和可伸缩性。</p><p></p></li><li class="listitem"><p>
                    Do not create a separate
                    <a class="link" href="glossary.html#glos_secondary_index" title="secondary index">secondary index</a>
                    for each column, because each query can only make use of one
                    index. Indexes on rarely tested columns or columns with only
                    a few different values might not be helpful for any queries.
                    If you have many queries for the same table, testing
                    different combinations of columns, try to create a small
                    number of
                    <a class="link" href="glossary.html#glos_concatenated_index" title="concatenated index">concatenated
                        indexes</a> rather than a large number of single-column
                    indexes. If an index contains all the columns needed for the
                    result set (known as a
                    <a class="link" href="glossary.html#glos_covering_index" title="covering index">covering index</a>),
                    the query might be able to avoid reading the table data at
                    all.
                </p><p style="color:blue;">不要为每个列创建单独的辅助索引，因为每个查询只能使用一个索引。很少测试的列或只有几个不同值的列上的索引可能对任何查询都没有帮助。如果对同一个表有多个查询，测试不同的列组合，请尝试创建少量的连接索引，而不是大量的单列索引。如果索引包含结果集所需的所有列（称为覆盖索引），则查询可能完全避免读取表数据。</p><p></p></li><li class="listitem"><p>
                    If an indexed column cannot contain any
                    <code class="literal">NULL</code> values, declare it as <code class="literal">NOT
                    NULL</code> when you create the table. The optimizer can
                    better determine which index is most effective to use for a
                    query, when it knows whether each column contains
                    <code class="literal">NULL</code> values.
                </p><p style="color:blue;">如果索引列不能包含任何空值，请在创建表时将其声明为非空。当优化器知道每个列是否包含空值时，它可以更好地确定哪个索引最适合用于查询。</p><p></p></li><li class="listitem"><p>
                    You can optimize single-query transactions for
                    <code class="literal">InnoDB</code> tables, using the technique in
                    <a class="xref" href="optimization.html#innodb-performance-ro-txn" title="8.5.3&nbsp;Optimizing InnoDB Read-Only Transactions">Section&nbsp;8.5.3, “Optimizing InnoDB Read-Only Transactions”</a>.
                </p><p style="color:blue;">您可以使用8.5.3节“优化InnoDB只读事务”中的技术为InnoDB表优化单查询事务。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-innodb-ddl-operations"></a>8.5.7&nbsp;Optimizing InnoDB DDL Operations</h3>

                    </div>

                </div>

            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Many DDL operations on tables and indexes
                    (<code class="literal">CREATE</code>, <code class="literal">ALTER</code>, and
                    <code class="literal">DROP</code> statements) can be performed online.
                    See <a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.13&nbsp;InnoDB and Online DDL">Section&nbsp;14.13, “InnoDB and Online DDL”</a> for details.
                </p><p style="color:blue;">对表和索引的许多ddl操作（create、alter和drop语句）都可以在线执行。详见14.13节“InnoDB和在线DDL”。</p><p></p></li><li class="listitem"><p>
                    Online DDL support for adding secondary indexes means that
                    you can generally speed up the process of creating and
                    loading a table and associated indexes by creating the table
                    without secondary indexes, then adding secondary indexes
                    after the data is loaded.
                </p><p style="color:blue;">对添加辅助索引的在线ddl支持意味着您通常可以通过创建不带辅助索引的表，然后在加载数据后添加辅助索引来加快创建和加载表及其关联索引的过程。</p><p></p></li><li class="listitem"><p>
                    Use <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> to empty a
                    table, not <code class="literal">DELETE FROM
                    <em class="replaceable"><code>tbl_name</code></em></code>. Foreign key
                    constraints can make a <code class="literal">TRUNCATE</code> statement
                    work like a regular <code class="literal">DELETE</code> statement, in
                    which case a sequence of commands like
                    <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a> and
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> might be
                    fastest.
                </p><p style="color:blue;">使用truncate table清空表，而不是从tbl_name中删除。外键约束可以使truncate语句像常规delete语句一样工作，在这种情况下，drop table和create table之类的命令序列可能最快。</p><p></p></li><li class="listitem"><p>
                    Because the primary key is integral to the storage layout of
                    each <code class="literal">InnoDB</code> table, and changing the
                    definition of the primary key involves reorganizing the
                    whole table, always set up the primary key as part of the
                    <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a> statement, and
                    plan ahead so that you do not need to
                    <code class="literal">ALTER</code> or <code class="literal">DROP</code> the
                    primary key afterward.
                </p><p style="color:blue;">因为主键是每个innodb表的存储布局的组成部分，更改主键的定义涉及到重新组织整个表，始终将主键设置为create table语句的一部分，并提前计划，这样以后就不需要更改或删除主键。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-innodb-diskio"></a>8.5.8&nbsp;Optimizing InnoDB Disk I/O</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286872248000"></a><a class="indexterm" name="idm140286872246512"></a><a class="indexterm" name="idm140286872245440"></a><a class="indexterm" name="idm140286872244368"></a><p>
            If you follow best practices for database design and tuning
            techniques for SQL operations, but your database is still slow
            due to heavy disk I/O activity, consider these disk I/O
            optimizations. If the Unix <code class="filename">top</code> tool or the
            Windows Task Manager shows that the CPU usage percentage with
            your workload is less than 70%, your workload is probably
            disk-bound.
        </p><p style="color:blue;">如果遵循数据库设计的最佳实践和SQL操作的优化技术，但由于磁盘I/O活动太多，数据库仍然很慢，请考虑这些磁盘I/O优化。如果unix top工具或windows任务管理器显示工作负载的cpu使用率低于70%，那么工作负载可能是磁盘绑定的。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Increase buffer pool size
                </p><p style="color:blue;">增加缓冲池大小</p><p></p><p>
                    When table data is cached in the <code class="literal">InnoDB</code>
                    buffer pool, it can be accessed repeatedly by queries
                    without requiring any disk I/O. Specify the size of the
                    buffer pool with the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                    option. This memory area is important enough that it is
                    typically recommended that
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a> is
                    configured to 50 to 75 percent of system memory. For more
                    information see, <a class="xref" href="optimization.html#memory-use" title="8.12.4.1&nbsp;How MySQL Uses Memory">Section&nbsp;8.12.4.1, “How MySQL Uses Memory”</a>.
                </p><p style="color:blue;">当表数据缓存在innodb缓冲池中时，查询可以重复访问它，而不需要任何磁盘I/O。使用innodb_buffer_pool_size选项指定缓冲池的大小。这个内存区域非常重要，通常建议将innodb_buffer_pool_size配置为系统内存的50%到75%。有关更多信息，请参阅第8.12.4.1节“MySQL如何使用内存”。</p><p></p></li><li class="listitem"><p>
                    Adjust the flush method
                </p><p style="color:blue;">调整冲洗方法</p><p></p><p>
                    In some versions of GNU/Linux and Unix, flushing files to
                    disk with the Unix <code class="literal">fsync()</code> call (which
                    <code class="literal">InnoDB</code> uses by default) and similar
                    methods is surprisingly slow. If database write performance
                    is an issue, conduct benchmarks with the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method</code></a>
                    parameter set to <code class="literal">O_DSYNC</code>.
                </p><p style="color:blue;">在某些版本的gnu/linux和unix中，使用unix fsync（）调用（innodb默认使用）和类似方法将文件刷新到磁盘的速度非常慢。如果数据库写性能是一个问题，请使用innodb_flush_method参数设置为o_dsync来执行基准测试。</p><p></p></li><li class="listitem"><p>
                    Use a noop or deadline I/O scheduler with native AIO on
                    Linux
                </p><p style="color:blue;">在Linux上对本机AIO使用Noop或Deadline I/O调度程序</p><p></p><p>
                    <code class="literal">InnoDB</code> uses the asynchronous I/O
                    subsystem (native AIO) on Linux to perform read-ahead and
                    write requests for data file pages. This behavior is
                    controlled by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio"><code class="literal">innodb_use_native_aio</code></a>
                    configuration option, which is enabled by default. With
                    native AIO, the type of I/O scheduler has greater influence
                    on I/O performance. Generally, noop and deadline I/O
                    schedulers are recommended. Conduct benchmarks to determine
                    which I/O scheduler provides the best results for your
                    workload and environment. For more information, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-linux-native-aio" title="14.8.7&nbsp;Using Asynchronous I/O on Linux">Section&nbsp;14.8.7, “Using Asynchronous I/O on Linux”</a>.
                </p><p style="color:blue;">innodb使用linux上的异步i/o子系统（本地aio）来执行数据文件页的读写请求。此行为由innodb_use_native_aio配置选项控制，该选项在默认情况下已启用。对于本机aio，i/o调度程序的类型对i/o性能有更大的影响。通常，建议使用noop和截止日期i/o调度程序。执行基准测试以确定哪个I/O调度程序为您的工作负载和环境提供最佳结果。有关更多信息，请参阅14.8.7节，“在Linux上使用异步I/O”。</p><p></p></li><li class="listitem"><p>
                    Use direct I/O on Solaris 10 for x86_64 architecture
                </p><p style="color:blue;">在用于x86_64体系结构的solaris 10上使用直接I/O</p><p></p><p>
                    When using the <code class="literal">InnoDB</code> storage engine on
                    Solaris 10 for x86_64 architecture (AMD Opteron), use direct
                    I/O for <code class="literal">InnoDB</code>-related files to avoid
                    degradation of <code class="literal">InnoDB</code> performance. To use
                    direct I/O for an entire UFS file system used for storing
                    <code class="literal">InnoDB</code>-related files, mount it with the
                    <code class="literal">forcedirectio</code> option; see
                    <code class="literal">mount_ufs(1M)</code>. (The default on Solaris
                    10/x86_64 is <span class="emphasis"><em>not</em></span> to use this option.)
                    To apply direct I/O only to <code class="literal">InnoDB</code> file
                    operations rather than the whole file system, set
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method =
                        O_DIRECT</code></a>. With this setting,
                    <code class="literal">InnoDB</code> calls
                    <code class="literal">directio()</code> instead of
                    <code class="literal">fcntl()</code> for I/O to data files (not for
                    I/O to log files).
                </p><p style="color:blue;">在solaris10forx86_64体系结构（amd opteron）上使用innodb存储引擎时，请对innodb相关文件使用直接i/o，以避免innodb性能下降。要对用于存储innodb相关文件的整个ufs文件系统使用直接i/o，请使用forcedirectio选项装载它；请参阅mount-ufs（1m）。（solaris 10/x86_64上的默认设置是不使用此选项。）要仅对innodb文件操作而不是整个文件系统应用直接i/o，请设置innodb_flush_method=o_direct。使用此设置，innodb调用directio（）而不是fcntl（）来对数据文件进行I/O（而不是对日志文件进行I/O）。</p><p></p></li><li class="listitem"><p>
                    Use raw storage for data and log files with Solaris 2.6 or
                    later
                </p><p style="color:blue;">在solaris 2.6或更高版本中对数据和日志文件使用原始存储</p><p></p><p>
                    When using the <code class="literal">InnoDB</code> storage engine with
                    a large
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                    value on any release of Solaris 2.6 and up and any platform
                    (sparc/x86/x64/amd64), conduct benchmarks with
                    <code class="literal">InnoDB</code> data files and log files on raw
                    devices or on a separate direct I/O UFS file system, using
                    the <code class="literal">forcedirectio</code> mount option as
                    described previously. (It is necessary to use the mount
                    option rather than setting
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method</code></a> if you
                    want direct I/O for the log files.) Users of the Veritas
                    file system VxFS should use the
                    <code class="literal">convosync=direct</code> mount option.
                </p><p style="color:blue;">在任何版本的solaris 2.6及更高版本和任何平台（sparc/x86/x64/amd64）上使用具有较大innodb缓冲池大小值的innodb存储引擎时，使用前面描述的forcedirectio mount选项，在原始设备或单独的直接i/o ufs文件系统上使用innodb数据文件和日志文件进行基准测试。（如果需要日志文件的直接I/O，则必须使用mount选项，而不是设置innodb_flush_方法。）Veritas文件系统Vxfs的用户应使用convasync=direct mount选项。</p><p></p><p>
                    Do not place other MySQL data files, such as those for
                    <code class="literal">MyISAM</code> tables, on a direct I/O file
                    system. Executables or libraries <span class="emphasis"><em>must
            not</em></span> be placed on a direct I/O file system.
                </p><p style="color:blue;">不要将其他mysql数据文件（例如myisam表的数据文件）放在直接i/o文件系统上。不能将可执行文件或库放在直接I/O文件系统上。</p><p></p></li><li class="listitem"><p>
                    Use additional storage devices
                </p><p style="color:blue;">使用其他存储设备</p><p></p><p>
                    Additional storage devices could be used to set up a RAID
                    configuration. For related information, see
                    <a class="xref" href="optimization.html#disk-issues" title="8.12.2&nbsp;Optimizing Disk I/O">Section&nbsp;8.12.2, “Optimizing Disk I/O”</a>.
                </p><p style="color:blue;">可以使用其他存储设备设置RAID配置。有关信息，请参阅第8.12.2节“优化磁盘I/O”。</p><p></p><p>
                    Alternatively, <code class="literal">InnoDB</code> tablespace data
                    files and log files can be placed on different physical
                    disks. For more information, refer to the following
                    sections:
                </p><p style="color:blue;">或者，innodb表空间数据文件和日志文件可以放在不同的物理磁盘上。有关详细信息，请参阅以下部分：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <a class="xref" href="innodb-storage-engine.html#innodb-init-startup-configuration" title="14.8.1&nbsp;InnoDB Startup Configuration">Section&nbsp;14.8.1, “InnoDB Startup Configuration”</a>
                        </p><p style="color:blue;">第14.8.1节，“InnoDB启动配置”</p><p></p></li><li class="listitem"><p>
                            <a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.6.3.6&nbsp;Creating a Tablespace Outside of the Data Directory">Section&nbsp;14.6.3.6, “Creating a Tablespace Outside of the Data Directory”</a>
                        </p><p style="color:blue;">第14.6.3.6节，“在数据目录外创建表空间”</p><p></p></li><li class="listitem"><p>
                            <a class="xref" href="innodb-storage-engine.html#general-tablespaces-creating" title="Creating a General Tablespace">Creating a General Tablespace</a>
                        </p><p style="color:blue;">创建常规表空间</p><p></p></li><li class="listitem"><p>
                            <a class="xref" href="innodb-storage-engine.html#innodb-migration" title="14.6.1.2&nbsp;Moving or Copying InnoDB Tables">Section&nbsp;14.6.1.2, “Moving or Copying InnoDB Tables”</a>
                        </p><p style="color:blue;">第14.6.1.2节，“移动或复制InnoDB表”</p><p></p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    Consider non-rotational storage
                </p><p style="color:blue;">考虑非旋转存储</p><p></p><p>
                    Non-rotational storage generally provides better performance
                    for random I/O operations; and rotational storage for
                    sequential I/O operations. When distributing data and log
                    files across rotational and non-rotational storage devices,
                    consider the type of I/O operations that are predominantly
                    performed on each file.
                </p><p style="color:blue;">非旋转存储通常为随机I/O操作提供更好的性能；而旋转存储则为顺序I/O操作提供更好的性能。在跨旋转和非旋转存储设备分发数据和日志文件时，请考虑主要在每个文件上执行的I/O操作的类型。</p><p></p><p>
                    Random I/O-oriented files typically include
                    <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a>
                    and <a class="link" href="glossary.html#glos_general_tablespace" title="general tablespace">general
                    tablespace</a> data files,
                    <a class="link" href="glossary.html#glos_undo_tablespace" title="undo tablespace">undo tablespace</a>
                    files, and
                    <a class="link" href="glossary.html#glos_temporary_tablespace" title="temporary tablespace">temporary
                        tablespace</a> files. Sequential I/O-oriented files
                    include <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_system_tablespace" title="system tablespace">system
                        tablespace</a> files (due to
                    <a class="link" href="glossary.html#glos_doublewrite_buffer" title="doublewrite buffer">doublewrite
                        buffering</a> and
                    <a class="link" href="glossary.html#glos_change_buffer" title="change buffer">change buffering</a>)
                    and log files such as <a class="link" href="glossary.html#glos_binary_log" title="binary log">binary
                    log</a> files and <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo
                    log</a> files.
                </p><p style="color:blue;">面向随机I/O的文件通常包括每个表的文件和常规表空间数据文件、撤消表空间文件和临时表空间文件。面向顺序I/O的文件包括InnoDB系统表空间文件（由于双写缓冲和更改缓冲）和日志文件，如二进制日志文件和重做日志文件。</p><p></p><p>
                    Review settings for the following configuration options when
                    using non-rotational storage:
                </p><p style="color:blue;">使用非旋转存储时，请查看以下配置选项的设置：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm"><code class="literal">innodb_checksum_algorithm</code></a>
                        </p><p style="color:blue;">InnoDB_校验和算法</p><p></p><p>
                            The <code class="literal">crc32</code> option uses a faster
                            checksum algorithm and is recommended for fast storage
                            systems.
                        </p><p style="color:blue;">crc32选项使用更快的校验和算法，建议用于快速存储系统。</p><p></p></li><li class="listitem"><p>
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors"><code class="literal">innodb_flush_neighbors</code></a>
                        </p><p style="color:blue;">innodb_flush_邻居</p><p></p><p>
                            Optimizes I/O for rotational storage devices. Disable it
                            for non-rotational storage or a mix of rotational and
                            non-rotational storage.
                        </p><p style="color:blue;">优化旋转存储设备的I/O。对于非旋转存储或旋转存储和非旋转存储的混合禁用它。</p><p></p></li><li class="listitem"><p>
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a>
                        </p><p style="color:blue;">InnoDB_IO_容量</p><p></p><p>
                            The default setting of 200 is generally sufficient for a
                            lower-end non-rotational storage device. For higher-end,
                            bus-attached devices, consider a higher setting such as
                            1000.
                        </p><p style="color:blue;">对于较低端的非旋转存储设备，默认设置200通常就足够了。对于更高端的总线连接设备，请考虑更高的设置，例如1000。</p><p></p></li><li class="listitem"><p>
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max"><code class="literal">innodb_io_capacity_max</code></a>
                        </p><p style="color:blue;">innodb_io_capacity_最大容量</p><p></p><p>
                            The default value of 2000 is intended for workloads that
                            use non-rotational storage. For a high-end, bus-attached
                            non-rotational storage device, consider a higher setting
                            such as 2500.
                        </p><p style="color:blue;">默认值2000用于使用非旋转存储的工作负载。对于高端、总线连接的非旋转存储设备，请考虑更高的设置，例如2500。</p><p></p></li><li class="listitem"><p>
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages"><code class="literal">innodb_log_compressed_pages</code></a>
                        </p><p style="color:blue;">InnoDB_Log_压缩页面</p><p></p><p>
                            If redo logs are on non-rotational storage, consider
                            disabling this option to reduce logging. See
                            <a class="link" href="optimization.html#innodb-disable-log-compressed-pages">Disable
                                logging of compressed pages</a>.
                        </p><p style="color:blue;">如果重做日志位于非旋转存储上，请考虑禁用此选项以减少日志记录。请参阅禁用压缩页的日志记录。</p><p></p></li><li class="listitem"><p>
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size"><code class="literal">innodb_log_file_size</code></a>
                        </p><p style="color:blue;">InnoDB_日志文件大小</p><p></p><p>
                            If redo logs are on non-rotational storage, configure
                            this option to maximize caching and write combining.
                        </p><p style="color:blue;">如果重做日志在非旋转存储中，则配置此选项以最大化缓存和写入组合。</p><p></p></li><li class="listitem"><p>
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size"><code class="literal">innodb_page_size</code></a>
                        </p><p style="color:blue;">innodb_页面大小</p><p></p><p>
                            Consider using a page size that matches the internal
                            sector size of the disk. Early-generation SSD devices
                            often have a 4KB sector size. Some newer devices have a
                            16KB sector size. The default <code class="literal">InnoDB</code>
                            page size is 16KB. Keeping the page size close to the
                            storage device block size minimizes the amount of
                            unchanged data that is rewritten to disk.
                        </p><p style="color:blue;">考虑使用与磁盘内部扇区大小匹配的页面大小。早期的ssd设备通常有4kb的扇区大小。一些较新的设备的扇区大小为16KB。默认innodb页面大小为16kb。将页面大小保持在接近存储设备块大小的位置可以最大限度地减少重写到磁盘的未更改数据量。</p><p></p></li><li class="listitem"><p>
                            <a class="link" href="replication.html#sysvar_binlog_row_image"><code class="literal">binlog_row_image</code></a>
                        </p><p style="color:blue;">binlog_row_图像</p><p></p><p>
                            If binary logs are on non-rotational storage and all
                            tables have primary keys, consider setting this option
                            to <code class="literal">minimal</code> to reduce logging.
                        </p><p style="color:blue;">如果二进制日志位于非循环存储中，并且所有表都有主键，请考虑将此选项设置为minimal以减少日志记录。</p><p></p></li></ul>
                    </div>
                    <p>
                        Ensure that TRIM support is enabled for your operating
                        system. It is typically enabled by default.
                    </p><p style="color:blue;">确保为您的操作系统启用了trim支持。它通常在默认情况下启用。</p><p></p></li><li class="listitem"><p>
                    Increase I/O capacity to avoid backlogs
                </p><p style="color:blue;">增加I/O容量以避免积压</p><p></p><p>
                    If throughput drops periodically because of
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_checkpoint" title="checkpoint">checkpoint</a>
                    operations, consider increasing the value of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a>
                    configuration option. Higher values cause more frequent
                    <a class="link" href="glossary.html#glos_flush" title="flush">flushing</a>, avoiding the
                    backlog of work that can cause dips in throughput.
                </p><p style="color:blue;">如果由于innodb checkpoint操作导致吞吐量周期性下降，请考虑增加innodb_io_capacity configuration选项的值。较高的值会导致更频繁的刷新，从而避免可能导致吞吐量下降的工作积压。</p><p></p></li><li class="listitem"><p>
                    Lower I/O capacity if flushing does not fall behind
                </p><p style="color:blue;">如果冲洗不落后，I/O容量会降低</p><p></p><p>
                    If the system is not falling behind with
                    <code class="literal">InnoDB</code>
                    <a class="link" href="glossary.html#glos_flush" title="flush">flushing</a> operations,
                    consider lowering the value of the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity"><code class="literal">innodb_io_capacity</code></a>
                    configuration option. Typically, you keep this option value
                    as low as practical, but not so low that it causes periodic
                    drops in throughput as mentioned in the preceding bullet. In
                    a typical scenario where you could lower the option value,
                    you might see a combination like this in the output from
                    <a class="link" href="sql-syntax.html#show-engine" title="13.7.5.15&nbsp;SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
                        INNODB STATUS</code></a>:
                </p><p style="color:blue;">如果系统没有落后于innodb刷新操作，请考虑降低innodb_io_capacity configuration选项的值。通常，将此选项值保持在尽可能低的实际值，但不要太低，以致于如前一项所述，它会导致吞吐量周期性下降。在可以降低选项值的典型场景中，您可能会在show engine innodb status的输出中看到这样的组合：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            History list length low, below a few thousand.
                        </p><p style="color:blue;">历史榜单长度低，在几千以下。</p><p></p></li><li class="listitem"><p>
                            Insert buffer merges close to rows inserted.
                        </p><p style="color:blue;">插入缓冲区合并靠近插入的行。</p><p></p></li><li class="listitem"><p>
                            Modified pages in buffer pool consistently well below
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct"><code class="literal">innodb_max_dirty_pages_pct</code></a>
                            of the buffer pool. (Measure at a time when the server
                            is not doing bulk inserts; it is normal during bulk
                            inserts for the modified pages percentage to rise
                            significantly.)
                        </p><p style="color:blue;">缓冲池中已修改的页始终远低于缓冲池的innodb max脏页pct。（在服务器不进行大容量插入时测量；在大容量插入期间，修改页面百分比显著上升是正常的。）</p><p></p></li><li class="listitem"><p>
                            <code class="literal">Log sequence number - Last checkpoint</code>
                            is at less than 7/8 or ideally less than 6/8 of the
                            total size of the <code class="literal">InnoDB</code>
                            <a class="link" href="glossary.html#glos_log_file" title="log file">log files</a>.
                        </p><p style="color:blue;">日志序列号-最后一个检查点小于InnoDB日志文件总大小的7/8或理想情况下小于6/8。</p><p></p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    Store system tablespace files on Fusion-io devices
                </p><p style="color:blue;">在Fusion IO设备上存储系统表空间文件</p><p></p><p>
                    You can take advantage of a doublewrite buffer-related I/O
                    optimization by storing system tablespace files
                    (<span class="quote">“<span class="quote">ibdata files</span>”</span>) on Fusion-io devices that
                    support atomic writes. In this case, doublewrite buffering
                    (<a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite"><code class="literal">innodb_doublewrite</code></a>) is
                    automatically disabled and Fusion-io atomic writes are used
                    for all data files. This feature is only supported on
                    Fusion-io hardware and is only enabled for Fusion-io NVMFS
                    on Linux. To take full advantage of this feature, an
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method"><code class="literal">innodb_flush_method</code></a> setting
                    of <code class="literal">O_DIRECT</code> is recommended.
                </p><p style="color:blue;">通过在支持原子写入的fusion i o设备上存储系统表空间文件（“ibdata文件”），可以利用与双写缓冲区相关的i/o优化。在这种情况下，doublewrite缓冲（innodb_doublewrite）被自动禁用，所有数据文件都使用fusion io原子写入。此功能仅在Fusion IO硬件上受支持，并且仅在Linux上为Fusion IO NVMFS启用。为了充分利用这一特性，建议将innodb_flush_method设置为o_direct。</p><p></p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Because the doublewrite buffer setting is global,
                            doublewrite buffering is also disabled for data files
                            residing on non-Fusion-io hardware.
                        </p><p style="color:blue;">由于doublewrite缓冲区设置是全局的，因此也会对驻留在非Fusion IO硬件上的数据文件禁用doublewrite缓冲。</p><p></p>
                    </div>
                </li><li class="listitem"><p><a name="innodb-disable-log-compressed-pages"></a>
                    Disable logging of compressed pages
                </p><p style="color:blue;">禁用压缩页的日志记录</p><p></p><p>
                    When using the <code class="literal">InnoDB</code> table
                    <a class="link" href="glossary.html#glos_compression" title="compression">compression</a> feature,
                    images of re-compressed
                    <a class="link" href="glossary.html#glos_page" title="page">pages</a> are written to the
                    <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo log</a> when changes
                    are made to compressed data. This behavior is controlled by
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages"><code class="literal">innodb_log_compressed_pages</code></a>,
                    which is enabled by default to prevent corruption that can
                    occur if a different version of the <code class="literal">zlib</code>
                    compression algorithm is used during recovery. If you are
                    certain that the <code class="literal">zlib</code> version will not
                    change, disable
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages"><code class="literal">innodb_log_compressed_pages</code></a>
                    to reduce redo log generation for workloads that modify
                    compressed data.
                </p><p style="color:blue;">当使用innodb table compression特性时，当对压缩数据进行更改时，重新压缩页面的图像被写入重做日志。此行为由innodb_log_compressed_pages控制，默认情况下启用此功能可防止在恢复期间使用不同版本的zlib压缩算法时发生损坏。如果确定zlib版本不会更改，请禁用innodb_log_compressed_pages以减少修改压缩数据的工作负载的重做日志生成。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-innodb-configuration-variables"></a>8.5.9&nbsp;Optimizing InnoDB Configuration Variables</h3>

                    </div>

                </div>

            </div>
            <p>
                Different settings work best for servers with light, predictable
                loads, versus servers that are running near full capacity all
                the time, or that experience spikes of high activity.
            </p><p style="color:blue;">不同的设置最适合负载轻且可预测的服务器，而不是始终运行在接近满容量或经历高活动高峰的服务器。</p><p></p><p>
            Because the <code class="literal">InnoDB</code> storage engine performs
            many of its optimizations automatically, many performance-tuning
            tasks involve monitoring to ensure that the database is
            performing well, and changing configuration options when
            performance drops. See
            <a class="xref" href="innodb-storage-engine.html#innodb-performance-schema" title="14.16&nbsp;InnoDB Integration with MySQL Performance Schema">Section&nbsp;14.16, “InnoDB Integration with MySQL Performance Schema”</a> for information
            about detailed <code class="literal">InnoDB</code> performance monitoring.
        </p><p style="color:blue;">由于innodb存储引擎会自动执行许多优化，因此许多性能调整任务都涉及到监控以确保数据库性能良好，以及在性能下降时更改配置选项。有关InnoDB性能监视的详细信息，请参阅第14.16节“InnoDB与MySQL性能模式的集成”。</p><p></p><p>
            The main configuration steps you can perform include:
        </p><p style="color:blue;">您可以执行的主要配置步骤包括：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Enabling <code class="literal">InnoDB</code> to use high-performance
                    memory allocators on systems that include them. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-use_sys_malloc" title="14.8.4&nbsp;Configuring the Memory Allocator for InnoDB">Section&nbsp;14.8.4, “Configuring the Memory Allocator for InnoDB”</a>.
                </p><p style="color:blue;">使innodb能够在包含高性能内存分配器的系统上使用它们。参见14.8.4节，“为InnoDB配置内存分配器”。</p><p></p></li><li class="listitem"><p>
                    Controlling the types of data change operations for which
                    <code class="literal">InnoDB</code> buffers the changed data, to avoid
                    frequent small disk writes. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-change-buffer-configuration" title="Configuring Change Buffering">Configuring Change Buffering</a>.
                    Because the default is to buffer all types of data change
                    operations, only change this setting if you need to reduce
                    the amount of buffering.
                </p><p style="color:blue;">控制innodb缓冲更改数据的数据更改操作类型，以避免频繁的小磁盘写入。请参阅配置更改缓冲。因为默认设置是缓冲所有类型的数据更改操作，所以只有在需要减少缓冲量时才更改此设置。</p><p></p></li><li class="listitem"><p>
                    Turning the adaptive hash indexing feature on and off using
                    the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index"><code class="literal">innodb_adaptive_hash_index</code></a>
                    option. See <a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="14.5.3&nbsp;Adaptive Hash Index">Section&nbsp;14.5.3, “Adaptive Hash Index”</a> for more
                    information. You might change this setting during periods of
                    unusual activity, then restore it to its original setting.
                </p><p style="color:blue;">使用NoNdByAddiTyVoHash索引选项打开和关闭自适应哈希索引特性。更多信息请参见第14.5.3节“自适应哈希索引”。您可以在异常活动期间更改此设置，然后将其还原为原始设置。</p><p></p></li><li class="listitem"><p>
                    Setting a limit on the number of concurrent threads that
                    <code class="literal">InnoDB</code> processes, if context switching is
                    a bottleneck. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.8.5&nbsp;Configuring Thread Concurrency for InnoDB">Section&nbsp;14.8.5, “Configuring Thread Concurrency for InnoDB”</a>.
                </p><p style="color:blue;">如果上下文切换是一个瓶颈，则设置innodb处理的并发线程数的限制。参见14.8.5节“为InnoDB配置线程并发”。</p><p></p></li><li class="listitem"><p>
                    Controlling the amount of prefetching that
                    <code class="literal">InnoDB</code> does with its read-ahead
                    operations. When the system has unused I/O capacity, more
                    read-ahead can improve the performance of queries. Too much
                    read-ahead can cause periodic drops in performance on a
                    heavily loaded system. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.8.3.4&nbsp;Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)">Section&nbsp;14.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.
                </p><p style="color:blue;">控制innodb对其预读操作执行的预取量。当系统有未使用的I/O容量时，更多的预读可以提高查询性能。过多的预读会导致重负载系统的性能周期性下降。参见14.8.3.4节，“配置InnoDB缓冲池预取（预读）”。</p><p></p></li><li class="listitem"><p>
                    Increasing the number of background threads for read or
                    write operations, if you have a high-end I/O subsystem that
                    is not fully utilized by the default values. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="14.8.6&nbsp;Configuring the Number of Background InnoDB I/O Threads">Section&nbsp;14.8.6, “Configuring the Number of Background InnoDB I/O Threads”</a>.
                </p><p style="color:blue;">如果您的高端I/O子系统未被默认值充分利用，则增加用于读或写操作的后台线程数。参见14.8.6节，“配置后台InnoDB I/O线程数”。</p><p></p></li><li class="listitem"><p>
                    Controlling how much I/O <code class="literal">InnoDB</code> performs
                    in the background. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-configuring-io-capacity" title="14.8.8&nbsp;Configuring InnoDB I/O Capacity">Section&nbsp;14.8.8, “Configuring InnoDB I/O Capacity”</a>. You might
                    scale back this setting if you observe periodic drops in
                    performance.
                </p><p style="color:blue;">控制InnoDB在后台执行的I/O量。参见第14.8.8节“配置InnoDB I/O容量”。如果观察到性能周期性下降，则可以缩小此设置。</p><p></p></li><li class="listitem"><p>
                    Controlling the algorithm that determines when
                    <code class="literal">InnoDB</code> performs certain types of
                    background writes. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>. The algorithm
                    works for some types of workloads but not others, so might
                    turn off this setting if you observe periodic drops in
                    performance.
                </p><p style="color:blue;">控制决定InnoDB何时执行特定类型后台写入的算法。见第14.8.3.5节“配置缓冲池冲洗”。该算法适用于某些类型的工作负载，但不适用于其他类型的工作负载，因此如果观察到性能周期性下降，则可能会关闭此设置。</p><p></p></li><li class="listitem"><p>
                    Taking advantage of multicore processors and their cache
                    memory configuration, to minimize delays in context
                    switching. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-spin_lock_polling" title="14.8.9&nbsp;Configuring Spin Lock Polling">Section&nbsp;14.8.9, “Configuring Spin Lock Polling”</a>.
                </p><p style="color:blue;">利用多核处理器及其高速缓存配置，最大限度地减少上下文切换的延迟。参见第14.8.9节“配置自旋锁轮询”。</p><p></p></li><li class="listitem"><p>
                    Preventing one-time operations such as table scans from
                    interfering with the frequently accessed data stored in the
                    <code class="literal">InnoDB</code> buffer cache. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="14.8.3.3&nbsp;Making the Buffer Pool Scan Resistant">Section&nbsp;14.8.3.3, “Making the Buffer Pool Scan Resistant”</a>.
                </p><p style="color:blue;">防止表扫描等一次性操作干扰innodb缓冲缓存中存储的频繁访问的数据。见第14.8.3.3节“使缓冲池具有抗扫描性”。</p><p></p></li><li class="listitem"><p>
                    Adjusting log files to a size that makes sense for
                    reliability and crash recovery. <code class="literal">InnoDB</code>
                    log files have often been kept small to avoid long startup
                    times after a crash. Optimizations introduced in MySQL 5.5
                    speed up certain steps of the crash
                    <a class="link" href="glossary.html#glos_crash_recovery" title="crash recovery">recovery</a> process.
                    In particular, scanning the
                    <a class="link" href="glossary.html#glos_redo_log" title="redo log">redo log</a> and applying
                    the redo log are faster due to improved algorithms for
                    memory management. If you have kept your log files
                    artificially small to avoid long startup times, you can now
                    consider increasing log file size to reduce the I/O that
                    occurs due recycling of redo log records.
                </p><p style="color:blue;">将日志文件调整到对可靠性和崩溃恢复有意义的大小。innodb日志文件通常保持较小，以避免崩溃后长时间启动。mysql 5.5中引入的优化加快了崩溃恢复过程的某些步骤。特别是，由于改进了内存管理算法，扫描重做日志和应用重做日志的速度更快。如果您将日志文件人为地保持较小以避免长时间启动，那么现在可以考虑增加日志文件大小以减少由于循环使用重做日志记录而发生的I/O。</p><p></p></li><li class="listitem"><p>
                    Configuring the size and number of instances for the
                    <code class="literal">InnoDB</code> buffer pool, especially important
                    for systems with multi-gigabyte buffer pools. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="14.8.3.2&nbsp;Configuring Multiple Buffer Pool Instances">Section&nbsp;14.8.3.2, “Configuring Multiple Buffer Pool Instances”</a>.
                </p><p style="color:blue;">为innodb缓冲池配置实例的大小和数量，对于具有千兆字节缓冲池的系统尤其重要。参见第14.8.3.2节“配置多个缓冲池实例”。</p><p></p></li><li class="listitem"><p>
                    Increasing the maximum number of concurrent transactions,
                    which dramatically improves scalability for the busiest
                    databases. See <a class="xref" href="innodb-storage-engine.html#innodb-undo-logs" title="14.6.7&nbsp;Undo Logs">Section&nbsp;14.6.7, “Undo Logs”</a>.
                </p><p style="color:blue;">增加最大并发事务数，从而显著提高最繁忙数据库的可伸缩性。见第14.6.7节“撤销日志”。</p><p></p></li><li class="listitem"><p>
                    Moving purge operations (a type of garbage collection) into
                    a background thread. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-purge-configuration" title="14.8.10&nbsp;Purge Configuration">Section&nbsp;14.8.10, “Purge Configuration”</a>. To effectively
                    measure the results of this setting, tune the other
                    I/O-related and thread-related configuration settings first.
                </p><p style="color:blue;">将清除操作（垃圾收集的一种类型）移动到后台线程中。见第14.8.10节“吹扫配置”。要有效测量此设置的结果，请首先调整其他与I/O相关和与线程相关的配置设置。</p><p></p></li><li class="listitem"><p>
                    Reducing the amount of switching that
                    <code class="literal">InnoDB</code> does between concurrent threads,
                    so that SQL operations on a busy server do not queue up and
                    form a <span class="quote">“<span class="quote">traffic jam</span>”</span>. Set a value for the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency"><code class="literal">innodb_thread_concurrency</code></a>
                    option, up to approximately 32 for a high-powered modern
                    system. Increase the value for the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_concurrency_tickets"><code class="literal">innodb_concurrency_tickets</code></a>
                    option, typically to 5000 or so. This combination of options
                    sets a cap on the number of threads that
                    <code class="literal">InnoDB</code> processes at any one time, and
                    allows each thread to do substantial work before being
                    swapped out, so that the number of waiting threads stays low
                    and operations can complete without excessive context
                    switching.
                </p><p style="color:blue;">减少innodb在并发线程之间的切换量，使繁忙服务器上的sql操作不会排队并形成“塞车”。为NoYbButhTraceRead选项设置一个值，对于一个高性能的现代系统来说，大约为32。增加innodb_concurrency_tickets选项的值，通常为5000左右。这两个选项的组合设置了innodb一次处理的线程数量上限，并允许每个线程在被换出之前做大量的工作，这样等待线程的数量保持在较低的水平，并且操作可以在没有过多上下文切换的情况下完成。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-innodb-many-tables"></a>8.5.10&nbsp;Optimizing InnoDB for Systems with Many Tables</h3>

                    </div>

                </div>

            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you have configured
                    <a class="link" href="innodb-storage-engine.html#innodb-statistics-estimation" title="14.8.11.2&nbsp;Configuring Non-Persistent Optimizer Statistics Parameters">non-persistent
                        optimizer statistics</a> (a non-default configuration),
                    <code class="literal">InnoDB</code> computes index
                    <a class="link" href="glossary.html#glos_cardinality" title="cardinality">cardinality</a> values
                    for a table the first time that table is accessed after
                    startup, instead of storing such values in the table. This
                    step can take significant time on systems that partition the
                    data into many tables. Since this overhead only applies to
                    the initial table open operation, to <span class="quote">“<span class="quote">warm up</span>”</span>
                    a table for later use, access it immediately after startup
                    by issuing a statement such as <code class="literal">SELECT 1 FROM
                    <em class="replaceable"><code>tbl_name</code></em> LIMIT 1</code>.
                </p><p style="color:blue;">如果已经配置了非持久优化器统计信息（非默认配置），innodb会在启动后第一次访问表时计算表的索引基数值，而不是将这些值存储在表中。在将数据划分为多个表的系统上，此步骤可能需要很长时间。由于此开销仅适用于初始的表打开操作，若要“预热”表以备以后使用，请在启动后立即通过发出语句（如从tbl_name limit 1中选择1）访问该表。</p><p></p><p>
                    Optimizer statistics are persisted to disk by default,
                    enabled by the
                    <a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent"><code class="literal">innodb_stats_persistent</code></a>
                    configuration option. For information about persistent
                    optimizer statistics, see
                    <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.8.11.1&nbsp;Configuring Persistent Optimizer Statistics Parameters">Section&nbsp;14.8.11.1, “Configuring Persistent Optimizer Statistics Parameters”</a>.
                </p><p style="color:blue;">默认情况下，优化器统计信息被持久化到磁盘，由innodb_stats_persistent配置选项启用。有关持久优化器统计信息，请参阅第14.8.11.1节“配置持久优化器统计参数”。</p><p></p></li></ul>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="optimizing-myisam"></a>8.6&nbsp;Optimizing for MyISAM Tables</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#optimizing-queries-myisam">8.6.1 Optimizing MyISAM Queries</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-myisam-bulk-data-loading">8.6.2 Bulk Data Loading for MyISAM Tables</a></span></dt><dt><span class="section"><a href="optimization.html#repair-table-optimization">8.6.3 Optimizing REPAIR TABLE Statements</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286872066640"></a><p>
        The <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> storage engine performs
        best with read-mostly data or with low-concurrency operations,
        because table locks limit the ability to perform simultaneous
        updates. In MySQL, <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> is the
        default storage engine rather than <code class="literal">MyISAM</code>.
    </p><p style="color:blue;">myisam存储引擎在以读为主的数据或低并发操作中表现最好，因为表锁限制了同时执行更新的能力。在mysql中，innodb是默认的存储引擎，而不是myisam。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-queries-myisam"></a>8.6.1&nbsp;Optimizing MyISAM Queries</h3>
                    </div>
                </div>
            </div>
            <p>
                Some general tips for speeding up queries on
                <code class="literal">MyISAM</code> tables:
            </p><p style="color:blue;">加快myisam表查询的一些一般提示：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    To help MySQL better optimize queries, use
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> or run
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --analyze</strong></span></a> on a table after it
                    has been loaded with data. This updates a value for each
                    index part that indicates the average number of rows that
                    have the same value. (For unique indexes, this is always 1.)
                    MySQL uses this to decide which index to choose when you
                    join two tables based on a nonconstant expression. You can
                    check the result from the table analysis by using
                    <code class="literal">SHOW INDEX FROM
                        <em class="replaceable"><code>tbl_name</code></em></code> and examining
                    the <code class="literal">Cardinality</code> value. <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk
            --description --verbose</strong></span></a> shows index distribution
                    information.
                </p><p style="color:blue;">为了帮助mysql更好地优化查询，可以使用analyze table或运行myisamchk——在加载了数据的表上进行分析。这将更新每个索引部分的值，该值指示具有相同值的平均行数。（对于唯一索引，始终为1。）mysql使用此选项来决定在基于非常量表达式连接两个表时选择哪个索引。通过使用show index from tbl_name并检查基数值，可以检查表分析的结果。myisamchk--description--verbose显示索引分布信息。</p><p></p></li><li class="listitem"><p>
                    To sort an index and data according to an index, use
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --sort-index --sort-records=1</strong></span></a>
                    (assuming that you want to sort on index 1). This is a good
                    way to make queries faster if you have a unique index from
                    which you want to read all rows in order according to the
                    index. The first time you sort a large table this way, it
                    may take a long time.
                </p><p style="color:blue;">若要根据索引对索引和数据进行排序，请使用myisamchk--sort index--sort records=1（假设要对索引1进行排序）。如果您有一个唯一的索引，希望从中按照索引的顺序读取所有行，那么这是加快查询速度的好方法。第一次用这种方法整理一张大桌子，可能要花很长时间。</p><p></p></li><li class="listitem"><p>
                    Try to avoid complex <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                    queries on <code class="literal">MyISAM</code> tables that are updated
                    frequently, to avoid problems with table locking that occur
                    due to contention between readers and writers.
                </p><p style="color:blue;">尽量避免对频繁更新的myisam表执行复杂的select查询，避免由于读写器之间的争用而导致的表锁定问题。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">MyISAM</code> supports concurrent inserts: If a
                    table has no free blocks in the middle of the data file, you
                    can <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> new rows into it
                    at the same time that other threads are reading from the
                    table. If it is important to be able to do this, consider
                    using the table in ways that avoid deleting rows. Another
                    possibility is to run <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE
                    TABLE</code></a> to defragment the table after you have
                    deleted a lot of rows from it. This behavior is altered by
                    setting the
                    <a class="link" href="server-administration.html#sysvar_concurrent_insert"><code class="literal">concurrent_insert</code></a> variable.
                    You can force new rows to be appended (and therefore permit
                    concurrent inserts), even in tables that have deleted rows.
                    See <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3&nbsp;Concurrent Inserts">Section&nbsp;8.11.3, “Concurrent Inserts”</a>.
                </p><p style="color:blue;">myisam支持并发插入：如果一个表的数据文件中间没有空闲块，那么可以在其他线程从表中读取数据的同时向其中插入新行。如果能够做到这一点很重要，请考虑以避免删除行的方式使用表。另一种可能是在删除表中的许多行之后运行优化表以对其进行碎片整理。通过设置concurrent_insert变量可以更改此行为。即使在已删除行的表中，也可以强制追加新行（因此允许并发插入）。见第8.11.3节“并发插入”。</p><p></p></li><li class="listitem"><p>
                    For <code class="literal">MyISAM</code> tables that change frequently,
                    try to avoid all variable-length columns
                    (<a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a>,
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>, and
                    <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a>). The table uses dynamic
                    row format if it includes even a single variable-length
                    column. See <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>.
                </p><p style="color:blue;">对于频繁更改的myisam表，请尽量避免使用所有可变长度的列（varchar、blob和text）。如果表甚至包含单个可变长度列，则使用动态行格式。见第15章，替代存储引擎。</p><p></p></li><li class="listitem"><p>
                    It is normally not useful to split a table into different
                    tables just because the rows become large. In accessing a
                    row, the biggest performance hit is the disk seek needed to
                    find the first byte of the row. After finding the data, most
                    modern disks can read the entire row fast enough for most
                    applications. The only cases where splitting up a table
                    makes an appreciable difference is if it is a
                    <code class="literal">MyISAM</code> table using dynamic row format
                    that you can change to a fixed row size, or if you very
                    often need to scan the table but do not need most of the
                    columns. See <a class="xref" href="storage-engines.html" title="Chapter&nbsp;15&nbsp;Alternative Storage Engines">Chapter&nbsp;15, <i>Alternative Storage Engines</i></a>.
                </p><p style="color:blue;">仅仅因为行变大，就将表拆分为不同的表通常是不有用的。在访问行时，最大的性能影响是查找行的第一个字节所需的磁盘查找。在找到数据之后，大多数现代磁盘可以足够快地读取整个行，以适合大多数应用程序。拆分一个表的唯一区别是它是一个使用动态行格式的myisam表，您可以将其更改为固定的行大小，或者您经常需要扫描该表，但不需要大多数列。见第15章，替代存储引擎。</p><p></p></li><li class="listitem"><p>
                    Use <code class="literal">ALTER TABLE ... ORDER BY
                    <em class="replaceable"><code>expr1</code></em>,
                    <em class="replaceable"><code>expr2</code></em>, ...</code> if you
                    usually retrieve rows in
                    <code class="literal"><em class="replaceable"><code>expr1</code></em>,
                        <em class="replaceable"><code>expr2</code></em>, ...</code> order. By
                    using this option after extensive changes to the table, you
                    may be able to get higher performance.
                </p><p style="color:blue;">使用更改表…按expr1，expr2，…如果您通常在expr1、expr2中检索行，…命令。通过在对表进行大量更改后使用此选项，可以获得更高的性能。</p><p></p></li><li class="listitem"><p>
                    If you often need to calculate results such as counts based
                    on information from a lot of rows, it may be preferable to
                    introduce a new table and update the counter in real time.
                    An update of the following form is very fast:
                </p><p style="color:blue;">如果您经常需要根据来自许多行的信息计算结果（如计数），那么最好引入一个新表并实时更新计数器。以下表单的更新速度非常快：</p><p></p><pre data-lang="sql" class="programlisting">UPDATE <em class="replaceable"><code>tbl_name</code></em> SET <em class="replaceable"><code>count_col</code></em>=<em class="replaceable"><code>count_col</code></em>+1 WHERE <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>constant</code></em>;
</pre><p>
                    This is very important when you use MySQL storage engines
                    such as <code class="literal">MyISAM</code> that has only table-level
                    locking (multiple readers with single writers). This also
                    gives better performance with most database systems, because
                    the row locking manager in this case has less to do.
                </p><p style="color:blue;">当您使用mysql存储引擎（如myisam）时，这一点非常重要，myisam只具有表级锁定（多个读卡器和单个写卡器）。对于大多数数据库系统，这也提供了更好的性能，因为在这种情况下，行锁定管理器的任务更少。</p><p></p></li><li class="listitem"><p>
                    Use <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>
                    periodically to avoid fragmentation with dynamic-format
                    <code class="literal">MyISAM</code> tables. See
                    <a class="xref" href="storage-engines.html#myisam-table-formats" title="15.2.3&nbsp;MyISAM Table Storage Formats">Section&nbsp;15.2.3, “MyISAM Table Storage Formats”</a>.
                </p><p style="color:blue;">定期使用optimize table以避免动态格式myisam tables的碎片化。见第15.2.3节，“myisam表存储格式”。</p><p></p></li><li class="listitem"><p>
                    Declaring a <code class="literal">MyISAM</code> table with the
                    <code class="literal">DELAY_KEY_WRITE=1</code> table option makes
                    index updates faster because they are not flushed to disk
                    until the table is closed. The downside is that if something
                    kills the server while such a table is open, you must ensure
                    that the table is okay by running the server with the
                    <a class="link" href="server-administration.html#sysvar_myisam_recover_options"><code class="literal">myisam_recover_options</code></a>
                    system variable set, or by running
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> before restarting the server.
                    (However, even in this case, you should not lose anything by
                    using <code class="literal">DELAY_KEY_WRITE</code>, because the key
                    information can always be generated from the data rows.)
                </p><p style="color:blue;">使用delay_key_write=1 table选项声明myisam表会使索引更新更快，因为在表关闭之前索引不会刷新到磁盘。缺点是，如果在打开这样的表时有东西杀死了服务器，则必须在设置myisam_recover_options系统变量的情况下运行服务器，或在重新启动服务器之前运行myisamchk，以确保该表正常。（但是，即使在这种情况下，使用delay_key_write也不应丢失任何内容，因为密钥信息始终可以从数据行生成。）</p><p></p></li><li class="listitem"><p>
                    Strings are automatically prefix- and end-space compressed
                    in <code class="literal">MyISAM</code> indexes. See
                    <a class="xref" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax">Section&nbsp;13.1.14, “CREATE INDEX Syntax”</a>.
                </p><p style="color:blue;">字符串在myisam索引中自动压缩前缀和结束空间。参见第13.1.14节“创建索引语法”。</p><p></p></li><li class="listitem"><p>
                    You can increase performance by caching queries or answers
                    in your application and then executing many inserts or
                    updates together. Locking the table during this operation
                    ensures that the index cache is only flushed once after all
                    updates. You can also take advantage of MySQL's query cache
                    to achieve similar results; see
                    <a class="xref" href="optimization.html#query-cache" title="8.10.3&nbsp;The MySQL Query Cache">Section&nbsp;8.10.3, “The MySQL Query Cache”</a>.
                </p><p style="color:blue;">通过在应用程序中缓存查询或答案，然后一起执行许多插入或更新，可以提高性能。在此操作期间锁定表可确保索引缓存在所有更新后仅刷新一次。您还可以利用mysql的查询缓存来获得类似的结果；请参见8.10.3节“mysql查询缓存”。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-myisam-bulk-data-loading"></a>8.6.2&nbsp;Bulk Data Loading for MyISAM Tables</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286872006416"></a><p>
            These performance tips supplement the general guidelines for
            fast inserts in <a class="xref" href="optimization.html#insert-optimization" title="8.2.4.1&nbsp;Optimizing INSERT Statements">Section&nbsp;8.2.4.1, “Optimizing INSERT Statements”</a>.
        </p><p style="color:blue;">这些性能提示补充了第8.2.4.1节“优化插入语句”中有关快速插入的一般指南。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For a <code class="literal">MyISAM</code> table, you can use
                    concurrent inserts to add rows at the same time that
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements are
                    running, if there are no deleted rows in middle of the data
                    file. See <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3&nbsp;Concurrent Inserts">Section&nbsp;8.11.3, “Concurrent Inserts”</a>.
                </p><p style="color:blue;">对于myisam表，如果数据文件中间没有删除的行，则可以在运行select语句的同时使用并发插入来添加行。见第8.11.3节“并发插入”。</p><p></p></li><li class="listitem"><p>
                    With some extra work, it is possible to make
                    <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> run even faster for
                    a <code class="literal">MyISAM</code> table when the table has many
                    indexes. Use the following procedure:
                </p><p style="color:blue;">通过一些额外的工作，当myisam表有许多索引时，可以使加载数据运行得更快。使用以下步骤：</p><p></p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Execute a <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a>
                            statement or a <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin
                flush-tables</strong></span></a> command.
                        </p><p style="color:blue;">执行flush tables语句或mysqladmin flush tables命令。</p><p></p></li><li class="listitem"><p>
                            Use <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk --keys-used=0 -rq
                <em class="replaceable"><code>/path/to/db/tbl_name</code></em></strong></span></a>
                            to remove all use of indexes for the table.
                        </p><p style="color:blue;">使用myisamchk--keys used=0-rq/path/to/db/tbl_name删除表中所有索引的使用。</p><p></p></li><li class="listitem"><p>
                            Insert data into the table with
                            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>. This does not
                            update any indexes and therefore is very fast.
                        </p><p style="color:blue;">将数据与加载数据一起插入表中。这不会更新任何索引，因此速度非常快。</p><p></p></li><li class="listitem"><p>
                            If you intend only to read from the table in the future,
                            use <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> to compress it. See
                            <a class="xref" href="storage-engines.html#compressed-format" title="15.2.3.3&nbsp;Compressed Table Characteristics">Section&nbsp;15.2.3.3, “Compressed Table Characteristics”</a>.
                        </p><p style="color:blue;">如果以后只想从表中读取，请使用myisampack压缩它。见第15.2.3.3节“压缩表特性”。</p><p></p></li><li class="listitem"><p>
                            Re-create the indexes with <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk -rq
                <em class="replaceable"><code>/path/to/db/tbl_name</code></em></strong></span></a>.
                            This creates the index tree in memory before writing it
                            to disk, which is much faster than updating the index
                            during <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> because
                            it avoids lots of disk seeks. The resulting index tree
                            is also perfectly balanced.
                        </p><p style="color:blue;">使用myisamchk-rq/path/to/db/tbl_名称重新创建索引。这将在将索引树写入磁盘之前在内存中创建索引树，这比在加载数据期间更新索引快得多，因为它避免了大量的磁盘查找。生成的索引树也是完全平衡的。</p><p></p></li><li class="listitem"><p>
                            Execute a <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a>
                            statement or a <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin
                flush-tables</strong></span></a> command.
                        </p><p style="color:blue;">执行flush tables语句或mysqladmin flush tables命令。</p><p></p></li></ol>
                    </div>
                    <p>
                        <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> performs the
                        preceding optimization automatically if the
                        <code class="literal">MyISAM</code> table into which you insert data
                        is empty. The main difference between automatic optimization
                        and using the procedure explicitly is that you can let
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> allocate much more temporary
                        memory for the index creation than you might want the server
                        to allocate for index re-creation when it executes the
                        <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> statement.
                    </p><p style="color:blue;">如果向其中插入数据的myisam表为空，则load data将自动执行前面的优化。自动优化和显式使用过程之间的主要区别在于，可以让myisamchk为索引创建分配的临时内存比您希望服务器在执行load data语句时为索引重新创建分配的临时内存多得多。</p><p></p><p>
                        You can also disable or enable the nonunique indexes for a
                        <code class="literal">MyISAM</code> table by using the following
                        statements rather than <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>. If you
                        use these statements, you can skip the
                        <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> operations:
                    </p><p style="color:blue;">也可以使用以下语句而不是myisamchk来禁用或启用myisam表的非唯一索引。如果使用这些语句，则可以跳过刷新表操作：</p><p></p><pre data-lang="sql" class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DISABLE KEYS;
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENABLE KEYS;
</pre></li><li class="listitem"><p>
                    To speed up <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> operations
                    that are performed with multiple statements for
                    nontransactional tables, lock your tables:
                </p><p style="color:blue;">要加快对非事务表使用多个语句执行的插入操作，请锁定表：</p><p></p><pre data-lang="sql" class="programlisting">LOCK TABLES a WRITE;
INSERT INTO a VALUES (1,23),(2,34),(4,33);
INSERT INTO a VALUES (8,26),(6,29);
...
UNLOCK TABLES;
</pre><p>
                    This benefits performance because the index buffer is
                    flushed to disk only once, after all
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements have
                    completed. Normally, there would be as many index buffer
                    flushes as there are <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                    statements. Explicit locking statements are not needed if
                    you can insert all rows with a single
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>.
                </p><p style="color:blue;">这有助于提高性能，因为索引缓冲区只在所有插入语句完成后刷新一次到磁盘。通常，索引缓冲区刷新的次数与insert语句的次数相同。如果可以用一次插入插入所有行，则不需要显式锁定语句。</p><p></p><p>
                    Locking also lowers the total time for multiple-connection
                    tests, although the maximum wait time for individual
                    connections might go up because they wait for locks. Suppose
                    that five clients attempt to perform inserts simultaneously
                    as follows:
                </p><p style="color:blue;">锁定也降低了多个连接测试的总时间，尽管各个连接的最大等待时间可能会上升，因为它们等待锁。假设五个客户机尝试同时执行插入，如下所示：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Connection 1 does 1000 inserts
                        </p><p style="color:blue;">连接1可插入1000个</p><p></p></li><li class="listitem"><p>
                            Connections 2, 3, and 4 do 1 insert
                        </p><p style="color:blue;">连接件2、3和4 Do 1插入件</p><p></p></li><li class="listitem"><p>
                            Connection 5 does 1000 inserts
                        </p><p style="color:blue;">连接5可插入1000个</p><p></p></li></ul>
                    </div>
                    <p>
                        If you do not use locking, connections 2, 3, and 4 finish
                        before 1 and 5. If you use locking, connections 2, 3, and 4
                        probably do not finish before 1 or 5, but the total time
                        should be about 40% faster.
                    </p><p style="color:blue;">如果不使用锁定，则连接2、3和4在1和5之前完成。如果使用锁定，连接2、3和4可能不会在1或5之前完成，但总时间应该快40%左右。</p><p></p><p>
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, and
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> operations are very
                        fast in MySQL, but you can obtain better overall performance
                        by adding locks around everything that does more than about
                        five successive inserts or updates. If you do very many
                        successive inserts, you could do a <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                        TABLES</code></a> followed by an
                        <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                            TABLES</code></a> once in a while (each 1,000 rows or so) to
                        permit other threads to access table. This would still
                        result in a nice performance gain.
                    </p><p style="color:blue;">在mysql中，insert、update和delete操作非常快，但是您可以通过在所有执行超过5次连续插入或更新的操作周围添加锁来获得更好的总体性能。如果您连续插入了很多次，您可以执行一次锁定表，然后偶尔执行一次解锁表（每1000行左右），以允许其他线程访问表。这仍然会带来不错的性能提升。</p><p></p><p>
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> is still much slower
                        for loading data than <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                        DATA</code></a>, even when using the strategies just
                        outlined.
                    </p><p style="color:blue;">insert在加载数据时仍然比加载数据慢得多，即使使用刚刚概述的策略。</p><p></p></li><li class="listitem"><p>
                    To increase performance for <code class="literal">MyISAM</code>
                    tables, for both <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>
                    and <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>, enlarge the key
                    cache by increasing the
                    <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> system
                    variable. See <a class="xref" href="server-administration.html#server-configuration" title="5.1.1&nbsp;Configuring the Server">Section&nbsp;5.1.1, “Configuring the Server”</a>.
                </p><p style="color:blue;">为了提高myisam表的性能，对于加载数据和插入，可以通过增加key_buffer_size系统变量来扩大密钥缓存。参见第5.1.1节“配置服务器”。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="repair-table-optimization"></a>8.6.3&nbsp;Optimizing REPAIR TABLE Statements</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286871937872"></a><p>
            <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> for
            <code class="literal">MyISAM</code> tables is similar to using
            <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> for repair operations, and some of
            the same performance optimizations apply:
        </p><p style="color:blue;">myisam表的repair table类似于使用myisamchk进行修复操作，并且应用了一些相同的性能优化：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> has variables that control
                    memory allocation. You may be able to its improve
                    performance by setting these variables, as described in
                    <a class="xref" href="programs.html#myisamchk-memory" title="4.6.3.6&nbsp;myisamchk Memory Usage">Section&nbsp;4.6.3.6, “myisamchk Memory Usage”</a>.
                </p><p style="color:blue;">myisamchk有控制内存分配的变量。您可以通过设置这些变量来提高性能，如第4.6.3.6节“myisamchk内存使用”中所述。</p><p></p></li><li class="listitem"><p>
                    For <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>, the same
                    principle applies, but because the repair is done by the
                    server, you set server system variables instead of
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> variables. Also, in addition to
                    setting memory-allocation variables, increasing the
                    <a class="link" href="server-administration.html#sysvar_myisam_max_sort_file_size"><code class="literal">myisam_max_sort_file_size</code></a>
                    system variable increases the likelihood that the repair
                    will use the faster filesort method and avoid the slower
                    repair by key cache method. Set the variable to the maximum
                    file size for your system, after checking to be sure that
                    there is enough free space to hold a copy of the table
                    files. The free space must be available in the file system
                    containing the original table files.
                </p><p style="color:blue;">对于修复表，同样的原则也适用，但是由于修复是由服务器完成的，所以您可以设置服务器系统变量而不是myisamchk变量。此外，除了设置内存分配变量外，增加myisam_max_sort_file_size系统变量还会增加修复将使用更快的文件排序方法的可能性，并避免使用较慢的密钥缓存修复方法。在检查以确保有足够的空闲空间来保存表文件的副本之后，将变量设置为系统的最大文件大小。包含原始表文件的文件系统中必须有可用空间。</p><p></p></li></ul>
            </div>
            <p>
                Suppose that a <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> table-repair
                operation is done using the following options to set its
                memory-allocation variables:
            </p><p style="color:blue;">假设myisamchk表修复操作是使用以下选项来设置其内存分配变量的：</p><p></p><pre data-lang="terminal" class="programlisting">--key_buffer_size=128M --myisam_sort_buffer_size=256M
--read_buffer_size=64M --write_buffer_size=64M
</pre><p>
            Some of those <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> variables correspond
            to server system variables:
        </p><p style="color:blue;">其中一些myisamchk变量对应于服务器系统变量：</p><p></p>
            <div class="informaltable">
                <table summary="myisamchk variables and corresponding server system variables."><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr>
                    <th scope="col"><a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> Variable</th>
                    <th scope="col">System Variable</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><code class="literal">key_buffer_size</code></td>
                    <td><a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a></td>
                </tr><tr>
                    <td scope="row"><code class="literal">myisam_sort_buffer_size</code></td>
                    <td><a class="link" href="server-administration.html#sysvar_myisam_sort_buffer_size"><code class="literal">myisam_sort_buffer_size</code></a></td>
                </tr><tr>
                    <td scope="row"><code class="literal">read_buffer_size</code></td>
                    <td><a class="link" href="server-administration.html#sysvar_read_buffer_size"><code class="literal">read_buffer_size</code></a></td>
                </tr><tr>
                    <td scope="row"><code class="literal">write_buffer_size</code></td>
                    <td>none</td>
                </tr></tbody></table>
            </div>
            <p>
                Each of the server system variables can be set at runtime, and
                some of them
                (<a class="link" href="server-administration.html#sysvar_myisam_sort_buffer_size"><code class="literal">myisam_sort_buffer_size</code></a>,
                <a class="link" href="server-administration.html#sysvar_read_buffer_size"><code class="literal">read_buffer_size</code></a>) have a
                session value in addition to a global value. Setting a session
                value limits the effect of the change to your current session
                and does not affect other users. Changing a global-only variable
                (<a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a>,
                <a class="link" href="server-administration.html#sysvar_myisam_max_sort_file_size"><code class="literal">myisam_max_sort_file_size</code></a>)
                affects other users as well. For
                <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a>, you must take
                into account that the buffer is shared with those users. For
                example, if you set the <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>
                <code class="literal">key_buffer_size</code> variable to 128MB, you could
                set the corresponding
                <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> system variable
                larger than that (if it is not already set larger), to permit
                key buffer use by activity in other sessions. However, changing
                the global key buffer size invalidates the buffer, causing
                increased disk I/O and slowdown for other sessions. An
                alternative that avoids this problem is to use a separate key
                cache, assign to it the indexes from the table to be repaired,
                and deallocate it when the repair is complete. See
                <a class="xref" href="optimization.html#multiple-key-caches" title="8.10.2.2&nbsp;Multiple Key Caches">Section&nbsp;8.10.2.2, “Multiple Key Caches”</a>.
            </p><p style="color:blue;">每个服务器系统变量都可以在运行时设置，其中一些变量（myisam_sort_buffer_size，read_buffer_size）除了全局值之外还有一个会话值。设置会话值会限制更改对当前会话的影响，并且不会影响其他用户。更改仅全局变量（key_buffer_size，myisam_max_sort_file_size）也会影响其他用户。对于密钥缓冲区大小，必须考虑到缓冲区是与这些用户共享的。例如，如果将myisamchk key_buffer_size变量设置为128MB，则可以将相应的key_buffer_size系统变量设置为大于该值（如果尚未设置为大于该值），以允许活动在其他会话中使用密钥缓冲区。但是，更改全局密钥缓冲区大小会使缓冲区无效，从而导致磁盘I/O增加和其他会话的速度减慢。避免此问题的另一种方法是使用单独的键缓存，将要修复的表中的索引分配给它，并在修复完成时解除分配。参见第8.10.2.2节“多密钥缓存”。</p><p></p><p>
            Based on the preceding remarks, a <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
            TABLE</code></a> operation can be done as follows to use settings
            similar to the <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> command. Here a
            separate 128MB key buffer is allocated and the file system is
            assumed to permit a file size of at least 100GB.
        </p><p style="color:blue;">基于上述说明，可以按如下方式执行修复表操作，以使用类似于myisamchk命令的设置。这里分配了一个单独的128MB密钥缓冲区，并且假定文件系统允许至少100GB的文件大小。</p><p></p><pre data-lang="sql" class="programlisting">SET SESSION myisam_sort_buffer_size = 256*1024*1024;
SET SESSION read_buffer_size = 64*1024*1024;
SET GLOBAL myisam_max_sort_file_size = 100*1024*1024*1024;
SET GLOBAL repair_cache.key_buffer_size = 128*1024*1024;
CACHE INDEX <em class="replaceable"><code>tbl_name</code></em> IN repair_cache;
LOAD INDEX INTO CACHE <em class="replaceable"><code>tbl_name</code></em>;
REPAIR TABLE <em class="replaceable"><code>tbl_name</code></em> ;
SET GLOBAL repair_cache.key_buffer_size = 0;
</pre><p>
            If you intend to change a global variable but want to do so only
            for the duration of a <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
            TABLE</code></a> operation to minimally affect other users, save
            its value in a user variable and restore it afterward. For
            example:
        </p><p style="color:blue;">如果要更改全局变量，但只希望在修复表操作期间更改，以尽量减少对其他用户的影响，请将其值保存在用户变量中，然后还原。例如：</p><p></p><pre data-lang="sql" class="programlisting">SET @old_myisam_sort_buffer_size = @@GLOBAL.myisam_max_sort_file_size;
SET GLOBAL myisam_max_sort_file_size = 100*1024*1024*1024;
REPAIR TABLE tbl_name ;
SET GLOBAL myisam_max_sort_file_size = @old_myisam_max_sort_file_size;
</pre><p>
            The system variables that affect <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR
            TABLE</code></a> can be set globally at server startup if you
            want the values to be in effect by default. For example, add
            these lines to the server <code class="filename">my.cnf</code> file:
        </p><p style="color:blue;">如果希望默认值有效，则可以在服务器启动时全局设置影响修复表的系统变量。例如，将这些行添加到服务器my.cnf文件：</p><p></p><pre data-lang="init" class="programlisting">[mysqld]
myisam_sort_buffer_size=256M
key_buffer_size=1G
myisam_max_sort_file_size=100G
</pre><p>
            These settings do not include
            <a class="link" href="server-administration.html#sysvar_read_buffer_size"><code class="literal">read_buffer_size</code></a>. Setting
            <a class="link" href="server-administration.html#sysvar_read_buffer_size"><code class="literal">read_buffer_size</code></a> globally to a
            large value does so for all sessions and can cause performance
            to suffer due to excessive memory allocation for a server with
            many simultaneous sessions.
        </p><p style="color:blue;">这些设置不包括读取缓冲区大小。对于所有会话，将全局读取缓冲区大小设置为一个大值会导致性能下降，这是由于同时有许多会话的服务器内存分配过多。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="optimizing-memory-tables"></a>8.7&nbsp;Optimizing for MEMORY Tables</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286871869744"></a><p>
        Consider using <code class="literal">MEMORY</code> tables for noncritical
        data that is accessed often, and is read-only or rarely updated.
        Benchmark your application against equivalent
        <code class="literal">InnoDB</code> or <code class="literal">MyISAM</code> tables
        under a realistic workload, to confirm that any additional
        performance is worth the risk of losing data, or the overhead of
        copying data from a disk-based table at application start.
    </p><p style="color:blue;">考虑对经常访问、只读或很少更新的非关键数据使用内存表。在实际工作负载下，将应用程序与等效的innodb或myisam表进行基准测试，以确认任何额外的性能都值得冒丢失数据的风险，或者在应用程序启动时从基于磁盘的表复制数据的开销。</p><p></p><p>
        For best performance with <code class="literal">MEMORY</code> tables,
        examine the kinds of queries against each table, and specify the
        type to use for each associated index, either a B-tree index or a
        hash index. On the <a class="link" href="sql-syntax.html#create-index" title="13.1.14&nbsp;CREATE INDEX Syntax"><code class="literal">CREATE INDEX</code></a>
        statement, use the clause <code class="literal">USING BTREE</code> or
        <code class="literal">USING HASH</code>. B-tree indexes are fast for queries
        that do greater-than or less-than comparisons through operators
        such as <code class="literal">&gt;</code> or <code class="literal">BETWEEN</code>.
        Hash indexes are only fast for queries that look up single values
        through the <code class="literal">=</code> operator, or a restricted set of
        values through the <code class="literal">IN</code> operator. For why
        <code class="literal">USING BTREE</code> is often a better choice than the
        default <code class="literal">USING HASH</code>, see
        <a class="xref" href="optimization.html#table-scan-avoidance" title="8.2.1.20&nbsp;Avoiding Full Table Scans">Section&nbsp;8.2.1.20, “Avoiding Full Table Scans”</a>. For implementation details
        of the different types of <code class="literal">MEMORY</code> indexes, see
        <a class="xref" href="optimization.html#index-btree-hash" title="8.3.8&nbsp;Comparison of B-Tree and Hash Indexes">Section&nbsp;8.3.8, “Comparison of B-Tree and Hash Indexes”</a>.
    </p><p style="color:blue;">为了获得内存表的最佳性能，请检查针对每个表的查询类型，并指定要用于每个关联索引（B树索引或哈希索引）的类型。在CREATEINDEX语句中，使用子句USINGBTREE或USINGHASH。对于通过&gt;或between之类的运算符进行大于或小于比较的查询，B树索引很快。哈希索引仅对通过=运算符查找单个值或通过in运算符查找限制值集的查询快速。关于为什么使用btree通常比默认使用hash更好，请参见第8.2.1.20节“避免全表扫描”。有关不同类型内存索引的实现详细信息，请参阅8.3.8节“B树索引和哈希索引的比较”。</p><p></p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="execution-plan-information"></a>8.8&nbsp;Understanding the Query Execution Plan</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#using-explain">8.8.1 Optimizing Queries with EXPLAIN</a></span></dt><dt><span class="section"><a href="optimization.html#explain-output">8.8.2 EXPLAIN Output Format</a></span></dt><dt><span class="section"><a href="optimization.html#explain-extended">8.8.3 Extended EXPLAIN Output Format</a></span></dt><dt><span class="section"><a href="optimization.html#explain-for-connection">8.8.4 Obtaining Execution Plan Information for a Named Connection</a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">8.8.5 Estimating Query Performance</a></span></dt></dl>
        </div>
        <p>
            Depending on the details of your tables, columns, indexes, and the
            conditions in your <code class="literal">WHERE</code> clause, the MySQL
            optimizer considers many techniques to efficiently perform the
            lookups involved in an SQL query. A query on a huge table can be
            performed without reading all the rows; a join involving several
            tables can be performed without comparing every combination of
            rows. The set of operations that the optimizer chooses to perform
            the most efficient query is called the <span class="quote">“<span class="quote">query execution
      plan</span>”</span>, also known as the
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> plan. Your goals are to
            recognize the aspects of the
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> plan that indicate a query
            is optimized well, and to learn the SQL syntax and indexing
            techniques to improve the plan if you see some inefficient
            operations.
        </p><p style="color:blue;">根据表、列、索引和where子句中的条件的详细信息，mysql优化器考虑了许多技术来高效地执行sql查询中涉及的查找。可以在不读取所有行的情况下对大型表执行查询；可以在不比较每一行组合的情况下执行包含多个表的联接。优化器选择执行最有效查询的一组操作称为“查询执行计划”，也称为解释计划。您的目标是识别说明计划的方面，它指示查询被优化，并且学习SQL语法和索引技术来改进计划，如果您看到一些低效的操作。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="using-explain"></a>8.8.1&nbsp;Optimizing Queries with EXPLAIN</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286871847504"></a><a class="indexterm" name="idm140286871846464"></a><p>
            The <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement provides
            information about how MySQL executes statements:
        </p><p style="color:blue;">explain语句提供有关mysql如何执行语句的信息：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> works with
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                    <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, and
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements.
                </p><p style="color:blue;">explain使用select、delete、insert、replace和update语句。</p><p></p></li><li class="listitem"><p>
                    When <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is used with an
                    explainable statement, MySQL displays information from the
                    optimizer about the statement execution plan. That is, MySQL
                    explains how it would process the statement, including
                    information about how tables are joined and in which order.
                    For information about using
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to obtain execution
                    plan information, see <a class="xref" href="optimization.html#explain-output" title="8.8.2&nbsp;EXPLAIN Output Format">Section&nbsp;8.8.2, “EXPLAIN Output Format”</a>.
                </p><p style="color:blue;">当explain与可解释语句一起使用时，mysql将显示来自优化器的有关语句执行计划的信息。也就是说，mysql解释了它将如何处理语句，包括有关如何联接表以及以何种顺序联接表的信息。有关使用explain获取执行计划信息的信息，请参阅第8.8.2节“explain output format”。</p><p></p></li><li class="listitem"><p>
                    When <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is used with
                    <code class="literal">FOR CONNECTION
                        <em class="replaceable"><code>connection_id</code></em></code> rather
                    than an explainable statement, it displays the execution
                    plan for the statement executing in the named connection.
                    See <a class="xref" href="optimization.html#explain-for-connection" title="8.8.4&nbsp;Obtaining Execution Plan Information for a Named Connection">Section&nbsp;8.8.4, “Obtaining Execution Plan Information for a Named Connection”</a>.
                </p><p style="color:blue;">当explain与for connection connection\u id一起使用而不是可解释的语句时，它将显示在命名连接中执行的语句的执行计划。参见第8.8.4节“获取命名连接的执行计划信息”。</p><p></p></li><li class="listitem"><p>
                    For <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements,
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> produces additional
                    execution plan information that can be displayed using
                    <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a>. See
                    <a class="xref" href="optimization.html#explain-extended" title="8.8.3&nbsp;Extended EXPLAIN Output Format">Section&nbsp;8.8.3, “Extended EXPLAIN Output Format”</a>.
                </p><p style="color:blue;">对于select语句，explain生成可以使用show warnings显示的附加执行计划信息。见第8.8.3节，“扩展解释输出格式”。</p><p></p></li><li class="listitem"><p>
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is useful for
                    examining queries involving partitioned tables. See
                    <a class="xref" href="partitioning.html#partitioning-info" title="22.3.5&nbsp;Obtaining Information About Partitions">Section&nbsp;22.3.5, “Obtaining Information About Partitions”</a>.
                </p><p style="color:blue;">explain对于检查涉及分区表的查询很有用。见第22.3.5节“获取分区信息”。</p><p></p></li><li class="listitem"><p>
                    The <code class="literal">FORMAT</code> option can be used to select
                    the output format. <code class="literal">TRADITIONAL</code> presents
                    the output in tabular format. This is the default if no
                    <code class="literal">FORMAT</code> option is present.
                    <code class="literal">JSON</code> format displays the information in
                    JSON format.
                </p><p style="color:blue;">format选项可用于选择输出格式。传统的以表格形式显示输出。如果不存在格式选项，则此为默认值。json格式以json格式显示信息。</p><p></p></li></ul>
            </div>
            <p>
                <a class="indexterm" name="idm140286871813184"></a>

                With the help of <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>, you can
                see where you should add indexes to tables so that the statement
                executes faster by using indexes to find rows. You can also use
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to check whether the
                optimizer joins the tables in an optimal order. To give a hint
                to the optimizer to use a join order corresponding to the order
                in which the tables are named in a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement, begin the
                statement with <code class="literal">SELECT STRAIGHT_JOIN</code> rather
                than just <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>. (See
                <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.) However,
                <code class="literal">STRAIGHT_JOIN</code> may prevent indexes from being
                used because it disables semijoin transformations. See
                <a class="xref" href="optimization.html#semijoins" title="8.2.2.1&nbsp;Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations">Section&nbsp;8.2.2.1, “Optimizing Subqueries, Derived Tables, and View References with Semijoin
                    Transformations”</a>.
            </p><p style="color:blue;">在explain的帮助下，您可以看到应该在哪里向表添加索引，以便通过使用索引查找行来加快语句的执行速度。您还可以使用explain检查优化器是否以最佳顺序连接表。要提示优化器使用与select语句中表的命名顺序相对应的联接顺序，请使用select straight_join开始语句，而不仅仅是select。（请参阅第13.2.9节“选择语法”。）但是，直连接可能会禁止使用索引，因为它禁用半连接转换。参见第8.2.2.1节，“使用半联接转换优化子查询、派生表和视图引用”。</p><p></p><p>
            The optimizer trace may sometimes provide information
            complementary to that of <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>.
            However, the optimizer trace format and content are subject to
            change between versions. For details, see
            <a class="ulink" href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html" target="_top">MySQL
                Internals: Tracing the Optimizer</a>.
        </p><p style="color:blue;">优化器跟踪有时可能提供与explain的信息互补的信息。但是，优化器跟踪格式和内容可能在不同版本之间发生更改。有关详细信息，请参见mysql内部：跟踪优化器。</p><p></p><p>
            If you have a problem with indexes not being used when you
            believe that they should be, run <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE
            TABLE</code></a> to update table statistics, such as cardinality
            of keys, that can affect the choices the optimizer makes. See
            <a class="xref" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax">Section&nbsp;13.7.2.1, “ANALYZE TABLE Syntax”</a>.
        </p><p style="color:blue;">如果在认为应该使用索引时没有使用索引有问题，请运行analyze table来更新表统计信息，例如键的基数，这可能会影响优化器的选择。见第13.7.2.1节“分析表语法”。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> can also be used to
                    obtain information about the columns in a table.
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                        <em class="replaceable"><code>tbl_name</code></em></code></a> is synonymous
                    with <code class="literal">DESCRIBE
                    <em class="replaceable"><code>tbl_name</code></em></code> and
                    <code class="literal">SHOW COLUMNS FROM
                        <em class="replaceable"><code>tbl_name</code></em></code>. For more
                    information, see <a class="xref" href="sql-syntax.html#describe" title="13.8.1&nbsp;DESCRIBE Syntax">Section&nbsp;13.8.1, “DESCRIBE Syntax”</a>, and
                    <a class="xref" href="sql-syntax.html#show-columns" title="13.7.5.5&nbsp;SHOW COLUMNS Syntax">Section&nbsp;13.7.5.5, “SHOW COLUMNS Syntax”</a>.
                </p><p style="color:blue;">explain还可用于获取有关表中列的信息。explain tbl_name与describe tbl_name同义，并显示来自tbl_name的列。有关详细信息，请参阅第13.8.1节“描述语法”和第13.7.5.5节“显示列语法”。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="explain-output"></a>8.8.2&nbsp;EXPLAIN Output Format</h3>

                    </div>

                </div>

            </div>
            <p>
                The <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement provides
                information about how MySQL executes statements.
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> works with
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, and
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements.
            </p><p style="color:blue;">explain语句提供有关mysql如何执行语句的信息。explain使用select、delete、insert、replace和update语句。</p><p></p><p>
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> returns a row of
            information for each table used in the
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement. It lists the
            tables in the output in the order that MySQL would read them
            while processing the statement. MySQL resolves all joins using a
            nested-loop join method. This means that MySQL reads a row from
            the first table, and then finds a matching row in the second
            table, the third table, and so on. When all tables are
            processed, MySQL outputs the selected columns and backtracks
            through the table list until a table is found for which there
            are more matching rows. The next row is read from this table and
            the process continues with the next table.
        </p><p style="color:blue;">explain为select语句中使用的每个表返回一行信息。它按照mysql在处理语句时读取表的顺序列出输出中的表。mysql使用嵌套循环连接方法解析所有连接。这意味着mysql从第一个表中读取一行，然后在第二个表、第三个表中找到匹配的行，依此类推。当处理所有表时，mysql将输出选定的列，并通过表列表进行回溯，直到找到有更多匹配行的表为止。从该表读取下一行，然后继续处理下一个表。</p><p></p><p>
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output includes partition
            information. Also, for <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
            statements, <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> generates
            extended information that can be displayed with
            <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> following the
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> (see
            <a class="xref" href="optimization.html#explain-extended" title="8.8.3&nbsp;Extended EXPLAIN Output Format">Section&nbsp;8.8.3, “Extended EXPLAIN Output Format”</a>).
        </p><p style="color:blue;">explain输出包含分区信息。此外，对于select语句，explain生成扩展信息，这些信息可以在explain之后显示show warnings（参见8.8.3节，“扩展explain输出格式”）。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    In older MySQL releases, partition and extended information
                    was produced using
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                        PARTITIONS</code></a> and
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                        EXTENDED</code></a>. Those syntaxes are still recognized for
                    backward compatibility but partition and extended output is
                    now enabled by default, so the <code class="literal">PARTITIONS</code>
                    and <code class="literal">EXTENDED</code> keywords are superfluous and
                    deprecated. Their use results in a warning, and they will be
                    removed from <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> syntax in
                    a future MySQL release.
                </p><p style="color:blue;">在旧的mysql版本中，分区和扩展信息是使用explain partitions和explain extended生成的。这些语法仍然被认为是向后兼容的，但分区和扩展输出现在默认启用，因此分区和扩展关键字是多余的，不推荐使用。它们的使用会导致警告，在未来的mysql版本中，它们将从explain语法中删除。</p><p></p><p>
                You cannot use the deprecated <code class="literal">PARTITIONS</code>
                and <code class="literal">EXTENDED</code> keywords together in the same
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement. In addition,
                neither of these keywords can be used together with the
                <code class="literal">FORMAT</code> option.
            </p><p style="color:blue;">不能在同一条解释语句中同时使用不推荐使用的分区和扩展关键字。此外，这些关键字都不能与format选项一起使用。</p><p></p>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Note
                </div>
                <p>
                    MySQL Workbench has a Visual Explain capability that provides a
                    visual representation of
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output. See
                    <a class="ulink" href="https://dev.mysql.com/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html" target="_top">Tutorial: Using Explain to Improve Query Performance</a>.
                </p><p style="color:blue;">mysql工作台具有可视化解释功能，它提供了解释输出的可视化表示。请参阅教程：使用explain提高查询性能。</p><p></p>
            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#explain-output-columns" title="EXPLAIN Output Columns">EXPLAIN Output Columns</a></p><p style="color:blue;">解释输出列</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#explain-join-types" title="EXPLAIN Join Types">EXPLAIN Join Types</a></p><p style="color:blue;">解释联接类型</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#explain-extra-information" title="EXPLAIN Extra Information">EXPLAIN Extra Information</a></p><p style="color:blue;">解释额外信息</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#explain-output-interpretation" title="EXPLAIN Output Interpretation">EXPLAIN Output Interpretation</a></p><p style="color:blue;">解释输出解释</p><p></p></li></ul>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="explain-output-columns"></a>EXPLAIN Output Columns</h4>

                        </div>

                    </div>

                </div>
                <p>
                    This section describes the output columns produced by
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>. Later sections provide
                    additional information about the
                    <a class="link" href="optimization.html#explain-join-types" title="EXPLAIN Join Types"><code class="literal">type</code></a>
                    and
                    <a class="link" href="optimization.html#explain-extra-information" title="EXPLAIN Extra Information"><code class="literal">Extra</code></a>
                    columns.
                </p><p style="color:blue;">本节介绍explain生成的输出列。后面的部分提供有关类型和额外列的附加信息。</p><p></p><p>
                Each output row from <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>
                provides information about one table. Each row contains the
                values summarized in
                <a class="xref" href="optimization.html#explain-output-column-table" title="Table&nbsp;8.1&nbsp;EXPLAIN Output Columns">Table&nbsp;8.1, “EXPLAIN Output Columns”</a>, and described
                in more detail following the table. Column names are shown in
                the table's first column; the second column provides the
                equivalent property name shown in the output when
                <code class="literal">FORMAT=JSON</code> is used.
            </p><p style="color:blue;">explain的每个输出行提供一个表的信息。每行包含表8.1“解释输出列”中总结的值，并在下表中进行更详细的描述。列名显示在表的第一列中；当使用format=json时，第二列提供输出中显示的等效属性名。</p><p></p>
                <div class="table">
                    <a name="explain-output-column-table"></a><p class="title"><b>Table&nbsp;8.1&nbsp;EXPLAIN Output Columns</b></p><p style="color:blue;">表8.1解释输出列</p><p></p>
                    <div class="table-contents">
                        <table summary="Output columns produced by the EXPLAIN statement."><colgroup><col width="25%"><col width="25%"><col width="50%"></colgroup><thead><tr>
                            <th scope="col">Column</th>
                            <th scope="col">JSON Name</th>
                            <th scope="col">Meaning</th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_id"><code class="literal">id</code></a></td>
                            <td><code class="literal">select_id</code></td>
                            <td>The <code class="literal">SELECT</code> identifier</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_select_type"><code class="literal">select_type</code></a></td>
                            <td>None</td>
                            <td>The <code class="literal">SELECT</code> type</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_table"><code class="literal">table</code></a></td>
                            <td><code class="literal">table_name</code></td>
                            <td>The table for the output row</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_partitions"><code class="literal">partitions</code></a></td>
                            <td><code class="literal">partitions</code></td>
                            <td>The matching partitions</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_type"><code class="literal">type</code></a></td>
                            <td><code class="literal">access_type</code></td>
                            <td>The join type</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_possible_keys"><code class="literal">possible_keys</code></a></td>
                            <td><code class="literal">possible_keys</code></td>
                            <td>The possible indexes to choose</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_key"><code class="literal">key</code></a></td>
                            <td><code class="literal">key</code></td>
                            <td>The index actually chosen</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_key_len"><code class="literal">key_len</code></a></td>
                            <td><code class="literal">key_length</code></td>
                            <td>The length of the chosen key</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_ref"><code class="literal">ref</code></a></td>
                            <td><code class="literal">ref</code></td>
                            <td>The columns compared to the index</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_rows"><code class="literal">rows</code></a></td>
                            <td><code class="literal">rows</code></td>
                            <td>Estimate of rows to be examined</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_filtered"><code class="literal">filtered</code></a></td>
                            <td><code class="literal">filtered</code></td>
                            <td>Percentage of rows filtered by table condition</td>
                        </tr><tr>
                            <td scope="row"><a class="link" href="optimization.html#explain_extra"><code class="literal">Extra</code></a></td>
                            <td>None</td>
                            <td>Additional information</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break">
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        JSON properties which are <code class="literal">NULL</code> are not
                        displayed in JSON-formatted <code class="literal">EXPLAIN</code>
                        output.
                    </p><p style="color:blue;">json格式的解释输出中不显示空的json属性。</p><p></p>
                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="explain_id"></a>
                        <code class="literal">id</code> (JSON name:
                        <code class="literal">select_id</code>)
                    </p><p style="color:blue;">id（json名称：select\u id）</p><p></p><p>
                        The <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> identifier. This
                        is the sequential number of the
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> within the query.
                        The value can be <code class="literal">NULL</code> if the row refers
                        to the union result of other rows. In this case, the
                        <code class="literal">table</code> column shows a value like
                        <code class="literal">&lt;union<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>N</code></em>&gt;</code>
                        to indicate that the row refers to the union of the rows
                        with <code class="literal">id</code> values of
                        <em class="replaceable"><code>M</code></em> and
                        <em class="replaceable"><code>N</code></em>.
                    </p><p style="color:blue;">选择标识符。这是查询中select的序列号。如果行引用其他行的并集结果，则该值可以为空。在这种情况下，table列显示一个类似于<union m，n="">的值，以指示行是指id值为m和n的行的并集。</union></p><p></p></li><li class="listitem"><p><a name="explain_select_type"></a>
                        <code class="literal">select_type</code> (JSON name: none)
                    </p><p style="color:blue;">选择类型（JSON名称：无）</p><p></p><p>
                        The type of <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, which
                        can be any of those shown in the following table. A
                        JSON-formatted <code class="literal">EXPLAIN</code> exposes the
                        <code class="literal">SELECT</code> type as a property of a
                        <code class="literal">query_block</code>, unless it is
                        <code class="literal">SIMPLE</code> or <code class="literal">PRIMARY</code>.
                        The JSON names (where applicable) are also shown in the
                        table.
                    </p><p style="color:blue;">select的类型，可以是下表中显示的任何类型。json格式的解释将select类型公开为查询块的属性，除非它是简单的或主要的。json名称（如果适用）也显示在表中。</p><p></p>
                        <div class="informaltable">
                            <table summary="select_type values and the meaning of each value."><colgroup><col width="25%"><col width="25%"><col width="50%"></colgroup><thead><tr>
                                <th scope="col"><code class="literal">select_type</code> Value</th>
                                <th scope="col">JSON Name</th>
                                <th scope="col">Meaning</th>
                            </tr></thead><tbody><tr>
                                <td scope="row"><code class="literal">SIMPLE</code></td>
                                <td>None</td>
                                <td>Simple <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> (not using
                                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a> or subqueries)</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">PRIMARY</code></td>
                                <td>None</td>
                                <td>Outermost <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a></td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a></td>
                                <td>None</td>
                                <td>Second or later <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement in a
                                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a></td>
                            </tr><tr>
                                <td scope="row"><code class="literal">DEPENDENT UNION</code></td>
                                <td><code class="literal">dependent</code> (<code class="literal">true</code>)</td>
                                <td>Second or later <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement in a
                                    <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>, dependent on
                                    outer query</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">UNION RESULT</code></td>
                                <td><code class="literal">union_result</code></td>
                                <td>Result of a <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>.</td>
                            </tr><tr>
                                <td scope="row"><a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">SUBQUERY</code></a></td>
                                <td>None</td>
                                <td>First <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> in subquery</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">DEPENDENT SUBQUERY</code></td>
                                <td><code class="literal">dependent</code> (<code class="literal">true</code>)</td>
                                <td>First <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> in subquery, dependent on
                                    outer query</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">DERIVED</code></td>
                                <td>None</td>
                                <td>Derived table</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">MATERIALIZED</code></td>
                                <td><code class="literal">materialized_from_subquery</code></td>
                                <td>Materialized subquery</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">UNCACHEABLE SUBQUERY</code></td>
                                <td><code class="literal">cacheable</code> (<code class="literal">false</code>)</td>
                                <td>A subquery for which the result cannot be cached and must be
                                    re-evaluated for each row of the outer query</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">UNCACHEABLE UNION</code></td>
                                <td><code class="literal">cacheable</code> (<code class="literal">false</code>)</td>
                                <td>The second or later select in a <a class="link" href="sql-syntax.html#union" title="13.2.9.3&nbsp;UNION Syntax"><code class="literal">UNION</code></a>
                                    that belongs to an uncacheable subquery (see
                                    <code class="literal">UNCACHEABLE SUBQUERY</code>)</td>
                            </tr></tbody></table>
                        </div>
                        <p>
                            <code class="literal">DEPENDENT</code> typically signifies the use
                            of a correlated subquery. See
                            <a class="xref" href="sql-syntax.html#correlated-subqueries" title="13.2.10.7&nbsp;Correlated Subqueries">Section&nbsp;13.2.10.7, “Correlated Subqueries”</a>.
                        </p><p style="color:blue;">dependent通常表示使用相关子查询。见第13.2.10.7节“相关子查询”。</p><p></p><p>
                            <code class="literal">DEPENDENT SUBQUERY</code> evaluation differs
                            from <code class="literal">UNCACHEABLE SUBQUERY</code> evaluation.
                            For <code class="literal">DEPENDENT SUBQUERY</code>, the subquery is
                            re-evaluated only once for each set of different values of
                            the variables from its outer context. For
                            <code class="literal">UNCACHEABLE SUBQUERY</code>, the subquery is
                            re-evaluated for each row of the outer context.
                        </p><p style="color:blue;">依赖子查询求值与不可缓存子查询求值不同。对于依赖子查询，对于来自其外部上下文的变量的每一组不同值，子查询只重新计算一次。对于不可缓存的子查询，将为外部上下文的每一行重新计算子查询。</p><p></p><p>
                            Cacheability of subqueries differs from caching of query
                            results in the query cache (which is described in
                            <a class="xref" href="optimization.html#query-cache-operation" title="8.10.3.1&nbsp;How the Query Cache Operates">Section&nbsp;8.10.3.1, “How the Query Cache Operates”</a>). Subquery caching
                            occurs during query execution, whereas the query cache is
                            used to store results only after query execution finishes.
                        </p><p style="color:blue;">子查询的可缓存性不同于查询缓存中查询结果的缓存（在8.10.3.1节“查询缓存的操作方式”中有说明）。子查询缓存在查询执行期间发生，而查询缓存仅在查询执行完成后用于存储结果。</p><p></p><p>
                            When you specify <code class="literal">FORMAT=JSON</code> with
                            <code class="literal">EXPLAIN</code>, the output has no single
                            property directly equivalent to
                            <code class="literal">select_type</code>; the
                            <code class="literal">query_block</code> property corresponds to a
                            given <code class="literal">SELECT</code>. Properties equivalent to
                            most of the <code class="literal">SELECT</code> subquery types just
                            shown are available (an example being
                            <code class="literal">materialized_from_subquery</code> for
                            <code class="literal">MATERIALIZED</code>), and are displayed when
                            appropriate. There are no JSON equivalents for
                            <code class="literal">SIMPLE</code> or <code class="literal">PRIMARY</code>.
                        </p><p style="color:blue;">当您使用explain指定format=json时，输出没有直接等效于select_type的单个属性；query_block属性对应于给定的select。与刚才显示的大多数选定子查询类型等效的属性是可用的（具体化的示例来自具体化的子查询），并在适当时显示。对于simple或primary，没有json等价物。</p><p></p><p>
                            The <code class="literal">select_type</code> value for
                            non-<a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements
                            displays the statement type for affected tables. For
                            example, <code class="literal">select_type</code> is
                            <code class="literal">DELETE</code> for
                            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements.
                        </p><p style="color:blue;">非select语句的select_type值显示受影响表的语句类型。例如，select_type is delete for delete语句。</p><p></p></li><li class="listitem"><p><a name="explain_table"></a>
                        <code class="literal">table</code> (JSON name:
                        <code class="literal">table_name</code>)
                    </p><p style="color:blue;">表（JSON名称：表名）</p><p></p><p>
                        The name of the table to which the row of output refers.
                        This can also be one of the following values:
                    </p><p style="color:blue;">输出行所引用的表的名称。这也可以是以下值之一：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">&lt;union<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>N</code></em>&gt;</code>:
                                The row refers to the union of the rows with
                                <code class="literal">id</code> values of
                                <em class="replaceable"><code>M</code></em> and
                                <em class="replaceable"><code>N</code></em>.
                            </p><p style="color:blue;"><union m，n="">：行是指id值为m和n的行的并集。</union></p><p></p></li><li class="listitem"><p>
                                <code class="literal">&lt;derived<em class="replaceable"><code>N</code></em>&gt;</code>:
                                The row refers to the derived table result for the row
                                with an <code class="literal">id</code> value of
                                <em class="replaceable"><code>N</code></em>. A derived table may
                                result, for example, from a subquery in the
                                <code class="literal">FROM</code> clause.
                            </p><p style="color:blue;"><derived n="">：该行引用id值为n的行的派生表结果。派生表可以例如从from子句中的子查询生成。</derived></p><p></p></li><li class="listitem"><p>
                                <code class="literal">&lt;subquery<em class="replaceable"><code>N</code></em>&gt;</code>:
                                The row refers to the result of a materialized
                                subquery for the row with an <code class="literal">id</code>
                                value of <em class="replaceable"><code>N</code></em>. See
                                <a class="xref" href="optimization.html#subquery-materialization" title="8.2.2.2&nbsp;Optimizing Subqueries with Materialization">Section&nbsp;8.2.2.2, “Optimizing Subqueries with Materialization”</a>.
                            </p><p style="color:blue;"><subquery n="">：行是指id值为n的行的物化子查询的结果。请参阅第8.2.2.2节“用物化优化子查询”。</subquery></p><p></p></li></ul>
                        </div>
                    </li><li class="listitem"><p><a name="explain_partitions"></a>
                        <code class="literal">partitions</code> (JSON name:
                        <code class="literal">partitions</code>)
                    </p><p style="color:blue;">分区（json名称：分区）</p><p></p><p>
                        The partitions from which records would be matched by the
                        query. The value is <code class="literal">NULL</code> for
                        nonpartitioned tables. See
                        <a class="xref" href="partitioning.html#partitioning-info" title="22.3.5&nbsp;Obtaining Information About Partitions">Section&nbsp;22.3.5, “Obtaining Information About Partitions”</a>.
                    </p><p style="color:blue;">查询将从中匹配记录的分区。非分区表的值为空。见第22.3.5节“获取分区信息”。</p><p></p></li><li class="listitem"><p><a name="explain_type"></a>
                        <code class="literal">type</code> (JSON name:
                        <code class="literal">access_type</code>)
                    </p><p style="color:blue;">类型（json名称：访问类型）</p><p></p><p>
                        The join type. For descriptions of the different types,
                        see
                        <a class="link" href="optimization.html#explain-join-types" title="EXPLAIN Join Types"><code class="literal">EXPLAIN</code>
                            Join Types</a>.
                    </p><p style="color:blue;">连接类型。有关不同类型的说明，请参见解释联接类型。</p><p></p></li><li class="listitem"><p><a name="explain_possible_keys"></a>
                        <code class="literal">possible_keys</code> (JSON name:
                        <code class="literal">possible_keys</code>)
                    </p><p style="color:blue;">可能的密钥（json名称：可能的密钥）</p><p></p><p>
                        The <code class="literal">possible_keys</code> column indicates the
                        indexes from which MySQL can choose to find the rows in
                        this table. Note that this column is totally independent
                        of the order of the tables as displayed in the output from
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>. That means that
                        some of the keys in <code class="literal">possible_keys</code> might
                        not be usable in practice with the generated table order.
                    </p><p style="color:blue;">“可能的键”列指示mysql可以从中选择查找此表中的行的索引。请注意，此列完全独立于explain的输出中显示的表的顺序。这意味着可能的密钥中的某些密钥在实际中可能无法使用生成的表顺序。</p><p></p><p>
                        If this column is <code class="literal">NULL</code> (or undefined in
                        JSON-formatted output), there are no relevant indexes. In
                        this case, you may be able to improve the performance of
                        your query by examining the <code class="literal">WHERE</code>
                        clause to check whether it refers to some column or
                        columns that would be suitable for indexing. If so, create
                        an appropriate index and check the query with
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> again. See
                        <a class="xref" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax">Section&nbsp;13.1.8, “ALTER TABLE Syntax”</a>.
                    </p><p style="color:blue;">如果此列为空（或在json格式的输出中未定义），则没有相关索引。在这种情况下，您可以通过检查WHERE子句来检查查询是否是指适合于索引的某些列或列，从而提高查询的性能。如果是，请创建适当的索引并再次使用explain检查查询。见第13.1.8节“更改表语法”。</p><p></p><p>
                        To see what indexes a table has, use <code class="literal">SHOW INDEX
                        FROM <em class="replaceable"><code>tbl_name</code></em></code>.
                    </p><p style="color:blue;">要查看表有哪些索引，请使用show index from tbl_name。</p><p></p></li><li class="listitem"><p><a name="explain_key"></a>
                        <code class="literal">key</code> (JSON name: <code class="literal">key</code>)
                    </p><p style="color:blue;">key（json名称：key）</p><p></p><p>
                        The <code class="literal">key</code> column indicates the key
                        (index) that MySQL actually decided to use. If MySQL
                        decides to use one of the <code class="literal">possible_keys</code>
                        indexes to look up rows, that index is listed as the key
                        value.
                    </p><p style="color:blue;">key列表示mysql实际决定使用的键（索引）。如果mysql决定使用其中一个可能的键索引来查找行，则该索引将列为键值。</p><p></p><p>
                        It is possible that <code class="literal">key</code> will name an
                        index that is not present in the
                        <code class="literal">possible_keys</code> value. This can happen if
                        none of the <code class="literal">possible_keys</code> indexes are
                        suitable for looking up rows, but all the columns selected
                        by the query are columns of some other index. That is, the
                        named index covers the selected columns, so although it is
                        not used to determine which rows to retrieve, an index
                        scan is more efficient than a data row scan.
                    </p><p style="color:blue;">密钥可能会命名可能的密钥值中不存在的索引。如果没有一个可能的_键索引适合查找行，但查询选择的所有列都是某些其他索引的列，则可能发生这种情况。也就是说，命名索引覆盖选定的列，因此尽管它不用于确定要检索哪些行，但索引扫描比数据行扫描更有效。</p><p></p><p>
                        For <code class="literal">InnoDB</code>, a secondary index might
                        cover the selected columns even if the query also selects
                        the primary key because <code class="literal">InnoDB</code> stores
                        the primary key value with each secondary index. If
                        <code class="literal">key</code> is <code class="literal">NULL</code>, MySQL
                        found no index to use for executing the query more
                        efficiently.
                    </p><p style="color:blue;">对于innodb，即使查询也选择主键，辅助索引也可能覆盖所选列，因为innodb将主键值与每个辅助索引一起存储。如果key为空，mysql找不到可用于更有效执行查询的索引。</p><p></p><p>
                        To force MySQL to use or ignore an index listed in the
                        <code class="literal">possible_keys</code> column, use
                        <code class="literal">FORCE INDEX</code>, <code class="literal">USE
                        INDEX</code>, or <code class="literal">IGNORE INDEX</code> in
                        your query. See <a class="xref" href="optimization.html#index-hints" title="8.9.4&nbsp;Index Hints">Section&nbsp;8.9.4, “Index Hints”</a>.
                    </p><p style="color:blue;">若要强制MySQL使用或忽略“可能的关键字”列中列出的索引，请在查询中使用“强制索引”、“使用索引”或“忽略索引”。见第8.9.4节“索引提示”。</p><p></p><p>
                        For <code class="literal">MyISAM</code> tables, running
                        <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a> helps the
                        optimizer choose better indexes. For
                        <code class="literal">MyISAM</code> tables, <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk
              --analyze</strong></span></a> does the same. See
                        <a class="xref" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax">Section&nbsp;13.7.2.1, “ANALYZE TABLE Syntax”</a>, and
                        <a class="xref" href="backup-and-recovery.html#myisam-table-maintenance" title="7.6&nbsp;MyISAM Table Maintenance and Crash Recovery">Section&nbsp;7.6, “MyISAM Table Maintenance and Crash Recovery”</a>.
                    </p><p style="color:blue;">对于myisam表，运行analyze table可以帮助优化器选择更好的索引。对于myisam表，myisamchk--analyze也会这样做。参见第13.7.2.1节“分析表语法”和第7.6节“myisam表维护和崩溃恢复”。</p><p></p></li><li class="listitem"><p><a name="explain_key_len"></a>
                        <code class="literal">key_len</code> (JSON name:
                        <code class="literal">key_length</code>)
                    </p><p style="color:blue;">key_len（json名称：key_length）</p><p></p><p>
                        The <code class="literal">key_len</code> column indicates the length
                        of the key that MySQL decided to use. The value of
                        <code class="literal">key_len</code> enables you to determine how
                        many parts of a multiple-part key MySQL actually uses. If
                        the <code class="literal">key</code> column says
                        <code class="literal">NULL</code>, the <code class="literal">len_len</code>
                        column also says <code class="literal">NULL</code>.
                    </p><p style="color:blue;">key_len列表示mysql决定使用的密钥的长度。key_len的值使您能够确定mysql实际使用多部分密钥的多少部分。如果键列为空，len_len列也为空。</p><p></p><p>
                        Due to the key storage format, the key length is one
                        greater for a column that can be <code class="literal">NULL</code>
                        than for a <code class="literal">NOT NULL</code> column.
                    </p><p style="color:blue;">由于密钥存储格式的原因，对于可以为空的列，密钥长度比不为空的列大一个。</p><p></p></li><li class="listitem"><p><a name="explain_ref"></a>
                        <code class="literal">ref</code> (JSON name: <code class="literal">ref</code>)
                    </p><p style="color:blue;">ref（json名称：ref）</p><p></p><p>
                        The <code class="literal">ref</code> column shows which columns or
                        constants are compared to the index named in the
                        <code class="literal">key</code> column to select rows from the
                        table.
                    </p><p style="color:blue;">ref列显示将哪些列或常量与键列中命名的索引进行比较，以便从表中选择行。</p><p></p><p>
                        If the value is <code class="literal">func</code>, the value used is
                        the result of some function. To see which function, use
                        <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> following
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to see the extended
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output. The
                        function might actually be an operator such as an
                        arithmetic operator.
                    </p><p style="color:blue;">如果值是func，则使用的值是某个函数的结果。要查看哪个函数，请使用show warnings following explain查看扩展的explain输出。函数实际上可能是一个运算符，例如算术运算符。</p><p></p></li><li class="listitem"><p><a name="explain_rows"></a>
                        <code class="literal">rows</code> (JSON name:
                        <code class="literal">rows</code>)
                    </p><p style="color:blue;">rows（json名称：rows）</p><p></p><p>
                        The <code class="literal">rows</code> column indicates the number of
                        rows MySQL believes it must examine to execute the query.
                    </p><p style="color:blue;">rows列表示mysql认为执行查询必须检查的行数。</p><p></p><p>
                        For <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables, this
                        number is an estimate, and may not always be exact.
                    </p><p style="color:blue;">对于innodb表，这个数字是一个估计值，可能并不总是准确的。</p><p></p></li><li class="listitem"><p><a name="explain_filtered"></a>
                        <code class="literal">filtered</code> (JSON name:
                        <code class="literal">filtered</code>)
                    </p><p style="color:blue;">已筛选（json名称：已筛选）</p><p></p><p>
                        The <code class="literal">filtered</code> column indicates an
                        estimated percentage of table rows that will be filtered
                        by the table condition. The maximum value is 100, which
                        means no filtering of rows occurred. Values decreasing
                        from 100 indicate increasing amounts of filtering.
                        <code class="literal">rows</code> shows the estimated number of rows
                        examined and <code class="literal">rows</code> ×
                        <code class="literal">filtered</code> shows the number of rows that
                        will be joined with the following table. For example, if
                        <code class="literal">rows</code> is 1000 and
                        <code class="literal">filtered</code> is 50.00 (50%), the number of
                        rows to be joined with the following table is 1000 ×
                        50% = 500.
                    </p><p style="color:blue;">筛选列指示将按表条件筛选的表行的估计百分比。最大值为100，这意味着没有对行进行筛选。值从100减少表示过滤量增加。rows显示检查的估计行数，rows×filtered显示将与下表联接的行数。例如，如果行为1000，筛选为50.00（50%），则要与下表联接的行数为1000×50%=500。</p><p></p></li><li class="listitem"><p><a name="explain_extra"></a>
                        <code class="literal">Extra</code> (JSON name: none)
                    </p><p style="color:blue;">额外（json名称：无）</p><p></p><p>
                        This column contains additional information about how
                        MySQL resolves the query. For descriptions of the
                        different values, see
                        <a class="link" href="optimization.html#explain-extra-information" title="EXPLAIN Extra Information"><code class="literal">EXPLAIN</code>
                            Extra Information</a>.
                    </p><p style="color:blue;">此列包含有关mysql如何解析查询的其他信息。有关不同值的说明，请参阅解释其他信息。</p><p></p><p>
                        There is no single JSON property corresponding to the
                        <code class="literal">Extra</code> column; however, values that can
                        occur in this column are exposed as JSON properties, or as
                        the text of the <code class="literal">message</code> property.
                    </p><p style="color:blue;">没有对应于额外列的单个json属性；但是，此列中可能出现的值将公开为json属性或消息属性的文本。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="explain-join-types"></a>EXPLAIN Join Types</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <code class="literal">type</code> column of
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output describes how
                    tables are joined. In JSON-formatted output, these are found
                    as values of the <code class="literal">access_type</code> property. The
                    following list describes the join types, ordered from the best
                    type to the worst:
                </p><p style="color:blue;">explain output的type列描述如何联接表。在json格式的输出中，这些是access_type属性的值。以下列表描述了从最佳类型到最差类型的连接类型：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="jointype_system"></a>
                        <a class="indexterm" name="idm140286871464592"></a>

                        <a class="indexterm" name="idm140286871463136"></a>

                        <a class="indexterm" name="idm140286871461648"></a>

                        <a class="link" href="optimization.html#jointype_system"><code class="literal">system</code></a>
                    </p><p style="color:blue;">系统</p><p></p><p>
                        The table has only one row (= system table). This is a
                        special case of the
                        <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a> join type.
                    </p><p style="color:blue;">该表只有一行（=系统表）。这是const join类型的特例。</p><p></p></li><li class="listitem"><p><a name="jointype_const"></a>
                        <a class="indexterm" name="idm140286871455968"></a>

                        <a class="indexterm" name="idm140286871454512"></a>

                        <a class="indexterm" name="idm140286871453024"></a>

                        <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a>
                    </p><p style="color:blue;">常量</p><p></p><p>
                        The table has at most one matching row, which is read at
                        the start of the query. Because there is only one row,
                        values from the column in this row can be regarded as
                        constants by the rest of the optimizer.
                        <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a> tables are very
                        fast because they are read only once.
                    </p><p style="color:blue;">表最多有一个匹配行，该行在查询开始时读取。因为只有一行，所以该行中列的值可以被优化器的其余部分视为常量。const表非常快，因为它们只读取一次。</p><p></p><p>
                        <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a> is used when you
                        compare all parts of a <code class="literal">PRIMARY KEY</code> or
                        <code class="literal">UNIQUE</code> index to constant values. In the
                        following queries, <em class="replaceable"><code>tbl_name</code></em> can
                        be used as a <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a>
                        table:
                    </p><p style="color:blue;">比较主键或唯一索引的所有部分与常量值时使用const。在以下查询中，tbl_name可以用作const表：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>primary_key</code></em>=1;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>primary_key_part1</code></em>=1 AND <em class="replaceable"><code>primary_key_part2</code></em>=2;
</pre></li><li class="listitem"><p><a name="jointype_eq_ref"></a>
                        <a class="indexterm" name="idm140286871439120"></a>

                        <a class="indexterm" name="idm140286871437664"></a>

                        <a class="link" href="optimization.html#jointype_eq_ref"><code class="literal">eq_ref</code></a>
                    </p><p style="color:blue;">等式参考</p><p></p><p>
                        One row is read from this table for each combination of
                        rows from the previous tables. Other than the
                        <a class="link" href="optimization.html#jointype_system"><code class="literal">system</code></a> and
                        <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a> types, this is
                        the best possible join type. It is used when all parts of
                        an index are used by the join and the index is a
                        <code class="literal">PRIMARY KEY</code> or <code class="literal">UNIQUE NOT
                        NULL</code> index.
                    </p><p style="color:blue;">对于前一个表中的每一行组合，从该表中读取一行。除了system和const类型之外，这是最好的连接类型。当联接使用索引的所有部分并且索引是主键或唯一的非空索引时，将使用该索引。</p><p></p><p>
                        <a class="link" href="optimization.html#jointype_eq_ref"><code class="literal">eq_ref</code></a> can be used for
                        indexed columns that are compared using the
                        <code class="literal">=</code> operator. The comparison value can be
                        a constant or an expression that uses columns from tables
                        that are read before this table. In the following
                        examples, MySQL can use an
                        <a class="link" href="optimization.html#jointype_eq_ref"><code class="literal">eq_ref</code></a> join to process
                        <em class="replaceable"><code>ref_table</code></em>:
                    </p><p style="color:blue;">eq_ref可用于使用=运算符比较的索引列。比较值可以是常量，也可以是使用在此表之前读取的表中的列的表达式。在以下示例中，mysql可以使用eq_ref join来处理ref_表：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li class="listitem"><p><a name="jointype_ref"></a>
                        <a class="indexterm" name="idm140286871417936"></a>

                        <a class="indexterm" name="idm140286871416512"></a>

                        <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a>
                    </p><p style="color:blue;">裁判</p><p></p><p>
                        All rows with matching index values are read from this
                        table for each combination of rows from the previous
                        tables. <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> is used if
                        the join uses only a leftmost prefix of the key or if the
                        key is not a <code class="literal">PRIMARY KEY</code> or
                        <code class="literal">UNIQUE</code> index (in other words, if the
                        join cannot select a single row based on the key value).
                        If the key that is used matches only a few rows, this is a
                        good join type.
                    </p><p style="color:blue;">对于上一个表中的每一行组合，都将从该表中读取具有匹配索引值的所有行。如果联接仅使用键的最左边前缀，或者键不是主键或唯一索引（换句话说，如果联接不能基于键值选择一行），则使用ref。如果所使用的键只匹配几行，则这是一种很好的联接类型。</p><p></p><p>
                        <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> can be used for
                        indexed columns that are compared using the
                        <code class="literal">=</code> or <code class="literal">&lt;=&gt;</code>
                        operator. In the following examples, MySQL can use a
                        <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> join to process
                        <em class="replaceable"><code>ref_table</code></em>:
                    </p><p style="color:blue;">ref可用于使用=或&lt;=&gt;运算符比较的索引列。在以下示例中，mysql可以使用ref join来处理ref_表：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em> WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li class="listitem"><p><a name="jointype_fulltext"></a>
                        <a class="indexterm" name="idm140286871395184"></a>

                        <a class="indexterm" name="idm140286871393728"></a>

                        <a class="link" href="optimization.html#jointype_fulltext"><code class="literal">fulltext</code></a>
                    </p><p style="color:blue;">全文索引</p><p></p><p>
                        The join is performed using a <code class="literal">FULLTEXT</code>
                        index.
                    </p><p style="color:blue;">使用全文索引执行联接。</p><p></p></li><li class="listitem"><p><a name="jointype_ref_or_null"></a>
                        <a class="indexterm" name="idm140286871388560"></a>

                        <a class="indexterm" name="idm140286871387104"></a>

                        <a class="link" href="optimization.html#jointype_ref_or_null"><code class="literal">ref_or_null</code></a>
                    </p><p style="color:blue;">ref_或_空</p><p></p><p>
                        This join type is like
                        <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a>, but with the
                        addition that MySQL does an extra search for rows that
                        contain <code class="literal">NULL</code> values. This join type
                        optimization is used most often in resolving subqueries.
                        In the following examples, MySQL can use a
                        <a class="link" href="optimization.html#jointype_ref_or_null"><code class="literal">ref_or_null</code></a> join to
                        process <em class="replaceable"><code>ref_table</code></em>:
                    </p><p style="color:blue;">这种连接类型类似于ref，但是mysql会额外搜索包含空值的行。这种连接类型优化最常用于解析子查询。在以下示例中，mysql可以使用ref_或_空联接来处理ref_表：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em> OR <em class="replaceable"><code>key_column</code></em> IS NULL;
</pre><p>
                        See <a class="xref" href="optimization.html#is-null-optimization" title="8.2.1.13&nbsp;IS NULL Optimization">Section&nbsp;8.2.1.13, “IS NULL Optimization”</a>.
                    </p><p style="color:blue;">见第8.2.1.13节“为空优化”。</p><p></p></li><li class="listitem"><p><a name="jointype_index_merge"></a>
                        <a class="indexterm" name="idm140286871374976"></a>

                        <a class="indexterm" name="idm140286871373520"></a>

                        <a class="link" href="optimization.html#jointype_index_merge"><code class="literal">index_merge</code></a>
                    </p><p style="color:blue;">索引合并</p><p></p><p>
                        This join type indicates that the Index Merge optimization
                        is used. In this case, the <code class="literal">key</code> column
                        in the output row contains a list of indexes used, and
                        <code class="literal">key_len</code> contains a list of the longest
                        key parts for the indexes used. For more information, see
                        <a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3&nbsp;Index Merge Optimization">Section&nbsp;8.2.1.3, “Index Merge Optimization”</a>.
                    </p><p style="color:blue;">此联接类型表示使用了索引合并优化。在这种情况下，输出行中的键列包含所用索引的列表，而键列包含所用索引的最长键部分的列表。有关详细信息，请参阅第8.2.1.3节“索引合并优化”。</p><p></p></li><li class="listitem"><p><a name="jointype_unique_subquery"></a>
                        <a class="indexterm" name="idm140286871366752"></a>

                        <a class="indexterm" name="idm140286871365264"></a>

                        <a class="link" href="optimization.html#jointype_unique_subquery"><code class="literal">unique_subquery</code></a>
                    </p><p style="color:blue;">唯一的子查询</p><p></p><p>
                        This type replaces
                        <a class="link" href="optimization.html#jointype_eq_ref"><code class="literal">eq_ref</code></a> for some
                        <code class="literal">IN</code> subqueries of the following form:
                    </p><p style="color:blue;">此类型替换以下形式的子查询中的某些eq_ref：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>primary_key</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre><p>
                        <a class="link" href="optimization.html#jointype_unique_subquery"><code class="literal">unique_subquery</code></a> is just
                        an index lookup function that replaces the subquery
                        completely for better efficiency.
                    </p><p style="color:blue;">unique_subquery只是一个索引查找函数，它完全替换了子查询，以提高效率。</p><p></p></li><li class="listitem"><p><a name="jointype_index_subquery"></a>
                        <a class="indexterm" name="idm140286871354464"></a>

                        <a class="indexterm" name="idm140286871353008"></a>

                        <a class="link" href="optimization.html#jointype_index_subquery"><code class="literal">index_subquery</code></a>
                    </p><p style="color:blue;">索引子查询</p><p></p><p>
                        This join type is similar to
                        <a class="link" href="optimization.html#jointype_unique_subquery"><code class="literal">unique_subquery</code></a>. It
                        replaces <code class="literal">IN</code> subqueries, but it works
                        for nonunique indexes in subqueries of the following form:
                    </p><p style="color:blue;">此联接类型类似于unique_子查询。它替换子查询中的索引，但适用于以下形式的子查询中的非唯一索引：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>key_column</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre></li><li class="listitem"><p><a name="jointype_range"></a>
                        <a class="indexterm" name="idm140286871343936"></a>

                        <a class="indexterm" name="idm140286871342480"></a>

                        <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a>
                    </p><p style="color:blue;">范围</p><p></p><p>
                        Only rows that are in a given range are retrieved, using
                        an index to select the rows. The <code class="literal">key</code>
                        column in the output row indicates which index is used.
                        The <code class="literal">key_len</code> contains the longest key
                        part that was used. The <code class="literal">ref</code> column is
                        <code class="literal">NULL</code> for this type.
                    </p><p style="color:blue;">只检索给定范围内的行，使用索引选择行。输出行中的键列指示使用哪个索引。密钥包含使用的最长密钥部分。此类型的ref列为空。</p><p></p><p>
                        <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a> can be used when
                        a key column is compared to a constant using any of the
                        <a class="link" href="functions.html#operator_equal"><code class="literal">=</code></a>,
                        <a class="link" href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>,
                        <a class="link" href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
                        <a class="link" href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
                        <a class="link" href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
                        <a class="link" href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
                        <a class="link" href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a>,
                        <a class="link" href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
                        <a class="link" href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>,
                        <a class="link" href="functions.html#operator_like"><code class="literal">LIKE</code></a>, or
                        <a class="link" href="functions.html#operator_in"><code class="literal">IN()</code></a> operators:
                    </p><p style="color:blue;">当使用以下任一运算符将键列与常量进行比较时，可以使用范围：=，&lt;&gt;，&gt;，&gt;=，&lt;，&lt;=，is null，&lt;=&gt;，between，like，or in（）：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> = 10;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> BETWEEN 10 and 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> IN (10,20,30);

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em> = 10 AND <em class="replaceable"><code>key_part2</code></em> IN (10,20,30);
</pre></li><li class="listitem"><p><a name="jointype_index"></a>
                        <a class="indexterm" name="idm140286871314848"></a>

                        <a class="indexterm" name="idm140286871313392"></a>

                        <a class="link" href="optimization.html#jointype_index"><code class="literal">index</code></a>
                    </p><p style="color:blue;">指数</p><p></p><p>
                        The <code class="literal">index</code> join type is the same as
                        <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a>, except that the
                        index tree is scanned. This occurs two ways:
                    </p><p style="color:blue;">索引联接类型与所有类型相同，只是扫描了索引树。这有两种方式：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                If the index is a covering index for the queries and
                                can be used to satisfy all data required from the
                                table, only the index tree is scanned. In this case,
                                the <code class="literal">Extra</code> column says
                                <code class="literal">Using index</code>. An index-only scan
                                usually is faster than
                                <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a> because the
                                size of the index usually is smaller than the table
                                data.
                            </p><p style="color:blue;">如果索引是查询的覆盖索引，并且可以用于满足表中所需的所有数据，则只扫描索引树。在这种情况下，额外的一列表示使用索引。仅索引扫描通常比全部扫描快，因为索引的大小通常小于表数据。</p><p></p></li><li class="listitem"><p>
                                A full table scan is performed using reads from the
                                index to look up data rows in index order.
                                <code class="literal">Uses index</code> does not appear in the
                                <code class="literal">Extra</code> column.
                            </p><p style="color:blue;">使用从索引中读取的数据按索引顺序查找数据行来执行完整表扫描。uses index不出现在额外的列中。</p><p></p></li></ul>
                        </div>
                        <p>
                            MySQL can use this join type when the query uses only
                            columns that are part of a single index.
                        </p><p style="color:blue;">当查询只使用作为单个索引一部分的列时，mysql可以使用此联接类型。</p><p></p></li><li class="listitem"><p><a name="jointype_all"></a>
                        <a class="indexterm" name="idm140286871299824"></a>

                        <a class="indexterm" name="idm140286871298400"></a>

                        <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a>
                    </p><p style="color:blue;">全部</p><p></p><p>
                        A full table scan is done for each combination of rows
                        from the previous tables. This is normally not good if the
                        table is the first table not marked
                        <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a>, and usually
                        <span class="emphasis"><em>very</em></span> bad in all other cases.
                        Normally, you can avoid
                        <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a> by adding indexes
                        that enable row retrieval from the table based on constant
                        values or column values from earlier tables.
                    </p><p style="color:blue;">对前一个表中的每一行组合进行完整的表扫描。如果表是第一个未标记为const的表，则这通常不好，在所有其他情况下通常都非常糟糕。通常，您可以通过添加索引来避免所有问题，这些索引支持基于常量值或来自早期表的列值从表中检索行。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="explain-extra-information"></a>EXPLAIN Extra Information</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <code class="literal">Extra</code> column of
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output contains
                    additional information about how MySQL resolves the query. The
                    following list explains the values that can appear in this
                    column. Each item also indicates for JSON-formatted output
                    which property displays the <code class="literal">Extra</code> value.
                    For some of these, there is a specific property. The others
                    display as the text of the <code class="literal">message</code>
                    property.
                </p><p style="color:blue;">explain output的附加列包含有关mysql如何解析查询的附加信息。下表说明了此列中可能出现的值。每个项还指示json格式的输出哪个属性显示额外的值。对于其中一些，有一个特定的属性。其他的则显示为消息属性的文本。</p><p></p><p>
                If you want to make your queries as fast as possible, look out
                for <code class="literal">Extra</code> column values of <code class="literal">Using
                filesort</code> and <code class="literal">Using temporary</code>, or,
                in JSON-formatted <code class="literal">EXPLAIN</code> output, for
                <code class="literal">using_filesort</code> and
                <code class="literal">using_temporary_table</code> properties equal to
                <code class="literal">true</code>.
            </p><p style="color:blue;">如果您想使查询尽可能快，请注意使用filesort和使用temporary的额外列值，或者在json格式的explain输出中，注意使用与true相等的\u filesort和使用与true相等的\u temporary\u table properties的额外列值。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">Child of '<em class="replaceable"><code>table</code></em>'
                            pushed join@1</code> (JSON: <code class="literal">message</code>
                        text)
                    </p><p style="color:blue;">“table”的子级push join@1（json:message text）</p><p></p><p>
                        This table is referenced as the child of
                        <em class="replaceable"><code>table</code></em> in a join that can be
                        pushed down to the NDB kernel. Applies only in NDB
                        Cluster, when pushed-down joins are enabled. See the
                        description of the
                        <a class="link" href="mysql-cluster.html#sysvar_ndb_join_pushdown"><code class="literal">ndb_join_pushdown</code></a> server
                        system variable for more information and examples.
                    </p><p style="color:blue;">这个表在一个可以下推到ndb内核的连接中被作为表的子表引用。仅适用于启用下推连接时的ndb集群。有关详细信息和示例，请参见ndb_join_pushdown server系统变量的说明。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">const row not found</code> (JSON property:
                        <code class="literal">const_row_not_found</code>)
                    </p><p style="color:blue;">找不到常量行（JSON属性：找不到常量行）</p><p></p><p>
                        For a query such as <code class="literal">SELECT ... FROM
                        <em class="replaceable"><code>tbl_name</code></em></code>, the table
                        was empty.
                    </p><p style="color:blue;">对于select之类的查询…从tbl_name看，表是空的。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Deleting all rows</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">删除所有行（json属性：消息）</p><p></p><p>
                        For <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>, some storage
                        engines (such as <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>)
                        support a handler method that removes all table rows in a
                        simple and fast way. This <code class="literal">Extra</code> value
                        is displayed if the engine uses this optimization.
                    </p><p style="color:blue;">对于delete，一些存储引擎（如myisam）支持一个处理程序方法，该方法可以简单快速地删除所有表行。如果引擎使用此优化，则显示此额外值。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Distinct</code> (JSON property:
                        <code class="literal">distinct</code>)
                    </p><p style="color:blue;">distinct（json属性：distinct）</p><p></p><p>
                        MySQL is looking for distinct values, so it stops
                        searching for more rows for the current row combination
                        after it has found the first matching row.
                    </p><p style="color:blue;">mysql正在寻找不同的值，因此在找到第一个匹配的行之后，它将停止搜索当前行组合的更多行。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">FirstMatch(<em class="replaceable"><code>tbl_name</code></em>)</code>
                        (JSON property: <code class="literal">first_match</code>)
                    </p><p style="color:blue;">first match（tbl_name）（json属性：first_match）</p><p></p><p>
                        The semijoin FirstMatch join shortcutting strategy is used
                        for <em class="replaceable"><code>tbl_name</code></em>.
                    </p><p style="color:blue;">半联接firstmatch联接快捷方式策略用于tbl_name。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Full scan on NULL key</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">对空键进行完全扫描（json属性：message）</p><p></p><p>
                        This occurs for subquery optimization as a fallback
                        strategy when the optimizer cannot use an index-lookup
                        access method.
                    </p><p style="color:blue;">当优化器无法使用索引查找访问方法时，作为回退策略的子查询优化会发生这种情况。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Impossible HAVING</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">无法拥有（json属性：消息）</p><p></p><p>
                        The <code class="literal">HAVING</code> clause is always false and
                        cannot select any rows.
                    </p><p style="color:blue;">having子句始终为false，不能选择任何行。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Impossible WHERE</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">不可能的位置（json属性：消息）</p><p></p><p>
                        The <code class="literal">WHERE</code> clause is always false and
                        cannot select any rows.
                    </p><p style="color:blue;">where子句始终为false，不能选择任何行。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Impossible WHERE noticed after reading const
                            tables</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">不可能，在读取const表后会注意到（json属性：message）</p><p></p><p>
                        MySQL has read all
                        <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a> (and
                        <a class="link" href="optimization.html#jointype_system"><code class="literal">system</code></a>) tables and
                        notice that the <code class="literal">WHERE</code> clause is always
                        false.
                    </p><p style="color:blue;">mysql已经读取了所有const（和system）表，注意where子句总是false。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">LooseScan(<em class="replaceable"><code>m</code></em>..<em class="replaceable"><code>n</code></em>)</code>
                        (JSON property: <code class="literal">message</code>)
                    </p><p style="color:blue;">loosscan（m..n）（json属性：消息）</p><p></p><p>
                        The semijoin LooseScan strategy is used.
                        <em class="replaceable"><code>m</code></em> and
                        <em class="replaceable"><code>n</code></em> are key part numbers.
                    </p><p style="color:blue;">采用半连接loosscan策略。M和N是关键零件号。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">No matching min/max row</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">没有匹配的最小/最大行（json属性：消息）</p><p></p><p>
                        No row satisfies the condition for a query such as
                        <code class="literal">SELECT MIN(...) FROM ... WHERE
                            <em class="replaceable"><code>condition</code></em></code>.
                    </p><p style="color:blue;">没有行满足查询条件，例如select min（…）from…什么情况。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">no matching row in const table</code> (JSON
                        property: <code class="literal">message</code>)
                    </p><p style="color:blue;">const表中没有匹配的行（json属性：message）</p><p></p><p>
                        For a query with a join, there was an empty table or a
                        table with no rows satisfying a unique index condition.
                    </p><p style="color:blue;">对于具有联接的查询，存在空表或没有满足唯一索引条件的行的表。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">No matching rows after partition
                            pruning</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">分区修剪后没有匹配的行（json属性：message）</p><p></p><p>
                        For <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> or
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, the optimizer found
                        nothing to delete or update after partition pruning. It is
                        similar in meaning to <code class="literal">Impossible WHERE</code>
                        for <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements.
                    </p><p style="color:blue;">对于删除或更新，优化器在删除分区后找不到要删除或更新的内容。它的含义类似于不可能在何处选择语句。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">No tables used</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">未使用表（json属性：消息）</p><p></p><p>
                        The query has no <code class="literal">FROM</code> clause, or has a
                        <code class="literal">FROM DUAL</code> clause.
                    </p><p style="color:blue;">查询没有FROM子句，或具有FROM双子句。</p><p></p><p>
                        For <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
                        <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a> statements,
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> displays this value
                        when there is no <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        part. For example, it appears for <code class="literal">EXPLAIN INSERT
                        INTO t VALUES(10)</code> because that is equivalent to
                        <code class="literal">EXPLAIN INSERT INTO t SELECT 10 FROM
                            DUAL</code>.
                    </p><p style="color:blue;">对于insert或replace语句，explain在没有select部分时显示此值。例如，explain insert into t值（10）出现，因为这相当于explain insert into t select 10 from dual。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Not exists</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">不存在（JSON属性：消息）</p><p></p><p>
                        MySQL was able to do a <code class="literal">LEFT JOIN</code>
                        optimization on the query and does not examine more rows
                        in this table for the previous row combination after it
                        finds one row that matches the <code class="literal">LEFT
                        JOIN</code> criteria. Here is an example of the type of
                        query that can be optimized this way:
                    </p><p style="color:blue;">mysql能够对查询执行左连接优化，并且在找到一个与左连接条件匹配的行之后，不会检查此表中的上一行组合的更多行。下面是一个可以通过这种方式优化的查询类型示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
  WHERE t2.id IS NULL;
</pre><p>
                        Assume that <code class="literal">t2.id</code> is defined as
                        <code class="literal">NOT NULL</code>. In this case, MySQL scans
                        <code class="literal">t1</code> and looks up the rows in
                        <code class="literal">t2</code> using the values of
                        <code class="literal">t1.id</code>. If MySQL finds a matching row in
                        <code class="literal">t2</code>, it knows that
                        <code class="literal">t2.id</code> can never be
                        <code class="literal">NULL</code>, and does not scan through the
                        rest of the rows in <code class="literal">t2</code> that have the
                        same <code class="literal">id</code> value. In other words, for each
                        row in <code class="literal">t1</code>, MySQL needs to do only a
                        single lookup in <code class="literal">t2</code>, regardless of how
                        many rows actually match in <code class="literal">t2</code>.
                    </p><p style="color:blue;">假设t2.id被定义为非空。在这种情况下，mysql扫描t1，并使用t1.id的值查找t2中的行。如果mysql在t2中找到匹配的行，它知道t2.id永远不能为空，并且不会扫描t2中具有相同id值的其余行。换句话说，对于t1中的每一行，mysql只需要在t2中执行一次查找，而不管t2中实际匹配了多少行。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Plan isn't ready yet</code> (JSON property:
                        none)
                    </p><p style="color:blue;">计划尚未准备好（json属性：none）</p><p></p><p>
                        This value occurs with <a class="link" href="optimization.html#explain-for-connection" title="8.8.4&nbsp;Obtaining Execution Plan Information for a Named Connection"><code class="literal">EXPLAIN FOR
                        CONNECTION</code></a> when the optimizer has not finished
                        creating the execution plan for the statement executing in
                        the named connection. If execution plan output comprises
                        multiple lines, any or all of them could have this
                        <code class="literal">Extra</code> value, depending on the progress
                        of the optimizer in determining the full execution plan.
                    </p><p style="color:blue;">当优化器尚未完成为在命名连接中执行的语句创建执行计划时，会出现此值，并解释连接。如果执行计划输出包含多行，则其中任何行或所有行都可能具有此额外值，具体取决于优化器确定完整执行计划的进度。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Range checked for each record (index map:
                            <em class="replaceable"><code>N</code></em>)</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">检查每个记录的范围（索引映射：n）（json属性：消息）</p><p></p><p>
                        MySQL found no good index to use, but found that some of
                        indexes might be used after column values from preceding
                        tables are known. For each row combination in the
                        preceding tables, MySQL checks whether it is possible to
                        use a <a class="link" href="optimization.html#jointype_range"><code class="literal">range</code></a> or
                        <a class="link" href="optimization.html#jointype_index_merge"><code class="literal">index_merge</code></a> access
                        method to retrieve rows. This is not very fast, but is
                        faster than performing a join with no index at all. The
                        applicability criteria are as described in
                        <a class="xref" href="optimization.html#range-optimization" title="8.2.1.2&nbsp;Range Optimization">Section&nbsp;8.2.1.2, “Range Optimization”</a>, and
                        <a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3&nbsp;Index Merge Optimization">Section&nbsp;8.2.1.3, “Index Merge Optimization”</a>, with the
                        exception that all column values for the preceding table
                        are known and considered to be constants.
                    </p><p style="color:blue;">mysql找不到好的索引可供使用，但发现在已知前面表中的列值之后，可能会使用某些索引。对于上表中的每一行组合，mysql检查是否可以使用范围或索引合并访问方法来检索行。这不是很快，但比执行完全没有索引的联接快。适用性标准如第8.2.1.2节“范围优化”和第8.2.1.3节“索引合并优化”所述，但上表的所有列值均已知并被视为常量除外。</p><p></p><p>
                        Indexes are numbered beginning with 1, in the same order
                        as shown by <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a> for
                        the table. The index map value
                        <em class="replaceable"><code>N</code></em> is a bitmask value that
                        indicates which indexes are candidates. For example, a
                        value of <code class="literal">0x19</code> (binary 11001) means that
                        indexes 1, 4, and 5 will be considered.
                    </p><p style="color:blue;">索引以1开头编号，顺序与表的“显示索引”所示的顺序相同。索引映射值n是指示哪些索引是候选索引的位掩码值。例如，值0x19（二进制11001）表示将考虑索引1、4和5。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Scanned <em class="replaceable"><code>N</code></em>
                            databases</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">扫描的n个数据库（json属性：消息）</p><p></p><p>
                        This indicates how many directory scans the server
                        performs when processing a query for
                        <code class="literal">INFORMATION_SCHEMA</code> tables, as described
                        in <a class="xref" href="optimization.html#information-schema-optimization" title="8.2.3&nbsp;Optimizing INFORMATION_SCHEMA Queries">Section&nbsp;8.2.3, “Optimizing INFORMATION_SCHEMA Queries”</a>. The
                        value of <em class="replaceable"><code>N</code></em> can be 0, 1, or
                        <code class="literal">all</code>.
                    </p><p style="color:blue;">这表示服务器在处理信息架构表查询时执行的目录扫描次数，如第8.2.3节“优化信息架构查询”所述。n的值可以是0、1或全部。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Select tables optimized away</code> (JSON
                        property: <code class="literal">message</code>)
                    </p><p style="color:blue;">选择已优化的表（json属性：message）</p><p></p><p>
                        The optimizer determined 1) that at most one row should be
                        returned, and 2) that to produce this row, a deterministic
                        set of rows must be read. When the rows to be read can be
                        read during the optimization phase (for example, by
                        reading index rows), there is no need to read any tables
                        during query execution.
                    </p><p style="color:blue;">优化器确定1）最多应返回一行，2）若要生成该行，必须读取一组确定的行。当要读取的行可以在优化阶段读取时（例如，通过读取索引行），查询执行期间不需要读取任何表。</p><p></p><p>
                        The first condition is fulfilled when the query is
                        implicitly grouped (contains an aggregate function but no
                        <code class="literal">GROUP BY</code> clause). The second condition
                        is fulfilled when one row lookup is performed per index
                        used. The number of indexes read determines the number of
                        rows to read.
                    </p><p style="color:blue;">当查询被隐式分组（包含聚合函数但不包含GROUPBY子句）时，满足第一个条件。当每使用一个索引执行一行查找时，满足第二个条件。读取的索引数决定了要读取的行数。</p><p></p><p>
                        Consider the following implicitly grouped query:
                    </p><p style="color:blue;">考虑以下隐式分组查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT MIN(c1), MIN(c2) FROM t1;
</pre><p>
                        Suppose that <code class="literal">MIN(c1)</code> can be retrieved
                        by reading one index row and <code class="literal">MIN(c2)</code>
                        can be retrieved by reading one row from a different
                        index. That is, for each column <code class="literal">c1</code> and
                        <code class="literal">c2</code>, there exists an index where the
                        column is the first column of the index. In this case, one
                        row is returned, produced by reading two deterministic
                        rows.
                    </p><p style="color:blue;">假设min（c1）可以通过读取一个索引行来检索，min（c2）可以通过从不同索引中读取一行来检索。也就是说，对于每一列C1和C2，存在一个索引，其中列是索引的第一列。在这种情况下，返回一行，通过读取两个确定性行来生成。</p><p></p><p>
                        This <code class="literal">Extra</code> value does not occur if the
                        rows to read are not deterministic. Consider this query:
                    </p><p style="color:blue;">如果要读取的行不是确定性的，则不会出现此额外值。请考虑以下查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT MIN(c2) FROM t1 WHERE c1 &lt;= 10;
</pre><p>
                        Suppose that <code class="literal">(c1, c2)</code> is a covering
                        index. Using this index, all rows with <code class="literal">c1 &lt;=
                        10</code> must be scanned to find the minimum
                        <code class="literal">c2</code> value. By contrast, consider this
                        query:
                    </p><p style="color:blue;">假设（c1，c2）是一个覆盖索引。使用此索引，必须扫描C1&lt;=10的所有行，以找到最小C2值。相比之下，请考虑以下查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT MIN(c2) FROM t1 WHERE c1 = 10;
</pre><p>
                        In this case, the first index row with <code class="literal">c1 =
                        10</code> contains the minimum <code class="literal">c2</code>
                        value. Only one row must be read to produce the returned
                        row.
                    </p><p style="color:blue;">在这种情况下，C1=10的第一个索引行包含最小C2值。必须只读取一行才能生成返回的行。</p><p></p><p>
                        For storage engines that maintain an exact row count per
                        table (such as <code class="literal">MyISAM</code>, but not
                        <code class="literal">InnoDB</code>), this <code class="literal">Extra</code>
                        value can occur for <code class="literal">COUNT(*)</code> queries
                        for which the <code class="literal">WHERE</code> clause is missing
                        or always true and there is no <code class="literal">GROUP BY</code>
                        clause. (This is an instance of an implicitly grouped
                        query where the storage engine influences whether a
                        deterministic number of rows can be read.)
                    </p><p style="color:blue;">对于为每个表维护精确行计数的存储引擎（例如myisam，但不是innodb），对于缺少where子句或始终为true且不存在group by子句的count（*）查询，可能会出现此额外值。（这是隐式分组查询的一个实例，其中存储引擎影响是否可以读取确定性数量的行。）</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Skip_open_table</code>,
                        <code class="literal">Open_frm_only</code>,
                        <code class="literal">Open_full_table</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">skip_open_table，open_frm_only，open_full_table（json属性：消息）</p><p></p><p>
                        These values indicate file-opening optimizations that
                        apply to queries for <code class="literal">INFORMATION_SCHEMA</code>
                        tables, as described in
                        <a class="xref" href="optimization.html#information-schema-optimization" title="8.2.3&nbsp;Optimizing INFORMATION_SCHEMA Queries">Section&nbsp;8.2.3, “Optimizing INFORMATION_SCHEMA Queries”</a>.
                    </p><p style="color:blue;">这些值表示适用于信息架构表查询的文件打开优化，如第8.2.3节“优化信息架构查询”所述。</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">Skip_open_table</code>: Table files do not
                                need to be opened. The information has already become
                                available within the query by scanning the database
                                directory.
                            </p><p style="color:blue;">skip_open_table：不需要打开表文件。通过扫描数据库目录，该信息已在查询中可用。</p><p></p></li><li class="listitem"><p>
                                <code class="literal">Open_frm_only</code>: Only the table's
                                <code class="filename">.frm</code> file need be opened.
                            </p><p style="color:blue;">open_frm_only：只需要打开表的.frm文件。</p><p></p></li><li class="listitem"><p>
                                <code class="literal">Open_full_table</code>: The unoptimized
                                information lookup. The <code class="filename">.frm</code>,
                                <code class="filename">.MYD</code>, and
                                <code class="filename">.MYI</code> files must be opened.
                            </p><p style="color:blue;">打开完整表：未优化的信息查找。必须打开.frm、.myd和.myi文件。</p><p></p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        <code class="literal">Start temporary</code>, <code class="literal">End
                        temporary</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">开始临时，结束临时（json属性：消息）</p><p></p><p>
                        This indicates temporary table use for the semijoin
                        Duplicate Weedout strategy.
                    </p><p style="color:blue;">这表示用于半联接重复weedout策略的临时表。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">unique row not found</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">找不到唯一行（JSON属性：消息）</p><p></p><p>
                        For a query such as <code class="literal">SELECT ... FROM
                        <em class="replaceable"><code>tbl_name</code></em></code>, no rows
                        satisfy the condition for a <code class="literal">UNIQUE</code>
                        index or <code class="literal">PRIMARY KEY</code> on the table.
                    </p><p style="color:blue;">对于select之类的查询…根据tbl_name，没有行满足表上唯一索引或主键的条件。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using filesort</code> (JSON property:
                        <code class="literal">using_filesort</code>)
                    </p><p style="color:blue;">使用文件排序（json属性：使用文件排序）</p><p></p><p>
                        MySQL must do an extra pass to find out how to retrieve
                        the rows in sorted order. The sort is done by going
                        through all rows according to the join type and storing
                        the sort key and pointer to the row for all rows that
                        match the <code class="literal">WHERE</code> clause. The keys then
                        are sorted and the rows are retrieved in sorted order. See
                        <a class="xref" href="optimization.html#order-by-optimization" title="8.2.1.14&nbsp;ORDER BY Optimization">Section&nbsp;8.2.1.14, “ORDER BY Optimization”</a>.
                    </p><p style="color:blue;">mysql必须执行额外的传递，以了解如何按排序顺序检索行。排序是根据联接类型遍历所有行，并存储排序键和指向与where子句匹配的所有行的指针。然后对键进行排序，并按排序顺序检索行。见第8.2.1.14节“按优化排序”。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using index</code> (JSON property:
                        <code class="literal">using_index</code>)
                    </p><p style="color:blue;">使用索引（json属性：使用索引）</p><p></p><p>
                        The column information is retrieved from the table using
                        only information in the index tree without having to do an
                        additional seek to read the actual row. This strategy can
                        be used when the query uses only columns that are part of
                        a single index.
                    </p><p style="color:blue;">只使用索引树中的信息从表中检索列信息，而不必执行额外的查找来读取实际行。当查询仅使用作为单个索引一部分的列时，可以使用此策略。</p><p></p><p>
                        For <code class="literal">InnoDB</code> tables that have a
                        user-defined clustered index, that index can be used even
                        when <code class="literal">Using index</code> is absent from the
                        <code class="literal">Extra</code> column. This is the case if
                        <code class="literal">type</code> is
                        <a class="link" href="optimization.html#jointype_index"><code class="literal">index</code></a> and
                        <code class="literal">key</code> is <code class="literal">PRIMARY</code>.
                    </p><p style="color:blue;">对于具有用户定义的聚集索引的innodb表，即使额外列中没有使用index，也可以使用该索引。如果type是index，key是primary，则会出现这种情况。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using index condition</code> (JSON property:
                        <code class="literal">using_index_condition</code>)
                    </p><p style="color:blue;">使用索引条件（json属性：使用索引条件）</p><p></p><p>
                        Tables are read by accessing index tuples and testing them
                        first to determine whether to read full table rows. In
                        this way, index information is used to defer (<span class="quote">“<span class="quote">push
              down</span>”</span>) reading full table rows unless it is
                        necessary. See
                        <a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.5&nbsp;Index Condition Pushdown Optimization">Section&nbsp;8.2.1.5, “Index Condition Pushdown Optimization”</a>.
                    </p><p style="color:blue;">通过访问索引元组并首先测试它们以确定是否读取完整的表行来读取表。这样，除非有必要，否则索引信息用于延迟（“下推”）读取完整的表行。见第8.2.1.5节“指标条件下推优化”。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using index for group-by</code> (JSON
                        property: <code class="literal">using_index_for_group_by</code>)
                    </p><p style="color:blue;">为group by使用索引（json属性：为groupby使用索引）</p><p></p><p>
                        Similar to the <code class="literal">Using index</code> table access
                        method, <code class="literal">Using index for group-by</code>
                        indicates that MySQL found an index that can be used to
                        retrieve all columns of a <code class="literal">GROUP BY</code> or
                        <code class="literal">DISTINCT</code> query without any extra disk
                        access to the actual table. Additionally, the index is
                        used in the most efficient way so that for each group,
                        only a few index entries are read. For details, see
                        <a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.15&nbsp;GROUP BY Optimization">Section&nbsp;8.2.1.15, “GROUP BY Optimization”</a>.
                    </p><p style="color:blue;">与using index table access方法类似，using index for group by表示mysql找到了一个索引，可以用来检索group by或distinct查询的所有列，而不需要对实际表进行任何额外的磁盘访问。此外，索引以最有效的方式使用，因此对于每个组，只读取几个索引项。有关详细信息，请参见第8.2.1.15节“按优化分组”。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using join buffer (Block Nested Loop)</code>,
                        <code class="literal">Using join buffer (Batched Key Access)</code>
                        (JSON property: <code class="literal">using_join_buffer</code>)
                    </p><p style="color:blue;">使用连接缓冲区（块嵌套循环），使用连接缓冲区（成批密钥访问）（JSON属性：使用连接缓冲区）</p><p></p><p>
                        Tables from earlier joins are read in portions into the
                        join buffer, and then their rows are used from the buffer
                        to perform the join with the current table.
                        <code class="literal">(Block Nested Loop)</code> indicates use of
                        the Block Nested-Loop algorithm and <code class="literal">(Batched Key
                        Access)</code> indicates use of the Batched Key Access
                        algorithm. That is, the keys from the table on the
                        preceding line of the
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output will be
                        buffered, and the matching rows will be fetched in batches
                        from the table represented by the line in which
                        <code class="literal">Using join buffer</code> appears.
                    </p><p style="color:blue;">早期联接中的表部分读入联接缓冲区，然后使用缓冲区中的行来执行与当前表的联接。（block nested loop）表示使用block nested loop算法，（batched key access）表示使用batched key access算法。也就是说，explain输出前一行的表中的键将被缓冲，匹配的行将从显示using join buffer的行所表示的表中成批获取。</p><p></p><p>
                        In JSON-formatted output, the value of
                        <code class="literal">using_join_buffer</code> is always either one
                        of <code class="literal">Block Nested Loop</code> or
                        <code class="literal">Batched Key Access</code>.
                    </p><p style="color:blue;">在json格式的输出中，使用连接缓冲区的值总是块嵌套循环或批处理密钥访问的值之一。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using MRR</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">使用mrr（json属性：消息）</p><p></p><p>
                        Tables are read using the Multi-Range Read optimization
                        strategy. See <a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.10&nbsp;Multi-Range Read Optimization">Section&nbsp;8.2.1.10, “Multi-Range Read Optimization”</a>.
                    </p><p style="color:blue;">使用多范围读取优化策略读取表。见第8.2.1.10节“多量程读取优化”。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using sort_union(...)</code>, <code class="literal">Using
                        union(...)</code>, <code class="literal">Using
                        intersect(...)</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">使用sort_union（…）、使用union（…）、使用intersect（…）（json属性：消息）</p><p></p><p>
                        These indicate the particular algorithm showing how index
                        scans are merged for the
                        <a class="link" href="optimization.html#jointype_index_merge"><code class="literal">index_merge</code></a> join type.
                        See <a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3&nbsp;Index Merge Optimization">Section&nbsp;8.2.1.3, “Index Merge Optimization”</a>.
                    </p><p style="color:blue;">这些指示了显示如何合并索引合并联接类型的索引扫描的特定算法。见第8.2.1.3节“索引合并优化”。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using temporary</code> (JSON property:
                        <code class="literal">using_temporary_table</code>)
                    </p><p style="color:blue;">使用临时（json属性：使用临时表）</p><p></p><p>
                        To resolve the query, MySQL needs to create a temporary
                        table to hold the result. This typically happens if the
                        query contains <code class="literal">GROUP BY</code> and
                        <code class="literal">ORDER BY</code> clauses that list columns
                        differently.
                    </p><p style="color:blue;">要解析查询，mysql需要创建一个临时表来保存结果。如果查询包含以不同方式列出列的GROUPBY和ORDERBY子句，则通常会发生这种情况。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using where</code> (JSON property:
                        <code class="literal">attached_condition</code>)
                    </p><p style="color:blue;">使用where（json属性：附加条件）</p><p></p><p>
                        A <code class="literal">WHERE</code> clause is used to restrict
                        which rows to match against the next table or send to the
                        client. Unless you specifically intend to fetch or examine
                        all rows from the table, you may have something wrong in
                        your query if the <code class="literal">Extra</code> value is not
                        <code class="literal">Using where</code> and the table join type is
                        <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a> or
                        <a class="link" href="optimization.html#jointype_index"><code class="literal">index</code></a>.
                    </p><p style="color:blue;">where子句用于限制与下一个表匹配或发送到客户端的行。除非您特别打算从表中提取或检查所有行，否则如果额外的值没有使用where，并且表联接类型是all或index，则查询中可能有错误。</p><p></p><p>
                        <code class="literal">Using where</code> has no direct counterpart
                        in JSON-formatted output; the
                        <code class="literal">attached_condition</code> property contains
                        any <code class="literal">WHERE</code> condition used.
                    </p><p style="color:blue;">using where在json格式的输出中没有直接对应项；附加的_condition属性包含使用的任何where条件。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Using where with pushed condition</code> (JSON
                        property: <code class="literal">message</code>)
                    </p><p style="color:blue;">使用where和push条件（json属性：message）</p><p></p><p>
                        This item applies to <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;21&nbsp;MySQL NDB Cluster 7.5 and NDB Cluster 7.6"><code class="literal">NDB</code></a>
                        tables <span class="emphasis"><em>only</em></span>. It means that NDB
                        Cluster is using the Condition Pushdown optimization to
                        improve the efficiency of a direct comparison between a
                        nonindexed column and a constant. In such cases, the
                        condition is <span class="quote">“<span class="quote">pushed down</span>”</span> to the
                        cluster's data nodes and is evaluated on all data
                        nodes simultaneously. This eliminates the need to send
                        nonmatching rows over the network, and can speed up such
                        queries by a factor of 5 to 10 times over cases where
                        Condition Pushdown could be but is not used. For more
                        information, see
                        <a class="xref" href="optimization.html#condition-pushdown-optimization" title="8.2.1.4&nbsp;Engine Condition Pushdown Optimization">Section&nbsp;8.2.1.4, “Engine Condition Pushdown Optimization”</a>.
                    </p><p style="color:blue;">此项仅适用于ndb表。这意味着ndb聚类是利用条件下推优化来提高非索引列与常数直接比较的效率。在这种情况下，条件被“下推”到集群的数据节点，并同时在所有数据节点上求值。这消除了通过网络发送非匹配行的需要，并且可以在条件下推（condition pushdown）可以使用但不使用的情况下，将此类查询的速度提高5到10倍。有关更多信息，请参见第8.2.1.4节“发动机状况下推优化”。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">Zero limit</code> (JSON property:
                        <code class="literal">message</code>)
                    </p><p style="color:blue;">零限制（json属性：消息）</p><p></p><p>
                        The query had a <code class="literal">LIMIT 0</code> clause and
                        cannot select any rows.
                    </p><p style="color:blue;">查询具有LIMIT 0子句，无法选择任何行。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="explain-output-interpretation"></a>EXPLAIN Output Interpretation</h4>

                        </div>

                    </div>

                </div>
                <p>
                    You can get a good indication of how good a join is by taking
                    the product of the values in the <code class="literal">rows</code>
                    column of the <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output.
                    This should tell you roughly how many rows MySQL must examine
                    to execute the query. If you restrict queries with the
                    <a class="link" href="server-administration.html#sysvar_max_join_size"><code class="literal">max_join_size</code></a> system
                    variable, this row product also is used to determine which
                    multiple-table <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                    statements to execute and which to abort. See
                    <a class="xref" href="server-administration.html#server-configuration" title="5.1.1&nbsp;Configuring the Server">Section&nbsp;5.1.1, “Configuring the Server”</a>.
                </p><p style="color:blue;">通过获取explain输出的rows列中的值的乘积，可以很好地指示联接有多好。这应该大致告诉您mysql必须检查多少行才能执行查询。如果使用max_join_size系统变量限制查询，则此行产品还用于确定要执行的多个表select语句和要中止的语句。参见第5.1.1节“配置服务器”。</p><p></p><p>
                The following example shows how a multiple-table join can be
                optimized progressively based on the information provided by
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>.
            </p><p style="color:blue;">下面的示例演示如何根据explain提供的信息逐步优化多表联接。</p><p></p><p>
                Suppose that you have the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement shown here and
                that you plan to examine it using
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>:
            </p><p style="color:blue;">假设这里显示了select语句，并且您计划使用explain检查它：</p><p></p><pre data-lang="sql" class="programlisting">EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
               tt.ProjectReference, tt.EstimatedShipDate,
               tt.ActualShipDate, tt.ClientID,
               tt.ServiceCodes, tt.RepetitiveID,
               tt.CurrentProcess, tt.CurrentDPPerson,
               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
               et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
          AND tt.ActualPC = et.EMPLOYID
          AND tt.AssignedPC = et_1.EMPLOYID
          AND tt.ClientID = do.CUSTNMBR;
</pre><p>
                For this example, make the following assumptions:
            </p><p style="color:blue;">对于此示例，请做出以下假设：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The columns being compared have been declared as follows.
                    </p><p style="color:blue;">正在比较的列声明如下。</p><p></p>
                        <div class="informaltable">
                            <table summary="Table names, column names, and data types for the columns being compared in the EXPLAIN example described in the preceding text."><colgroup><col width="10%"><col width="25%"><col width="25%"></colgroup><thead><tr>
                                <th scope="col">Table</th>
                                <th scope="col">Column</th>
                                <th scope="col">Data Type</th>
                            </tr></thead><tbody><tr>
                                <td scope="row"><code class="literal">tt</code></td>
                                <td><code class="literal">ActualPC</code></td>
                                <td><code class="literal">CHAR(10)</code></td>
                            </tr><tr>
                                <td scope="row"><code class="literal">tt</code></td>
                                <td><code class="literal">AssignedPC</code></td>
                                <td><code class="literal">CHAR(10)</code></td>
                            </tr><tr>
                                <td scope="row"><code class="literal">tt</code></td>
                                <td><code class="literal">ClientID</code></td>
                                <td><code class="literal">CHAR(10)</code></td>
                            </tr><tr>
                                <td scope="row"><code class="literal">et</code></td>
                                <td><code class="literal">EMPLOYID</code></td>
                                <td><code class="literal">CHAR(15)</code></td>
                            </tr><tr>
                                <td scope="row"><code class="literal">do</code></td>
                                <td><code class="literal">CUSTNMBR</code></td>
                                <td><code class="literal">CHAR(15)</code></td>
                            </tr></tbody></table>
                        </div>
                    </li><li class="listitem"><p>
                        The tables have the following indexes.
                    </p><p style="color:blue;">这些表有以下索引。</p><p></p>
                        <div class="informaltable">
                            <table summary="Indexes for each of the tables that are part of the EXPLAIN example described in the preceding text."><colgroup><col width="10%"><col width="40%"></colgroup><thead><tr>
                                <th scope="col">Table</th>
                                <th scope="col">Index</th>
                            </tr></thead><tbody><tr>
                                <td scope="row"><code class="literal">tt</code></td>
                                <td><code class="literal">ActualPC</code></td>
                            </tr><tr>
                                <td scope="row"><code class="literal">tt</code></td>
                                <td><code class="literal">AssignedPC</code></td>
                            </tr><tr>
                                <td scope="row"><code class="literal">tt</code></td>
                                <td><code class="literal">ClientID</code></td>
                            </tr><tr>
                                <td scope="row"><code class="literal">et</code></td>
                                <td><code class="literal">EMPLOYID</code> (primary key)</td>
                            </tr><tr>
                                <td scope="row"><code class="literal">do</code></td>
                                <td><code class="literal">CUSTNMBR</code> (primary key)</td>
                            </tr></tbody></table>
                        </div>
                    </li><li class="listitem"><p>
                        The <code class="literal">tt.ActualPC</code> values are not evenly
                        distributed.
                    </p><p style="color:blue;">tt.actualpc值分布不均匀。</p><p></p></li></ul>
                </div>
                <p>
                    Initially, before any optimizations have been performed, the
                    <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement produces the
                    following information:
                </p><p style="color:blue;">最初，在执行任何优化之前，explain语句会生成以下信息：</p><p></p><pre data-lang="none" class="programlisting">table type possible_keys key  key_len ref  rows  Extra
et    ALL  PRIMARY       NULL NULL    NULL 74
do    ALL  PRIMARY       NULL NULL    NULL 2135
et_1  ALL  PRIMARY       NULL NULL    NULL 74
tt    ALL  AssignedPC,   NULL NULL    NULL 3872
           ClientID,
           ActualPC
      Range checked for each record (index map: 0x23)
</pre><p>
                Because <code class="literal">type</code> is
                <a class="link" href="optimization.html#jointype_all"><code class="literal">ALL</code></a> for each table, this
                output indicates that MySQL is generating a Cartesian product
                of all the tables; that is, every combination of rows. This
                takes quite a long time, because the product of the number of
                rows in each table must be examined. For the case at hand,
                this product is 74 × 2135 × 74 × 3872 =
                45,268,558,720 rows. If the tables were bigger, you can only
                imagine how long it would take.
            </p><p style="color:blue;">因为type是每个表的全部，所以这个输出表明mysql正在生成所有表的笛卡尔积；也就是说，每一行的组合。这需要相当长的时间，因为必须检查每个表中行数的乘积。对于手头的箱子，这个产品是74×2135×74×3872=45268558720行。如果桌子再大一点，你只能想象要花多长时间。</p><p></p><p>
                One problem here is that MySQL can use indexes on columns more
                efficiently if they are declared as the same type and size. In
                this context, <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> and
                <a class="link" href="data-types.html#char" title="11.4.1&nbsp;The CHAR and VARCHAR Types"><code class="literal">CHAR</code></a> are considered the same if
                they are declared as the same size.
                <code class="literal">tt.ActualPC</code> is declared as
                <code class="literal">CHAR(10)</code> and <code class="literal">et.EMPLOYID</code>
                is <code class="literal">CHAR(15)</code>, so there is a length mismatch.
            </p><p style="color:blue;">这里的一个问题是，如果将列声明为相同的类型和大小，mysql可以更有效地对列使用索引。在这个上下文中，如果varchar和char声明为相同的大小，则它们被认为是相同的。tt.actualpc声明为char（10），et.employid声明为char（15），因此长度不匹配。</p><p></p><p>
                To fix this disparity between column lengths, use
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> to lengthen
                <code class="literal">ActualPC</code> from 10 characters to 15
                characters:
            </p><p style="color:blue;">若要修复列长度之间的差异，请使用alter table将actualpc从10个字符延长到15个字符：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY ActualPC VARCHAR(15);</code></strong>
</pre><p>
                Now <code class="literal">tt.ActualPC</code> and
                <code class="literal">et.EMPLOYID</code> are both
                <code class="literal">VARCHAR(15)</code>. Executing the
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement again
                produces this result:
            </p><p style="color:blue;">现在tt.actualpc和et.employid都是varchar（15）。再次执行explain语句将产生以下结果：</p><p></p><pre data-lang="none" class="programlisting">table type   possible_keys key     key_len ref         rows    Extra
tt    ALL    AssignedPC,   NULL    NULL    NULL        3872    Using
             ClientID,                                         where
             ActualPC
do    ALL    PRIMARY       NULL    NULL    NULL        2135
      Range checked for each record (index map: 0x1)
et_1  ALL    PRIMARY       NULL    NULL    NULL        74
      Range checked for each record (index map: 0x1)
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1
</pre><p>
                This is not perfect, but is much better: The product of the
                <code class="literal">rows</code> values is less by a factor of 74. This
                version executes in a couple of seconds.
            </p><p style="color:blue;">这并不完美，但要好得多：行值的乘积小于74。这个版本会在几秒钟内执行。</p><p></p><p>
                A second alteration can be made to eliminate the column length
                mismatches for the <code class="literal">tt.AssignedPC =
                et_1.EMPLOYID</code> and <code class="literal">tt.ClientID =
                do.CUSTNMBR</code> comparisons:
            </p><p style="color:blue;">可以进行第二次更改以消除tt.assignedpc=et_1.employid和tt.clientid=do.custnmbr比较的列长度不匹配：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),</code></strong>
                      <strong class="userinput"><code>MODIFY ClientID   VARCHAR(15);</code></strong>
</pre><p>
                After that modification,
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> produces the output
                shown here:
            </p><p style="color:blue;">修改之后，explain将生成如下所示的输出：</p><p></p><pre data-lang="none" class="programlisting">table type   possible_keys key      key_len ref           rows Extra
et    ALL    PRIMARY       NULL     NULL    NULL          74
tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using
             ClientID,                                         where
             ActualPC
et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1
</pre><p>
                At this point, the query is optimized almost as well as
                possible. The remaining problem is that, by default, MySQL
                assumes that values in the <code class="literal">tt.ActualPC</code>
                column are evenly distributed, and that is not the case for
                the <code class="literal">tt</code> table. Fortunately, it is easy to
                tell MySQL to analyze the key distribution:
            </p><p style="color:blue;">在这一点上，查询几乎是尽可能优化的。剩下的问题是，默认情况下，mysql假设tt.actualpc列中的值是均匀分布的，而tt表则不是这样。幸运的是，让mysql分析密钥分布很容易：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>ANALYZE TABLE tt;</code></strong>
</pre><p>
                With the additional index information, the join is perfect and
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> produces this result:
            </p><p style="color:blue;">使用附加的索引信息，连接是完美的，explain会产生以下结果：</p><p></p><pre data-lang="none" class="programlisting">table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using
             ClientID,                                        where
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1
</pre><p>
                <a class="indexterm" name="idm140286870958816"></a>

                The <code class="literal">rows</code> column in the output from
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is an educated guess
                from the MySQL join optimizer. Check whether the numbers are
                even close to the truth by comparing the
                <code class="literal">rows</code> product with the actual number of rows
                that the query returns. If the numbers are quite different,
                you might get better performance by using
                <code class="literal">STRAIGHT_JOIN</code> in your
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement and trying to
                list the tables in a different order in the
                <code class="literal">FROM</code> clause. (However,
                <code class="literal">STRAIGHT_JOIN</code> may prevent indexes from
                being used because it disables semijoin transformations. See
                <a class="xref" href="optimization.html#semijoins" title="8.2.2.1&nbsp;Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations">Section&nbsp;8.2.2.1, “Optimizing Subqueries, Derived Tables, and View References with Semijoin
                    Transformations”</a>.)
            </p><p style="color:blue;">explain输出中的rows列是来自mysql连接优化器的推测。通过将rows乘积与查询返回的实际行数进行比较，检查这些数字是否甚至接近真实值。如果数字相差很大，则可以在select语句中使用直接连接并尝试在from子句中按不同顺序列出表，从而获得更好的性能。（但是，直连接可能会阻止使用索引，因为它禁用半连接转换。参见第8.2.2.1节，“使用半联接转换优化子查询、派生表和视图引用”。</p><p></p><p>
                It is possible in some cases to execute statements that modify
                data when <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                SELECT</code></a> is used with a subquery; for more
                information, see <a class="xref" href="sql-syntax.html#derived-tables" title="13.2.10.8&nbsp;Derived Tables">Section&nbsp;13.2.10.8, “Derived Tables”</a>.
            </p><p style="color:blue;">在某些情况下，当explain select与子查询一起使用时，可以执行修改数据的语句；有关更多信息，请参阅第13.2.10.8节“派生表”。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="explain-extended"></a>8.8.3&nbsp;Extended EXPLAIN Output Format</h3>

                    </div>

                </div>

            </div>
            <p>
                For <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements, the
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> statement produces extra
                (<span class="quote">“<span class="quote">extended</span>”</span>) information that is not part of
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output but can be viewed
                by issuing a <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a>
                statement following <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>. The
                <code class="literal">Message</code> value in <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                WARNINGS</code></a> output displays how the optimizer qualifies
                table and column names in the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement, what the
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> looks like after the
                application of rewriting and optimization rules, and possibly
                other notes about the optimization process.
            </p><p style="color:blue;">对于select语句，explain语句生成额外的（“扩展”）信息，这些信息不是explain输出的一部分，但是可以通过在explain之后发出show warnings语句来查看。show warnings output中的消息值显示优化器如何限定select语句中的表名和列名，应用重写和优化规则后select的外观，以及可能的有关优化过程的其他注释。</p><p></p><p>
            The extended information displayable with a
            <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> statement following
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> is produced only for
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements.
            <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> displays an empty
            result for other explainable statements
            (<a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, and
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>).
        </p><p style="color:blue;">explain后面的show warnings语句显示的扩展信息只为select语句生成。show warnings显示其他可解释语句（delete、insert、replace和update）的空结果。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    In older MySQL releases, extended information was produced
                    using <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN
                    EXTENDED</code></a>. That syntax is still recognized for
                    backward compatibility but extended output is now enabled by
                    default, so the <code class="literal">EXTENDED</code> keyword is
                    superfluous and deprecated. Its use results in a warning, and
                    it will be removed from <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>
                    syntax in a future MySQL release.
                </p><p style="color:blue;">在旧的mysql版本中，扩展信息是使用explain extended生成的。由于向后兼容，仍然可以识别该语法，但现在默认情况下已启用扩展输出，因此扩展关键字是多余的，已弃用。它的使用会导致一个警告，在以后的mysql版本中，它将从explain语法中删除。</p><p></p>
            </div>
            <p>
                Here is an example of extended
                <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output:
            </p><p style="color:blue;">下面是扩展解释输出的一个示例：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN</code></strong>
       <strong class="userinput"><code>SELECT t1.a, t1.a IN (SELECT t2.a FROM t2) FROM t1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
         type: index
possible_keys: NULL
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 4
     filtered: 100.00
        Extra: Using index
*************************** 2. row ***************************
           id: 2
  select_type: SUBQUERY
        table: t2
         type: index
possible_keys: a
          key: a
      key_len: 5
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using index
2 rows in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `test`.`t1`.`a` AS `a`,
         &lt;in_optimizer&gt;(`test`.`t1`.`a`,`test`.`t1`.`a` in
         ( &lt;materialize&gt; (/* select#2 */ select `test`.`t2`.`a`
         from `test`.`t2` where 1 having 1 ),
         &lt;primary_index_lookup&gt;(`test`.`t1`.`a` in
         &lt;temporary table&gt; on &lt;auto_key&gt;
         where ((`test`.`t1`.`a` = `materialized-subquery`.`a`))))) AS `t1.a
         IN (SELECT t2.a FROM t2)` from `test`.`t1`
1 row in set (0.00 sec)
</pre><p>
            Because the statement displayed by <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
            WARNINGS</code></a> may contain special markers to provide
            information about query rewriting or optimizer actions, the
            statement is not necessarily valid SQL and is not intended to be
            executed. The output may also include rows with
            <code class="literal">Message</code> values that provide additional
            non-SQL explanatory notes about actions taken by the optimizer.
        </p><p style="color:blue;">由于show warnings显示的语句可能包含特殊标记，以提供有关查询重写或优化器操作的信息，因此该语句不一定是有效的sql，也不打算执行。输出还可以包括带有消息值的行，这些消息值提供了有关优化器所采取的操作的附加非sql注释。</p><p></p><p>
            The following list describes special markers that can appear in
            the extended output displayed by <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
            WARNINGS</code></a>:
        </p><p style="color:blue;">下面的列表描述了可以显示在“显示警告”显示的扩展输出中的特殊标记：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">&lt;auto_key&gt;</code>
                </p><p style="color:blue;">&lt;自动键&gt;</p><p></p><p>
                    An automatically generated key for a temporary table.
                </p><p style="color:blue;">为临时表自动生成的键。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;cache&gt;(<em class="replaceable"><code>expr</code></em>)</code>
                </p><p style="color:blue;"><cache>（表达式）</cache></p><p></p><p>
                    The expression (such as a scalar subquery) is executed once
                    and the resulting value is saved in memory for later use.
                    For results consisting of multiple values, a temporary table
                    may be created and you will see <code class="literal">&lt;temporary
                    table&gt;</code> instead.
                </p><p style="color:blue;">表达式（例如标量子查询）执行一次，结果值保存在内存中以供以后使用。对于包含多个值的结果，可能会创建一个临时表，您将看到<temporary table="">。</temporary></p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;exists&gt;(<em class="replaceable"><code>query
                        fragment</code></em>)</code>
                </p><p style="color:blue;"><exists>（查询片段）</exists></p><p></p><p>
                    The subquery predicate is converted to an
                    <code class="literal">EXISTS</code> predicate and the subquery is
                    transformed so that it can be used together with the
                    <code class="literal">EXISTS</code> predicate.
                </p><p style="color:blue;">子查询谓词被转换为exists谓词，子查询被转换为可以与exists谓词一起使用。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;in_optimizer&gt;(<em class="replaceable"><code>query
                        fragment</code></em>)</code>
                </p><p style="color:blue;"><in_optimizer>（查询片段）</in_optimizer></p><p></p><p>
                    This is an internal optimizer object with no user
                    significance.
                </p><p style="color:blue;">这是一个没有用户意义的内部优化器对象。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;index_lookup&gt;(<em class="replaceable"><code>query
                        fragment</code></em>)</code>
                </p><p style="color:blue;"><index_lookup>（查询片段）</index_lookup></p><p></p><p>
                    The query fragment is processed using an index lookup to
                    find qualifying rows.
                </p><p style="color:blue;">使用索引查找查找符合条件的行来处理查询片段。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;if&gt;(<em class="replaceable"><code>condition</code></em>,
                        <em class="replaceable"><code>expr1</code></em>,
                        <em class="replaceable"><code>expr2</code></em>)</code>
                </p><p style="color:blue;"><if>（条件，expr1，expr2）</if></p><p></p><p>
                    If the condition is true, evaluate to
                    <em class="replaceable"><code>expr1</code></em>, otherwise
                    <em class="replaceable"><code>expr2</code></em>.
                </p><p style="color:blue;">如果条件为true，则计算为expr1，否则为expr2。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;is_not_null_test&gt;(<em class="replaceable"><code>expr</code></em>)</code>
                </p><p style="color:blue;"><is_not_null_test>（表达式）</is_not_null_test></p><p></p><p>
                    A test to verify that the expression does not evaluate to
                    <code class="literal">NULL</code>.
                </p><p style="color:blue;">验证表达式的计算结果是否为空的测试。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;materialize&gt;(<em class="replaceable"><code>query
                        fragment</code></em>)</code>
                </p><p style="color:blue;"><materialize>（查询片段）</materialize></p><p></p><p>
                    Subquery materialization is used.
                </p><p style="color:blue;">使用子查询物化。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">`materialized-subquery`.<em class="replaceable"><code>col_name</code></em></code>
                </p><p style="color:blue;">`物化子查询`.col_name</p><p></p><p>
                    A reference to the column
                    <em class="replaceable"><code>col_name</code></em> in an internal temporary
                    table materialized to hold the result from evaluating a
                    subquery.
                </p><p style="color:blue;">对内部临时表中列col_name的引用具体化，以保存计算子查询的结果。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;primary_index_lookup&gt;(<em class="replaceable"><code>query
                        fragment</code></em>)</code>
                </p><p style="color:blue;"><primary_index_lookup>（查询片段）</primary_index_lookup></p><p></p><p>
                    The query fragment is processed using a primary key lookup
                    to find qualifying rows.
                </p><p style="color:blue;">查询片段使用主键查找来查找符合条件的行。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;ref_null_helper&gt;(<em class="replaceable"><code>expr</code></em>)</code>
                </p><p style="color:blue;"><ref_null_helper>（表达式）</ref_null_helper></p><p></p><p>
                    This is an internal optimizer object with no user
                    significance.
                </p><p style="color:blue;">这是一个没有用户意义的内部优化器对象。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">/* select#<em class="replaceable"><code>N</code></em> */
                        <em class="replaceable"><code>select_stmt</code></em></code>
                </p><p style="color:blue;">/*选择n*/选择stmt</p><p></p><p>
                    The <code class="literal">SELECT</code> is associated with the row in
                    non-extended <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> output
                    that has an <code class="literal">id</code> value of
                    <em class="replaceable"><code>N</code></em>.
                </p><p style="color:blue;">select与非扩展解释输出中id值为n的行相关联。</p><p></p></li><li class="listitem"><p>
                    <code class="literal"><em class="replaceable"><code>outer_tables</code></em> semi join
                        (<em class="replaceable"><code>inner_tables</code></em>)</code>
                </p><p style="color:blue;">外表半联接（内表）</p><p></p><p>
                    A semijoin operation.
                    <em class="replaceable"><code>inner_tables</code></em> shows the tables
                    that were not pulled out. See <a class="xref" href="optimization.html#semijoins" title="8.2.2.1&nbsp;Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations">Section&nbsp;8.2.2.1, “Optimizing Subqueries, Derived Tables, and View References with Semijoin
                    Transformations”</a>.
                </p><p style="color:blue;">半连接操作。内表显示未拉出的表。参见第8.2.2.1节，“使用半联接转换优化子查询、派生表和视图引用”。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">&lt;temporary table&gt;</code>
                </p><p style="color:blue;">&lt;临时表&gt;</p><p></p><p>
                    This represents an internal temporary table created to cache
                    an intermediate result.
                </p><p style="color:blue;">这表示为缓存中间结果而创建的内部临时表。</p><p></p></li></ul>
            </div>
            <p>
                When some tables are of <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a>
                or <a class="link" href="optimization.html#jointype_system"><code class="literal">system</code></a> type, expressions
                involving columns from these tables are evaluated early by the
                optimizer and are not part of the displayed statement. However,
                with <code class="literal">FORMAT=JSON</code>, some
                <a class="link" href="optimization.html#jointype_const"><code class="literal">const</code></a> table accesses are
                displayed as a <a class="link" href="optimization.html#jointype_ref"><code class="literal">ref</code></a> access
                that uses a const value.
            </p><p style="color:blue;">当某些表是const或system类型时，优化器会在早期计算涉及这些表中的列的表达式，而这些表达式不是所显示语句的一部分。但是，对于format=json，某些const表访问显示为使用const值的ref访问。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="explain-for-connection"></a>8.8.4&nbsp;Obtaining Execution Plan Information for a Named Connection</h3>

                    </div>

                </div>

            </div>
            <p>
                To obtain the execution plan for an explainable statement
                executing in a named connection, use this statement:
            </p><p style="color:blue;">要获取在命名连接中执行的可解释语句的执行计划，请使用以下语句：</p><p></p><pre data-lang="sql" class="programlisting">EXPLAIN [<em class="replaceable"><code>options</code></em>] FOR CONNECTION <em class="replaceable"><code>connection_id</code></em>;
</pre><p>
            <a class="link" href="optimization.html#explain-for-connection" title="8.8.4&nbsp;Obtaining Execution Plan Information for a Named Connection"><code class="literal">EXPLAIN FOR CONNECTION</code></a> returns
            the <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> information that is
            currently being used to execute a query in a given connection.
            Because of changes to data (and supporting statistics) it may
            produce a different result from running
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> on the equivalent query
            text. This difference in behavior can be useful in diagnosing
            more transient performance problems. For example, if you are
            running a statement in one session that is taking a long time to
            complete, using <a class="link" href="optimization.html#explain-for-connection" title="8.8.4&nbsp;Obtaining Execution Plan Information for a Named Connection"><code class="literal">EXPLAIN FOR
            CONNECTION</code></a> in another session may yield useful
            information about the cause of the delay.
        </p><p style="color:blue;">explain for connection返回当前用于在给定连接中执行查询的explain信息。由于对数据（和支持统计信息）的更改，它可能会产生与对等效查询文本运行explain不同的结果。这种行为上的差异可以帮助诊断更多的瞬态性能问题。例如，如果您在一个会话中运行的语句需要很长时间才能完成，则在另一个会话中使用explain for connection可能会生成有关延迟原因的有用信息。</p><p></p><p>
            <em class="replaceable"><code>connection_id</code></em> is the connection
            identifier, as obtained from the
            <code class="literal">INFORMATION_SCHEMA</code>
            <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> table or the
            <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> statement. If
            you have the <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a> privilege,
            you can specify the identifier for any connection. Otherwise,
            you can specify the identifier only for your own connections.
        </p><p style="color:blue;">connection_id是从information_schema processlist表或show processlist语句获得的连接标识符。如果您具有进程特权，则可以为任何连接指定标识符。否则，只能为自己的连接指定标识符。</p><p></p><p>
            If the named connection is not executing a statement, the result
            is empty. Otherwise, <code class="literal">EXPLAIN FOR CONNECTION</code>
            applies only if the statement being executed in the named
            connection is explainable. This includes
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
            <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
            <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, and
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>. (However,
            <code class="literal">EXPLAIN FOR CONNECTION</code> does not work for
            prepared statements, even prepared statements of those types.)
        </p><p style="color:blue;">如果命名连接没有执行语句，则结果为空。否则，explain for connection仅在命名连接中执行的语句是可解释的时才适用。这包括选择、删除、插入、替换和更新。（但是，explain for connection不适用于准备好的语句，甚至不适用于那些类型的准备好的语句。）</p><p></p><p>
            If the named connection is executing an explainable statement,
            the output is what you would obtain by using
            <code class="literal">EXPLAIN</code> on the statement itself.
        </p><p style="color:blue;">如果指定的连接正在执行一个可解释的语句，则输出是通过对语句本身使用explain可以获得的结果。</p><p></p><p>
            If the named connection is executing a statement that is not
            explainable, an error occurs. For example, you cannot name the
            connection identifier for your current session because
            <code class="literal">EXPLAIN</code> is not explainable:
        </p><p style="color:blue;">如果命名连接正在执行无法解释的语句，则会发生错误。例如，无法为当前会话命名连接标识符，因为无法解释解释：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT CONNECTION_ID();</code></strong>
+-----------------+
| CONNECTION_ID() |
+-----------------+
|             373 |
+-----------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN FOR CONNECTION 373;</code></strong>
ERROR 1889 (HY000): EXPLAIN FOR CONNECTION command is supported
only for SELECT/UPDATE/INSERT/DELETE/REPLACE
</pre><p>
            The <code class="literal">Com_explain_other</code> status variable
            indicates the number of
            <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN FOR
                CONNECTION</code></a> statements executed.
        </p><p style="color:blue;">com_explain_other status变量表示执行的连接语句的explain数。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="estimating-performance"></a>8.8.5&nbsp;Estimating Query Performance</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286870827072"></a><a class="indexterm" name="idm140286870825616"></a><a class="indexterm" name="idm140286870824128"></a><p>
            In most cases, you can estimate query performance by counting
            disk seeks. For small tables, you can usually find a row in one
            disk seek (because the index is probably cached). For bigger
            tables, you can estimate that, using B-tree indexes, you need
            this many seeks to find a row:
            <code class="literal">log(<em class="replaceable"><code>row_count</code></em>) /
                log(<em class="replaceable"><code>index_block_length</code></em> / 3 * 2 /
                (<em class="replaceable"><code>index_length</code></em> +
                <em class="replaceable"><code>data_pointer_length</code></em>)) + 1</code>.
        </p><p style="color:blue;">在大多数情况下，可以通过计算磁盘查找数来估计查询性能。对于小表，通常可以在一个磁盘搜索中找到一行（因为索引可能已缓存）。对于更大的表，您可以估计，使用B-树索引，您需要这么多查找行：log（row_count）/log（index_block_length/3*2/（index_length+data_pointer_length））+1。</p><p></p><p>
            In MySQL, an index block is usually 1,024 bytes and the data
            pointer is usually four bytes. For a 500,000-row table with a
            key value length of three bytes (the size of
            <a class="link" href="data-types.html#integer-types" title="11.2.1&nbsp;Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT"><code class="literal">MEDIUMINT</code></a>), the formula indicates
            <code class="literal">log(500,000)/log(1024/3*2/(3+4)) + 1</code> =
            <code class="literal">4</code> seeks.
        </p><p style="color:blue;">在mysql中，索引块通常是1024字节，数据指针通常是4字节。对于键值长度为3字节（mediumint大小）的500000行表，公式指示log（500000）/log（1024/3*2/（3+4））+1=4 seeks。</p><p></p><p>
            This index would require storage of about 500,000 * 7 * 3/2 =
            5.2MB (assuming a typical index buffer fill ratio of 2/3), so
            you probably have much of the index in memory and so need only
            one or two calls to read data to find the row.
        </p><p style="color:blue;">这个索引需要大约500000*7*3/2=5.2MB的存储空间（假设典型的索引缓冲区填充率为2/3），所以您可能有很多索引在内存中，因此只需要一个或两个调用来读取数据以查找行。</p><p></p><p>
            For writes, however, you need four seek requests to find where
            to place a new index value and normally two seeks to update the
            index and write the row.
        </p><p style="color:blue;">但是，对于写操作，您需要四个seek请求来找到放置新索引值的位置，通常需要两个seek请求来更新索引并写入行。</p><p></p><p>
            The preceding discussion does not mean that your application
            performance slowly degenerates by log
            <em class="replaceable"><code>N</code></em>. As long as everything is cached by
            the OS or the MySQL server, things become only marginally slower
            as the table gets bigger. After the data gets too big to be
            cached, things start to go much slower until your applications
            are bound only by disk seeks (which increase by log
            <em class="replaceable"><code>N</code></em>). To avoid this, increase the key
            cache size as the data grows. For <code class="literal">MyISAM</code>
            tables, the key cache size is controlled by the
            <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> system
            variable. See <a class="xref" href="server-administration.html#server-configuration" title="5.1.1&nbsp;Configuring the Server">Section&nbsp;5.1.1, “Configuring the Server”</a>.
        </p><p style="color:blue;">前面的讨论并不意味着您的应用程序性能会因日志n而缓慢下降。只要操作系统或mysql服务器缓存了所有内容，当表变大时，速度只会稍微慢一点。当数据变得太大而无法缓存时，事情开始变得慢得多，直到应用程序只被磁盘搜索绑定（日志n增加了磁盘搜索）。为了避免这种情况，请随着数据的增长增加密钥缓存的大小。对于myisam表，键缓存大小由key_buffer_size系统变量控制。参见第5.1.1节“配置服务器”。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="controlling-optimizer"></a>8.9&nbsp;Controlling the Query Optimizer</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#controlling-query-plan-evaluation">8.9.1 Controlling Query Plan Evaluation</a></span></dt><dt><span class="section"><a href="optimization.html#switchable-optimizations">8.9.2 Switchable Optimizations</a></span></dt><dt><span class="section"><a href="optimization.html#optimizer-hints">8.9.3 Optimizer Hints</a></span></dt><dt><span class="section"><a href="optimization.html#index-hints">8.9.4 Index Hints</a></span></dt><dt><span class="section"><a href="optimization.html#cost-model">8.9.5 The Optimizer Cost Model</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286870808992"></a><p>
        MySQL provides optimizer control through system variables that
        affect how query plans are evaluated, switchable optimizations,
        optimizer and index hints, and the optimizer cost model.
    </p><p style="color:blue;">mysql通过影响查询计划评估方式的系统变量、可切换的优化、优化器和索引提示以及优化器成本模型提供优化器控制。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="controlling-query-plan-evaluation"></a>8.9.1&nbsp;Controlling Query Plan Evaluation</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286870805728"></a><p>
            The task of the query optimizer is to find an optimal plan for
            executing an SQL query. Because the difference in performance
            between <span class="quote">“<span class="quote">good</span>”</span> and <span class="quote">“<span class="quote">bad</span>”</span> plans can be
            orders of magnitude (that is, seconds versus hours or even
            days), most query optimizers, including that of MySQL, perform a
            more or less exhaustive search for an optimal plan among all
            possible query evaluation plans. For join queries, the number of
            possible plans investigated by the MySQL optimizer grows
            exponentially with the number of tables referenced in a query.
            For small numbers of tables (typically less than 7 to 10) this
            is not a problem. However, when larger queries are submitted,
            the time spent in query optimization may easily become the major
            bottleneck in the server's performance.
        </p><p style="color:blue;">查询优化器的任务是找到执行sql查询的最佳计划。由于“好的”和“坏的”计划之间的性能差异可能是数量级的（即秒与小时甚至天），因此大多数查询优化器（包括mysql的查询优化器）或多或少都会在所有可能的查询评估计划中执行一次详尽的搜索，以寻找最佳计划。对于连接查询，mysql优化器调查的可能计划数随着查询中引用的表数呈指数增长。对于少量的表（通常小于7到10个表），这不是问题。然而，当提交更大的查询时，查询优化所花费的时间很容易成为服务器性能的主要瓶颈。</p><p></p><p>
            A more flexible method for query optimization enables the user
            to control how exhaustive the optimizer is in its search for an
            optimal query evaluation plan. The general idea is that the
            fewer plans that are investigated by the optimizer, the less
            time it spends in compiling a query. On the other hand, because
            the optimizer skips some plans, it may miss finding an optimal
            plan.
        </p><p style="color:blue;">一种更灵活的查询优化方法使用户能够控制优化器在搜索最优查询评估计划时的穷尽性。一般的想法是，优化器调查的计划越少，它在编译查询上花费的时间就越少。另一方面，由于优化器跳过了一些计划，它可能会错过寻找最佳计划的机会。</p><p></p><p>
            The behavior of the optimizer with respect to the number of
            plans it evaluates can be controlled using two system variables:
        </p><p style="color:blue;">优化器相对于其评估的计划数的行为可以使用两个系统变量进行控制：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The <a class="link" href="server-administration.html#sysvar_optimizer_prune_level"><code class="literal">optimizer_prune_level</code></a>
                    variable tells the optimizer to skip certain plans based on
                    estimates of the number of rows accessed for each table. Our
                    experience shows that this kind of <span class="quote">“<span class="quote">educated
            guess</span>”</span> rarely misses optimal plans, and may
                    dramatically reduce query compilation times. That is why
                    this option is on
                    (<code class="literal">optimizer_prune_level=1</code>) by default.
                    However, if you believe that the optimizer missed a better
                    query plan, this option can be switched off
                    (<code class="literal">optimizer_prune_level=0</code>) with the risk
                    that query compilation may take much longer. Note that, even
                    with the use of this heuristic, the optimizer still explores
                    a roughly exponential number of plans.
                </p><p style="color:blue;">optimizer_prune_level变量告诉优化器根据对每个表访问的行数的估计跳过某些计划。我们的经验表明，这种“有根据的猜测”很少会错过最佳计划，而且可能会大大减少查询编译时间。这就是为什么默认情况下此选项处于启用状态（优化器修剪级别=1）。但是，如果您认为优化器错过了一个更好的查询计划，则可以关闭此选项（优化器修剪级别=0），这样可能会导致查询编译花费更长的时间。请注意，即使使用了这种启发式方法，优化器仍然会探索大致呈指数级的计划数。</p><p></p></li><li class="listitem"><p>
                    The <a class="link" href="server-administration.html#sysvar_optimizer_search_depth"><code class="literal">optimizer_search_depth</code></a>
                    variable tells how far into the <span class="quote">“<span class="quote">future</span>”</span> of
                    each incomplete plan the optimizer should look to evaluate
                    whether it should be expanded further. Smaller values of
                    <a class="link" href="server-administration.html#sysvar_optimizer_search_depth"><code class="literal">optimizer_search_depth</code></a> may
                    result in orders of magnitude smaller query compilation
                    times. For example, queries with 12, 13, or more tables may
                    easily require hours and even days to compile if
                    <a class="link" href="server-administration.html#sysvar_optimizer_search_depth"><code class="literal">optimizer_search_depth</code></a> is
                    close to the number of tables in the query. At the same
                    time, if compiled with
                    <a class="link" href="server-administration.html#sysvar_optimizer_search_depth"><code class="literal">optimizer_search_depth</code></a>
                    equal to 3 or 4, the optimizer may compile in less than a
                    minute for the same query. If you are unsure of what a
                    reasonable value is for
                    <a class="link" href="server-administration.html#sysvar_optimizer_search_depth"><code class="literal">optimizer_search_depth</code></a>,
                    this variable can be set to 0 to tell the optimizer to
                    determine the value automatically.
                </p><p style="color:blue;">optimizer_search_depth变量告诉优化器应该观察每个不完整计划的“未来”多远，以评估是否应该进一步扩展它。优化器搜索深度的值越小，查询编译时间就越短。例如，如果优化器搜索深度接近查询中的表数，则使用12、13或更多表的查询可能很容易需要数小时甚至数天来编译。同时，如果使用等于3或4的optimizer_search_depth进行编译，优化器可以在不到一分钟的时间内为同一查询进行编译。如果不确定优化器搜索深度的合理值，可以将此变量设置为0，以告诉优化器自动确定该值。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="switchable-optimizations"></a>8.9.2&nbsp;Switchable Optimizations</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286870786064"></a><a class="indexterm" name="idm140286870784976"></a><p>
            The <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
            variable enables control over optimizer behavior. Its value is a
            set of flags, each of which has a value of <code class="literal">on</code>
            or <code class="literal">off</code> to indicate whether the corresponding
            optimizer behavior is enabled or disabled. This variable has
            global and session values and can be changed at runtime. The
            global default can be set at server startup.
        </p><p style="color:blue;">optimizer_switch系统变量启用对优化器行为的控制。它的值是一组标志，每个标志的值都是on或off，以指示相应的优化器行为是启用还是禁用。此变量具有全局值和会话值，可以在运行时更改。全局默认值可以在服务器启动时设置。</p><p></p><p>
            To see the current set of optimizer flags, select the variable
            value:
        </p><p style="color:blue;">要查看当前优化器标志集，请选择变量值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch\G</code></strong>
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=on,
                    index_merge_sort_union=on,
                    index_merge_intersection=on,
                    engine_condition_pushdown=on,
                    index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,
                    block_nested_loop=on,batched_key_access=off,
                    materialization=on,semijoin=on,loosescan=on,
                    firstmatch=on,duplicateweedout=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on,
                    condition_fanout_filter=on,derived_merge=on
</pre><p>
            To change the value of
            <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a>, assign a
            value consisting of a comma-separated list of one or more
            commands:
        </p><p style="color:blue;">要更改优化器开关的值，请指定一个由一个或多个命令的逗号分隔列表组成的值：</p><p></p><pre data-lang="sql" class="programlisting">SET [GLOBAL|SESSION] optimizer_switch='<em class="replaceable"><code>command</code></em>[,<em class="replaceable"><code>command</code></em>]...';
</pre><p>
            Each <em class="replaceable"><code>command</code></em> value should have one of
            the forms shown in the following table.
        </p><p style="color:blue;">每个命令值都应具有下表中所示的一种形式。</p><p></p>
            <div class="informaltable">
                <table summary="The syntax of the command value for SET optimizer_switch commands."><colgroup><col width="25%"><col width="75%"></colgroup><thead><tr>
                    <th scope="col">Command Syntax</th>
                    <th scope="col">Meaning</th>
                </tr></thead><tbody><tr>
                    <td scope="row"><code class="literal">default</code></td>
                    <td>Reset every optimization to its default value</td>
                </tr><tr>
                    <td scope="row"><code class="literal"><em class="replaceable"><code>opt_name</code></em>=default</code></td>
                    <td>Set the named optimization to its default value</td>
                </tr><tr>
                    <td scope="row"><code class="literal"><em class="replaceable"><code>opt_name</code></em>=off</code></td>
                    <td>Disable the named optimization</td>
                </tr><tr>
                    <td scope="row"><code class="literal"><em class="replaceable"><code>opt_name</code></em>=on</code></td>
                    <td>Enable the named optimization</td>
                </tr></tbody></table>
            </div>
            <p>
                The order of the commands in the value does not matter, although
                the <code class="literal">default</code> command is executed first if
                present. Setting an <em class="replaceable"><code>opt_name</code></em> flag to
                <code class="literal">default</code> sets it to whichever of
                <code class="literal">on</code> or <code class="literal">off</code> is its default
                value. Specifying any given <em class="replaceable"><code>opt_name</code></em>
                more than once in the value is not permitted and causes an
                error. Any errors in the value cause the assignment to fail with
                an error, leaving the value of
                <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> unchanged.
            </p><p style="color:blue;">值中命令的顺序无关紧要，尽管默认命令在出现时首先执行。将opt_name标志设置为默认值会将其设置为默认值的“开”或“关”。不允许在值中多次指定任何给定的opt_名称，并会导致错误。值中的任何错误都会导致赋值失败并返回错误，从而使优化器开关的值保持不变。</p><p></p><p>
            The following list describes the permissible
            <em class="replaceable"><code>opt_name</code></em> flag names, grouped by
            optimization strategy:
        </p><p style="color:blue;">以下列表描述了按优化策略分组的允许的opt_name标志名称：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Batched Key Access Flags
                </p><p style="color:blue;">批处理密钥访问标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">batched_key_access</code> (default
                            <code class="literal">off</code>)
                        </p><p style="color:blue;">成批密钥访问（默认关闭）</p><p></p><p>
                            Controls use of BKA join algorithm.
                        </p><p style="color:blue;">控制BKA连接算法的使用。</p><p></p></li></ul>
                    </div>
                    <p>
                        For <code class="literal">batched_key_access</code> to have any effect
                        when set to <code class="literal">on</code>, the
                        <code class="literal">mrr</code> flag must also be
                        <code class="literal">on</code>. Currently, the cost estimation for
                        MRR is too pessimistic. Hence, it is also necessary for
                        <code class="literal">mrr_cost_based</code> to be
                        <code class="literal">off</code> for BKA to be used.
                    </p><p style="color:blue;">要使批处理密钥访问在设置为“开”时生效，mrr标志也必须为“开”。目前，mrr的成本估算过于悲观。因此，也有必要关闭基于mrr_的成本_，以便使用bka。</p><p></p><p>
                        For more information, see
                        <a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.11&nbsp;Block Nested-Loop and Batched Key Access Joins">Section&nbsp;8.2.1.11, “Block Nested-Loop and Batched Key Access Joins”</a>.
                    </p><p style="color:blue;">有关详细信息，请参阅第8.2.1.11节“块嵌套循环和批处理密钥访问联接”。</p><p></p></li><li class="listitem"><p>
                    Block Nested-Loop Flags
                </p><p style="color:blue;">块嵌套循环标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">block_nested_loop</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">块嵌套循环（默认为打开）</p><p></p><p>
                            Controls use of BNL join algorithm.
                        </p><p style="color:blue;">控制BNL联接算法的使用。</p><p></p></li></ul>
                    </div>
                    <p>
                        For more information, see
                        <a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.11&nbsp;Block Nested-Loop and Batched Key Access Joins">Section&nbsp;8.2.1.11, “Block Nested-Loop and Batched Key Access Joins”</a>.
                    </p><p style="color:blue;">有关详细信息，请参阅第8.2.1.11节“块嵌套循环和批处理密钥访问联接”。</p><p></p></li><li class="listitem"><p>
                    Condition Filtering Flags
                </p><p style="color:blue;">条件筛选标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">condition_fanout_filter</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">条件扇出过滤器（默认打开）</p><p></p><p>
                            Controls use of condition filtering.
                        </p><p style="color:blue;">控制条件筛选的使用。</p><p></p></li></ul>
                    </div>
                    <p>
                        For more information, see
                        <a class="xref" href="optimization.html#condition-filtering" title="8.2.1.12&nbsp;Condition Filtering">Section&nbsp;8.2.1.12, “Condition Filtering”</a>.
                    </p><p style="color:blue;">有关更多信息，请参见第8.2.1.12节“条件过滤”。</p><p></p></li><li class="listitem"><p>
                    Derived Table Merging Flags
                </p><p style="color:blue;">派生表合并标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">derived_merge</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">派生合并（默认打开）</p><p></p><p>
                            Controls merging of derived tables and views into outer
                            query block.
                        </p><p style="color:blue;">控制将派生表和视图合并到外部查询块中。</p><p></p></li></ul>
                    </div>
                    <p>
                        The <code class="literal">derived_merge</code> flag controls whether
                        the optimizer attempts to merge derived tables and view
                        references into the outer query block, assuming that no
                        other rule prevents merging; for example, an
                        <code class="literal">ALGORITHM</code> directive for a view takes
                        precedence over the <code class="literal">derived_merge</code>
                        setting. By default, the flag is <code class="literal">on</code> to
                        enable merging.
                    </p><p style="color:blue;">派生合并标志控制优化器是否尝试将派生表和视图引用合并到外部查询块中，前提是没有其他规则阻止合并；例如，视图的算法指令优先于派生合并设置。默认情况下，标志处于启用状态以启用合并。</p><p></p><p>
                        For more information, see
                        <a class="xref" href="optimization.html#derived-table-optimization" title="8.2.2.4&nbsp;Optimizing Derived Tables and View References with Merging or Materialization">Section&nbsp;8.2.2.4, “Optimizing Derived Tables and View References with Merging or
                            Materialization”</a>.
                    </p><p style="color:blue;">有关详细信息，请参阅第8.2.2.4节“使用合并或物化优化派生表和视图引用”。</p><p></p></li><li class="listitem"><p>
                    Engine Condition Pushdown Flags
                </p><p style="color:blue;">发动机状况下推标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">engine_condition_pushdown</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">发动机状况下推（默认打开）</p><p></p><p>
                            Controls engine condition pushdown.
                        </p><p style="color:blue;">控制发动机状况下推。</p><p></p></li></ul>
                    </div>
                    <p>
                        For more information, see
                        <a class="xref" href="optimization.html#condition-pushdown-optimization" title="8.2.1.4&nbsp;Engine Condition Pushdown Optimization">Section&nbsp;8.2.1.4, “Engine Condition Pushdown Optimization”</a>.
                    </p><p style="color:blue;">有关更多信息，请参见第8.2.1.4节“发动机状况下推优化”。</p><p></p></li><li class="listitem"><p>
                    Index Condition Pushdown Flags
                </p><p style="color:blue;">索引条件下推标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">index_condition_pushdown</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">索引条件下推（默认打开）</p><p></p><p>
                            Controls index condition pushdown.
                        </p><p style="color:blue;">控制索引条件下推。</p><p></p></li></ul>
                    </div>
                    <p>
                        For more information, see
                        <a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.5&nbsp;Index Condition Pushdown Optimization">Section&nbsp;8.2.1.5, “Index Condition Pushdown Optimization”</a>.
                    </p><p style="color:blue;">有关详细信息，请参见第8.2.1.5节“索引条件下推优化”。</p><p></p></li><li class="listitem"><p>
                    Index Extensions Flags
                </p><p style="color:blue;">索引扩展标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">use_index_extensions</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">使用索引扩展（默认打开）</p><p></p><p>
                            Controls use of index extensions.
                        </p><p style="color:blue;">控制索引扩展的使用。</p><p></p></li></ul>
                    </div>
                    <p>
                        For more information, see
                        <a class="xref" href="optimization.html#index-extensions" title="8.3.9&nbsp;Use of Index Extensions">Section&nbsp;8.3.9, “Use of Index Extensions”</a>.
                    </p><p style="color:blue;">有关更多信息，请参见第8.3.9节“索引扩展的使用”。</p><p></p></li><li class="listitem"><p>
                    Index Merge Flags
                </p><p style="color:blue;">索引合并标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">index_merge</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">索引合并（默认打开）</p><p></p><p>
                            Controls all Index Merge optimizations.
                        </p><p style="color:blue;">控制所有索引合并优化。</p><p></p></li><li class="listitem"><p>
                            <code class="literal">index_merge_intersection</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">索引合并交叉点（默认打开）</p><p></p><p>
                            Controls the Index Merge Intersection Access
                            optimization.
                        </p><p style="color:blue;">控制索引合并交叉口访问优化。</p><p></p></li><li class="listitem"><p>
                            <code class="literal">index_merge_sort_union</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">索引合并排序联合（默认打开）</p><p></p><p>
                            Controls the Index Merge Sort-Union Access optimization.
                        </p><p style="color:blue;">控制索引合并排序联合访问优化。</p><p></p></li><li class="listitem"><p>
                            <code class="literal">index_merge_union</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">索引合并联合（默认打开）</p><p></p><p>
                            Controls the Index Merge Union Access optimization.
                        </p><p style="color:blue;">控制索引合并联合访问优化。</p><p></p></li></ul>
                    </div>
                    <p>
                        For more information, see
                        <a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.3&nbsp;Index Merge Optimization">Section&nbsp;8.2.1.3, “Index Merge Optimization”</a>.
                    </p><p style="color:blue;">有关详细信息，请参阅第8.2.1.3节“索引合并优化”。</p><p></p></li><li class="listitem"><p>
                    Multi-Range Read Flags
                </p><p style="color:blue;">多范围读取标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">mrr</code> (default <code class="literal">on</code>)
                        </p><p style="color:blue;">MRR（默认打开）</p><p></p><p>
                            Controls the Multi-Range Read strategy.
                        </p><p style="color:blue;">控制多范围读取策略。</p><p></p></li><li class="listitem"><p>
                            <code class="literal">mrr_cost_based</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">mrr_基于成本（默认值）</p><p></p><p>
                            Controls use of cost-based MRR if
                            <code class="literal">mrr=on</code>.
                        </p><p style="color:blue;">如果mrr=on，则控制基于成本的mrr的使用。</p><p></p></li></ul>
                    </div>
                    <p>
                        For more information, see
                        <a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.10&nbsp;Multi-Range Read Optimization">Section&nbsp;8.2.1.10, “Multi-Range Read Optimization”</a>.
                    </p><p style="color:blue;">有关更多信息，请参阅第8.2.1.10节“多范围读取优化”。</p><p></p></li><li class="listitem"><p>
                    Semijoin Flags
                </p><p style="color:blue;">半连接标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">semijoin</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">半联接（默认打开）</p><p></p><p>
                            Controls all semijoin strategies.
                        </p><p style="color:blue;">控制所有半联接策略。</p><p></p></li><li class="listitem"><p>
                            <code class="literal">duplicateweedout</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">DuplicateWeedOut（默认打开）</p><p></p><p>
                            Controls the semijoin Duplicate Weedout strategy.
                        </p><p style="color:blue;">控制半联接重复weedout策略。</p><p></p></li><li class="listitem"><p>
                            <code class="literal">firstmatch</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">FirstMatch（默认打开）</p><p></p><p>
                            Controls the semijoin FirstMatch strategy.
                        </p><p style="color:blue;">控制半联接FirstMatch策略。</p><p></p></li><li class="listitem"><p>
                            <code class="literal">loosescan</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">LooseScan（默认打开）</p><p></p><p>
                            Controls the semijoin LooseScan strategy (not to be
                            confused with Loose Index Scan for <code class="literal">GROUP
                            BY</code>).
                        </p><p style="color:blue;">控制半连接loosscan策略（不要与group by的loose index scan混淆）。</p><p></p></li></ul>
                    </div>
                    <p>
                        The <code class="literal">semijoin</code>,
                        <code class="literal">firstmatch</code>, <code class="literal">loosescan</code>,
                        and <code class="literal">duplicateweedout</code> flags enable control
                        over semijoin strategies. The <code class="literal">semijoin</code>
                        flag controls whether semijoins are used. If it is set to
                        <code class="literal">on</code>, the <code class="literal">firstmatch</code> and
                        <code class="literal">loosescan</code> flags enable finer control over
                        the permitted semijoin strategies.
                    </p><p style="color:blue;">半联接、FirstMatch、LooseScan和DuplicateWeedOut标志允许控制半联接策略。半联接标志控制是否使用半联接。如果设置为on，那么firstmatch和loosescan标志可以更好地控制允许的半连接策略。</p><p></p><p>
                        If the <code class="literal">duplicateweedout</code> semijoin strategy
                        is disabled, it is not used unless all other applicable
                        strategies are also disabled.
                    </p><p style="color:blue;">如果DuplicateWeedOutOut半联接策略被禁用，则除非所有其他适用策略也被禁用，否则不会使用该策略。</p><p></p><p>
                        If <code class="literal">semijoin</code> and
                        <code class="literal">materialization</code> are both
                        <code class="literal">on</code>, semijoins also use materialization
                        where applicable. These flags are <code class="literal">on</code> by
                        default.
                    </p><p style="color:blue;">如果半连接和物化都处于启用状态，则半连接在适用的情况下也使用物化。默认情况下，这些标志处于启用状态。</p><p></p><p>
                        For more information, see <a class="xref" href="optimization.html#semijoins" title="8.2.2.1&nbsp;Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations">Section&nbsp;8.2.2.1, “Optimizing Subqueries, Derived Tables, and View References with Semijoin
                        Transformations”</a>.
                    </p><p style="color:blue;">有关详细信息，请参阅第8.2.2.1节“使用半联接转换优化子查询、派生表和视图引用”。</p><p></p></li><li class="listitem"><p>
                    Subquery Materialization Flags
                </p><p style="color:blue;">子查询物化标志</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">materialization</code> (default
                            <code class="literal">on</code>)
                        </p><p style="color:blue;">物化（默认打开）</p><p></p><p>
                            Controls materialization (including semijoin
                            materialization).
                        </p><p style="color:blue;">控制物化（包括半连接物化）。</p><p></p></li><li class="listitem"><p>
                            <code class="literal">subquery_materialization_cost_based</code>
                            (default <code class="literal">on</code>)
                        </p><p style="color:blue;">子查询基于物化成本（默认为）</p><p></p><p>
                            Use cost-based materialization choice.
                        </p><p style="color:blue;">使用基于成本的物化选择。</p><p></p></li></ul>
                    </div>
                    <p>
                        The <code class="literal">materialization</code> flag controls whether
                        subquery materialization is used. If
                        <code class="literal">semijoin</code> and
                        <code class="literal">materialization</code> are both
                        <code class="literal">on</code>, semijoins also use materialization
                        where applicable. These flags are <code class="literal">on</code> by
                        default.
                    </p><p style="color:blue;">物化标志控制是否使用子查询物化。如果半连接和物化都处于启用状态，则半连接在适用的情况下也使用物化。默认情况下，这些标志处于启用状态。</p><p></p><p>
                        The <code class="literal">subquery_materialization_cost_based</code>
                        flag enables control over the choice between subquery
                        materialization and
                        <code class="literal">IN</code>-to-<code class="literal">EXISTS</code> subquery
                        transformation. If the flag is <code class="literal">on</code> (the
                        default), the optimizer performs a cost-based choice between
                        subquery materialization and
                        <code class="literal">IN</code>-to-<code class="literal">EXISTS</code> subquery
                        transformation if either method could be used. If the flag
                        is <code class="literal">off</code>, the optimizer chooses subquery
                        materialization over
                        <code class="literal">IN</code>-to-<code class="literal">EXISTS</code> subquery
                        transformation.
                    </p><p style="color:blue;">基于子查询物化和基于成本的标志可以控制子查询物化和in到现有子查询转换之间的选择。如果标志为on（默认值），优化器将在子查询物化和in-to-exists子查询转换（如果两种方法都可以使用）之间执行基于成本的选择。如果标志为off，优化器将选择子查询物化而不是in来存在子查询转换。</p><p></p><p>
                        For more information, see
                        <a class="xref" href="optimization.html#subquery-optimization" title="8.2.2&nbsp;Optimizing Subqueries, Derived Tables, and View References">Section&nbsp;8.2.2, “Optimizing Subqueries, Derived Tables, and View References”</a>.
                    </p><p style="color:blue;">有关详细信息，请参见第8.2.2节“优化子查询、派生表和视图引用”。</p><p></p></li></ul>
            </div>
            <p>
                When you assign a value to
                <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a>, flags that
                are not mentioned keep their current values. This makes it
                possible to enable or disable specific optimizer behaviors in a
                single statement without affecting other behaviors. The
                statement does not depend on what other optimizer flags exist
                and what their values are. Suppose that all Index Merge
                optimizations are enabled:
            </p><p style="color:blue;">将值分配给优化器开关时，未提及的标志将保留其当前值。这使得在单个语句中启用或禁用特定优化器行为成为可能，而不会影响其他行为。语句不依赖于其他优化器标志存在什么以及它们的值是什么。假设启用了所有索引合并优化：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch\G</code></strong>
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=on,
                    index_merge_sort_union=on,
                    index_merge_intersection=on,
                    engine_condition_pushdown=on,
                    index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,
                    block_nested_loop=on,batched_key_access=off,
                    materialization=on,semijoin=on,loosescan=on,
                    firstmatch=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on,
                    condition_fanout_filter=on
</pre><p>
            If the server is using the Index Merge Union or Index Merge
            Sort-Union access methods for certain queries and you want to
            check whether the optimizer will perform better without them,
            set the variable value like this:
        </p><p style="color:blue;">如果服务器正在对某些查询使用索引合并联合或索引合并排序联合访问方法，并且您希望检查优化器在没有这些方法的情况下是否会执行得更好，请设置如下变量值：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET optimizer_switch='index_merge_union=off,index_merge_sort_union=off';</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch\G</code></strong>
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=off,
                    index_merge_sort_union=off,
                    index_merge_intersection=on,
                    engine_condition_pushdown=on,
                    index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,
                    block_nested_loop=on,batched_key_access=off,
                    materialization=on,semijoin=on,loosescan=on,
                    firstmatch=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on,
                    condition_fanout_filter=on
</pre>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizer-hints"></a>8.9.3&nbsp;Optimizer Hints</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286870629712"></a><a class="indexterm" name="idm140286870628640"></a><p>
            One means of control over optimizer strategies is to set the
            <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
            variable (see <a class="xref" href="optimization.html#switchable-optimizations" title="8.9.2&nbsp;Switchable Optimizations">Section&nbsp;8.9.2, “Switchable Optimizations”</a>).
            Changes to this variable affect execution of all subsequent
            queries; to affect one query differently from another, it's
            necessary to change
            <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> before each
            one.
        </p><p style="color:blue;">控制优化器策略的一种方法是设置优化器开关系统变量（参见第8.9.2节“可切换优化”）。对该变量的更改会影响所有后续查询的执行；要以不同的方式影响一个查询，必须在每个查询之前更改优化器开关。</p><p></p><p>
            another way to control the optimizer is by using optimizer
            hints, which can be specified within individual statements.
            Because optimizer hints apply on a per-statement basis, they
            provide finer control over statement execution plans than can be
            achieved using
            <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a>. For example,
            you can enable an optimization for one table in a statement and
            disable the optimization for a different table. Hints within a
            statement take precedence over
            <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> flags.
        </p><p style="color:blue;">控制优化器的另一种方法是使用优化器提示，可以在单个语句中指定。因为优化器提示是基于每个语句应用的，所以它们提供了比使用优化器开关更精细的语句执行计划控制。例如，可以对语句中的一个表启用优化，对另一个表禁用优化。语句中的提示优先于优化器开关标志。</p><p></p><p>
            Examples:
        </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1
  FROM t3 WHERE f1 &gt; 30 AND f1 &lt; 33;
SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ NO_ICP(t1, t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ SEMIJOIN(FIRSTMATCH, LOOSESCAN) */ * FROM t1 ...;
EXPLAIN SELECT /*+ NO_ICP(t1) */ * FROM t1 WHERE ...;
</pre>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client by default strips comments
                    from SQL statements sent to the server (including optimizer
                    hints) until MySQL 5.7.7, when it was changed to pass
                    optimizer hints to the server. To ensure that optimizer hints
                    are not stripped if you are using an older version of the
                    <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client with a version of the server
                    that understands optimizer hints, invoke
                    <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> with the
                    <a class="link" href="programs.html#option_mysql_comments"><code class="option">--comments</code></a> option.
                </p><p style="color:blue;">默认情况下，mysql客户机从发送到服务器的sql语句（包括优化器提示）中删除注释，直到mysql 5.7.7被更改为向服务器传递优化器提示。要确保在使用旧版本的MySQL客户机和理解优化器提示的服务器版本时不会剥离优化器提示，请使用--comments选项调用MySQL。</p><p></p>
            </div>
            <p>
                Optimizer hints, described here, differ from index hints,
                described in <a class="xref" href="optimization.html#index-hints" title="8.9.4&nbsp;Index Hints">Section&nbsp;8.9.4, “Index Hints”</a>. Optimizer and index
                hints may be used separately or together.
            </p><p style="color:blue;">这里描述的优化器提示与第8.9.4节“索引提示”中描述的索引提示不同。优化器和索引提示可以单独使用，也可以一起使用。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-overview" title="Optimizer Hint Overview">Optimizer Hint Overview</a></p><p style="color:blue;">优化器提示概述</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-syntax" title="Optimizer Hint Syntax">Optimizer Hint Syntax</a></p><p style="color:blue;">优化器提示语法</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints">Table-Level Optimizer Hints</a></p><p style="color:blue;">表级优化器提示</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints">Index-Level Optimizer Hints</a></p><p style="color:blue;">索引级优化器提示</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints">Subquery Optimizer Hints</a></p><p style="color:blue;">子查询优化器提示</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-execution-time" title="Statement Execution Time Optimizer Hints">Statement Execution Time Optimizer Hints</a></p><p style="color:blue;">语句执行时间优化器提示</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#optimizer-hints-query-block-naming" title="Optimizer Hints for Naming Query Blocks">Optimizer Hints for Naming Query Blocks</a></p><p style="color:blue;">用于命名查询块的优化器提示</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="optimizer-hints-overview"></a>Optimizer Hint Overview</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Optimizer hints apply at different scope levels:
                </p><p style="color:blue;">优化器提示适用于不同的范围级别：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Global: The hint affects the entire statement
                    </p><p style="color:blue;">全局：提示影响整个语句</p><p></p></li><li class="listitem"><p>
                        Query block: The hint affects a particular query block
                        within a statement
                    </p><p style="color:blue;">查询块：提示影响语句中的特定查询块</p><p></p></li><li class="listitem"><p>
                        Table-level: The hint affects a particular table within a
                        query block
                    </p><p style="color:blue;">表级：提示影响查询块中的特定表</p><p></p></li><li class="listitem"><p>
                        Index-level: The hint affects a particular index within a
                        table
                    </p><p style="color:blue;">索引级别：提示影响表中的特定索引</p><p></p></li></ul>
                </div>
                <p>
                    The following table summarizes the available optimizer hints,
                    the optimizer strategies they affect, and the scope or scopes
                    at which they apply. More details are given later.
                </p><p style="color:blue;">下表总结了可用的优化器提示、它们影响的优化器策略以及它们应用的范围。稍后将提供更多细节。</p><p></p>
                <div class="table">
                    <a name="optimizer-hints-table"></a><p class="title"><b>Table&nbsp;8.2&nbsp;Optimizer Hints Available</b></p><p style="color:blue;">表8.2提供优化器提示</p><p></p>
                    <div class="table-contents">
                        <table summary="Optimizer hint names, descriptions, and contexts in which they apply."><colgroup><col width="30%"><col width="40%"><col width="30%"></colgroup><thead><tr>
                            <th scope="col">Hint Name</th>
                            <th scope="col">Description</th>
                            <th scope="col">Applicable Scopes</th>
                        </tr></thead><tbody><tr>
                            <td align="left" scope="row"><a class="link" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints"><code class="literal">BKA</code></a>,
                                <a class="link" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints"><code class="literal">NO_BKA</code></a></td>
                            <td align="left">Affects Batched Key Access join processing</td>
                            <td>Query block, table</td>
                        </tr><tr>
                            <td align="left" scope="row"><a class="link" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints"><code class="literal">BNL</code></a>,
                                <a class="link" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints"><code class="literal">NO_BNL</code></a></td>
                            <td align="left">Affects Block Nested-Loop join processing</td>
                            <td>Query block, table</td>
                        </tr><tr>
                            <td align="left" scope="row"><a class="link" href="optimization.html#optimizer-hints-execution-time" title="Statement Execution Time Optimizer Hints"><code class="literal">MAX_EXECUTION_TIME</code></a></td>
                            <td align="left">Limits statement execution time</td>
                            <td>Global</td>
                        </tr><tr>
                            <td align="left" scope="row"><a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">MRR</code></a>,
                                <a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">NO_MRR</code></a></td>
                            <td align="left">Affects Multi-Range Read optimization</td>
                            <td>Table, index</td>
                        </tr><tr>
                            <td align="left" scope="row"><a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">NO_ICP</code></a></td>
                            <td align="left">Affects Index Condition Pushdown optimization</td>
                            <td>Table, index</td>
                        </tr><tr>
                            <td align="left" scope="row"><a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">NO_RANGE_OPTIMIZATION</code></a></td>
                            <td align="left">Affects range optimization</td>
                            <td>Table, index</td>
                        </tr><tr>
                            <td align="left" scope="row"><a class="link" href="optimization.html#optimizer-hints-query-block-naming" title="Optimizer Hints for Naming Query Blocks"><code class="literal">QB_NAME</code></a></td>
                            <td align="left">Assigns name to query block</td>
                            <td>Query block</td>
                        </tr><tr>
                            <td align="left" scope="row"><a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">SEMIJOIN</code></a>,
                                <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">NO_SEMIJOIN</code></a></td>
                            <td align="left">Affects semijoin strategies</td>
                            <td>Query block</td>
                        </tr><tr>
                            <td align="left" scope="row"><a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">SUBQUERY</code></a></td>
                            <td align="left">Affects materialization,
                                <code class="literal">IN</code>-to-<code class="literal">EXISTS</code>
                                subquery stratgies</td>
                            <td>Query block</td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                Disabling an optimization prevents the optimizer from using
                it. Enabling an optimization means the optimizer is free to
                use the strategy if it applies to statement execution, not
                that the optimizer necessarily will use it.
            </p><p style="color:blue;">禁用优化将阻止优化器使用它。启用优化意味着如果策略应用于语句执行，优化器可以自由使用该策略，而不是优化器必须使用它。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="optimizer-hints-syntax"></a>Optimizer Hint Syntax</h4>

                        </div>

                    </div>

                </div>
                <p>
                    MySQL supports comments in SQL statements as described in
                    <a class="xref" href="language-structure.html#comments" title="9.6&nbsp;Comment Syntax">Section&nbsp;9.6, “Comment Syntax”</a>. Optimizer hints must be specified
                    within <code class="literal">/*+ ... */</code> comments. That is,
                    optimizer hints use a variant of <code class="literal">/* ... */</code>
                    C-style comment syntax, with a <code class="literal">+</code> character
                    following the <code class="literal">/*</code> comment opening sequence.
                    Examples:
                </p><p style="color:blue;">MySQL支持SQL语句中的注释，如第9.6节“注释语法”所述。优化器提示必须在/*+…*/评论。也就是说，优化器提示使用/*…*/C风格的注释语法，在/*注释打开序列后面有一个+字符。示例：</p><p></p><pre data-lang="sql" class="programlisting">/*+ BKA(t1) */
/*+ BNL(t1, t2) */
/*+ NO_RANGE_OPTIMIZATION(t4 PRIMARY) */
/*+ QB_NAME(qb2) */
</pre><p>
                Whitespace is permitted after the <code class="literal">+</code>
                character.
            </p><p style="color:blue;">+字符后允许有空白。</p><p></p><p>
                The parser recognizes optimizer hint comments after the
                initial keyword of <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>,
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>,
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#replace" title="13.2.8&nbsp;REPLACE Syntax"><code class="literal">REPLACE</code></a>, and
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements. Hints are
                permitted in these contexts:
            </p><p style="color:blue;">解析器在select、update、insert、replace和delete语句的初始关键字之后识别优化器提示注释。在这些上下文中允许使用提示：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        At the beginning of query and data change statements:
                    </p><p style="color:blue;">在查询和数据更改语句的开头：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ ... */ ...
INSERT /*+ ... */ ...
REPLACE /*+ ... */ ...
UPDATE /*+ ... */ ...
DELETE /*+ ... */ ...
</pre></li><li class="listitem"><p>
                        At the beginning of query blocks:
                    </p><p style="color:blue;">在查询块的开头：</p><p></p><pre data-lang="sql" class="programlisting">(SELECT /*+ ... */ ... )
(SELECT ... ) UNION (SELECT /*+ ... */ ... )
(SELECT /*+ ... */ ... ) UNION (SELECT /*+ ... */ ... )
UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
INSERT ... SELECT /*+ ... */ ...
</pre></li><li class="listitem"><p>
                        In hintable statements prefaced by
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>. For example:
                    </p><p style="color:blue;">在以explain开头的可提示语句中。例如：</p><p></p><pre data-lang="sql" class="programlisting">EXPLAIN SELECT /*+ ... */ ...
EXPLAIN UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
</pre><p>
                        The implication is that you can use
                        <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to see how
                        optimizer hints affect execution plans. Use
                        <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW WARNINGS</code></a> immediately
                        after <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> to see how
                        hints are used. The extended <code class="literal">EXPLAIN</code>
                        output displayed by a following <a class="link" href="sql-syntax.html#show-warnings" title="13.7.5.40&nbsp;SHOW WARNINGS Syntax"><code class="literal">SHOW
                        WARNINGS</code></a> indicates which hints were used.
                        Ignored hints are not displayed.
                    </p><p style="color:blue;">这意味着您可以使用explain查看优化器提示如何影响执行计划。使用“解释后立即显示警告”查看如何使用提示。以下show warnings显示的扩展解释输出指示使用了哪些提示。不显示忽略的提示。</p><p></p></li></ul>
                </div>
                <p>
                    A hint comment may contain multiple hints, but a query block
                    cannot contain multiple hint comments. This is valid:
                </p><p style="color:blue;">提示注释可以包含多个提示，但查询块不能包含多个提示注释。这是有效的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ BNL(t1) BKA(t2) */ ...
</pre><p>
                But this is invalid:
            </p><p style="color:blue;">但这是无效的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ BNL(t1) */ /* BKA(t2) */ ...
</pre><p>
                When a hint comment contains multiple hints, the possibility
                of duplicates and conflicts exists. The following general
                guidelines apply. For specific hint types, additional rules
                may apply, as indicated in the hint descriptions.
            </p><p style="color:blue;">当提示注释包含多个提示时，存在重复和冲突的可能性。以下一般准则适用。对于特定的提示类型，可以应用其他规则，如提示说明中所示。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Duplicate hints: For a hint such as <code class="literal">/*+ MRR(idx1)
                        MRR(idx1) */</code>, MySQL uses the first hint and
                        issues a warning about the duplicate hint.
                    </p><p style="color:blue;">重复提示：对于像/*+mrr（idx1）mrr（idx1）*/这样的提示，mysql使用第一个提示并发出关于重复提示的警告。</p><p></p></li><li class="listitem"><p>
                        Conflicting hints: For a hint such as <code class="literal">/*+
                        MRR(idx1) NO_MRR(idx1) */</code>, MySQL uses the first
                        hint and issues a warning about the second conflicting
                        hint.
                    </p><p style="color:blue;">冲突提示：对于诸如/*+mrr（idx1）no-mrr（idx1）*/之类的提示，mysql使用第一个提示，并对第二个冲突提示发出警告。</p><p></p></li></ul>
                </div>
                <p>
                    Query block names are identifiers and follow the usual rules
                    about what names are valid and how to quote them (see
                    <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>).
                </p><p style="color:blue;">查询块名是标识符，并遵循关于哪些名称是有效的以及如何引用它们的常规规则（请参见第9.2节“模式对象名”）。</p><p></p><p>
                Hint names, query block names, and strategy names are not case
                sensitive. References to table and index names follow the
                usual identifier case sensitivity rules (see
                <a class="xref" href="language-structure.html#identifier-case-sensitivity" title="9.2.3&nbsp;Identifier Case Sensitivity">Section&nbsp;9.2.3, “Identifier Case Sensitivity”</a>).
            </p><p style="color:blue;">提示名称、查询块名称和策略名称不区分大小写。对表和索引名的引用遵循通常的标识符区分大小写规则（请参阅第9.2.3节“标识符区分大小写”）。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="optimizer-hints-table-level"></a>Table-Level Optimizer Hints</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Table-level hints affect use of the Block Nested-Loop (BNL)
                    and Batched Key Access (BKA) join-processing algorithms (see
                    <a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.11&nbsp;Block Nested-Loop and Batched Key Access Joins">Section&nbsp;8.2.1.11, “Block Nested-Loop and Batched Key Access Joins”</a>). These hint types
                    apply to specific tables, or all tables in a query block.
                </p><p style="color:blue;">表级提示影响块嵌套循环（BNL）和批处理密钥访问（BKA）连接处理算法的使用（请参阅第8.2.1.11节“块嵌套循环和批处理密钥访问连接”）。这些提示类型适用于特定表或查询块中的所有表。</p><p></p><p>
                Syntax of table-level hints:
            </p><p style="color:blue;">表级提示的语法：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>hint_name</code></em>([@<em class="replaceable"><code>query_block_name</code></em>] [<em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...])
<em class="replaceable"><code>hint_name</code></em>([<em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em>] ...])
</pre><p>
                The syntax refers to these terms:
            </p><p style="color:blue;">语法指的是这些术语：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <em class="replaceable"><code>hint_name</code></em>: These hint names are
                        permitted:
                    </p><p style="color:blue;">提示名称：允许使用以下提示名称：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <a class="link" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints"><code class="literal">BKA</code></a>,
                                <a class="link" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints"><code class="literal">NO_BKA</code></a>: Enable or
                                disable BKA for the specified tables.
                            </p><p style="color:blue;">bka，no_bka：启用或禁用指定表的bka。</p><p></p></li><li class="listitem"><p>
                                <a class="link" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints"><code class="literal">BNL</code></a>,
                                <a class="link" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints"><code class="literal">NO_BNL</code></a>: Enable or
                                disable BNL for the specified tables.
                            </p><p style="color:blue;">bnl，no_bnl：为指定表启用或禁用bnl。</p><p></p></li></ul>
                        </div>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                To use a BNL or BKA hint to enable join buffering for
                                any inner table of an outer join, join buffering must be
                                enabled for all inner tables of the outer join.
                            </p><p style="color:blue;">要使用bnl或bka提示为外部联接的任何内部表启用联接缓冲，必须为外部联接的所有内部表启用联接缓冲。</p><p></p>
                        </div>
                    </li><li class="listitem"><p>
                        <em class="replaceable"><code>tbl_name</code></em>: The name of a table
                        used in the statement. The hint applies to all tables that
                        it names. If the hint names no tables, it applies to all
                        tables of the query block in which it occurs.
                    </p><p style="color:blue;">tbl_name：语句中使用的表的名称。该提示适用于它命名的所有表。如果提示未命名任何表，则它将应用于发生该提示的查询块的所有表。</p><p></p><p>
                        If a table has an alias, hints must refer to the alias,
                        not the table name.
                    </p><p style="color:blue;">如果表有别名，提示必须引用别名，而不是表名。</p><p></p><p>
                        Table names in hints cannot be qualified with schema
                        names.
                    </p><p style="color:blue;">提示中的表名不能用架构名限定。</p><p></p></li><li class="listitem"><p>
                        <em class="replaceable"><code>query_block_name</code></em>: The query
                        block to which the hint applies. If the hint includes no
                        leading
                        <code class="literal">@<em class="replaceable"><code>query_block_name</code></em></code>,
                        the hint applies to the query block in which it occurs.
                        For
                        <code class="literal"><em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em></code>
                        syntax, the hint applies to the named table in the named
                        query block. To assign a name to a query block, see
                        <a class="xref" href="optimization.html#optimizer-hints-query-block-naming" title="Optimizer Hints for Naming Query Blocks">Optimizer Hints for Naming Query Blocks</a>.
                    </p><p style="color:blue;">查询块名称：应用提示的查询块。如果提示不包含前导@query_block_name，则该提示将应用于发生该提示的查询块。对于tbl_name@query_block_name语法，提示将应用于命名查询块中的命名表。要为查询块指定名称，请参见优化器提示以命名查询块。</p><p></p></li></ul>
                </div>
                <p>
                    Examples:
                </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ NO_BKA(t1, t2) */ t1.* FROM t1 INNER JOIN t2 INNER JOIN t3;
SELECT /*+ NO_BNL() BKA(t1) */ t1.* FROM t1 INNER JOIN t2 INNER JOIN t3;
</pre><p>
                A table-level hint applies to tables that receive records from
                previous tables, not sender tables. Consider this statement:
            </p><p style="color:blue;">表级提示适用于从以前的表而不是发送者表接收记录的表。请考虑以下声明：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ BNL(t2) */ FROM t1, t2;
</pre><p>
                If the optimizer chooses to process <code class="literal">t1</code>
                first, it applies a Block Nested-Loop join to
                <code class="literal">t2</code> by buffering the rows from
                <code class="literal">t1</code> before starting to read from
                <code class="literal">t2</code>. If the optimizer instead chooses to
                process <code class="literal">t2</code> first, the hint has no effect
                because <code class="literal">t2</code> is a sender table.
            </p><p style="color:blue;">如果优化器选择首先处理T1，那么它将在开始从T2读取之前缓冲T1中的行，从而对T2应用块嵌套循环联接。如果优化器选择首先处理t2，则提示无效，因为t2是一个sender表。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="optimizer-hints-index-level"></a>Index-Level Optimizer Hints</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Index-level hints affect which index-processing strategies the
                    optimizer uses for particular tables or indexes. These hint
                    types affect use of Index Condition Pushdown (ICP),
                    Multi-Range Read (MRR), and range optimizations (see
                    <a class="xref" href="optimization.html#select-optimization" title="8.2.1&nbsp;Optimizing SELECT Statements">Section&nbsp;8.2.1, “Optimizing SELECT Statements”</a>).
                </p><p style="color:blue;">索引级提示影响优化器对特定表或索引使用的索引处理策略。这些提示类型影响索引条件下推（icp）、多范围读取（mrr）和范围优化的使用（请参阅第8.2.1节“优化选择语句”）。</p><p></p><p>
                Syntax of index-level hints:
            </p><p style="color:blue;">索引级提示的语法：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>hint_name</code></em>([@<em class="replaceable"><code>query_block_name</code></em>] <em class="replaceable"><code>tbl_name</code></em> [<em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...])
<em class="replaceable"><code>hint_name</code></em>(<em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em> [<em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...])
</pre><p>
                The syntax refers to these terms:
            </p><p style="color:blue;">语法指的是这些术语：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <em class="replaceable"><code>hint_name</code></em>: These hint names are
                        permitted:
                    </p><p style="color:blue;">提示名称：允许使用以下提示名称：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">MRR</code></a>,
                                <a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">NO_MRR</code></a>: Enable or
                                disable MRR for the specified table or indexes. MRR
                                hints apply only to <code class="literal">InnoDB</code> and
                                <code class="literal">MyISAM</code> tables.
                            </p><p style="color:blue;">mrr，no_mrr：启用或禁用指定表或索引的mrr。mrr提示仅适用于innodb和myisam表。</p><p></p></li><li class="listitem"><p>
                                <a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">NO_ICP</code></a>: Disable ICP
                                for the specified table or indexes. By default, ICP is
                                a candidate optimization strategy, so there is no hint
                                for enabling it.
                            </p><p style="color:blue;">无icp：禁用指定表或索引的icp。默认情况下，icp是一个候选优化策略，因此没有启用它的提示。</p><p></p></li><li class="listitem"><p>
                                <a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">NO_RANGE_OPTIMIZATION</code></a>:
                                Disable index range access for the specified table or
                                indexes. This hint also disables Index Merge and Loose
                                Index Scan for the table or indexes. By default, range
                                access is a candidate optimization strategy, so there
                                is no hint for enabling it.
                            </p><p style="color:blue;">无范围优化：禁用指定表或索引的索引范围访问。此提示还禁用表或索引的索引合并和松散索引扫描。默认情况下，范围访问是一种候选优化策略，因此没有启用它的提示。</p><p></p><p>
                                This hint may be useful when the number of ranges may
                                be high and range optimization would require many
                                resources.
                            </p><p style="color:blue;">当范围数可能很高并且范围优化需要很多资源时，此提示可能很有用。</p><p></p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        <em class="replaceable"><code>tbl_name</code></em>: The table to which
                        the hint applies.
                    </p><p style="color:blue;">tbl_name：应用提示的表。</p><p></p></li><li class="listitem"><p>
                        <em class="replaceable"><code>index_name</code></em>: The name of an
                        index in the named table. The hint applies to all indexes
                        that it names. If the hint names no indexes, it applies to
                        all indexes in the table.
                    </p><p style="color:blue;">index_name：命名表中索引的名称。该提示适用于它命名的所有索引。如果提示未命名索引，则应用于表中的所有索引。</p><p></p><p>
                        To refer to a primary key, use the name
                        <code class="literal">PRIMARY</code>. To see the index names for a
                        table, use <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW INDEX</code></a>.
                    </p><p style="color:blue;">要引用主键，请使用名称primary。要查看表的索引名，请使用show index。</p><p></p></li><li class="listitem"><p>
                        <em class="replaceable"><code>query_block_name</code></em>: The query
                        block to which the hint applies. If the hint includes no
                        leading
                        <code class="literal">@<em class="replaceable"><code>query_block_name</code></em></code>,
                        the hint applies to the query block in which it occurs.
                        For
                        <code class="literal"><em class="replaceable"><code>tbl_name</code></em>@<em class="replaceable"><code>query_block_name</code></em></code>
                        syntax, the hint applies to the named table in the named
                        query block. To assign a name to a query block, see
                        <a class="xref" href="optimization.html#optimizer-hints-query-block-naming" title="Optimizer Hints for Naming Query Blocks">Optimizer Hints for Naming Query Blocks</a>.
                    </p><p style="color:blue;">查询块名称：应用提示的查询块。如果提示不包含前导@query_block_name，则该提示将应用于发生该提示的查询块。对于tbl_name@query_block_name语法，提示将应用于命名查询块中的命名表。要为查询块指定名称，请参见优化器提示以命名查询块。</p><p></p></li></ul>
                </div>
                <p>
                    Examples:
                </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ MRR(t1) */ * FROM t1 WHERE f2 &lt;= 3 AND 3 &lt;= f3;
SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1
  FROM t3 WHERE f1 &gt; 30 AND f1 &lt; 33;
INSERT INTO t3(f1, f2, f3)
  (SELECT /*+ NO_ICP(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
   WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1
   AND t1.f2 AND t2.f2 + 1 &gt;= t1.f1 + 1);
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="optimizer-hints-subquery"></a>Subquery Optimizer Hints</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Subquery hints affect whether to use semijoin transformations
                    and which semijoin strategies to permit, and, when semijoins
                    are not used, whether to use subquery materialization or
                    <code class="literal">IN</code>-to-<code class="literal">EXISTS</code>
                    transformations. For more information about these
                    optimizations, see <a class="xref" href="optimization.html#subquery-optimization" title="8.2.2&nbsp;Optimizing Subqueries, Derived Tables, and View References">Section&nbsp;8.2.2, “Optimizing Subqueries, Derived Tables, and View References”</a>.
                </p><p style="color:blue;">子查询提示影响是否使用半联接转换以及允许使用哪些半联接策略，并且在不使用半联接时，影响是使用子查询物化还是使用in来存在转换。有关这些优化的详细信息，请参阅第8.2.2节“优化子查询、派生表和视图引用”。</p><p></p><p>
                Syntax of hints that affect semijoin strategies:
            </p><p style="color:blue;">影响半连接策略的提示语法：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>hint_name</code></em>([@<em class="replaceable"><code>query_block_name</code></em>] [<em class="replaceable"><code>strategy</code></em> [, <em class="replaceable"><code>strategy</code></em>] ...])
</pre><p>
                The syntax refers to these terms:
            </p><p style="color:blue;">语法指的是这些术语：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <em class="replaceable"><code>hint_name</code></em>: These hint names are
                        permitted:
                    </p><p style="color:blue;">提示名称：允许使用以下提示名称：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">SEMIJOIN</code></a>,
                                <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">NO_SEMIJOIN</code></a>: Enable
                                or disable the named semijoin strategies.
                            </p><p style="color:blue;">半联接，无半联接：启用或禁用指定的半联接策略。</p><p></p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        <em class="replaceable"><code>strategy</code></em>: A semijoin strategy
                        to be enabled or disabled. These strategy names are
                        permitted: <code class="literal">DUPSWEEDOUT</code>,
                        <code class="literal">FIRSTMATCH</code>,
                        <code class="literal">LOOSESCAN</code>,
                        <code class="literal">MATERIALIZATION</code>.
                    </p><p style="color:blue;">策略：要启用或禁用的半联接策略。允许使用这些策略名称：dupsweedout、firstmatch、loosescan、materialization。</p><p></p><p>
                        For <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">SEMIJOIN</code></a> hints, if
                        no strategies are named, semijoin is used if possible
                        based on the strategies enabled according to the
                        <a class="link" href="server-administration.html#sysvar_optimizer_switch"><code class="literal">optimizer_switch</code></a> system
                        variable. If strategies are named but inapplicable for the
                        statement, <code class="literal">DUPSWEEDOUT</code> is used.
                    </p><p style="color:blue;">对于半联接提示，如果没有命名策略，则在可能的情况下，根据根据优化器开关系统变量启用的策略使用半联接。如果策略已命名但不适用于语句，则使用dupsweedout。</p><p></p><p>
                        For <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">NO_SEMIJOIN</code></a> hints,
                        if no strategies are named, semijoin is not used. If
                        strategies are named that rule out all applicable
                        strategies for the statement,
                        <code class="literal">DUPSWEEDOUT</code> is used.
                    </p><p style="color:blue;">对于没有半连接提示，如果没有命名策略，则不使用半连接。如果策略被命名为排除语句的所有适用策略，则使用dupsweedout。</p><p></p></li></ul>
                </div>
                <p>
                    If one subquery is nested within another and both are merged
                    into a semijoin of an outer query, any specification of
                    semijoin strategies for the innermost query are ignored.
                    <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">SEMIJOIN</code></a> and
                    <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">NO_SEMIJOIN</code></a> hints can still
                    be used to enable or disable semijoin transformations for such
                    nested subqueries.
                </p><p style="color:blue;">如果一个子查询嵌套在另一个子查询中，并且这两个子查询合并为外部查询的半联接，则忽略最内部查询的任何半联接策略规范。半联接和无半联接提示仍然可以用于启用或禁用此类嵌套子查询的半联接转换。</p><p></p><p>
                If <code class="literal">DUPSWEEDOUT</code> is disabled, on occasion the
                optimizer may generate a query plan that is far from optimal.
                This occurs due to heuristic pruning during greedy search,
                which can be avoided by setting
                <a class="link" href="server-administration.html#sysvar_optimizer_prune_level"><code class="literal">optimizer_prune_level=0</code></a>.
            </p><p style="color:blue;">如果dupsweedout被禁用，优化器有时可能会生成一个远远不是最优的查询计划。这是由于贪婪搜索期间的启发式修剪造成的，可以通过设置优化器修剪级别=0来避免。</p><p></p><p>
                Examples:
            </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ NO_SEMIJOIN(@subq1 FIRSTMATCH, LOOSESCAN) */ * FROM t2
  WHERE t2.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3);
SELECT /*+ SEMIJOIN(@subq1 MATERIALIZATION, DUPSWEEDOUT) */ * FROM t2
  WHERE t2.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3);
</pre><p>
                Syntax of hints that affect whether to use subquery
                materialization or
                <code class="literal">IN</code>-to-<code class="literal">EXISTS</code>
                transformations:
            </p><p style="color:blue;">影响是使用子查询物化还是在中使用现有转换的提示语法：</p><p></p><pre data-lang="sql" class="programlisting">SUBQUERY([@<em class="replaceable"><code>query_block_name</code></em>] <em class="replaceable"><code>strategy</code></em>)
</pre><p>
                The hint name is always
                <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">SUBQUERY</code></a>.
            </p><p style="color:blue;">提示名称始终是子查询。</p><p></p><p>
                For <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">SUBQUERY</code></a> hints, these
                <em class="replaceable"><code>strategy</code></em> values are permitted:
                <code class="literal">INTOEXISTS</code>,
                <code class="literal">MATERIALIZATION</code>.
            </p><p style="color:blue;">对于子查询提示，允许使用以下策略值：intoExists、materialization。</p><p></p><p>
                Examples:
            </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT id, a IN (SELECT /*+ SUBQUERY(MATERIALIZATION) */ a FROM t1) FROM t2;
SELECT * FROM t2 WHERE t2.a IN (SELECT /*+ SUBQUERY(INTOEXISTS) */ a FROM t1);
</pre><p>
                For semijoin and <a class="link" href="optimization.html#optimizer-hints-subquery" title="Subquery Optimizer Hints"><code class="literal">SUBQUERY</code></a>
                hints, a leading
                <code class="literal">@<em class="replaceable"><code>query_block_name</code></em></code>
                specifies the query block to which the hint applies. If the
                hint includes no leading
                <code class="literal">@<em class="replaceable"><code>query_block_name</code></em></code>,
                the hint applies to the query block in which it occurs. To
                assign a name to a query block, see
                <a class="xref" href="optimization.html#optimizer-hints-query-block-naming" title="Optimizer Hints for Naming Query Blocks">Optimizer Hints for Naming Query Blocks</a>.
            </p><p style="color:blue;">对于半联接和子查询提示，前导@query_block_name指定该提示应用于的查询块。如果提示不包含前导@query_block_name，则该提示将应用于发生该提示的查询块。要为查询块指定名称，请参见优化器提示以命名查询块。</p><p></p><p>
                If a hint comment contains multiple subquery hints, the first
                is used. If there are other following hints of that type, they
                produce a warning. Following hints of other types are silently
                ignored.
            </p><p style="color:blue;">如果提示注释包含多个子查询提示，则使用第一个子查询提示。如果有其他类似的提示，它们会发出警告。以下其他类型的提示将被忽略。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="optimizer-hints-execution-time"></a>Statement Execution Time Optimizer Hints</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <a class="link" href="optimization.html#optimizer-hints-execution-time" title="Statement Execution Time Optimizer Hints"><code class="literal">MAX_EXECUTION_TIME</code></a> hint
                    is permitted only for <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                    statements. It places a limit <em class="replaceable"><code>N</code></em> (a
                    timeout value in milliseconds) on how long a statement is
                    permitted to execute before the server terminates it:
                </p><p style="color:blue;">max_execution_time提示只允许用于select语句。它将限制n（以毫秒为单位的超时值）设置为允许在服务器终止语句之前执行该语句的时间：</p><p></p><pre data-lang="sql" class="programlisting">MAX_EXECUTION_TIME(<em class="replaceable"><code>N</code></em>)
</pre><p>
                Example with a timeout of 1 second (1000 milliseconds):
            </p><p style="color:blue;">超时为1秒（1000毫秒）的示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM t1 INNER JOIN t2 WHERE ...
</pre><p>
                The
                <a class="link" href="optimization.html#optimizer-hints-execution-time" title="Statement Execution Time Optimizer Hints"><code class="literal">MAX_EXECUTION_TIME(<em class="replaceable"><code>N</code></em>)</code></a>
                hint sets a statement execution timeout of
                <em class="replaceable"><code>N</code></em> milliseconds. If this option is
                absent or <em class="replaceable"><code>N</code></em> is 0, the statement
                timeout established by the
                <a class="link" href="server-administration.html#sysvar_max_execution_time"><code class="literal">max_execution_time</code></a> system
                variable applies.
            </p><p style="color:blue;">max_execution_time（n）提示将语句执行超时设置为n毫秒。如果此选项不存在或n为0，则应用由max_execution_time系统变量建立的语句超时。</p><p></p><p>
                The <a class="link" href="optimization.html#optimizer-hints-execution-time" title="Statement Execution Time Optimizer Hints"><code class="literal">MAX_EXECUTION_TIME</code></a> hint
                is applicable as follows:
            </p><p style="color:blue;">max_execution_time提示适用于以下情况：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        For statements with multiple <code class="literal">SELECT</code>
                        keywords, such as unions or statements with subqueries,
                        <a class="link" href="optimization.html#optimizer-hints-execution-time" title="Statement Execution Time Optimizer Hints"><code class="literal">MAX_EXECUTION_TIME</code></a>
                        applies to the entire statement and must appear after the
                        first <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>.
                    </p><p style="color:blue;">对于具有多个select关键字的语句，例如unions或带有子查询的语句，max_execution_time应用于整个语句，并且必须出现在第一个select之后。</p><p></p></li><li class="listitem"><p>
                        It applies to read-only
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements.
                        Statements that are not read only are those that invoke a
                        stored function that modifies data as a side effect.
                    </p><p style="color:blue;">它适用于只读select语句。非只读语句是那些调用存储函数以修改数据作为副作用的语句。</p><p></p></li><li class="listitem"><p>
                        It does not apply to <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        statements in stored programs and is ignored.
                    </p><p style="color:blue;">它不适用于存储程序中的select语句，并被忽略。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="optimizer-hints-query-block-naming"></a>Optimizer Hints for Naming Query Blocks</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Table-level, index-level, and subquery optimizer hints permit
                    specific query blocks to be named as part of their argument
                    syntax. To create these names, use the
                    <a class="link" href="optimization.html#optimizer-hints-query-block-naming" title="Optimizer Hints for Naming Query Blocks"><code class="literal">QB_NAME</code></a> hint, which assigns
                    a name to the query block in which it occurs:
                </p><p style="color:blue;">表级、索引级和子查询优化器提示允许将特定查询块命名为其参数语法的一部分。若要创建这些名称，请使用qb_name提示，该提示会将名称指定给发生该名称的查询块：</p><p></p><pre data-lang="sql" class="programlisting">QB_NAME(<em class="replaceable"><code>name</code></em>)
</pre><p>
                <a class="link" href="optimization.html#optimizer-hints-query-block-naming" title="Optimizer Hints for Naming Query Blocks"><code class="literal">QB_NAME</code></a> hints can be used to
                make explicit in a clear way which query blocks other hints
                apply to. They also permit all non-query block name hints to
                be specified within a single hint comment for easier
                understanding of complex statements. Consider the following
                statement:
            </p><p style="color:blue;">qb_name提示可用于以明确的方式显式显示其他提示所适用的查询块。它们还允许在单个提示注释中指定所有非查询块名提示，以便于理解复杂语句。请考虑以下声明：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ...
  FROM (SELECT ...
  FROM (SELECT ... FROM ...)) ...
</pre><p>
                <a class="link" href="optimization.html#optimizer-hints-query-block-naming" title="Optimizer Hints for Naming Query Blocks"><code class="literal">QB_NAME</code></a> hints assign names
                to query blocks in the statement:
            </p><p style="color:blue;">qb_name提示为语句中的查询块指定名称：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ QB_NAME(qb1) */ ...
  FROM (SELECT /*+ QB_NAME(qb2) */ ...
  FROM (SELECT /*+ QB_NAME(qb3) */ ... FROM ...)) ...
</pre><p>
                Then other hints can use those names to refer to the
                appropriate query blocks:
            </p><p style="color:blue;">然后其他提示可以使用这些名称来引用相应的查询块：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ QB_NAME(qb1) MRR(@qb1 t1) BKA(@qb2) NO_MRR(@qb3t1 idx1, id2) */ ...
  FROM (SELECT /*+ QB_NAME(qb2) */ ...
  FROM (SELECT /*+ QB_NAME(qb3) */ ... FROM ...)) ...
</pre><p>
                The resulting effect is as follows:
            </p><p style="color:blue;">其结果如下：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">MRR(@qb1 t1)</code></a> applies to
                        table <code class="literal">t1</code> in query block
                        <code class="literal">qb1</code>.
                    </p><p style="color:blue;">mrr（@qb1 t1）适用于查询块qb1中的表t1。</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="optimization.html#optimizer-hints-table-level" title="Table-Level Optimizer Hints"><code class="literal">BKA(@qb2)</code></a> applies to
                        query block <code class="literal">qb2</code>.
                    </p><p style="color:blue;">bka（@qb2）适用于查询块qb2。</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="optimization.html#optimizer-hints-index-level" title="Index-Level Optimizer Hints"><code class="literal">NO_MRR(@qb3 t1 idx1,
                            id2)</code></a> applies to indexes <code class="literal">idx1</code>
                        and <code class="literal">idx2</code> in table <code class="literal">t1</code>
                        in query block <code class="literal">qb3</code>.
                    </p><p style="color:blue;">没有mrr（@qb3 t1 idx1，id2）适用于查询块qb3中表t1中的索引idx1和idx2。</p><p></p></li></ul>
                </div>
                <p>
                    Query block names are identifiers and follow the usual rules
                    about what names are valid and how to quote them (see
                    <a class="xref" href="language-structure.html#identifiers" title="9.2&nbsp;Schema Object Names">Section&nbsp;9.2, “Schema Object Names”</a>). For example, a query block
                    name that contains spaces must be quoted, which can be done
                    using backticks:
                </p><p style="color:blue;">查询块名是标识符，并遵循关于哪些名称是有效的以及如何引用它们的常规规则（请参见第9.2节“模式对象名”）。例如，必须引用包含空格的查询块名，这可以使用反勾号完成：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ BKA(@`my hint name`) */ ...
  FROM (SELECT /*+ QB_NAME(`my hint name`) */ ...) ...
</pre><p>
                If the <a class="link" href="server-administration.html#sqlmode_ansi_quotes"><code class="literal">ANSI_QUOTES</code></a> SQL mode
                is enabled, it is also possible to quote query block names
                within double quotation marks:
            </p><p style="color:blue;">如果启用了ansi_quotes sql模式，也可以在双引号内引用查询块名：</p><p></p><pre data-lang="sql" class="programlisting">SELECT /*+ BKA(@"my hint name") */ ...
  FROM (SELECT /*+ QB_NAME("my hint name") */ ...) ...
</pre>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="index-hints"></a>8.9.4&nbsp;Index Hints</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286870335216"></a><a class="indexterm" name="idm140286870334144"></a><a class="indexterm" name="idm140286870332656"></a><a class="indexterm" name="idm140286870331584"></a><a class="indexterm" name="idm140286870330512"></a><a class="indexterm" name="idm140286870329440"></a><a class="indexterm" name="idm140286870328368"></a><a class="indexterm" name="idm140286870327296"></a><p>
            Index hints give the optimizer information about how to choose
            indexes during query processing. Index hints, described here,
            differ from optimizer hints, described in
            <a class="xref" href="optimization.html#optimizer-hints" title="8.9.3&nbsp;Optimizer Hints">Section&nbsp;8.9.3, “Optimizer Hints”</a>. Index and optimizer hints may
            be used separately or together.
        </p><p style="color:blue;">索引提示向优化器提供有关如何在查询处理期间选择索引的信息。此处描述的索引提示与第8.9.3节“优化器提示”中描述的优化器提示不同。索引和优化器提示可以单独使用，也可以一起使用。</p><p></p><p>
            Index hints apply only to <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
            statements. (They are accepted by the parser for
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements but are ignored
            and have no effect.)
        </p><p style="color:blue;">索引提示仅适用于select语句。（它们被update语句的解析器接受，但是被忽略并且没有任何效果。）</p><p></p><p>
            Index hints are specified following a table name. (For the
            general syntax for specifying tables in a
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement, see
            <a class="xref" href="sql-syntax.html#join" title="13.2.9.2&nbsp;JOIN Syntax">Section&nbsp;13.2.9.2, “JOIN Syntax”</a>.) The syntax for referring to an
            individual table, including index hints, looks like this:
        </p><p style="color:blue;">索引提示是在表名之后指定的。（有关在select语句中指定表的一般语法，请参阅13.2.9.2节，“连接语法”。）引用单个表（包括索引提示）的语法如下所示：</p><p></p><pre data-lang="sql" class="programlisting"><em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] [<em class="replaceable"><code>index_hint_list</code></em>]

<em class="replaceable"><code>index_hint_list</code></em>:
    <em class="replaceable"><code>index_hint</code></em> [<em class="replaceable"><code>index_hint</code></em>] ...

<em class="replaceable"><code>index_hint</code></em>:
    USE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] ([<em class="replaceable"><code>index_list</code></em>])
  | {IGNORE|FORCE} {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] (<em class="replaceable"><code>index_list</code></em>)

<em class="replaceable"><code>index_list</code></em>:
    <em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...
</pre><p>
            The <code class="literal">USE INDEX
            (<em class="replaceable"><code>index_list</code></em>)</code> hint tells
            MySQL to use only one of the named indexes to find rows in the
            table. The alternative syntax <code class="literal">IGNORE INDEX
            (<em class="replaceable"><code>index_list</code></em>)</code> tells MySQL to
            not use some particular index or indexes. These hints are useful
            if <a class="link" href="sql-syntax.html#explain" title="13.8.2&nbsp;EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a> shows that MySQL is
            using the wrong index from the list of possible indexes.
        </p><p style="color:blue;">use index（index_list）提示告诉mysql只使用一个命名索引来查找表中的行。另一种语法ignore index（index_list）告诉mysql不要使用某些特定的索引。如果explain显示mysql从可能的索引列表中使用了错误的索引，那么这些提示非常有用。</p><p></p><p>
            The <code class="literal">FORCE INDEX</code> hint acts like <code class="literal">USE
            INDEX (<em class="replaceable"><code>index_list</code></em>)</code>, with
            the addition that a table scan is assumed to be
            <span class="emphasis"><em>very</em></span> expensive. In other words, a table
            scan is used only if there is no way to use one of the named
            indexes to find rows in the table.
        </p><p style="color:blue;">force index提示的作用类似于use index（index_list），另外还假设表扫描非常昂贵。换句话说，只有在无法使用命名索引之一查找表中的行时，才使用表扫描。</p><p></p><p>
            Each hint requires index names, not column names. To refer to a
            primary key, use the name <code class="literal">PRIMARY</code>. To see the
            index names for a table, use the <a class="link" href="sql-syntax.html#show-index" title="13.7.5.22&nbsp;SHOW INDEX Syntax"><code class="literal">SHOW
            INDEX</code></a> statement or the
            <a class="link" href="information-schema.html#statistics-table" title="24.24&nbsp;The INFORMATION_SCHEMA STATISTICS Table"><code class="literal">INFORMATION_SCHEMA.STATISTICS</code></a>
            table.
        </p><p style="color:blue;">每个提示都需要索引名，而不是列名。要引用主键，请使用名称primary。若要查看表的索引名，请使用show index语句或information\u schema.statistics表。</p><p></p><p>
            An <em class="replaceable"><code>index_name</code></em> value need not be a
            full index name. It can be an unambiguous prefix of an index
            name. If a prefix is ambiguous, an error occurs.
        </p><p style="color:blue;">索引名值不必是完整的索引名。它可以是索引名的明确前缀。如果前缀不明确，则会发生错误。</p><p></p><p>
            Examples:
        </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM table1 USE INDEX (col1_index,col2_index)
  WHERE col1=1 AND col2=2 AND col3=3;

SELECT * FROM table1 IGNORE INDEX (col3_index)
  WHERE col1=1 AND col2=2 AND col3=3;
</pre><p>
            The syntax for index hints has the following characteristics:
        </p><p style="color:blue;">索引提示的语法具有以下特征：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    It is syntactically valid to omit
                    <em class="replaceable"><code>index_list</code></em> for <code class="literal">USE
                    INDEX</code>, which means <span class="quote">“<span class="quote">use no indexes.</span>”</span>
                    Omitting <em class="replaceable"><code>index_list</code></em> for
                    <code class="literal">FORCE INDEX</code> or <code class="literal">IGNORE
                    INDEX</code> is a syntax error.
                </p><p style="color:blue;">省略索引列表以使用索引在语法上是有效的，这意味着“不使用索引”。省略索引列表以使用强制索引或忽略索引是语法错误。</p><p></p></li><li class="listitem"><p>
                    You can specify the scope of an index hint by adding a
                    <code class="literal">FOR</code> clause to the hint. This provides
                    more fine-grained control over optimizer selection of an
                    execution plan for various phases of query processing. To
                    affect only the indexes used when MySQL decides how to find
                    rows in the table and how to process joins, use <code class="literal">FOR
                    JOIN</code>. To influence index usage for sorting or
                    grouping rows, use <code class="literal">FOR ORDER BY</code> or
                    <code class="literal">FOR GROUP BY</code>.
                </p><p style="color:blue;">可以通过向提示中添加for子句来指定索引提示的范围。这为查询处理的各个阶段的执行计划的优化器选择提供了更细粒度的控制。要仅影响mysql决定如何在表中查找行以及如何处理联接时使用的索引，请使用for join。要影响排序或分组行的索引使用，请使用for order by或for group by。</p><p></p></li><li class="listitem"><p>
                    You can specify multiple index hints:
                </p><p style="color:blue;">可以指定多个索引提示：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX FOR ORDER BY (i2) ORDER BY a;
</pre><p>
                    It is not an error to name the same index in several hints
                    (even within the same hint):
                </p><p style="color:blue;">在多个提示中命名同一索引（即使在同一提示中）也不是错误的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 USE INDEX (i1) USE INDEX (i1,i1);
</pre><p>
                    However, it is an error to mix <code class="literal">USE INDEX</code>
                    and <code class="literal">FORCE INDEX</code> for the same table:
                </p><p style="color:blue;">但是，对于同一个表混合使用索引和强制索引是错误的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 USE INDEX FOR JOIN (i1) FORCE INDEX FOR JOIN (i2);
</pre></li></ul>
            </div>
            <p>
                If an index hint includes no <code class="literal">FOR</code> clause, the
                scope of the hint is to apply to all parts of the statement. For
                example, this hint:
            </p><p style="color:blue;">如果索引提示包含no for子句，则提示的范围将应用于语句的所有部分。例如，此提示：</p><p></p><pre data-lang="sql" class="programlisting">IGNORE INDEX (i1)
</pre><p>
            is equivalent to this combination of hints:
        </p><p style="color:blue;">相当于以下提示的组合：</p><p></p><pre data-lang="sql" class="programlisting">IGNORE INDEX FOR JOIN (i1)
IGNORE INDEX FOR ORDER BY (i1)
IGNORE INDEX FOR GROUP BY (i1)
</pre><p>
            In MySQL 5.0, hint scope with no <code class="literal">FOR</code> clause
            was to apply only to row retrieval. To cause the server to use
            this older behavior when no <code class="literal">FOR</code> clause is
            present, enable the <a class="link" href="server-administration.html#sysvar_old"><code class="literal">old</code></a> system
            variable at server startup. Take care about enabling this
            variable in a replication setup. With statement-based binary
            logging, having different modes for the master and slaves might
            lead to replication errors.
        </p><p style="color:blue;">在mysql 5.0中，没有for子句的提示作用域只应用于行检索。若要使服务器在不存在for子句时使用此旧行为，请在服务器启动时启用旧系统变量。请注意在复制设置中启用此变量。对于基于语句的二进制日志记录，主服务器和从服务器使用不同的模式可能会导致复制错误。</p><p></p><p>
            When index hints are processed, they are collected in a single
            list by type (<code class="literal">USE</code>, <code class="literal">FORCE</code>,
            <code class="literal">IGNORE</code>) and by scope (<code class="literal">FOR
            JOIN</code>, <code class="literal">FOR ORDER BY</code>, <code class="literal">FOR
            GROUP BY</code>). For example:
        </p><p style="color:blue;">当处理索引提示时，它们按类型（use、force、ignore）和范围（对于join、order by、group by）收集在单个列表中。例如：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
  USE INDEX () IGNORE INDEX (i2) USE INDEX (i1) USE INDEX (i2);
</pre><p>
            is equivalent to:
        </p><p style="color:blue;">相当于：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1
   USE INDEX (i1,i2) IGNORE INDEX (i2);
</pre><p>
            The index hints then are applied for each scope in the following
            order:
        </p><p style="color:blue;">然后按以下顺序为每个作用域应用索引提示：</p><p></p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
                    <code class="literal">{USE|FORCE} INDEX</code> is applied if present.
                    (If not, the optimizer-determined set of indexes is used.)
                </p><p style="color:blue;">{use force}索引将应用（如果存在）。（如果没有，则使用优化器确定的索引集。）</p><p></p></li><li class="listitem"><p>
                    <code class="literal">IGNORE INDEX</code> is applied over the result
                    of the previous step. For example, the following two queries
                    are equivalent:
                </p><p style="color:blue;">忽略索引应用于上一步的结果。例如，以下两个查询是等效的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX (i2) USE INDEX (i2);

SELECT * FROM t1 USE INDEX (i1);
</pre></li></ol>
            </div>
            <p>
                For <code class="literal">FULLTEXT</code> searches, index hints work as
                follows:
            </p><p style="color:blue;">对于全文搜索，索引提示的工作方式如下：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For natural language mode searches, index hints are silently
                    ignored. For example, <code class="literal">IGNORE INDEX(i1)</code> is
                    ignored with no warning and the index is still used.
                </p><p style="color:blue;">对于自然语言模式搜索，索引提示将被忽略。例如，忽略索引（i1）而不发出警告，并且索引仍在使用。</p><p></p></li><li class="listitem"><p>
                    For boolean mode searches, index hints with <code class="literal">FOR
                    ORDER BY</code> or <code class="literal">FOR GROUP BY</code> are
                    silently ignored. Index hints with <code class="literal">FOR
                    JOIN</code> or no <code class="literal">FOR</code> modifier are
                    honored. In contrast to how hints apply for
                    non-<code class="literal">FULLTEXT</code> searches, the hint is used
                    for all phases of query execution (finding rows and
                    retrieval, grouping, and ordering). This is true even if the
                    hint is given for a non-<code class="literal">FULLTEXT</code> index.
                </p><p style="color:blue;">对于布尔模式搜索，带有for order by或for group by的索引提示将被忽略。使用for join或no for修饰符的索引提示将被接受。与提示如何应用于非全文搜索不同，提示用于查询执行的所有阶段（查找行和检索、分组和排序）。即使为非全文索引提供了提示，这也是正确的。</p><p></p><p>
                    For example, the following two queries are equivalent:
                </p><p style="color:blue;">例如，以下两个查询是等效的：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM t
  USE INDEX (index1)
  IGNORE INDEX (index1) FOR ORDER BY
  IGNORE INDEX (index1) FOR GROUP BY
  WHERE ... IN BOOLEAN MODE ... ;

SELECT * FROM t
  USE INDEX (index1)
  WHERE ... IN BOOLEAN MODE ... ;
</pre></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="cost-model"></a>8.9.5&nbsp;The Optimizer Cost Model</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286870252784"></a><a class="indexterm" name="idm140286870251328"></a><p>
            To generate execution plans, the optimizer uses a cost model
            that is based on estimates of the cost of various operations
            that occur during query execution. The optimizer has a set of
            compiled-in default <span class="quote">“<span class="quote">cost constants</span>”</span> available to
            it to make decisions regarding execution plans.
        </p><p style="color:blue;">为了生成执行计划，优化器使用一个成本模型，该模型基于对查询执行期间发生的各种操作的成本估计。优化器有一组默认编译的“成本常量”可供其进行有关执行计划的决策。</p><p></p><p>
            The optimizer also has a database of cost estimates to use
            during execution plan construction. These estimates are stored
            in the <code class="literal">server_cost</code> and
            <code class="literal">engine_cost</code> tables in the
            <code class="literal">mysql</code> system database and are configurable at
            any time. The intent of these tables is to make it possible to
            easily adjust the cost estimates that the optimizer uses when it
            attempts to arrive at query execution plans.
        </p><p style="color:blue;">优化器还有一个成本估算数据库，可以在执行计划构建期间使用。这些估计值存储在mysql系统数据库的server_cost和engine_cost表中，可以随时配置。这些表的目的是使优化器在尝试到达查询执行计划时能够轻松地调整使用的成本估算。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#cost-model-operation" title="Cost Model General Operation">Cost Model General Operation</a></p><p style="color:blue;">一般作业成本模型</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#cost-model-database" title="The Cost Model Database">The Cost Model Database</a></p><p style="color:blue;">成本模型数据库</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#cost-model-database-modifications" title="Making Changes to the Cost Model Database">Making Changes to the Cost Model Database</a></p><p style="color:blue;">更改成本模型数据库</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="cost-model-operation"></a>Cost Model General Operation</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The configurable optimizer cost model works like this:
                </p><p style="color:blue;">可配置优化器成本模型的工作方式如下：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The server reads the cost model tables into memory at
                        startup and uses the in-memory values at runtime. Any
                        non-<code class="literal">NULL</code> cost estimate specified in the
                        tables takes precedence over the corresponding compiled-in
                        default cost constant. Any <code class="literal">NULL</code>
                        estimate indicates to the optimizer to use the compiled-in
                        default.
                    </p><p style="color:blue;">服务器在启动时将成本模型表读入内存，并在运行时使用内存中的值。表中指定的任何非空成本估算都优先于相应的默认成本常数编译。任何空估计值都指示优化器使用默认编译的。</p><p></p></li><li class="listitem"><p>
                        At runtime, the server may reread the cost tables. This
                        occurs when a storage engine is dynamically loaded or when
                        a <a class="link" href="sql-syntax.html#flush-optimizer-costs"><code class="literal">FLUSH OPTIMIZER_COSTS</code></a>
                        statement is executed.
                    </p><p style="color:blue;">在运行时，服务器可以重新读取成本表。当动态加载存储引擎或执行刷新优化器成本语句时，会发生这种情况。</p><p></p></li><li class="listitem"><p>
                        Cost tables enable server administrators to easily adjust
                        cost estimates by changing entries in the tables. It is
                        also easy to revert to a default by setting an entry's
                        cost to <code class="literal">NULL</code>. The optimizer uses the
                        in-memory cost values, so changes to the tables should be
                        followed by <a class="link" href="sql-syntax.html#flush-optimizer-costs"><code class="literal">FLUSH
                        OPTIMIZER_COSTS</code></a> to take effect.
                    </p><p style="color:blue;">成本表使服务器管理员能够通过更改表中的条目轻松调整成本估算。通过将条目的成本设置为空，也很容易恢复为默认值。优化器使用内存中的成本值，因此对表所做的更改之后应该有flush optimizer_costs才能生效。</p><p></p></li><li class="listitem"><p>
                        The in-memory cost estimates that are current when a
                        client session begins apply throughout that session until
                        it ends. In particular, if the server rereads the cost
                        tables, any changed estimates apply only to subsequently
                        started sessions. Existing sessions are unaffected.
                    </p><p style="color:blue;">客户机会话开始时的内存内成本估计值在整个会话期间一直应用到会话结束。特别是，如果服务器重新读取成本表，则任何更改的估计值仅适用于随后启动的会话。现有会话不受影响。</p><p></p></li><li class="listitem"><p>
                        Cost tables are specific to a given server instance. The
                        server does not replicate cost table changes to
                        replication slaves.
                    </p><p style="color:blue;">成本表特定于给定的服务器实例。服务器不会将成本表更改复制到复制从属服务器。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="cost-model-database"></a>The Cost Model Database</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The optimizer cost model database consists of two tables in
                    the <code class="literal">mysql</code> system database that contain cost
                    estimate information for operations that occur during query
                    execution:
                </p><p style="color:blue;">优化器成本模型数据库由mysql系统数据库中的两个表组成，其中包含查询执行期间发生的操作的成本估算信息：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="indexterm" name="idm140286870226800"></a>

                        <a class="indexterm" name="idm140286870225312"></a>

                        <code class="literal">server_cost</code>: Optimizer cost estimates
                        for general server operations
                    </p><p style="color:blue;">服务器成本：一般服务器操作的优化器成本估计</p><p></p></li><li class="listitem"><p>
                        <a class="indexterm" name="idm140286870222272"></a>

                        <a class="indexterm" name="idm140286870220784"></a>

                        <code class="literal">engine_cost</code>: Optimizer cost estimates
                        for operations specific to particular storage engines
                    </p><p style="color:blue;">引擎成本：针对特定存储引擎的操作的优化器成本估计</p><p></p></li></ul>
                </div>
                <p>
                    The <code class="literal">server_cost</code> table contains these
                    columns:
                </p><p style="color:blue;">服务器成本表包含以下列：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">cost_name</code>
                    </p><p style="color:blue;">成本名称</p><p></p><p>
                        The name of a cost estimate used in the cost model. The
                        name is not case-sensitive. If the server does not
                        recognize the cost name when it reads this table, it
                        writes a warning to the error log.
                    </p><p style="color:blue;">成本模型中使用的成本估算的名称。名称不区分大小写。如果服务器在读取此表时无法识别成本名称，则会将警告写入错误日志。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">cost_value</code>
                    </p><p style="color:blue;">成本价值</p><p></p><p>
                        The cost estimate value. If the value is
                        non-<code class="literal">NULL</code>, the server uses it as the
                        cost. Otherwise, it uses the default estimate (the
                        compiled-in value). DBAs can change a cost estimate by
                        updating this column. If the server finds that the cost
                        value is invalid (nonpositive) when it reads this table,
                        it writes a warning to the error log.
                    </p><p style="color:blue;">成本估算值。如果该值不为空，服务器将使用该值作为开销。否则，它将使用默认估计值（compiled in值）。DBA可以通过更新此列来更改成本估算。如果服务器在读取此表时发现成本值无效（非正），则会将警告写入错误日志。</p><p></p><p>
                        To override a default cost estimate (for an entry that
                        specifies <code class="literal">NULL</code>), set the cost to a
                        non-<code class="literal">NULL</code> value. To revert to the
                        default, set the value to <code class="literal">NULL</code>. Then
                        execute <a class="link" href="sql-syntax.html#flush-optimizer-costs"><code class="literal">FLUSH
                        OPTIMIZER_COSTS</code></a> to tell the server to reread the
                        cost tables.
                    </p><p style="color:blue;">要覆盖默认成本估算（对于指定为空的条目），请将成本设置为非空值。若要还原为默认值，请将该值设置为空。然后执行flush optimizer_costs命令服务器重新读取成本表。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">last_update</code>
                    </p><p style="color:blue;">上次更新</p><p></p><p>
                        The time of the last row update.
                    </p><p style="color:blue;">最后一行更新的时间。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">comment</code>
                    </p><p style="color:blue;">评论</p><p></p><p>
                        A descriptive comment associated with the cost estimate.
                        DBAs can use this column to provide information about why
                        a cost estimate row stores a particular value.
                    </p><p style="color:blue;">与成本估算相关的描述性注释。DBA可以使用此列提供有关成本估算行存储特定值的原因的信息。</p><p></p></li></ul>
                </div>
                <p>
                    The primary key for the <code class="literal">server_cost</code> table
                    is the <code class="literal">cost_name</code> column, so it is not
                    possible to create multiple entries for any cost estimate.
                </p><p style="color:blue;">服务器成本表的主键是“成本名称”列，因此无法为任何成本估算创建多个条目。</p><p></p><p>
                The server recognizes these <code class="literal">cost_name</code>
                values for the <code class="literal">server_cost</code> table:
            </p><p style="color:blue;">服务器识别服务器成本表的这些成本名称值：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">disk_temptable_create_cost</code> (default
                        40.0), <code class="literal">disk_temptable_row_cost</code> (default
                        1.0)
                    </p><p style="color:blue;">磁盘诱惑成本（默认值40.0）、磁盘诱惑成本（默认值1.0）</p><p></p><p>
                        The cost estimates for internally created temporary tables
                        stored in a disk-based storage engine (either
                        <code class="literal">InnoDB</code> or <code class="literal">MyISAM</code>).
                        Increasing these values increases the cost estimate of
                        using internal temporary tables and makes the optimizer
                        prefer query plans with less use of them. For information
                        about such tables, see
                        <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4&nbsp;Internal Temporary Table Use in MySQL">Section&nbsp;8.4.4, “Internal Temporary Table Use in MySQL”</a>.
                    </p><p style="color:blue;">存储在基于磁盘的存储引擎（innodb或myisam）中的内部创建的临时表的成本估计。增加这些值会增加使用内部临时表的成本估算，并使优化器更喜欢使用较少的查询计划。有关此类表的信息，请参阅8.4.4节“MySQL中的内部临时表使用”。</p><p></p><p>
                        The larger default values for these disk parameters
                        compared to the default values for the corresponding
                        memory parameters
                        (<code class="literal">memory_temptable_create_cost</code>,
                        <code class="literal">memory_temptable_row_cost</code>) reflects the
                        greater cost of processing disk-based tables.
                    </p><p style="color:blue;">这些磁盘参数的默认值比相应内存参数的默认值（内存创建成本、内存行成本）大，反映了处理基于磁盘的表的更大成本。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">key_compare_cost</code> (default 0.1)
                    </p><p style="color:blue;">键比较成本（默认为0.1）</p><p></p><a class="indexterm" name="idm140286870190544"></a><a class="indexterm" name="idm140286870189472"></a><p>
                        The cost of comparing record keys. Increasing this value
                        causes a query plan that compares many keys to become more
                        expensive. For example, a query plan that performs a
                        <code class="literal">filesort</code> becomes relatively more
                        expensive compared to a query plan that avoids sorting by
                        using an index.
                    </p><p style="color:blue;">比较记录键的成本。增加这个值会导致比较许多键的查询计划变得更加昂贵。例如，与避免使用索引进行排序的查询计划相比，执行文件排序的查询计划变得相对昂贵。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">memory_temptable_create_cost</code> (default
                        2.0), <code class="literal">memory_temptable_row_cost</code>
                        (default 0.2)
                    </p><p style="color:blue;">内存可诱惑创建成本（默认值2.0），内存可诱惑行成本（默认值0.2）</p><p></p><p>
                        The cost estimates for internally created temporary tables
                        stored in the <code class="literal">MEMORY</code> storage engine.
                        Increasing these values increases the cost estimate of
                        using internal temporary tables and makes the optimizer
                        prefer query plans with less use of them. For information
                        about such tables, see
                        <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4&nbsp;Internal Temporary Table Use in MySQL">Section&nbsp;8.4.4, “Internal Temporary Table Use in MySQL”</a>.
                    </p><p style="color:blue;">存储在内存存储引擎中的内部创建的临时表的成本估计。增加这些值会增加使用内部临时表的成本估算，并使优化器更喜欢使用较少的查询计划。有关此类表的信息，请参阅8.4.4节“MySQL中的内部临时表使用”。</p><p></p><p>
                        The smaller default values for these memory parameters
                        compared to the default values for the corresponding disk
                        parameters (<code class="literal">disk_temptable_create_cost</code>,
                        <code class="literal">disk_temptable_row_cost</code>) reflects the
                        lesser cost of processing memory-based tables.
                    </p><p style="color:blue;">这些内存参数的默认值小于相应磁盘参数的默认值（磁盘创建成本、磁盘行成本），这反映了处理基于内存的表的成本较低。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">row_evaluate_cost</code> (default 0.2)
                    </p><p style="color:blue;">行评估成本（默认为0.2）</p><p></p><p>
                        The cost of evaluating record conditions. Increasing this
                        value causes a query plan that examines many rows to
                        become more expensive compared to a query plan that
                        examines fewer rows. For example, a table scan becomes
                        relatively more expensive compared to a range scan that
                        reads fewer rows.
                    </p><p style="color:blue;">评估记录条件的成本。与检查较少行的查询计划相比，增加此值会导致检查许多行的查询计划变得更昂贵。例如，与读取较少行的范围扫描相比，表扫描变得相对更昂贵。</p><p></p></li></ul>
                </div>
                <p>
                    The <code class="literal">engine_cost</code> table contains these
                    columns:
                </p><p style="color:blue;">引擎成本表包含以下列：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">engine_name</code>
                    </p><p style="color:blue;">发动机名称</p><p></p><p>
                        The name of the storage engine to which this cost estimate
                        applies. The name is not case-sensitive. If the value is
                        <code class="literal">default</code>, it applies to all storage
                        engines that have no named entry of their own. If the
                        server does not recognize the engine name when it reads
                        this table, it writes a warning to the error log.
                    </p><p style="color:blue;">此成本估算适用的存储引擎的名称。名称不区分大小写。如果该值为默认值，则它将应用于没有自己的命名条目的所有存储引擎。如果服务器在读取此表时无法识别引擎名称，则会将警告写入错误日志。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">device_type</code>
                    </p><p style="color:blue;">设备类型</p><p></p><p>
                        The device type to which this cost estimate applies. The
                        column is intended for specifying different cost estimates
                        for different storage device types, such as hard disk
                        drives versus solid state drives. Currently, this
                        information is not used and 0 is the only permitted value.
                    </p><p style="color:blue;">此成本估算适用的设备类型。该列旨在为不同的存储设备类型（如硬盘驱动器和固态驱动器）指定不同的成本估算。目前，不使用此信息，0是唯一允许的值。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">cost_name</code>
                    </p><p style="color:blue;">成本名称</p><p></p><p>
                        Same as in the <code class="literal">server_cost</code> table.
                    </p><p style="color:blue;">与服务器成本表中的相同。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">cost_value</code>
                    </p><p style="color:blue;">成本价值</p><p></p><p>
                        Same as in the <code class="literal">server_cost</code> table.
                    </p><p style="color:blue;">与服务器成本表中的相同。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">last_update</code>
                    </p><p style="color:blue;">上次更新</p><p></p><p>
                        Same as in the <code class="literal">server_cost</code> table.
                    </p><p style="color:blue;">与服务器成本表中的相同。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">comment</code>
                    </p><p style="color:blue;">评论</p><p></p><p>
                        Same as in the <code class="literal">server_cost</code> table.
                    </p><p style="color:blue;">与服务器成本表中的相同。</p><p></p></li></ul>
                </div>
                <p>
                    The primary key for the <code class="literal">engine_cost</code> table
                    is a tuple comprising the (<code class="literal">cost_name</code>,
                    <code class="literal">engine_name</code>,
                    <code class="literal">device_type</code>) columns, so it is not possible
                    to create multiple entries for any combination of values in
                    those columns.
                </p><p style="color:blue;">engine_cost表的主键是包含（cost_name、engine_name、device_type）列的元组，因此无法为这些列中的任何值组合创建多个条目。</p><p></p><p>
                The server recognizes these <code class="literal">cost_name</code>
                values for the <code class="literal">engine_cost</code> table:
            </p><p style="color:blue;">服务器识别引擎成本表的这些成本名称值：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <code class="literal">io_block_read_cost</code> (default 1.0)
                    </p><p style="color:blue;">IO U块读取成本（默认为1.0）</p><p></p><p>
                        The cost of reading an index or data block from disk.
                        Increasing this value causes a query plan that reads many
                        disk blocks to become more expensive compared to a query
                        plan that reads fewer disk blocks. For example, a table
                        scan becomes relatively more expensive compared to a range
                        scan that reads fewer blocks.
                    </p><p style="color:blue;">从磁盘读取索引或数据块的成本。与读取较少磁盘块的查询计划相比，增加此值会导致读取许多磁盘块的查询计划变得更昂贵。例如，与读取较少块的范围扫描相比，表扫描变得相对更昂贵。</p><p></p></li><li class="listitem"><p>
                        <code class="literal">memory_block_read_cost</code> (default 1.0)
                    </p><p style="color:blue;">内存块读取成本（默认为1.0）</p><p></p><p>
                        Similar to <code class="literal">io_block_read_cost</code>, but
                        represents the cost of reading an index or data block from
                        an in-memory database buffer.
                    </p><p style="color:blue;">类似于io_block_read_cost，但表示从内存中的数据库缓冲区读取索引或数据块的成本。</p><p></p></li></ul>
                </div>
                <p>
                    If the <code class="literal">io_block_read_cost</code> and
                    <code class="literal">memory_block_read_cost</code> values differ, the
                    execution plan may change between two runs of the same query.
                    Suppose that the cost for memory access is less than the cost
                    for disk access. In that case, at server startup before data
                    has been read into the buffer pool, you may get a different
                    plan than after the query has been run because then the data
                    will be in memory.
                </p><p style="color:blue;">如果io_block_read_cost和memory_block_read_cost值不同，则在同一查询的两次运行之间，执行计划可能会改变。假设内存访问的成本小于磁盘访问的成本。在这种情况下，在将数据读入缓冲池之前的服务器启动时，您可能会得到一个不同于运行查询之后的计划，因为数据将在内存中。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="cost-model-database-modifications"></a>Making Changes to the Cost Model Database</h4>

                        </div>

                    </div>

                </div>
                <p>
                    For DBAs who wish to change the cost model parameters from
                    their defaults, try doubling or halving the value and
                    measuring the effect.
                </p><p style="color:blue;">对于希望从默认值更改成本模型参数的dba，尝试将该值加倍或减半并测量其效果。</p><p></p><p>
                Changes to the <code class="literal">io_block_read_cost</code> and
                <code class="literal">memory_block_read_cost</code> parameters are most
                likely to yield worthwhile results. These parameter values
                enable cost models for data access methods to take into
                account the costs of reading information from different
                sources; that is, the cost of reading information from disk
                versus reading information already in a memory buffer. For
                example, all other things being equal, setting
                <code class="literal">io_block_read_cost</code> to a value larger than
                <code class="literal">memory_block_read_cost</code> causes the optimizer
                to prefer query plans that read information already held in
                memory to plans that must read from disk.
            </p><p style="color:blue;">对io_block_read_cost和memory_block_read_cost参数的更改最有可能产生有价值的结果。这些参数值使数据访问方法的成本模型能够考虑从不同来源读取信息的成本；也就是说，从磁盘读取信息的成本与读取已在内存缓冲区中的信息的成本。例如，在所有其他条件相同的情况下，将IO块读取成本设置为大于内存块读取成本的值会导致优化器更喜欢读取已保存在内存中的信息的查询计划，而不是必须从磁盘读取的计划。</p><p></p><p>
                This example shows how to change the default value for
                <code class="literal">io_block_read_cost</code>:
            </p><p style="color:blue;">此示例显示如何更改IO块读取成本的默认值：</p><p></p><pre data-lang="sql" class="programlisting">UPDATE mysql.engine_cost
  SET cost_value = 2.0
  WHERE cost_name = 'io_block_read_cost';
FLUSH OPTIMIZER_COSTS;
</pre><p>
                This example shows how to change the value of
                <code class="literal">io_block_read_cost</code> only for the
                <code class="literal">InnoDB</code> storage engine:
            </p><p style="color:blue;">这个例子展示了如何更改innodb存储引擎的io_block_read_cost的值：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO mysql.engine_cost
  VALUES ('InnoDB', 0, 'io_block_read_cost', 3.0,
  CURRENT_TIMESTAMP, 'Using a slower disk for InnoDB');
FLUSH OPTIMIZER_COSTS;
</pre>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="buffering-caching"></a>8.10&nbsp;Buffering and Caching</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#innodb-buffer-pool-optimization">8.10.1 InnoDB Buffer Pool Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">8.10.2 The MyISAM Key Cache</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache">8.10.3 The MySQL Query Cache</a></span></dt><dt><span class="section"><a href="optimization.html#statement-caching">8.10.4 Caching of Prepared Statements and Stored Programs</a></span></dt></dl>
        </div>
        <p>
            MySQL uses several strategies that cache information in memory
            buffers to increase performance.
        </p><p style="color:blue;">mysql使用几种策略将信息缓存在内存缓冲区中以提高性能。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="innodb-buffer-pool-optimization"></a>8.10.1&nbsp;InnoDB Buffer Pool Optimization</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286870132944"></a><a class="indexterm" name="idm140286870131872"></a><a class="indexterm" name="idm140286870130800"></a><p>
            <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> maintains a storage area
            called the <a class="link" href="glossary.html#glos_buffer_pool" title="buffer pool">buffer pool</a>
            for caching data and indexes in memory. Knowing how the
            <code class="literal">InnoDB</code> buffer pool works, and taking
            advantage of it to keep frequently accessed data in memory, is
            an important aspect of MySQL tuning.
        </p><p style="color:blue;">innodb维护一个名为缓冲池的存储区域，用于缓存内存中的数据和索引。了解innodb缓冲池的工作原理，并利用它将频繁访问的数据保存在内存中，是mysql调优的一个重要方面。</p><p></p><p>
            For an explanation of the inner workings of the
            <code class="literal">InnoDB</code> buffer pool, an overview of its LRU
            replacement algorithm, and general configuration information,
            see <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="14.5.1&nbsp;Buffer Pool">Section&nbsp;14.5.1, “Buffer Pool”</a>.
        </p><p style="color:blue;">有关InnoDB缓冲池内部工作原理的说明、其LRU替换算法的概述和一般配置信息，请参阅第14.5.1节“缓冲池”。</p><p></p><p>
            For additional <code class="literal">InnoDB</code> buffer pool
            configuration and tuning information, see these sections:
        </p><p style="color:blue;">有关innodb缓冲池配置和调优的更多信息，请参阅以下部分：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.8.3.4&nbsp;Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)">Section&nbsp;14.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>
                </p><p style="color:blue;">第14.8.3.4节，“配置InnoDB缓冲池预取（预读）”</p><p></p></li><li class="listitem"><p>
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-flushing" title="14.8.3.5&nbsp;Configuring Buffer Pool Flushing">Section&nbsp;14.8.3.5, “Configuring Buffer Pool Flushing”</a>
                </p><p style="color:blue;">第14.8.3.5节，“配置缓冲池冲洗”</p><p></p></li><li class="listitem"><p>
                    <a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="14.8.3.3&nbsp;Making the Buffer Pool Scan Resistant">Section&nbsp;14.8.3.3, “Making the Buffer Pool Scan Resistant”</a>
                </p><p style="color:blue;">第14.8.3.3节，“使缓冲池抗扫描”</p><p></p></li><li class="listitem"><p>
                    <a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="14.8.3.2&nbsp;Configuring Multiple Buffer Pool Instances">Section&nbsp;14.8.3.2, “Configuring Multiple Buffer Pool Instances”</a>
                </p><p style="color:blue;">第14.8.3.2节，“配置多个缓冲池实例”</p><p></p></li><li class="listitem"><p>
                    <a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.8.3.6&nbsp;Saving and Restoring the Buffer Pool State">Section&nbsp;14.8.3.6, “Saving and Restoring the Buffer Pool State”</a>
                </p><p style="color:blue;">第14.8.3.6节，“保存和恢复缓冲池状态”</p><p></p></li><li class="listitem"><p>
                    <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="14.8.3.1&nbsp;Configuring InnoDB Buffer Pool Size">Section&nbsp;14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a>
                </p><p style="color:blue;">第14.8.3.1节，“配置InnoDB缓冲池大小”</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="myisam-key-cache"></a>8.10.2&nbsp;The MyISAM Key Cache</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#shared-key-cache">8.10.2.1 Shared Key Cache Access</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-key-caches">8.10.2.2 Multiple Key Caches</a></span></dt><dt><span class="section"><a href="optimization.html#midpoint-insertion">8.10.2.3 Midpoint Insertion Strategy</a></span></dt><dt><span class="section"><a href="optimization.html#index-preloading">8.10.2.4 Index Preloading</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-block-size">8.10.2.5 Key Cache Block Size</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-restructuring">8.10.2.6 Restructuring a Key Cache</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286870112496"></a><a class="indexterm" name="idm140286870111424"></a><p>
            To minimize disk I/O, the <code class="literal">MyISAM</code> storage
            engine exploits a strategy that is used by many database
            management systems. It employs a cache mechanism to keep the
            most frequently accessed table blocks in memory:
        </p><p style="color:blue;">为了最小化磁盘i/o，myisam存储引擎利用了一种被许多数据库管理系统使用的策略。它使用缓存机制将最常访问的表块保留在内存中：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    For index blocks, a special structure called the
                    <span class="firstterm">key cache</span> (or
                    <span class="firstterm">key buffer</span>) is
                    maintained. The structure contains a number of block buffers
                    where the most-used index blocks are placed.
                </p><p style="color:blue;">对于索引块，将维护一个称为密钥缓存（或密钥缓冲区）的特殊结构。该结构包含许多块缓冲区，其中放置了最常用的索引块。</p><p></p></li><li class="listitem"><p>
                    For data blocks, MySQL uses no special cache. Instead it
                    relies on the native operating system file system cache.
                </p><p style="color:blue;">对于数据块，mysql不使用特殊的缓存。相反，它依赖于本机操作系统文件系统缓存。</p><p></p></li></ul>
            </div>
            <p>
                This section first describes the basic operation of the
                <code class="literal">MyISAM</code> key cache. Then it discusses features
                that improve key cache performance and that enable you to better
                control cache operation:
            </p><p style="color:blue;">本节首先介绍myisam密钥缓存的基本操作。然后讨论提高密钥缓存性能并使您能够更好地控制缓存操作的功能：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Multiple sessions can access the cache concurrently.
                </p><p style="color:blue;">多个会话可以同时访问缓存。</p><p></p></li><li class="listitem"><p>
                    You can set up multiple key caches and assign table indexes
                    to specific caches.
                </p><p style="color:blue;">可以设置多个键缓存并将表索引分配给特定缓存。</p><p></p></li></ul>
            </div>
            <p>
                To control the size of the key cache, use the
                <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> system
                variable. If this variable is set equal to zero, no key cache is
                used. The key cache also is not used if the
                <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> value is too
                small to allocate the minimal number of block buffers (8).
            </p><p style="color:blue;">要控制密钥缓存的大小，请使用KEY U BUFFER U SIZE系统变量。如果此变量设置为零，则不使用密钥缓存。如果密钥缓冲区大小值太小，无法分配最小数量的块缓冲区（8），则也不使用密钥缓存。</p><p></p><p>
            When the key cache is not operational, index files are accessed
            using only the native file system buffering provided by the
            operating system. (In other words, table index blocks are
            accessed using the same strategy as that employed for table data
            blocks.)
        </p><p style="color:blue;">当密钥缓存不可操作时，只能使用操作系统提供的本机文件系统缓冲区访问索引文件。（换句话说，使用与表数据块相同的策略访问表索引块。）</p><p></p><p>
            An index block is a contiguous unit of access to the
            <code class="literal">MyISAM</code> index files. Usually the size of an
            index block is equal to the size of nodes of the index B-tree.
            (Indexes are represented on disk using a B-tree data structure.
            Nodes at the bottom of the tree are leaf nodes. Nodes above the
            leaf nodes are nonleaf nodes.)
        </p><p style="color:blue;">索引块是访问myisam索引文件的连续单元。通常索引块的大小等于索引b树的节点大小。（索引在磁盘上使用B树数据结构表示。树底部的节点是叶节点。叶节点上方的节点是非叶节点。）</p><p></p><p>
            All block buffers in a key cache structure are the same size.
            This size can be equal to, greater than, or less than the size
            of a table index block. Usually one these two values is a
            multiple of the other.
        </p><p style="color:blue;">密钥缓存结构中的所有块缓冲区大小相同。此大小可以等于、大于或小于表索引块的大小。通常这两个值之一是另一个值的倍数。</p><p></p><p>
            When data from any table index block must be accessed, the
            server first checks whether it is available in some block buffer
            of the key cache. If it is, the server accesses data in the key
            cache rather than on disk. That is, it reads from the cache or
            writes into it rather than reading from or writing to disk.
            Otherwise, the server chooses a cache block buffer containing a
            different table index block (or blocks) and replaces the data
            there by a copy of required table index block. As soon as the
            new index block is in the cache, the index data can be accessed.
        </p><p style="color:blue;">当必须访问来自任何表索引块的数据时，服务器首先检查它是否在密钥缓存的某个块缓冲区中可用。如果是，服务器将访问密钥缓存中的数据，而不是磁盘上的数据。也就是说，它从缓存中读取或写入数据，而不是从磁盘中读取或写入数据。否则，服务器将选择包含不同表索引块的缓存块缓冲区，并用所需表索引块的副本替换其中的数据。只要新的索引块在缓存中，就可以访问索引数据。</p><p></p><p>
            If it happens that a block selected for replacement has been
            modified, the block is considered <span class="quote">“<span class="quote">dirty.</span>”</span> In this
            case, prior to being replaced, its contents are flushed to the
            table index from which it came.
        </p><p style="color:blue;">如果选择要替换的块已被修改，则该块被视为“脏的”。在这种情况下，在替换之前，其内容将刷新到它来自的表索引中。</p><p></p><p>
            Usually the server follows an <span class="firstterm">LRU
        (Least Recently Used)</span> strategy: When choosing a block
            for replacement, it selects the least recently used index block.
            To make this choice easier, the key cache module maintains all
            used blocks in a special list (<span class="firstterm">LRU
        chain</span>) ordered by time of use. When a block is
            accessed, it is the most recently used and is placed at the end
            of the list. When blocks need to be replaced, blocks at the
            beginning of the list are the least recently used and become the
            first candidates for eviction.
        </p><p style="color:blue;">通常服务器遵循lru（最近使用最少的）策略：当选择要替换的块时，它选择最近使用最少的索引块。为了使这一选择更容易，密钥缓存模块将所有使用的块维护在按使用时间排序的特殊列表（lru链）中。当访问一个块时，它是最近使用的块，并放置在列表的末尾。当需要替换块时，列表开头的块是最近使用最少的，并成为第一个要驱逐的候选块。</p><p></p><p>
            The <code class="literal">InnoDB</code> storage engine also uses an LRU
            algorithm, to manage its buffer pool. See
            <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="14.5.1&nbsp;Buffer Pool">Section&nbsp;14.5.1, “Buffer Pool”</a>.
        </p><p style="color:blue;">innodb存储引擎还使用lru算法来管理其缓冲池。见第14.5.1节“缓冲池”。</p><p></p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="shared-key-cache"></a>8.10.2.1&nbsp;Shared Key Cache Access</h4>
                        </div>
                    </div>
                </div>
                <p>
                    Threads can access key cache buffers simultaneously, subject
                    to the following conditions:
                </p><p style="color:blue;">在下列条件下，线程可以同时访问密钥缓存缓冲区：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A buffer that is not being updated can be accessed by
                        multiple sessions.
                    </p><p style="color:blue;">多个会话可以访问未更新的缓冲区。</p><p></p></li><li class="listitem"><p>
                        A buffer that is being updated causes sessions that need
                        to use it to wait until the update is complete.
                    </p><p style="color:blue;">正在更新的缓冲区导致需要使用它的会话等待更新完成。</p><p></p></li><li class="listitem"><p>
                        Multiple sessions can initiate requests that result in
                        cache block replacements, as long as they do not interfere
                        with each other (that is, as long as they need different
                        index blocks, and thus cause different cache blocks to be
                        replaced).
                    </p><p style="color:blue;">多个会话可以启动导致缓存块替换的请求，只要它们不相互干扰（也就是说，只要它们需要不同的索引块，从而导致不同的缓存块被替换）。</p><p></p></li></ul>
                </div>
                <p>
                    Shared access to the key cache enables the server to improve
                    throughput significantly.
                </p><p style="color:blue;">对密钥缓存的共享访问使服务器能够显著提高吞吐量。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="multiple-key-caches"></a>8.10.2.2&nbsp;Multiple Key Caches</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Shared access to the key cache improves performance but does
                    not eliminate contention among sessions entirely. They still
                    compete for control structures that manage access to the key
                    cache buffers. To reduce key cache access contention further,
                    MySQL also provides multiple key caches. This feature enables
                    you to assign different table indexes to different key caches.
                </p><p style="color:blue;">共享访问密钥缓存可以提高性能，但不会完全消除会话之间的争用。它们仍在争夺管理对密钥缓存缓冲区的访问的控制结构。为了进一步减少密钥缓存访问争用，mysql还提供了多个密钥缓存。此功能使您能够将不同的表索引分配给不同的键缓存。</p><p></p><p>
                Where there are multiple key caches, the server must know
                which cache to use when processing queries for a given
                <code class="literal">MyISAM</code> table. By default, all
                <code class="literal">MyISAM</code> table indexes are cached in the
                default key cache. To assign table indexes to a specific key
                cache, use the <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a>
                statement (see <a class="xref" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax">Section&nbsp;13.7.6.2, “CACHE INDEX Syntax”</a>). For example,
                the following statement assigns indexes from the tables
                <code class="literal">t1</code>, <code class="literal">t2</code>, and
                <code class="literal">t3</code> to the key cache named
                <code class="literal">hot_cache</code>:
            </p><p style="color:blue;">如果有多个密钥缓存，服务器必须知道在处理给定myisam表的查询时要使用哪个缓存。默认情况下，所有myisam表索引都缓存在默认密钥缓存中。要将表索引分配给特定的键缓存，请使用cache index语句（请参阅第13.7.6.2节“缓存索引语法”）。例如，以下语句将表T1、T2和T3中的索引分配给名为hot_cache的密钥缓存：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CACHE INDEX t1, t2, t3 IN hot_cache;</code></strong>
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
</pre><p>
                The key cache referred to in a <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE
                INDEX</code></a> statement can be created by setting its size
                with a <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                GLOBAL</code></a> parameter setting statement or by using
                server startup options. For example:
            </p><p style="color:blue;">可以通过使用set global parameter setting语句设置其大小或使用服务器启动选项来创建cache index语句中引用的密钥缓存。例如：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL keycache1.key_buffer_size=128*1024;</code></strong>
</pre><p>
                To destroy a key cache, set its size to zero:
            </p><p style="color:blue;">要销毁密钥缓存，请将其大小设置为零：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL keycache1.key_buffer_size=0;</code></strong>
</pre><p>
                You cannot destroy the default key cache. Any attempt to do
                this is ignored:
            </p><p style="color:blue;">无法销毁默认密钥缓存。任何尝试都将被忽略：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL key_buffer_size = 0;</code></strong>

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'key_buffer_size';</code></strong>
+-----------------+---------+
| Variable_name   | Value   |
+-----------------+---------+
| key_buffer_size | 8384512 |
+-----------------+---------+
</pre><p>
                Key cache variables are structured system variables that have
                a name and components. For
                <code class="literal">keycache1.key_buffer_size</code>,
                <code class="literal">keycache1</code> is the cache variable name and
                <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> is the cache
                component. See <a class="xref" href="server-administration.html#structured-system-variables" title="5.1.8.3&nbsp;Structured System Variables">Section&nbsp;5.1.8.3, “Structured System Variables”</a>,
                for a description of the syntax used for referring to
                structured key cache system variables.
            </p><p style="color:blue;">关键缓存变量是具有名称和组件的结构化系统变量。对于keycache1.key_buffer_size，keycache1是缓存变量名，key_buffer_size是缓存组件。参见第5.1.8.3节“结构化系统变量”，了解用于引用结构化密钥缓存系统变量的语法说明。</p><p></p><p>
                By default, table indexes are assigned to the main (default)
                key cache created at the server startup. When a key cache is
                destroyed, all indexes assigned to it are reassigned to the
                default key cache.
            </p><p style="color:blue;">默认情况下，表索引被分配给在服务器启动时创建的主（默认）键缓存。当密钥缓存被销毁时，分配给它的所有索引都将重新分配给默认密钥缓存。</p><p></p><p>
                For a busy server, you can use a strategy that involves three
                key caches:
            </p><p style="color:blue;">对于繁忙的服务器，可以使用包含三个密钥缓存的策略：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A <span class="quote">“<span class="quote">hot</span>”</span> key cache that takes up 20% of the
                        space allocated for all key caches. Use this for tables
                        that are heavily used for searches but that are not
                        updated.
                    </p><p style="color:blue;">一个“热”密钥缓存，占为所有密钥缓存分配的空间的20%。对于大量用于搜索但未更新的表，请使用此选项。</p><p></p></li><li class="listitem"><p>
                        A <span class="quote">“<span class="quote">cold</span>”</span> key cache that takes up 20% of the
                        space allocated for all key caches. Use this cache for
                        medium-sized, intensively modified tables, such as
                        temporary tables.
                    </p><p style="color:blue;">一个“冷”密钥缓存，占所有密钥缓存分配空间的20%。将此缓存用于中等大小、密集修改的表，例如临时表。</p><p></p></li><li class="listitem"><p>
                        A <span class="quote">“<span class="quote">warm</span>”</span> key cache that takes up 60% of the
                        key cache space. Employ this as the default key cache, to
                        be used by default for all other tables.
                    </p><p style="color:blue;">一个“热”密钥缓存，占密钥缓存空间的60%。将其用作默认密钥缓存，默认情况下用于所有其他表。</p><p></p></li></ul>
                </div>
                <p>
                    One reason the use of three key caches is beneficial is that
                    access to one key cache structure does not block access to the
                    others. Statements that access tables assigned to one cache do
                    not compete with statements that access tables assigned to
                    another cache. Performance gains occur for other reasons as
                    well:
                </p><p style="color:blue;">使用三个密钥缓存的一个好处是，对一个密钥缓存结构的访问不会阻止对其他密钥缓存结构的访问。访问分配给一个缓存的表的语句与访问分配给另一个缓存的表的语句不竞争。业绩增长也有其他原因：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The hot cache is used only for retrieval queries, so its
                        contents are never modified. Consequently, whenever an
                        index block needs to be pulled in from disk, the contents
                        of the cache block chosen for replacement need not be
                        flushed first.
                    </p><p style="color:blue;">热缓存仅用于检索查询，因此其内容从不被修改。因此，每当需要从磁盘中提取索引块时，不必首先刷新选定要替换的缓存块的内容。</p><p></p></li><li class="listitem"><p>
                        For an index assigned to the hot cache, if there are no
                        queries requiring an index scan, there is a high
                        probability that the index blocks corresponding to nonleaf
                        nodes of the index B-tree remain in the cache.
                    </p><p style="color:blue;">对于分配给热缓存的索引，如果没有需要索引扫描的查询，则与索引b树的非叶节点相对应的索引块很可能保留在缓存中。</p><p></p></li><li class="listitem"><p>
                        An update operation most frequently executed for temporary
                        tables is performed much faster when the updated node is
                        in the cache and need not be read from disk first. If the
                        size of the indexes of the temporary tables are comparable
                        with the size of cold key cache, the probability is very
                        high that the updated node is in the cache.
                    </p><p style="color:blue;">当更新的节点在缓存中且不需要首先从磁盘读取时，对临时表执行最频繁的更新操作的速度要快得多。如果临时表的索引大小与冷键缓存的大小相当，则更新的节点在缓存中的概率非常高。</p><p></p></li></ul>
                </div>
                <p>
                    The <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a> statement sets
                    up an association between a table and a key cache, but the
                    association is lost each time the server restarts. If you want
                    the association to take effect each time the server starts,
                    one way to accomplish this is to use an option file: Include
                    variable settings that configure your key caches, and an
                    <a class="link" href="server-administration.html#sysvar_init_file"><code class="literal">init_file</code></a> system variable
                    that names a file containing <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE
                    INDEX</code></a> statements to be executed. For example:
                </p><p style="color:blue;">cache index语句在表和键缓存之间建立关联，但每次服务器重新启动时，该关联都会丢失。如果希望每次服务器启动时关联都生效，则可以使用选项文件：包括配置密钥缓存的变量设置，以及命名包含要执行的缓存索引语句的文件的init_文件系统变量。例如：</p><p></p><pre data-lang="ini" class="programlisting">key_buffer_size = 4G
hot_cache.key_buffer_size = 2G
cold_cache.key_buffer_size = 2G
init_file=/<em class="replaceable"><code>path</code></em>/<em class="replaceable"><code>to</code></em>/<em class="replaceable"><code>data-directory</code></em>/mysqld_init.sql
</pre><p>
                The statements in <code class="filename">mysqld_init.sql</code> are
                executed each time the server starts. The file should contain
                one SQL statement per line. The following example assigns
                several tables each to <code class="literal">hot_cache</code> and
                <code class="literal">cold_cache</code>:
            </p><p style="color:blue;">mysqld_init.sql中的语句在每次服务器启动时执行。文件每行应包含一个SQL语句。下面的示例为热缓存和冷缓存分别分配多个表：</p><p></p><pre data-lang="sql" class="programlisting">CACHE INDEX db1.t1, db1.t2, db2.t3 IN hot_cache
CACHE INDEX db1.t4, db2.t5, db2.t6 IN cold_cache
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="midpoint-insertion"></a>8.10.2.3&nbsp;Midpoint Insertion Strategy</h4>

                        </div>

                    </div>

                </div>
                <p>
                    By default, the key cache management system uses a simple LRU
                    strategy for choosing key cache blocks to be evicted, but it
                    also supports a more sophisticated method called the
                    <span class="firstterm">midpoint insertion
          strategy.</span>
                </p><p style="color:blue;">默认情况下，密钥缓存管理系统使用一种简单的lru策略来选择要逐出的密钥缓存块，但它也支持一种称为中点插入策略的更为复杂的方法。</p><p></p><p>
                When using the midpoint insertion strategy, the LRU chain is
                divided into two parts: a hot sublist and a warm sublist. The
                division point between two parts is not fixed, but the key
                cache management system takes care that the warm part is not
                <span class="quote">“<span class="quote">too short,</span>”</span> always containing at least
                <a class="link" href="server-administration.html#sysvar_key_cache_division_limit"><code class="literal">key_cache_division_limit</code></a>
                percent of the key cache blocks.
                <a class="link" href="server-administration.html#sysvar_key_cache_division_limit"><code class="literal">key_cache_division_limit</code></a> is a
                component of structured key cache variables, so its value is a
                parameter that can be set per cache.
            </p><p style="color:blue;">在使用中点插入策略时，lru链分为两部分：热子列表和热子列表。两个部分之间的分割点不是固定的，但是密钥缓存管理系统会注意暖部分不是“太短”，总是至少包含密钥缓存块的密钥缓存分割限制百分比。key_cache_division_limit是结构化密钥缓存变量的一个组成部分，因此它的值是一个可以为每个缓存设置的参数。</p><p></p><p>
                When an index block is read from a table into the key cache,
                it is placed at the end of the warm sublist. After a certain
                number of hits (accesses of the block), it is promoted to the
                hot sublist. At present, the number of hits required to
                promote a block (3) is the same for all index blocks.
            </p><p style="color:blue;">当索引块从表读取到键缓存中时，它被放置在warm子列表的末尾。在一定数量的点击（访问块）之后，它被提升到热子列表。目前，提升一个块（3）所需的点击次数对于所有索引块都是相同的。</p><p></p><p>
                A block promoted into the hot sublist is placed at the end of
                the list. The block then circulates within this sublist. If
                the block stays at the beginning of the sublist for a long
                enough time, it is demoted to the warm sublist. This time is
                determined by the value of the
                <a class="link" href="server-administration.html#sysvar_key_cache_age_threshold"><code class="literal">key_cache_age_threshold</code></a>
                component of the key cache.
            </p><p style="color:blue;">提升到热子列表的块放在列表的末尾。然后块在这个子列表中循环。如果块在子列表的开头停留足够长的时间，则将其降级为warm子列表。此时间由密钥缓存的密钥缓存年龄阈值组件的值确定。</p><p></p><p>
                The threshold value prescribes that, for a key cache
                containing <em class="replaceable"><code>N</code></em> blocks, the block at
                the beginning of the hot sublist not accessed within the last
                <code class="literal"><em class="replaceable"><code>N</code></em> *
                    key_cache_age_threshold / 100</code> hits is to be moved to
                the beginning of the warm sublist. It then becomes the first
                candidate for eviction, because blocks for replacement always
                are taken from the beginning of the warm sublist.
            </p><p style="color:blue;">阈值规定，对于包含n个块的密钥缓存，在最后n*个密钥缓存年龄阈值/100次点击中未被访问的热子列表开始处的块将被移动到热子列表的开始处。然后它就成为第一个逐出的候选对象，因为用于替换的块总是从warm子列表的开头开始。</p><p></p><p>
                The midpoint insertion strategy enables you to keep
                more-valued blocks always in the cache. If you prefer to use
                the plain LRU strategy, leave the
                <a class="link" href="server-administration.html#sysvar_key_cache_division_limit"><code class="literal">key_cache_division_limit</code></a>
                value set to its default of 100.
            </p><p style="color:blue;">中点插入策略使您能够始终在缓存中保留更有值的块。如果您喜欢使用普通lru策略，请将key_cache_division_limit值设置为默认值100。</p><p></p><p>
                The midpoint insertion strategy helps to improve performance
                when execution of a query that requires an index scan
                effectively pushes out of the cache all the index blocks
                corresponding to valuable high-level B-tree nodes. To avoid
                this, you must use a midpoint insertion strategy with the
                <a class="link" href="server-administration.html#sysvar_key_cache_division_limit"><code class="literal">key_cache_division_limit</code></a> set
                to much less than 100. Then valuable frequently hit nodes are
                preserved in the hot sublist during an index scan operation as
                well.
            </p><p style="color:blue;">当执行需要索引扫描的查询时，中点插入策略有助于提高性能，该查询有效地将与有价值的高级b树节点对应的所有索引块从缓存中推出。为了避免这种情况，您必须使用一种中点插入策略，将key_cache_division_limit设置为远小于100。然后在索引扫描操作期间，有价值的频繁命中节点也被保存在热子列表中。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="index-preloading"></a>8.10.2.4&nbsp;Index Preloading</h4>

                        </div>

                    </div>

                </div>
                <p>
                    If there are enough blocks in a key cache to hold blocks of an
                    entire index, or at least the blocks corresponding to its
                    nonleaf nodes, it makes sense to preload the key cache with
                    index blocks before starting to use it. Preloading enables you
                    to put the table index blocks into a key cache buffer in the
                    most efficient way: by reading the index blocks from disk
                    sequentially.
                </p><p style="color:blue;">如果一个键缓存中有足够的块来保存整个索引的块，或者至少保存与其非叶节点对应的块，那么在开始使用索引块之前用索引块预加载键缓存是有意义的。预加载使您能够以最有效的方式将表索引块放入键缓存缓冲区：按顺序从磁盘读取索引块。</p><p></p><p>
                Without preloading, the blocks are still placed into the key
                cache as needed by queries. Although the blocks will stay in
                the cache, because there are enough buffers for all of them,
                they are fetched from disk in random order, and not
                sequentially.
            </p><p style="color:blue;">如果不进行预加载，查询仍会根据需要将块放置到密钥缓存中。尽管块将保留在缓存中，但由于有足够的缓冲区供所有块使用，因此它们是按随机顺序从磁盘中提取的，而不是按顺序提取的。</p><p></p><p>
                To preload an index into a cache, use the
                <a class="link" href="sql-syntax.html#load-index" title="13.7.6.5&nbsp;LOAD INDEX INTO CACHE Syntax"><code class="literal">LOAD INDEX INTO
                    CACHE</code></a> statement. For example, the following
                statement preloads nodes (index blocks) of indexes of the
                tables <code class="literal">t1</code> and <code class="literal">t2</code>:
            </p><p style="color:blue;">要将索引预加载到缓存中，请使用LOAD INDEX INTO CACHE语句。例如，以下语句预加载表T1和T2的索引节点（索引块）：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</code></strong>
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
</pre><p>
                The <code class="literal">IGNORE LEAVES</code> modifier causes only
                blocks for the nonleaf nodes of the index to be preloaded.
                Thus, the statement shown preloads all index blocks from
                <code class="literal">t1</code>, but only blocks for the nonleaf nodes
                from <code class="literal">t2</code>.
            </p><p style="color:blue;">“忽略叶”修改器只会导致预加载索引的非叶节点的块。因此，所示语句预加载来自T1的所有索引块，但仅预加载来自T2的非叶节点的块。</p><p></p><p>
                If an index has been assigned to a key cache using a
                <a class="link" href="sql-syntax.html#cache-index" title="13.7.6.2&nbsp;CACHE INDEX Syntax"><code class="literal">CACHE INDEX</code></a> statement,
                preloading places index blocks into that cache. Otherwise, the
                index is loaded into the default key cache.
            </p><p style="color:blue;">如果已使用CACHE INDEX语句将索引分配给键缓存，则预加载会将索引块放置到该缓存中。否则，索引将加载到默认密钥缓存中。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="key-cache-block-size"></a>8.10.2.5&nbsp;Key Cache Block Size</h4>

                        </div>

                    </div>

                </div>
                <p>
                    It is possible to specify the size of the block buffers for an
                    individual key cache using the
                    <a class="link" href="server-administration.html#sysvar_key_cache_block_size"><code class="literal">key_cache_block_size</code></a>
                    variable. This permits tuning of the performance of I/O
                    operations for index files.
                </p><p style="color:blue;">可以使用key-cache-block-size变量指定单个密钥缓存的块缓冲区大小。这允许调整索引文件的I/O操作的性能。</p><p></p><p>
                The best performance for I/O operations is achieved when the
                size of read buffers is equal to the size of the native
                operating system I/O buffers. But setting the size of key
                nodes equal to the size of the I/O buffer does not always
                ensure the best overall performance. When reading the big leaf
                nodes, the server pulls in a lot of unnecessary data,
                effectively preventing reading other leaf nodes.
            </p><p style="color:blue;">当读取缓冲区的大小等于本机操作系统I/O缓冲区的大小时，I/O操作将获得最佳性能。但是，将关键节点的大小设置为I/O缓冲区的大小并不总是确保最佳的总体性能。在读取大型叶节点时，服务器会拉入大量不必要的数据，有效地防止读取其他叶节点。</p><p></p><p>
                To control the size of blocks in the <code class="filename">.MYI</code>
                index file of <code class="literal">MyISAM</code> tables, use the
                <a class="link" href="server-administration.html#option_mysqld_myisam-block-size"><code class="option">--myisam-block-size</code></a> option at
                server startup.
            </p><p style="color:blue;">要控制myisam表的.myi索引文件中块的大小，请在服务器启动时使用--myisam block size选项。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="key-cache-restructuring"></a>8.10.2.6&nbsp;Restructuring a Key Cache</h4>

                        </div>

                    </div>

                </div>
                <p>
                    A key cache can be restructured at any time by updating its
                    parameter values. For example:
                </p><p style="color:blue;">密钥缓存可以随时通过更新其参数值来重新构造。例如：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL cold_cache.key_buffer_size=4*1024*1024;</code></strong>
</pre><p>
                If you assign to either the
                <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> or
                <a class="link" href="server-administration.html#sysvar_key_cache_block_size"><code class="literal">key_cache_block_size</code></a> key
                cache component a value that differs from the component's
                current value, the server destroys the cache's old structure
                and creates a new one based on the new values. If the cache
                contains any dirty blocks, the server saves them to disk
                before destroying and re-creating the cache. Restructuring
                does not occur if you change other key cache parameters.
            </p><p style="color:blue;">如果为键缓冲区大小或键缓存块大小的键缓存组件指定一个与组件当前值不同的值，服务器将破坏缓存的旧结构，并基于新值创建新结构。如果缓存包含任何脏块，服务器会在销毁和重新创建缓存之前将其保存到磁盘。如果更改其他键缓存参数，则不会发生重新构造。</p><p></p><p>
                When restructuring a key cache, the server first flushes the
                contents of any dirty buffers to disk. After that, the cache
                contents become unavailable. However, restructuring does not
                block queries that need to use indexes assigned to the cache.
                Instead, the server directly accesses the table indexes using
                native file system caching. File system caching is not as
                efficient as using a key cache, so although queries execute, a
                slowdown can be anticipated. After the cache has been
                restructured, it becomes available again for caching indexes
                assigned to it, and the use of file system caching for the
                indexes ceases.
            </p><p style="color:blue;">重新构造密钥缓存时，服务器首先将任何脏缓冲区的内容刷新到磁盘。之后，缓存内容将不可用。但是，重组不会阻止需要使用分配给缓存的索引的查询。相反，服务器使用本机文件系统缓存直接访问表索引。文件系统缓存的效率不如使用密钥缓存，因此尽管查询会执行，但速度可能会减慢。重新构造缓存后，它将再次可用于缓存分配给它的索引，并停止对索引使用文件系统缓存。</p><p></p>
            </div>

        </div>

        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="query-cache"></a>8.10.3&nbsp;The MySQL Query Cache</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#query-cache-operation">8.10.3.1 How the Query Cache Operates</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-in-select">8.10.3.2 Query Cache SELECT Options</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-configuration">8.10.3.3 Query Cache Configuration</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-status-and-maintenance">8.10.3.4 Query Cache Status and Maintenance</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286869992304"></a><a class="indexterm" name="idm140286869991232"></a>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The query cache is deprecated as of MySQL 5.7.20, and is
                    removed in MySQL 8.0.
                </p><p style="color:blue;">从mysql 5.7.20开始，查询缓存已被弃用，并在mysql 8.0中被删除。</p><p></p>
            </div>
            <p>
                The query cache stores the text of a
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement together with
                the corresponding result that was sent to the client. If an
                identical statement is received later, the server retrieves the
                results from the query cache rather than parsing and executing
                the statement again. The query cache is shared among sessions,
                so a result set generated by one client can be sent in response
                to the same query issued by another client.
            </p><p style="color:blue;">查询缓存存储select语句的文本以及发送到客户端的相应结果。如果稍后收到相同的语句，服务器将从查询缓存中检索结果，而不是再次解析和执行该语句。查询缓存在会话之间共享，因此一个客户端生成的结果集可以被发送以响应另一个客户端发出的相同查询。</p><p></p><p>
            The query cache can be useful in an environment where you have
            tables that do not change very often and for which the server
            receives many identical queries. This is a typical situation for
            many Web servers that generate many dynamic pages based on
            database content.
        </p><p style="color:blue;">查询缓存在这样一个环境中非常有用：在这种环境中，表不会经常更改，并且服务器会接收许多相同的查询。这是许多基于数据库内容生成许多动态页面的web服务器的典型情况。</p><p></p><p>
            The query cache does not return stale data. When tables are
            modified, any relevant entries in the query cache are flushed.
        </p><p style="color:blue;">查询缓存不返回过时的数据。修改表时，将刷新查询缓存中的所有相关项。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The query cache does not work in an environment where you have
                    multiple <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> servers updating the same
                    <code class="literal">MyISAM</code> tables.
                </p><p style="color:blue;">在有多个mysqld服务器更新相同myisam表的环境中，查询缓存不起作用。</p><p></p>
            </div>
            <p>
                The query cache is used for prepared statements under the
                conditions described in <a class="xref" href="optimization.html#query-cache-operation" title="8.10.3.1&nbsp;How the Query Cache Operates">Section&nbsp;8.10.3.1, “How the Query Cache Operates”</a>.
            </p><p style="color:blue;">查询缓存用于在8.10.3.1节“查询缓存如何操作”中描述的条件下准备的语句。</p><p></p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    The query cache is not supported for partitioned tables, and
                    is automatically disabled for queries involving partitioned
                    tables. The query cache cannot be enabled for such queries.
                </p><p style="color:blue;">分区表不支持查询缓存，对于涉及分区表的查询将自动禁用查询缓存。无法为此类查询启用查询缓存。</p><p></p>
            </div>
            <p>
                Some performance data for the query cache follows. These results
                were generated by running the MySQL benchmark suite on a Linux
                Alpha 2×500MHz system with 2GB RAM and a 64MB query cache.
            </p><p style="color:blue;">下面是查询缓存的一些性能数据。这些结果是通过在linux alpha 2×500MHz系统上运行mysql基准测试套件生成的，该系统具有2GB的RAM和64MB的查询缓存。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If all the queries you are performing are simple (such as
                    selecting a row from a table with one row), but still differ
                    so that the queries cannot be cached, the overhead for
                    having the query cache active is 13%. This could be regarded
                    as the worst case scenario. In real life, queries tend to be
                    much more complicated, so the overhead normally is
                    significantly lower.
                </p><p style="color:blue;">如果您执行的所有查询都很简单（例如从一行的表中选择一行），但仍然不同，因此无法缓存查询，则激活查询缓存的开销为13%。这可能被视为最坏的情况。在现实生活中，查询往往要复杂得多，因此通常开销要低得多。</p><p></p></li><li class="listitem"><p>
                    Searches for a single row in a single-row table are 238%
                    faster with the query cache than without it. This can be
                    regarded as close to the minimum speedup to be expected for
                    a query that is cached.
                </p><p style="color:blue;">使用查询缓存在单行表中搜索单行比不使用查询缓存快238%。这可以被视为接近缓存查询的预期最小加速。</p><p></p></li></ul>
            </div>
            <p>
                To disable the query cache at server startup, set the
                <a class="link" href="server-administration.html#sysvar_query_cache_size"><code class="literal">query_cache_size</code></a> system
                variable to 0. By disabling the query cache code, there is no
                noticeable overhead.
            </p><p style="color:blue;">要在服务器启动时禁用查询缓存，请将查询缓存大小系统变量设置为0。通过禁用查询缓存代码，没有明显的开销。</p><p></p><p>
            The query cache offers the potential for substantial performance
            improvement, but do not assume that it will do so under all
            circumstances. With some query cache configurations or server
            workloads, you might actually see a performance decrease:
        </p><p style="color:blue;">查询缓存提供了显著性能改进的潜力，但不要假设它在所有情况下都会这样做。对于某些查询缓存配置或服务器工作负载，您可能会看到性能下降：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Be cautious about sizing the query cache excessively large,
                    which increases the overhead required to maintain the cache,
                    possibly beyond the benefit of enabling it. Sizes in tens of
                    megabytes are usually beneficial. Sizes in the hundreds of
                    megabytes might not be.
                </p><p style="color:blue;">请小心调整查询缓存的大小，这会增加维护缓存所需的开销，可能超出启用缓存的好处。几十兆字节的大小通常是有益的。数百兆字节的大小可能不是。</p><p></p></li><li class="listitem"><p>
                    Server workload has a significant effect on query cache
                    efficiency. A query mix consisting almost entirely of a
                    fixed set of <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                    statements is much more likely to benefit from enabling the
                    cache than a mix in which frequent
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements cause
                    continual invalidation of results in the cache. In some
                    cases, a workaround is to use the
                    <code class="literal">SQL_NO_CACHE</code> option to prevent results
                    from even entering the cache for
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements that use
                    frequently modified tables. (See
                    <a class="xref" href="optimization.html#query-cache-in-select" title="8.10.3.2&nbsp;Query Cache SELECT Options">Section&nbsp;8.10.3.2, “Query Cache SELECT Options”</a>.)
                </p><p style="color:blue;">服务器工作负载对查询缓存效率有显著影响。几乎完全由一组固定的select语句组成的查询混合比频繁插入语句导致缓存中结果持续失效的混合更有可能从启用缓存中获益。在某些情况下，解决方法是使用sql_no_cache选项来防止结果进入使用频繁修改表的select语句的缓存。（见第8.10.3.2节，“查询缓存选择选项”。）</p><p></p></li></ul>
            </div>
            <p>
                To verify that enabling the query cache is beneficial, test the
                operation of your MySQL server with the cache enabled and
                disabled. Then retest periodically because query cache
                efficiency may change as server workload changes.
            </p><p style="color:blue;">要验证启用查询缓存是否有益，请在启用和禁用缓存的情况下测试mysql服务器的操作。然后定期重新测试，因为查询缓存效率可能随着服务器工作负载的变化而变化。</p><p></p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="query-cache-operation"></a>8.10.3.1&nbsp;How the Query Cache Operates</h4>

                        </div>

                    </div>

                </div>

                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The query cache is deprecated as of MySQL 5.7.20, and is
                        removed in MySQL 8.0.
                    </p><p style="color:blue;">从mysql 5.7.20开始，查询缓存已被弃用，并在mysql 8.0中被删除。</p><p></p>
                </div>
                <p>
                    This section describes how the query cache works when it is
                    operational. <a class="xref" href="optimization.html#query-cache-configuration" title="8.10.3.3&nbsp;Query Cache Configuration">Section&nbsp;8.10.3.3, “Query Cache Configuration”</a>,
                    describes how to control whether it is operational.
                </p><p style="color:blue;">本节描述查询缓存在可操作时的工作方式。第8.10.3.3节“查询缓存配置”描述了如何控制其是否可操作。</p><p></p><p>
                Incoming queries are compared to those in the query cache
                before parsing, so the following two queries are regarded as
                different by the query cache:
            </p><p style="color:blue;">在解析之前，将传入查询与查询缓存中的查询进行比较，因此以下两个查询被查询缓存视为不同的查询：</p><p></p><pre data-lang="sql" class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
Select * from <em class="replaceable"><code>tbl_name</code></em>
</pre><p>
                Queries must be <span class="emphasis"><em>exactly</em></span> the same (byte
                for byte) to be seen as identical. In addition, query strings
                that are identical may be treated as different for other
                reasons. Queries that use different databases, different
                protocol versions, or different default character sets are
                considered different queries and are cached separately.
            </p><p style="color:blue;">查询必须完全相同（逐字节）才能被视为相同。此外，由于其他原因，相同的查询字符串可能被视为不同的。使用不同数据库、不同协议版本或不同默认字符集的查询被视为不同的查询，并分别缓存。</p><p></p><p>
                The cache is not used for queries of the following types:
            </p><p style="color:blue;">缓存不用于以下类型的查询：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Queries that are a subquery of an outer query
                    </p><p style="color:blue;">作为外部查询的子查询的查询</p><p></p></li><li class="listitem"><p>
                        Queries executed within the body of a stored function,
                        trigger, or event
                    </p><p style="color:blue;">在存储函数、触发器或事件的主体内执行的查询</p><p></p></li></ul>
                </div>
                <p>
                    Before a query result is fetched from the query cache, MySQL
                    checks whether the user has
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> privilege for all
                    databases and tables involved. If this is not the case, the
                    cached result is not used.
                </p><p style="color:blue;">在从查询缓存中获取查询结果之前，mysql检查用户是否对所有涉及的数据库和表具有select权限。如果不是这样，则不使用缓存结果。</p><p></p><p>
                If a query result is returned from query cache, the server
                increments the <a class="link" href="server-administration.html#statvar_Qcache_hits"><code class="literal">Qcache_hits</code></a>
                status variable, not <code class="literal">Com_select</code>. See
                <a class="xref" href="optimization.html#query-cache-status-and-maintenance" title="8.10.3.4&nbsp;Query Cache Status and Maintenance">Section&nbsp;8.10.3.4, “Query Cache Status and Maintenance”</a>.
            </p><p style="color:blue;">如果查询结果是从查询缓存返回的，则服务器将递增qcache_hits状态变量，而不是com_select。参见第8.10.3.4节“查询缓存状态和维护”。</p><p></p><p>
                If a table changes, all cached queries that use the table
                become invalid and are removed from the cache. This includes
                queries that use <code class="literal">MERGE</code> tables that map to
                the changed table. A table can be changed by many types of
                statements, such as <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>,
                <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a>,
                <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                <a class="link" href="sql-syntax.html#drop-table" title="13.1.29&nbsp;DROP TABLE Syntax"><code class="literal">DROP TABLE</code></a>, or
                <a class="link" href="sql-syntax.html#drop-database" title="13.1.22&nbsp;DROP DATABASE Syntax"><code class="literal">DROP DATABASE</code></a>.
            </p><p style="color:blue;">如果表发生更改，则使用该表的所有缓存查询都将无效并从缓存中删除。这包括使用映射到已更改表的合并表的查询。表可以由许多类型的语句更改，例如insert、update、delete、truncate table、alter table、drop table或drop database。</p><p></p><p>
                The query cache also works within transactions when using
                <code class="literal">InnoDB</code> tables.
            </p><p style="color:blue;">当使用innodb表时，查询缓存也可以在事务中工作。</p><p></p><p>
                The result from a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> query
                on a view is cached.
            </p><p style="color:blue;">对视图执行select查询的结果将被缓存。</p><p></p><p>
                The query cache works for <code class="literal">SELECT SQL_CALC_FOUND_ROWS
                ...</code> queries and stores a value that is returned by a
                following <code class="literal">SELECT FOUND_ROWS()</code> query.
                <a class="link" href="functions.html#function_found-rows"><code class="literal">FOUND_ROWS()</code></a> returns the
                correct value even if the preceding query was fetched from the
                cache because the number of found rows is also stored in the
                cache. The <code class="literal">SELECT FOUND_ROWS()</code> query itself
                cannot be cached.
            </p><p style="color:blue;">查询缓存适用于选定的SQL计算找到的行…查询并存储以下select found_rows（）查询返回的值。found_rows（）返回正确的值，即使前面的查询是从缓存中提取的，因为找到的行数也存储在缓存中。无法缓存select found_rows（）查询本身。</p><p></p><p>
                Prepared statements that are issued using the binary protocol
                using <a class="link" href="connectors-apis.html#mysql-stmt-prepare" title="27.8.11.21&nbsp;mysql_stmt_prepare()"><code class="literal">mysql_stmt_prepare()</code></a> and
                <a class="link" href="connectors-apis.html#mysql-stmt-execute" title="27.8.11.10&nbsp;mysql_stmt_execute()"><code class="literal">mysql_stmt_execute()</code></a> (see
                <a class="xref" href="connectors-apis.html#c-api-prepared-statements" title="27.8.8&nbsp;C API Prepared Statements">Section&nbsp;27.8.8, “C API Prepared Statements”</a>), are subject to
                limitations on caching. Comparison with statements in the
                query cache is based on the text of the statement after
                expansion of <code class="literal">?</code> parameter markers. The
                statement is compared only with other cached statements that
                were executed using the binary protocol. That is, for query
                cache purposes, prepared statements issued using the binary
                protocol are distinct from prepared statements issued using
                the text protocol (see
                <a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5&nbsp;Prepared SQL Statement Syntax">Section&nbsp;13.5, “Prepared SQL Statement Syntax”</a>).
            </p><p style="color:blue;">使用mysql_stmt_prepare（）和mysql_stmt_execute（）使用二进制协议发出的prepared语句（请参阅27.8.8节，“C API prepared statements”）受缓存限制。与查询缓存中的语句进行比较是基于扩展后的语句文本吗？参数标记。该语句仅与使用二进制协议执行的其他缓存语句进行比较。也就是说，出于查询缓存的目的，使用二进制协议发出的准备语句与使用文本协议发出的准备语句是不同的（请参阅13.5节，“准备SQL语句语法”）。</p><p></p><p>
                A query cannot be cached if it uses any of the following
                functions:
            </p><p style="color:blue;">如果查询使用以下任何函数，则无法缓存该查询：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="functions.html#function_aes-decrypt"><code class="literal">AES_DECRYPT()</code></a>
                    </p><p style="color:blue;">AES_解密（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_aes-encrypt"><code class="literal">AES_ENCRYPT()</code></a>
                    </p><p style="color:blue;">AES加密（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_benchmark"><code class="literal">BENCHMARK()</code></a>
                    </p><p style="color:blue;">基准（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_connection-id"><code class="literal">CONNECTION_ID()</code></a>
                    </p><p style="color:blue;">连接ID（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_convert-tz"><code class="literal">CONVERT_TZ()</code></a>
                    </p><p style="color:blue;">转换TZ（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_curdate"><code class="literal">CURDATE()</code></a>
                    </p><p style="color:blue;">当前日期（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_current-date"><code class="literal">CURRENT_DATE()</code></a>
                    </p><p style="color:blue;">当前日期（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_current-time"><code class="literal">CURRENT_TIME()</code></a>
                    </p><p style="color:blue;">当前时间（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP()</code></a>
                    </p><p style="color:blue;">当前时间戳（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_current-user"><code class="literal">CURRENT_USER()</code></a>
                    </p><p style="color:blue;">当前用户（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_curtime"><code class="literal">CURTIME()</code></a>
                    </p><p style="color:blue;">缩短时间（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_database"><code class="literal">DATABASE()</code></a>
                    </p><p style="color:blue;">数据库（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_encrypt"><code class="literal">ENCRYPT()</code></a> with one
                        parameter
                    </p><p style="color:blue;">带一个参数的encrypt（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_found-rows"><code class="literal">FOUND_ROWS()</code></a>
                    </p><p style="color:blue;">找到行（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a>
                    </p><p style="color:blue;">获取锁（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_is-free-lock"><code class="literal">IS_FREE_LOCK()</code></a>
                    </p><p style="color:blue;">是否有锁（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_is-used-lock"><code class="literal">IS_USED_LOCK()</code></a>
                    </p><p style="color:blue;">是否使用了锁（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a>
                    </p><p style="color:blue;">上次插入的ID（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_load-file"><code class="literal">LOAD_FILE()</code></a>
                    </p><p style="color:blue;">加载文件（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_master-pos-wait"><code class="literal">MASTER_POS_WAIT()</code></a>
                    </p><p style="color:blue;">主人等待（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_now"><code class="literal">NOW()</code></a>
                    </p><p style="color:blue;">现在（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_password"><code class="literal">PASSWORD()</code></a>
                    </p><p style="color:blue;">密码（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_rand"><code class="literal">RAND()</code></a>
                    </p><p style="color:blue;">兰德（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_random-bytes"><code class="literal">RANDOM_BYTES()</code></a>
                    </p><p style="color:blue;">随机字节（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_release-all-locks"><code class="literal">RELEASE_ALL_LOCKS()</code></a>
                    </p><p style="color:blue;">释放所有锁（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_release-lock"><code class="literal">RELEASE_LOCK()</code></a>
                    </p><p style="color:blue;">解除锁定（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_sleep"><code class="literal">SLEEP()</code></a>
                    </p><p style="color:blue;">睡眠（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_sysdate"><code class="literal">SYSDATE()</code></a>
                    </p><p style="color:blue;">系统日期（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_unix-timestamp"><code class="literal">UNIX_TIMESTAMP()</code></a> with no
                        parameters
                    </p><p style="color:blue;">unix_timestamp（）不带参数</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_user"><code class="literal">USER()</code></a>
                    </p><p style="color:blue;">用户（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_uuid"><code class="literal">UUID()</code></a>
                    </p><p style="color:blue;">Uuid（）</p><p></p></li><li class="listitem"><p>
                        <a class="link" href="functions.html#function_uuid-short"><code class="literal">UUID_SHORT()</code></a>
                    </p><p style="color:blue;">短（）</p><p></p></li></ul>
                </div>
                <p>
                    A query also is not cached under these conditions:
                </p><p style="color:blue;">在以下情况下，查询也不会缓存：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        It refers to user-defined functions (UDFs) or stored
                        functions.
                    </p><p style="color:blue;">它指的是用户定义函数（udf）或存储函数。</p><p></p></li><li class="listitem"><p>
                        It refers to user variables or local stored program
                        variables.
                    </p><p style="color:blue;">它指的是用户变量或本地存储的程序变量。</p><p></p></li><li class="listitem"><p>
                        It refers to tables in the <code class="literal">mysql</code>,
                        <code class="literal">INFORMATION_SCHEMA</code>, or
                        <code class="literal">performance_schema</code> database.
                    </p><p style="color:blue;">它指的是mysql、information-schema或performance-schema数据库中的表。</p><p></p></li><li class="listitem"><p>
                        It refers to any partitioned tables.
                    </p><p style="color:blue;">它引用任何分区表。</p><p></p></li><li class="listitem"><p>
                        It is of any of the following forms:
                    </p><p style="color:blue;">有下列形式之一：</p><p></p><pre data-lang="sql" class="programlisting">SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
SELECT ... INTO OUTFILE ...
SELECT ... INTO DUMPFILE ...
SELECT * FROM ... WHERE autoincrement_col IS NULL
</pre><p>
                        The last form is not cached because it is used as the ODBC
                        workaround for obtaining the last insert ID value. See the
                        Connector/ODBC section of
                        <a class="xref" href="connectors-apis.html" title="Chapter&nbsp;27&nbsp;Connectors and APIs">Chapter&nbsp;27, <i>Connectors and APIs</i></a>.
                    </p><p style="color:blue;">最后一个表单未缓存，因为它用作获取最后一个insert id值的odbc解决方案。请参阅第27章“连接器和API”的连接器/ODBC部分。</p><p></p><p>
                        Statements within transactions that use
                        <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a> isolation
                        level also cannot be cached because they use <code class="literal">LOCK
                        IN SHARE MODE</code> locking.
                    </p><p style="color:blue;">事务中使用可序列化隔离级别的语句也无法缓存，因为它们使用共享模式锁定中的锁定。</p><p></p></li><li class="listitem"><p>
                        It uses <code class="literal">TEMPORARY</code> tables.
                    </p><p style="color:blue;">它使用临时表。</p><p></p></li><li class="listitem"><p>
                        It does not use any tables.
                    </p><p style="color:blue;">它不使用任何表。</p><p></p></li><li class="listitem"><p>
                        It generates warnings.
                    </p><p style="color:blue;">它会产生警告。</p><p></p></li><li class="listitem"><p>
                        The user has a column-level privilege for any of the
                        involved tables.
                    </p><p style="color:blue;">用户对任何涉及的表都具有列级权限。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="query-cache-in-select"></a>8.10.3.2&nbsp;Query Cache SELECT Options</h4>

                        </div>

                    </div>

                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The query cache is deprecated as of MySQL 5.7.20, and is
                        removed in MySQL 8.0.
                    </p><p style="color:blue;">从mysql 5.7.20开始，查询缓存已被弃用，并在mysql 8.0中被删除。</p><p></p>
                </div>
                <p>
                    Two query cache-related options may be specified in
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements:
                </p><p style="color:blue;">在select语句中可以指定两个与查询缓存相关的选项：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="indexterm" name="idm140286869841584"></a>

                        <code class="literal">SQL_CACHE</code>
                    </p><p style="color:blue;">SQL缓存</p><p></p><p>
                        The query result is cached if it is cacheable and the
                        value of the
                        <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type</code></a> system
                        variable is <code class="literal">ON</code> or
                        <code class="literal">DEMAND</code>.
                    </p><p style="color:blue;">如果查询结果是可缓存的，并且查询缓存类型系统变量的值是on或demand，则查询结果将被缓存。</p><p></p></li><li class="listitem"><a class="indexterm" name="idm140286869836144"></a><p>
                        <code class="literal">SQL_NO_CACHE</code>
                    </p><p style="color:blue;">SQL无缓存</p><p></p><p>
                        The server does not use the query cache. It neither checks
                        the query cache to see whether the result is already
                        cached, nor does it cache the query result.
                    </p><p style="color:blue;">服务器不使用查询缓存。它既不检查查询缓存以查看结果是否已缓存，也不缓存查询结果。</p><p></p></li></ul>
                </div>
                <p>
                    Examples:
                </p><p style="color:blue;">示例：</p><p></p><pre data-lang="sql" class="programlisting">SELECT SQL_CACHE id, name FROM customer;
SELECT SQL_NO_CACHE id, name FROM customer;
</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="query-cache-configuration"></a>8.10.3.3&nbsp;Query Cache Configuration</h4>

                        </div>

                    </div>

                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The query cache is deprecated as of MySQL 5.7.20, and is
                        removed in MySQL 8.0.
                    </p><p style="color:blue;">从mysql 5.7.20开始，查询缓存已被弃用，并在mysql 8.0中被删除。</p><p></p>
                </div>
                <p>
                    The <a class="link" href="server-administration.html#sysvar_have_query_cache"><code class="literal">have_query_cache</code></a> server
                    system variable indicates whether the query cache is
                    available:
                </p><p style="color:blue;">have_query_cache server系统变量指示查询缓存是否可用：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'have_query_cache';</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
</pre><p>
                When using a standard MySQL binary, this value is always
                <code class="literal">YES</code>, even if query caching is disabled.
            </p><p style="color:blue;">使用标准mysql二进制文件时，即使禁用了查询缓存，此值也始终为yes。</p><p></p><p>
                Several other system variables control query cache operation.
                These can be set in an option file or on the command line when
                starting <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>. The query cache system
                variables all have names that begin with
                <code class="literal">query_cache_</code>. They are described briefly in
                <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>, with additional
                configuration information given here.
            </p><p style="color:blue;">其他几个系统变量控制查询缓存操作。这些可以在选项文件中设置，也可以在启动mysqld时在命令行中设置。查询缓存系统变量的名称都以查询缓存开头。在第5.1.7节“服务器系统变量”中对它们进行了简要描述，并在此处提供了其他配置信息。</p><p></p><p>
                To set the size of the query cache, set the
                <a class="link" href="server-administration.html#sysvar_query_cache_size"><code class="literal">query_cache_size</code></a> system
                variable. Setting it to 0 disables the query cache, as does
                setting <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type=0</code></a>.
                By default, the query cache is disabled. This is achieved
                using a default size of 1M, with a default for
                <code class="literal">query_cache_type</code> of 0.
            </p><p style="color:blue;">要设置查询缓存的大小，请设置查询缓存大小系统变量。将其设置为0将禁用查询缓存，将查询缓存类型设置为0也是如此。默认情况下，查询缓存被禁用。这是使用默认大小1m实现的，默认查询缓存类型为0。</p><p></p><p>
                To reduce overhead significantly, start the server with
                <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type=0</code></a> if you
                will not be using the query cache.
            </p><p style="color:blue;">若要显著减少开销，请在不使用查询缓存的情况下使用query-cache-type=0启动服务器。</p><p></p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        When using the Windows Configuration Wizard to install or
                        configure MySQL, the default value for
                        <a class="link" href="server-administration.html#sysvar_query_cache_size"><code class="literal">query_cache_size</code></a> will be
                        configured automatically for you based on the different
                        configuration types available. When using the Windows
                        Configuration Wizard, the query cache may be enabled (that
                        is, set to a nonzero value) due to the selected
                        configuration. The query cache is also controlled by the
                        setting of the
                        <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type</code></a> variable.
                        Check the values of these variables as set in your
                        <code class="filename">my.ini</code> file after configuration has
                        taken place.
                    </p><p style="color:blue;">使用Windows配置向导安装或配置MySQL时，将根据可用的不同配置类型自动为您配置查询缓存大小的默认值。使用windows配置向导时，由于所选配置，可能会启用查询缓存（即设置为非零值）。查询缓存也由查询缓存类型变量的设置控制。配置完成后，检查my ini文件中设置的这些变量的值。</p><p></p>
                </div>
                <p>
                    When you set <a class="link" href="server-administration.html#sysvar_query_cache_size"><code class="literal">query_cache_size</code></a>
                    to a nonzero value, keep in mind that the query cache needs a
                    minimum size of about 40KB to allocate its structures. (The
                    exact size depends on system architecture.) If you set the
                    value too small, you'll get a warning, as in this example:
                </p><p style="color:blue;">当您将query_cache_size设置为非零值时，请记住查询缓存需要大约40kb的最小大小来分配其结构。（具体大小取决于系统体系结构。）如果设置的值太小，将收到警告，如本例所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL query_cache_size = 40000;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1282
Message: Query cache failed to set size 39936;
         new query cache size is 0

mysql&gt; <strong class="userinput"><code>SET GLOBAL query_cache_size = 41984;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'query_cache_size';</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_size | 41984 |
+------------------+-------+
</pre><p>
                For the query cache to actually be able to hold any query
                results, its size must be set larger:
            </p><p style="color:blue;">要使查询缓存实际上能够保存任何查询结果，必须将其大小设置为更大：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL query_cache_size = 1000000;</code></strong>
Query OK, 0 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'query_cache_size';</code></strong>
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| query_cache_size | 999424 |
+------------------+--------+
1 row in set (0.00 sec)
</pre><p>
                The <a class="link" href="server-administration.html#sysvar_query_cache_size"><code class="literal">query_cache_size</code></a> value is
                aligned to the nearest 1024 byte block. The value reported may
                therefore be different from the value that you assign.
            </p><p style="color:blue;">查询缓存大小值与最近的1024字节块对齐。因此，报告的值可能与您分配的值不同。</p><p></p><p>
                If the query cache size is greater than 0, the
                <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type</code></a> variable
                influences how it works. This variable can be set to the
                following values:
            </p><p style="color:blue;">如果查询缓存大小大于0，则查询缓存类型变量将影响其工作方式。此变量可以设置为以下值：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        A value of <code class="literal">0</code> or <code class="literal">OFF</code>
                        prevents caching or retrieval of cached results.
                    </p><p style="color:blue;">值为0或关闭可防止缓存或检索缓存的结果。</p><p></p></li><li class="listitem"><p>
                        A value of <code class="literal">1</code> or <code class="literal">ON</code>
                        enables caching except of those statements that begin with
                        <code class="literal">SELECT SQL_NO_CACHE</code>.
                    </p><p style="color:blue;">值1或on启用缓存，但以select sql_no_cache开头的语句除外。</p><p></p></li><li class="listitem"><p>
                        A value of <code class="literal">2</code> or
                        <code class="literal">DEMAND</code> causes caching of only those
                        statements that begin with <code class="literal">SELECT
                        SQL_CACHE</code>.
                    </p><p style="color:blue;">值为2或Demand时，只缓存以select SQL_cache开头的语句。</p><p></p></li></ul>
                </div>
                <p>
                    If <a class="link" href="server-administration.html#sysvar_query_cache_size"><code class="literal">query_cache_size</code></a> is 0, you
                    should also set
                    <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type</code></a> variable to
                    0. In this case, the server does not acquire the query cache
                    mutex at all, which means that the query cache cannot be
                    enabled at runtime and there is reduced overhead in query
                    execution.
                </p><p style="color:blue;">如果query_cache_size为0，则还应将query_cache_type变量设置为0。在这种情况下，服务器根本不获取查询缓存互斥量，这意味着查询缓存在运行时无法启用，查询执行的开销也会减少。</p><p></p><p>
                Setting the <code class="literal">GLOBAL</code>
                <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type</code></a> value
                determines query cache behavior for all clients that connect
                after the change is made. Individual clients can control cache
                behavior for their own connection by setting the
                <code class="literal">SESSION</code>
                <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type</code></a> value. For
                example, a client can disable use of the query cache for its
                own queries like this:
            </p><p style="color:blue;">设置全局查询缓存类型值将确定更改后连接的所有客户端的查询缓存行为。单个客户端可以通过设置会话查询缓存类型值来控制自己连接的缓存行为。例如，客户机可以禁止对其自己的查询使用查询缓存，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET SESSION query_cache_type = OFF;</code></strong>
</pre><p>
                If you set <a class="link" href="server-administration.html#sysvar_query_cache_type"><code class="literal">query_cache_type</code></a>
                at server startup (rather than at runtime with a
                <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                statement), only the numeric values are permitted.
            </p><p style="color:blue;">如果在服务器启动时（而不是在运行时使用set语句）设置query_cache_type，则只允许使用数值。</p><p></p><p>
                To control the maximum size of individual query results that
                can be cached, set the
                <a class="link" href="server-administration.html#sysvar_query_cache_limit"><code class="literal">query_cache_limit</code></a> system
                variable. The default value is 1MB.
            </p><p style="color:blue;">若要控制可以缓存的单个查询结果的最大大小，请设置。默认值为1MB。</p><p></p><p>
                Be careful not to set the size of the cache too large. Due to
                the need for threads to lock the cache during updates, you may
                see lock contention issues with a very large cache.
            </p><p style="color:blue;">注意不要将缓存的大小设置得太大。由于需要线程在更新期间锁定缓存，您可能会看到非常大的缓存存在锁争用问题。</p><p></p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        You can set the maximum size that can be specified for the
                        query cache at runtime with the
                        <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET</code></a>
                        statement by using the
                        <code class="option">--maximum-query_cache_size=<em class="replaceable"><code>32M</code></em></code>
                        option on the command line or in the configuration file.
                    </p><p style="color:blue;">通过在命令行或配置文件中使用-Meimul-QueRyCaseEySigaby= 32 M选项，可以在运行时使用SET语句设置查询缓存指定的最大大小。</p><p></p>
                </div>
                <p>
                    When a query is to be cached, its result (the data sent to the
                    client) is stored in the query cache during result retrieval.
                    Therefore the data usually is not handled in one big chunk.
                    The query cache allocates blocks for storing this data on
                    demand, so when one block is filled, a new block is allocated.
                    Because memory allocation operation is costly (timewise), the
                    query cache allocates blocks with a minimum size given by the
                    <a class="link" href="server-administration.html#sysvar_query_cache_min_res_unit"><code class="literal">query_cache_min_res_unit</code></a>
                    system variable. When a query is executed, the last result
                    block is trimmed to the actual data size so that unused memory
                    is freed. Depending on the types of queries your server
                    executes, you might find it helpful to tune the value of
                    <a class="link" href="server-administration.html#sysvar_query_cache_min_res_unit"><code class="literal">query_cache_min_res_unit</code></a>:
                </p><p style="color:blue;">当要缓存查询时，其结果（发送到客户端的数据）在结果检索期间存储在查询缓存中。因此，数据通常不在一大块中处理。查询缓存按需分配用于存储此数据的块，因此当一个块被填充时，将分配一个新块。由于内存分配操作代价高昂（按时间顺序），查询缓存使用查询缓存单元系统变量给定的最小大小来分配块。执行查询时，最后一个结果块将被修剪为实际数据大小，以便释放未使用的内存。根据服务器执行的查询类型，您可能会发现调整query-cache-min-res单元的值很有帮助：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The default value of
                        <a class="link" href="server-administration.html#sysvar_query_cache_min_res_unit"><code class="literal">query_cache_min_res_unit</code></a>
                        is 4KB. This should be adequate for most cases.
                    </p><p style="color:blue;">query_cache_min_res_unit的默认值是4KB。这在大多数情况下应该是足够的。</p><p></p></li><li class="listitem"><p>
                        If you have a lot of queries with small results, the
                        default block size may lead to memory fragmentation, as
                        indicated by a large number of free blocks. Fragmentation
                        can force the query cache to prune (delete) queries from
                        the cache due to lack of memory. In this case, decrease
                        the value of
                        <a class="link" href="server-administration.html#sysvar_query_cache_min_res_unit"><code class="literal">query_cache_min_res_unit</code></a>.
                        The number of free blocks and queries removed due to
                        pruning are given by the values of the
                        <a class="link" href="server-administration.html#statvar_Qcache_free_blocks"><code class="literal">Qcache_free_blocks</code></a> and
                        <a class="link" href="server-administration.html#statvar_Qcache_lowmem_prunes"><code class="literal">Qcache_lowmem_prunes</code></a>
                        status variables.
                    </p><p style="color:blue;">如果有很多查询的结果很小，那么默认的块大小可能会导致内存碎片，如大量空闲块所示。由于内存不足，碎片可能会强制查询缓存从缓存中删除（删除）查询。在这种情况下，减小query_cache_min_res_unit的值。由于修剪而删除的空闲块和查询的数量由qcache_free_块和qcache_lowmem_prunes状态变量的值给出。</p><p></p></li><li class="listitem"><p>
                        If most of your queries have large results (check the
                        <a class="link" href="server-administration.html#statvar_Qcache_total_blocks"><code class="literal">Qcache_total_blocks</code></a> and
                        <a class="link" href="server-administration.html#statvar_Qcache_queries_in_cache"><code class="literal">Qcache_queries_in_cache</code></a>
                        status variables), you can increase performance by
                        increasing
                        <a class="link" href="server-administration.html#sysvar_query_cache_min_res_unit"><code class="literal">query_cache_min_res_unit</code></a>.
                        However, be careful to not make it too large (see the
                        previous item).
                    </p><p style="color:blue;">如果大多数查询都有较大的结果（检查qcache_total_blocks和qcache_querys_in_cache status变量），则可以通过增加query_min_res_unit来提高性能。但是，请注意不要使它太大（参见上一项）。</p><p></p></li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="query-cache-status-and-maintenance"></a>8.10.3.4&nbsp;Query Cache Status and Maintenance</h4>

                        </div>

                    </div>

                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The query cache is deprecated as of MySQL 5.7.20, and is
                        removed in MySQL 8.0.
                    </p><p style="color:blue;">从mysql 5.7.20开始，查询缓存已被弃用，并在mysql 8.0中被删除。</p><p></p>
                </div>
                <p>
                    To check whether the query cache is present in your MySQL
                    server, use the following statement:
                </p><p style="color:blue;">要检查mysql服务器中是否存在查询缓存，请使用以下语句：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'have_query_cache';</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
</pre><p>
                You can defragment the query cache to better utilize its
                memory with the <a class="link" href="sql-syntax.html#flush-query-cache"><code class="literal">FLUSH QUERY
                CACHE</code></a> statement. The statement does not remove any
                queries from the cache.
            </p><p style="color:blue;">您可以使用flush query cache语句对查询缓存进行碎片整理，以更好地利用其内存。语句不会从缓存中删除任何查询。</p><p></p><p>
                The <code class="literal">RESET QUERY CACHE</code> statement removes all
                query results from the query cache. The
                <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> statement also
                does this.
            </p><p style="color:blue;">reset query cache语句从查询缓存中删除所有查询结果。flush tables语句也这样做。</p><p></p><p>
                To monitor query cache performance, use
                <a class="link" href="sql-syntax.html#show-status" title="13.7.5.35&nbsp;SHOW STATUS Syntax"><code class="literal">SHOW STATUS</code></a> to view the cache
                status variables:
            </p><p style="color:blue;">要监视查询缓存性能，请使用show status查看缓存状态变量：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Qcache%';</code></strong>
+-------------------------+--------+
| Variable_name           | Value  |
+-------------------------+--------+
| Qcache_free_blocks      | 36     |
| Qcache_free_memory      | 138488 |
| Qcache_hits             | 79570  |
| Qcache_inserts          | 27087  |
| Qcache_lowmem_prunes    | 3114   |
| Qcache_not_cached       | 22989  |
| Qcache_queries_in_cache | 415    |
| Qcache_total_blocks     | 912    |
+-------------------------+--------+
</pre><p>
                Descriptions of each of these variables are given in
                <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>. Some uses for them
                are described here.
            </p><p style="color:blue;">第5.1.9节“服务器状态变量”给出了这些变量的描述。这里描述了它们的一些用途。</p><p></p><p>
                The total number of <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                queries is given by this formula:
            </p><p style="color:blue;">选择查询的总数由以下公式给出：</p><p></p><pre data-lang="none" class="programlisting">  Com_select
+ Qcache_hits
+ queries with errors found by parser
</pre><p>
                The <code class="literal">Com_select</code> value is given by this
                formula:
            </p><p style="color:blue;">COM选择值由以下公式给出：</p><p></p><pre data-lang="none" class="programlisting">  Qcache_inserts
+ Qcache_not_cached
+ queries with errors found during the column-privileges check
</pre><p>
                The query cache uses variable-length blocks, so
                <a class="link" href="server-administration.html#statvar_Qcache_total_blocks"><code class="literal">Qcache_total_blocks</code></a> and
                <a class="link" href="server-administration.html#statvar_Qcache_free_blocks"><code class="literal">Qcache_free_blocks</code></a> may
                indicate query cache memory fragmentation. After
                <a class="link" href="sql-syntax.html#flush-query-cache"><code class="literal">FLUSH QUERY CACHE</code></a>, only a
                single free block remains.
            </p><p style="color:blue;">查询缓存使用可变长度的块，因此qcache_total_blocks和qcache_free_blocks可能指示查询缓存内存碎片。刷新查询缓存后，只剩下一个空闲块。</p><p></p><p>
                Every cached query requires a minimum of two blocks (one for
                the query text and one or more for the query results). Also,
                every table that is used by a query requires one block.
                However, if two or more queries use the same table, only one
                table block needs to be allocated.
            </p><p style="color:blue;">每个缓存查询至少需要两个块（一个用于查询文本，一个或多个用于查询结果）。此外，查询使用的每个表都需要一个块。但是，如果两个或多个查询使用同一个表，则只需要分配一个表块。</p><p></p><p>
                The information provided by the
                <a class="link" href="server-administration.html#statvar_Qcache_lowmem_prunes"><code class="literal">Qcache_lowmem_prunes</code></a> status
                variable can help you tune the query cache size. It counts the
                number of queries that have been removed from the cache to
                free up memory for caching new queries. The query cache uses a
                least recently used (LRU) strategy to decide which queries to
                remove from the cache. Tuning information is given in
                <a class="xref" href="optimization.html#query-cache-configuration" title="8.10.3.3&nbsp;Query Cache Configuration">Section&nbsp;8.10.3.3, “Query Cache Configuration”</a>.
            </p><p style="color:blue;">qcache_lowmem_prunes status变量提供的信息可以帮助您调整查询缓存大小。它统计已从缓存中删除的查询数，以释放内存用于缓存新查询。查询缓存使用最近使用最少（lru）策略来决定要从缓存中删除哪些查询。调整信息在第8.10.3.3节“查询缓存配置”中给出。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="statement-caching"></a>8.10.4&nbsp;Caching of Prepared Statements and Stored Programs</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286869723984"></a><a class="indexterm" name="idm140286869722528"></a><p>
            For certain statements that a client might execute multiple
            times during a session, the server converts the statement to an
            internal structure and caches that structure to be used during
            execution. Caching enables the server to perform more
            efficiently because it avoids the overhead of reconverting the
            statement should it be needed again during the session.
            Conversion and caching occurs for these statements:
        </p><p style="color:blue;">对于客户端可能在会话期间多次执行的某些语句，服务器将该语句转换为内部结构，并缓存该结构以在执行期间使用。缓存使服务器能够更有效地执行，因为它避免了在会话期间再次需要语句时重新转换语句的开销。对这些语句进行转换和缓存：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Prepared statements, both those processed at the SQL level
                    (using the <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a> statement)
                    and those processed using the binary client/server protocol
                    (using the
                    <a class="link" href="connectors-apis.html#mysql-stmt-prepare" title="27.8.11.21&nbsp;mysql_stmt_prepare()"><code class="literal">mysql_stmt_prepare()</code></a> C API
                    function). The
                    <a class="link" href="server-administration.html#sysvar_max_prepared_stmt_count"><code class="literal">max_prepared_stmt_count</code></a>
                    system variable controls the total number of statements the
                    server caches. (The sum of the number of prepared statements
                    across all sessions.)
                </p><p style="color:blue;">准备好的语句，包括在sql级别处理的语句（使用prepare语句）和使用二进制客户机/服务器协议处理的语句（使用mysql_stmt_prepare（）c api函数）。max_prepared_stmt_count系统变量控制服务器缓存的语句总数。（所有会话中准备的语句数的总和。）</p><p></p></li><li class="listitem"><p>
                    Stored programs (stored procedures and functions, triggers,
                    and events). In this case, the server converts and caches
                    the entire program body. The
                    <a class="link" href="server-administration.html#sysvar_stored_program_cache"><code class="literal">stored_program_cache</code></a> system
                    variable indicates the approximate number of stored programs
                    the server caches per session.
                </p><p style="color:blue;">存储程序（存储过程和函数、触发器和事件）。在这种情况下，服务器转换并缓存整个程序体。StutdJavaStudioCache系统变量指示每个会话缓存服务器所存储的程序的大致数目。</p><p></p></li></ul>
            </div>
            <p>
                The server maintains caches for prepared statements and stored
                programs on a per-session basis. Statements cached for one
                session are not accessible to other sessions. When a session
                ends, the server discards any statements cached for it.
            </p><p style="color:blue;">服务器在每个会话的基础上为准备好的语句和存储的程序维护缓存。其他会话无法访问为一个会话缓存的语句。会话结束时，服务器将丢弃为其缓存的任何语句。</p><p></p><p>
            When the server uses a cached internal statement structure, it
            must take care that the structure does not go out of date.
            Metadata changes can occur for an object used by the statement,
            causing a mismatch between the current object definition and the
            definition as represented in the internal statement structure.
            Metadata changes occur for DDL statements such as those that
            create, drop, alter, rename, or truncate tables, or that
            analyze, optimize, or repair tables. Table content changes (for
            example, with <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
            <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>) do not change metadata,
            nor do <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements.
        </p><p style="color:blue;">当服务器使用缓存的内部语句结构时，必须注意该结构不会过期。语句使用的对象可能会发生元数据更改，从而导致当前对象定义与内部语句结构中表示的定义不匹配。对ddl语句（如创建、删除、更改、重命名或截断表的语句，或分析、优化或修复表的语句）进行元数据更改。表内容更改（例如，使用insert或update）不会更改元数据，也不会更改select语句。</p><p></p><p>
            Here is an illustration of the problem. Suppose that a client
            prepares this statement:
        </p><p style="color:blue;">这是这个问题的一个例子。假设客户准备了以下语句：</p><p></p><pre data-lang="sql" class="programlisting">PREPARE s1 FROM 'SELECT * FROM t1';
</pre><p>
            The <code class="literal">SELECT *</code> expands in the internal
            structure to the list of columns in the table. If the set of
            columns in the table is modified with <code class="literal">ALTER
            TABLE</code>, the prepared statement goes out of date. If the
            server does not detect this change the next time the client
            executes <code class="literal">s1</code>, the prepared statement will
            return incorrect results.
        </p><p style="color:blue;">在内部结构中，select*扩展到表中的列列表。如果使用alter table修改表中的列集，则准备的语句将过期。如果下次客户端执行s1时服务器未检测到此更改，则准备好的语句将返回不正确的结果。</p><p></p><p>
            To avoid problems caused by metadata changes to tables or views
            referred to by the prepared statement, the server detects these
            changes and automatically reprepares the statement when it is
            next executed. That is, the server reparses the statement and
            rebuilds the internal structure. Reparsing also occurs after
            referenced tables or views are flushed from the table definition
            cache, either implicitly to make room for new entries in the
            cache, or explicitly due to <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH
            TABLES</code></a>.
        </p><p style="color:blue;">为了避免由准备好的语句引用的表或视图的元数据更改引起的问题，服务器将检测这些更改，并在下次执行语句时自动重新准备语句。也就是说，服务器重新解析语句并重建内部结构。在从表定义缓存中刷新被引用的表或视图之后，也会发生重新分析，可能是隐式地为缓存中的新条目腾出空间，也可能是显式地由于刷新表而导致。</p><p></p><p>
            Similarly, if changes occur to objects used by a stored program,
            the server reparses affected statements within the program.
        </p><p style="color:blue;">类似地，如果存储程序使用的对象发生更改，服务器将重新解析程序中受影响的语句。</p><p></p><p>
            The server also detects metadata changes for objects in
            expressions. These might be used in statements specific to
            stored programs, such as <code class="literal">DECLARE CURSOR</code> or
            flow-control statements such as
            <a class="link" href="sql-syntax.html#if" title="13.6.5.2&nbsp;IF Syntax"><code class="literal">IF</code></a>,
            <a class="link" href="sql-syntax.html#case" title="13.6.5.1&nbsp;CASE Syntax"><code class="literal">CASE</code></a>, and
            <a class="link" href="sql-syntax.html#return" title="13.6.5.7&nbsp;RETURN Syntax"><code class="literal">RETURN</code></a>.
        </p><p style="color:blue;">服务器还检测表达式中对象的元数据更改。这些语句可以用于特定于存储程序的语句中，如declare cursor或流控制语句（如if、case和return）。</p><p></p><p>
            To avoid reparsing entire stored programs, the server reparses
            affected statements or expressions within a program only as
            needed. Examples:
        </p><p style="color:blue;">为了避免重新解析整个存储的程序，服务器只在需要时重新解析程序中受影响的语句或表达式。示例：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Suppose that metadata for a table or view is changed.
                    Reparsing occurs for a <code class="literal">SELECT *</code> within
                    the program that accesses the table or view, but not for a
                    <code class="literal">SELECT *</code> that does not access the table
                    or view.
                </p><p style="color:blue;">假设表或视图的元数据已更改。对访问表或视图的程序中的select*进行重新分析，但对不访问表或视图的select*不进行重新分析。</p><p></p></li><li class="listitem"><p>
                    When a statement is affected, the server reparses it only
                    partially if possible. Consider this
                    <a class="link" href="sql-syntax.html#case" title="13.6.5.1&nbsp;CASE Syntax"><code class="literal">CASE</code></a> statement:
                </p><p style="color:blue;">当语句受到影响时，服务器只在可能的情况下对其进行部分重新解析。考虑这个案例陈述：</p><p></p><pre data-lang="sql" class="programlisting">CASE <em class="replaceable"><code>case_expr</code></em>
  WHEN <em class="replaceable"><code>when_expr1</code></em> ...
  WHEN <em class="replaceable"><code>when_expr2</code></em> ...
  WHEN <em class="replaceable"><code>when_expr3</code></em> ...
  ...
END CASE
</pre><p>
                    If a metadata change affects only <code class="literal">WHEN
                    <em class="replaceable"><code>when_expr3</code></em></code>, that
                    expression is reparsed. <em class="replaceable"><code>case_expr</code></em>
                    and the other <code class="literal">WHEN</code> expressions are not
                    reparsed.
                </p><p style="color:blue;">如果元数据更改仅在表达式3时生效，则该表达式将被重新解析。case_expr和其他未重新解析的表达式。</p><p></p></li></ul>
            </div>
            <p>
                Reparsing uses the default database and SQL mode that were in
                effect for the original conversion to internal form.
            </p><p style="color:blue;">重新分析使用默认的数据库和SQL模式，这些模式对原始的内部表单转换有效。</p><p></p><p>
            The server attempts reparsing up to three times. An error occurs
            if all attempts fail.
        </p><p style="color:blue;">服务器最多尝试重新解析三次。如果所有尝试都失败，则会发生错误。</p><p></p><p>
            Reparsing is automatic, but to the extent that it occurs,
            diminishes prepared statement and stored program performance.
        </p><p style="color:blue;">重新分析是自动的，但在一定程度上会降低准备好的语句和存储程序的性能。</p><p></p><p>
            For prepared statements, the
            <a class="link" href="server-administration.html#statvar_Com_xxx"><code class="literal">Com_stmt_reprepare</code></a>
            status variable tracks the number of repreparations.
        </p><p style="color:blue;">对于准备好的语句，com_stmt_repreprepare status变量跟踪重复的次数。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="locking-issues"></a>8.11&nbsp;Optimizing Locking Operations</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#internal-locking">8.11.1 Internal Locking Methods</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">8.11.2 Table Locking Issues</a></span></dt><dt><span class="section"><a href="optimization.html#concurrent-inserts">8.11.3 Concurrent Inserts</a></span></dt><dt><span class="section"><a href="optimization.html#metadata-locking">8.11.4 Metadata Locking</a></span></dt><dt><span class="section"><a href="optimization.html#external-locking">8.11.5 External Locking</a></span></dt></dl>
        </div>
        <p>
            MySQL manages contention for table contents using
            <a class="link" href="glossary.html#glos_locking" title="locking">locking</a>:
        </p><p style="color:blue;">mysql使用锁定管理表内容的争用：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Internal locking is performed within the MySQL server itself
                to manage contention for table contents by multiple threads.
                This type of locking is internal because it is performed
                entirely by the server and involves no other programs. See
                <a class="xref" href="optimization.html#internal-locking" title="8.11.1&nbsp;Internal Locking Methods">Section&nbsp;8.11.1, “Internal Locking Methods”</a>.
            </p><p style="color:blue;">在mysql服务器内部执行内部锁定，以管理多个线程对表内容的争用。这种类型的锁定是内部的，因为它完全由服务器执行，不涉及其他程序。见第8.11.1节“内部锁定方法”。</p><p></p></li><li class="listitem"><p>
                External locking occurs when the server and other programs
                lock <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> table files to
                coordinate among themselves which program can access the
                tables at which time. See <a class="xref" href="optimization.html#external-locking" title="8.11.5&nbsp;External Locking">Section&nbsp;8.11.5, “External Locking”</a>.
            </p><p style="color:blue;">外部锁定发生在服务器和其他程序锁定myisam表文件以协调它们之间的关系时，此时哪个程序可以访问这些表。见第8.11.5节“外部锁定”。</p><p></p></li></ul>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="internal-locking"></a>8.11.1&nbsp;Internal Locking Methods</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286869671280"></a><a class="indexterm" name="idm140286869670240"></a><a class="indexterm" name="idm140286869668752"></a><a class="indexterm" name="idm140286869667680"></a><a class="indexterm" name="idm140286869666192"></a><a class="indexterm" name="idm140286869665120"></a><a class="indexterm" name="idm140286869664048"></a><a class="indexterm" name="idm140286869662560"></a><a class="indexterm" name="idm140286869661072"></a><p>
            This section discusses internal locking; that is, locking
            performed within the MySQL server itself to manage contention
            for table contents by multiple sessions. This type of locking is
            internal because it is performed entirely by the server and
            involves no other programs. For locking performed on MySQL files
            by other programs, see <a class="xref" href="optimization.html#external-locking" title="8.11.5&nbsp;External Locking">Section&nbsp;8.11.5, “External Locking”</a>.
        </p><p style="color:blue;">本节讨论内部锁定；也就是说，在mysql服务器本身中执行锁定，以管理多个会话对表内容的争用。这种类型的锁定是内部的，因为它完全由服务器执行，不涉及其他程序。有关其他程序对mysql文件执行的锁定，请参阅8.11.5节“外部锁定”。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#internal-row-level-locking" title="Row-Level Locking">Row-Level Locking</a></p><p style="color:blue;">行级锁定</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#internal-table-level-locking" title="Table-Level Locking">Table-Level Locking</a></p><p style="color:blue;">表级锁定</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#internal-locking-choices" title="Choosing the Type of Locking">Choosing the Type of Locking</a></p><p style="color:blue;">选择锁定类型</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="internal-row-level-locking"></a>Row-Level Locking</h4>

                        </div>

                    </div>

                </div>
                <p>
                    MySQL uses <a class="link" href="glossary.html#glos_row_lock" title="row lock">row-level
                    locking</a> for <code class="literal">InnoDB</code> tables to support
                    simultaneous write access by multiple sessions, making them
                    suitable for multi-user, highly concurrent, and OLTP
                    applications.
                </p><p style="color:blue;">mysql对innodb表使用行级锁来支持多个会话的同时写访问，使它们适合于多用户、高度并发和oltp应用程序。</p><p></p><p>
                To avoid <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlocks</a> when
                performing multiple concurrent write operations on a single
                <code class="literal">InnoDB</code> table, acquire necessary locks at
                the start of the transaction by issuing a <code class="literal">SELECT ...
                FOR UPDATE</code> statement for each group of rows expected
                to be modified, even if the data change statements come later
                in the transaction. If transactions modify or lock more than
                one table, issue the applicable statements in the same order
                within each transaction. Deadlocks affect performance rather
                than representing a serious error, because
                <code class="literal">InnoDB</code> automatically
                <a class="link" href="glossary.html#glos_deadlock_detection" title="deadlock detection">detects</a>
                deadlock conditions and rolls back one of the affected
                transactions.
            </p><p style="color:blue;">为了避免在单个innodb表上执行多个并发写操作时出现死锁，请在事务开始时通过发出select命令获取必要的锁…对于预期要修改的每一组行的update语句，即使数据更改语句稍后出现在事务中。如果事务修改或锁定多个表，则在每个事务中以相同的顺序发出适用的语句。死锁影响性能而不是表示严重错误，因为innodb会自动检测死锁情况并回滚一个受影响的事务。</p><p></p><p>
                On high concurrency systems, deadlock detection can cause a
                slowdown when numerous threads wait for the same lock. At
                times, it may be more efficient to disable deadlock detection
                and rely on the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout"><code class="literal">innodb_lock_wait_timeout</code></a>
                setting for transaction rollback when a deadlock occurs.
                Deadlock detection can be disabled using the
                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_deadlock_detect"><code class="literal">innodb_deadlock_detect</code></a>
                configuration option.
            </p><p style="color:blue;">在高并发性系统中，当多个线程等待同一个锁时，死锁检测可能会导致速度减慢。有时，禁用死锁检测和在发生死锁时依赖innodb_lock_wait_timeout设置进行事务回滚可能更有效。可以使用innodb_deadlock_detect配置选项禁用死锁检测。</p><p></p><p>
                Advantages of row-level locking:
            </p><p style="color:blue;">行级锁定的优点：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Fewer lock conflicts when different sessions access
                        different rows.
                    </p><p style="color:blue;">当不同的会话访问不同的行时，锁冲突更少。</p><p></p></li><li class="listitem"><p>
                        Fewer changes for rollbacks.
                    </p><p style="color:blue;">回滚的更改更少。</p><p></p></li><li class="listitem"><p>
                        Possible to lock a single row for a long time.
                    </p><p style="color:blue;">可以长时间锁定一行。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="internal-table-level-locking"></a>Table-Level Locking</h4>

                        </div>

                    </div>

                </div>
                <p>
                    MySQL uses <a class="link" href="glossary.html#glos_table_lock" title="table lock">table-level
                    locking</a> for <code class="literal">MyISAM</code>,
                    <code class="literal">MEMORY</code>, and <code class="literal">MERGE</code>
                    tables, permitting only one session to update those tables at
                    a time. This locking level makes these storage engines more
                    suitable for read-only, read-mostly, or single-user
                    applications.
                </p><p style="color:blue;">mysql对myisam、内存和合并表使用表级锁定，一次只允许一个会话更新这些表。此锁定级别使这些存储引擎更适合于只读、多读或单用户应用程序。</p><p></p><p>
                These storage engines avoid
                <a class="link" href="glossary.html#glos_deadlock" title="deadlock">deadlocks</a> by always
                requesting all needed locks at once at the beginning of a
                query and always locking the tables in the same order. The
                tradeoff is that this strategy reduces concurrency; other
                sessions that want to modify the table must wait until the
                current data change statement finishes.
            </p><p style="color:blue;">这些存储引擎总是在查询开始时一次请求所有需要的锁，并且总是以相同的顺序锁定表，从而避免死锁。折衷的办法是，此策略减少了并发性；要修改表的其他会话必须等到当前数据更改语句完成。</p><p></p><p>
                Advantages of table-level locking:
            </p><p style="color:blue;">表级锁定的优点：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Relatively little memory required (row locking requires
                        memory per row or group of rows locked)
                    </p><p style="color:blue;">所需内存相对较少（行锁定要求每行或每组锁定的行具有内存）</p><p></p></li><li class="listitem"><p>
                        Fast when used on a large part of the table because only a
                        single lock is involved.
                    </p><p style="color:blue;">在表的很大一部分使用时很快，因为只涉及一个锁。</p><p></p></li><li class="listitem"><p>
                        Fast if you often do <code class="literal">GROUP BY</code>
                        operations on a large part of the data or must scan the
                        entire table frequently.
                    </p><p style="color:blue;">如果经常对大部分数据执行分组操作，或者必须经常扫描整个表，则速度很快。</p><p></p></li></ul>
                </div>
                <p>
                    MySQL grants table write locks as follows:
                </p><p style="color:blue;">mysql按如下方式授予表写锁：</p><p></p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        If there are no locks on the table, put a write lock on
                        it.
                    </p><p style="color:blue;">如果桌子上没有锁，就在上面加一个写锁。</p><p></p></li><li class="listitem"><p>
                        Otherwise, put the lock request in the write lock queue.
                    </p><p style="color:blue;">否则，将锁请求放入写锁队列。</p><p></p></li></ol>
                </div>
                <p>
                    MySQL grants table read locks as follows:
                </p><p style="color:blue;">mysql按如下方式授予表读锁：</p><p></p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        If there are no write locks on the table, put a read lock
                        on it.
                    </p><p style="color:blue;">如果表上没有写锁，则对其设置读锁。</p><p></p></li><li class="listitem"><p>
                        Otherwise, put the lock request in the read lock queue.
                    </p><p style="color:blue;">否则，将锁请求放入读锁队列。</p><p></p></li></ol>
                </div>
                <p>
                    Table updates are given higher priority than table retrievals.
                    Therefore, when a lock is released, the lock is made available
                    to the requests in the write lock queue and then to the
                    requests in the read lock queue. This ensures that updates to
                    a table are not <span class="quote">“<span class="quote">starved</span>”</span> even when there is
                    heavy <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> activity for the
                    table. However, if there are many updates for a table,
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements wait until
                    there are no more updates.
                </p><p style="color:blue;">表更新的优先级高于表检索。因此，当释放锁时，该锁对写锁队列中的请求可用，然后对读锁队列中的请求可用。这确保了即使在表有大量的select活动时，对表的更新也不会“饿死”。但是，如果一个表有很多更新，select语句会等到没有更多更新。</p><p></p><p>
                For information on altering the priority of reads and writes,
                see <a class="xref" href="optimization.html#table-locking" title="8.11.2&nbsp;Table Locking Issues">Section&nbsp;8.11.2, “Table Locking Issues”</a>.
            </p><p style="color:blue;">有关更改读写优先级的信息，请参阅第8.11.2节“表锁定问题”。</p><p></p><p>
                You can analyze the table lock contention on your system by
                checking the
                <a class="link" href="server-administration.html#statvar_Table_locks_immediate"><code class="literal">Table_locks_immediate</code></a> and
                <a class="link" href="server-administration.html#statvar_Table_locks_waited"><code class="literal">Table_locks_waited</code></a> status
                variables, which indicate the number of times that requests
                for table locks could be granted immediately and the number
                that had to wait, respectively:
            </p><p style="color:blue;">您可以通过检查table_locks_immediate和table_locks_waited状态变量来分析系统上的表锁争用，这些变量分别表示可以立即授予表锁请求的次数和必须等待的次数：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Table%';</code></strong>
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
</pre><p>
                The Performance Schema lock tables also provide locking
                information. See
                <a class="xref" href="performance-schema.html#performance-schema-lock-tables" title="25.12.12&nbsp;Performance Schema Lock Tables">Section&nbsp;25.12.12, “Performance Schema Lock Tables”</a>.
            </p><p style="color:blue;">性能架构锁定表还提供锁定信息。见第25.12.12节“性能模式锁表”。</p><p></p><a class="indexterm" name="idm140286869611200"></a><a class="indexterm" name="idm140286869610128"></a><p>
                The <code class="literal">MyISAM</code> storage engine supports
                concurrent inserts to reduce contention between readers and
                writers for a given table: If a <code class="literal">MyISAM</code>
                table has no free blocks in the middle of the data file, rows
                are always inserted at the end of the data file. In this case,
                you can freely mix concurrent
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> and
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements for a
                <code class="literal">MyISAM</code> table without locks. That is, you
                can insert rows into a <code class="literal">MyISAM</code> table at the
                same time other clients are reading from it. Holes can result
                from rows having been deleted from or updated in the middle of
                the table. If there are holes, concurrent inserts are disabled
                but are enabled again automatically when all holes have been
                filled with new data. To control this behavior, use the
                <a class="link" href="server-administration.html#sysvar_concurrent_insert"><code class="literal">concurrent_insert</code></a> system
                variable. See <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3&nbsp;Concurrent Inserts">Section&nbsp;8.11.3, “Concurrent Inserts”</a>.
            </p><p style="color:blue;">myisam存储引擎支持并发插入，以减少给定表的读写器之间的争用：如果myisam表在数据文件中间没有空闲块，则总是在数据文件末尾插入行。在这种情况下，可以自由地混合myisam表的并发insert和select语句，而不使用锁。也就是说，可以在其他客户机从myisam表中读取数据的同时将行插入到该表中。从表中间删除或更新的行可能会导致出现孔。如果存在孔，则禁用并发插入，但当所有孔都已填充新数据时，将再次自动启用。要控制此行为，请使用concurrent_insert系统变量。见第8.11.3节“并发插入”。</p><p></p><p>
                If you acquire a table lock explicitly with
                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>, you can request a
                <code class="literal">READ LOCAL</code> lock rather than a
                <code class="literal">READ</code> lock to enable other sessions to
                perform concurrent inserts while you have the table locked.
            </p><p style="color:blue;">如果使用锁表显式获取表锁，则可以请求读取本地锁而不是读取锁，以使其他会话在锁定表时执行并发插入。</p><p></p><p>
                To perform many <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> and
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> operations on a table
                <code class="literal">t1</code> when concurrent inserts are not
                possible, you can insert rows into a temporary table
                <code class="literal">temp_t1</code> and update the real table with the
                rows from the temporary table:
            </p><p style="color:blue;">要在无法同时插入时对表T1执行许多插入和选择操作，可以将行插入临时表temp_T1，并使用临时表中的行更新实际表：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLES t1 WRITE, temp_t1 WRITE;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 SELECT * FROM temp_t1;</code></strong>
mysql&gt; <strong class="userinput"><code>DELETE FROM temp_t1;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="internal-locking-choices"></a>Choosing the Type of Locking</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Generally, table locks are superior to row-level locks in the
                    following cases:
                </p><p style="color:blue;">通常，在以下情况下，表锁优于行级锁：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Most statements for the table are reads.
                    </p><p style="color:blue;">该表的大多数语句都是reads。</p><p></p></li><li class="listitem"><p>
                        Statements for the table are a mix of reads and writes,
                        where writes are updates or deletes for a single row that
                        can be fetched with one key read:
                    </p><p style="color:blue;">表的语句是读和写的混合，其中写是对一行的更新或删除，可以用一个键读取：</p><p></p><pre data-lang="sql" class="programlisting">UPDATE <em class="replaceable"><code>tbl_name</code></em> SET <em class="replaceable"><code>column</code></em>=<em class="replaceable"><code>value</code></em> WHERE <em class="replaceable"><code>unique_key_col</code></em>=<em class="replaceable"><code>key_value</code></em>;
DELETE FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>unique_key_col</code></em>=<em class="replaceable"><code>key_value</code></em>;
</pre></li><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> combined with
                        concurrent <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>
                        statements, and very few
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> or
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements.
                    </p><p style="color:blue;">select与并发insert语句结合使用，很少有update或delete语句。</p><p></p></li><li class="listitem"><p>
                        Many scans or <code class="literal">GROUP BY</code> operations on
                        the entire table without any writers.
                    </p><p style="color:blue;">对整个表执行许多扫描或按操作分组，而不使用任何写入程序。</p><p></p></li></ul>
                </div>
                <p>
                    With higher-level locks, you can more easily tune applications
                    by supporting locks of different types, because the lock
                    overhead is less than for row-level locks.
                </p><p style="color:blue;">使用更高级别的锁，您可以通过支持不同类型的锁来更轻松地优化应用程序，因为锁开销小于行级锁。</p><p></p><p>
                Options other than row-level locking:
            </p><p style="color:blue;">行级锁定以外的选项：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Versioning (such as that used in MySQL for concurrent
                        inserts) where it is possible to have one writer at the
                        same time as many readers. This means that the database or
                        table supports different views for the data depending on
                        when access begins. Other common terms for this are
                        <span class="quote">“<span class="quote">time travel,</span>”</span> <span class="quote">“<span class="quote">copy on write,</span>”</span>
                        or <span class="quote">“<span class="quote">copy on demand.</span>”</span>
                    </p><p style="color:blue;">版本控制（如mysql中用于并发插入的版本控制），其中可以同时拥有一个写入程序和多个读取程序。这意味着数据库或表支持不同的数据视图，这取决于访问开始的时间。其他常用术语是“时间旅行”、“书面复印”或“按需复印”。</p><p></p></li><li class="listitem"><p>
                        Copy on demand is in many cases superior to row-level
                        locking. However, in the worst case, it can use much more
                        memory than using normal locks.
                    </p><p style="color:blue;">在许多情况下，按需复制优于行级锁定。然而，在最坏的情况下，它可以使用比使用普通锁更多的内存。</p><p></p></li><li class="listitem"><p>
                        Instead of using row-level locks, you can employ
                        application-level locks, such as those provided by
                        <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a> and
                        <a class="link" href="functions.html#function_release-lock"><code class="literal">RELEASE_LOCK()</code></a> in MySQL.
                        These are advisory locks, so they work only with
                        applications that cooperate with each other. See
                        <a class="xref" href="functions.html#locking-functions" title="12.14&nbsp;Locking Functions">Section&nbsp;12.14, “Locking Functions”</a>.
                    </p><p style="color:blue;">与使用行级锁不同，您可以使用应用程序级锁，例如mysql中get_lock（）和release_lock（）提供的锁。这些是顾问锁，因此它们只与相互协作的应用程序一起工作。见第12.14节“锁定功能”。</p><p></p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="table-locking"></a>8.11.2&nbsp;Table Locking Issues</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286869562560"></a><p>
            <code class="literal">InnoDB</code> tables use row-level locking so that
            multiple sessions and applications can read from and write to
            the same table simultaneously, without making each other wait or
            producing inconsistent results. For this storage engine, avoid
            using the <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> statement,
            because it does not offer any extra protection, but instead
            reduces concurrency. The automatic row-level locking makes these
            tables suitable for your busiest databases with your most
            important data, while also simplifying application logic since
            you do not need to lock and unlock tables. Consequently, the
            <code class="literal">InnoDB</code> storage engine is the default in
            MySQL.
        </p><p style="color:blue;">innodb表使用行级锁定，这样多个会话和应用程序可以同时读取和写入同一个表，而不会使彼此等待或产生不一致的结果。对于这个存储引擎，避免使用lock tables语句，因为它不提供任何额外的保护，而是减少了并发性。自动行级锁定使这些表适合最繁忙的数据库和最重要的数据，同时也简化了应用程序逻辑，因为您不需要锁定和解锁表。因此，innodb存储引擎是mysql中的默认引擎。</p><p></p><p>
            MySQL uses table locking (instead of page, row, or column
            locking) for all storage engines except
            <code class="literal">InnoDB</code>. The locking operations themselves do
            not have much overhead. But because only one session can write
            to a table at any one time, for best performance with these
            other storage engines, use them primarily for tables that are
            queried often and rarely inserted into or updated.
        </p><p style="color:blue;">mysql对除innodb以外的所有存储引擎使用表锁定（而不是页、行或列锁定）。锁定操作本身没有太多开销。但是，由于一次只能有一个会话可以写入一个表，因此为了与这些其他存储引擎一起获得最佳性能，请将它们主要用于经常查询且很少插入或更新的表。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#table-locking-innodb" title="Performance Considerations Favoring InnoDB">Performance Considerations Favoring InnoDB</a></p><p style="color:blue;">有利于InnoDB的性能考虑</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#table-locking-workarounds" title="Workarounds for Locking Performance Issues">Workarounds for Locking Performance Issues</a></p><p style="color:blue;">锁定性能问题的解决方法</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="table-locking-innodb"></a>Performance Considerations Favoring InnoDB</h4>

                        </div>

                    </div>

                </div>
                <p>
                    When choosing whether to create a table using
                    <code class="literal">InnoDB</code> or a different storage engine, keep
                    in mind the following disadvantages of table locking:
                </p><p style="color:blue;">在选择使用innodb还是其他存储引擎创建表时，请记住表锁定的以下缺点：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Table locking enables many sessions to read from a table
                        at the same time, but if a session wants to write to a
                        table, it must first get exclusive access, meaning it
                        might have to wait for other sessions to finish with the
                        table first. During the update, all other sessions that
                        want to access this particular table must wait until the
                        update is done.
                    </p><p style="color:blue;">表锁定允许多个会话同时从一个表中读取数据，但如果一个会话要写入一个表，它必须首先获得独占访问权，这意味着它可能必须等待其他会话先完成对该表的访问。在更新期间，要访问此特定表的所有其他会话必须等到更新完成。</p><p></p></li><li class="listitem"><p>
                        Table locking causes problems when a session is waiting
                        because the disk is full and free space needs to become
                        available before the session can proceed. In this case,
                        all sessions that want to access the problem table are
                        also put in a waiting state until more disk space is made
                        available.
                    </p><p style="color:blue;">当会话正在等待时，表锁定会导致问题，因为磁盘已满，需要有可用空间才能继续会话。在这种情况下，要访问问题表的所有会话也将处于等待状态，直到有更多的磁盘空间可用。</p><p></p></li><li class="listitem"><p>
                        A <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement that
                        takes a long time to run prevents other sessions from
                        updating the table in the meantime, making the other
                        sessions appear slow or unresponsive. While a session is
                        waiting to get exclusive access to the table for updates,
                        other sessions that issue
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements will
                        queue up behind it, reducing concurrency even for
                        read-only sessions.
                    </p><p style="color:blue;">运行时间较长的select语句可防止其他会话同时更新表，从而使其他会话看起来很慢或没有响应。当会话等待以独占方式访问表以进行更新时，发出select语句的其他会话将在其后面排队，从而降低了即使是只读会话的并发性。</p><p></p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="table-locking-workarounds"></a>Workarounds for Locking Performance Issues</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following items describe some ways to avoid or reduce
                    contention caused by table locking:
                </p><p style="color:blue;">以下项目描述了一些避免或减少由表锁定引起的争用的方法：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Consider switching the table to the
                        <code class="literal">InnoDB</code> storage engine, either using
                        <code class="literal">CREATE TABLE ... ENGINE=INNODB</code> during
                        setup, or using <code class="literal">ALTER TABLE ...
                        ENGINE=INNODB</code> for an existing table. See
                        <a class="xref" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine">Chapter&nbsp;14, <i>The InnoDB Storage Engine</i></a> for more details
                        about this storage engine.
                    </p><p style="color:blue;">考虑将表切换到innodb存储引擎，或者使用create table…engine=innodb在安装期间，或使用alter table…引擎=现有表的InDB。有关此存储引擎的更多详细信息，请参阅第14章，InnoDB存储引擎。</p><p></p></li><li class="listitem"><p>
                        Optimize <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements
                        to run faster so that they lock tables for a shorter time.
                        You might have to create some summary tables to do this.
                    </p><p style="color:blue;">优化select语句以使其运行更快，以便它们锁定表的时间更短。您可能必须创建一些摘要表才能执行此操作。</p><p></p></li><li class="listitem"><p>
                        Start <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with
                        <a class="link" href="server-administration.html#sysvar_low_priority_updates"><code class="option">--low-priority-updates</code></a>. For
                        storage engines that use only table-level locking (such as
                        <code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>, and
                        <code class="literal">MERGE</code>), this gives all statements that
                        update (modify) a table lower priority than
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements. In this
                        case, the second <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        statement in the preceding scenario would execute before
                        the <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statement, and
                        would not wait for the first
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> to finish.
                    </p><p style="color:blue;">使用--低优先级更新启动mysqld。对于只使用表级锁定的存储引擎（如myisam、memory和merge），这将使更新（修改）表的所有语句的优先级低于select语句。在这种情况下，前面场景中的第二个select语句将在update语句之前执行，而不会等待第一个select语句完成。</p><p></p></li><li class="listitem"><p>
                        To specify that all updates issued in a specific
                        connection should be done with low priority, set the
                        <a class="link" href="server-administration.html#sysvar_low_priority_updates"><code class="literal">low_priority_updates</code></a>
                        server system variable equal to 1.
                    </p><p style="color:blue;">要指定在特定连接中发出的所有更新都应以低优先级完成，请将low_priority_updates server系统变量设置为1。</p><p></p></li><li class="listitem"><p>
                        To give a specific <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                        <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a>, or
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statement lower
                        priority, use the <code class="literal">LOW_PRIORITY</code>
                        attribute.
                    </p><p style="color:blue;">若要赋予特定的INSERT、UPDATE或DELETE语句较低的优先级，请使用“低优先级”属性。</p><p></p></li><li class="listitem"><p>
                        To give a specific <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        statement higher priority, use the
                        <code class="literal">HIGH_PRIORITY</code> attribute. See
                        <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
                    </p><p style="color:blue;">要赋予特定的select语句更高的优先级，请使用high_priority属性。参见第13.2.9节“选择语法”。</p><p></p></li><li class="listitem"><p>
                        Start <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with a low value for the
                        <a class="link" href="server-administration.html#sysvar_max_write_lock_count"><code class="literal">max_write_lock_count</code></a>
                        system variable to force MySQL to temporarily elevate the
                        priority of all <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                        statements that are waiting for a table after a specific
                        number of inserts to the table occur. This permits
                        <code class="literal">READ</code> locks after a certain number of
                        <code class="literal">WRITE</code> locks.
                    </p><p style="color:blue;">使用max_write_lock_count系统变量的低值启动mysqld，以强制mysql在发生特定数量的表插入之后临时提升等待表的所有select语句的优先级。这允许在一定数量的写锁之后进行读锁。</p><p></p></li><li class="listitem"><p>


                        If you have problems with
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> combined with
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, consider switching
                        to <code class="literal">MyISAM</code> tables, which support
                        concurrent <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> and
                        <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements. (See
                        <a class="xref" href="optimization.html#concurrent-inserts" title="8.11.3&nbsp;Concurrent Inserts">Section&nbsp;8.11.3, “Concurrent Inserts”</a>.)
                    </p><p style="color:blue;">如果insert和select结合使用时出现问题，请考虑切换到myisam表，该表支持并发的select和insert语句。（见第8.11.3节，“并发插入件”。）</p><p></p></li><li class="listitem"><p>
                        If you have problems with mixed
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> and
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> statements, the
                        <code class="literal">LIMIT</code> option to
                        <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> may help. See
                        <a class="xref" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax">Section&nbsp;13.2.2, “DELETE Syntax”</a>.
                    </p><p style="color:blue;">如果您在混合select和delete语句中有问题，那么要删除的limit选项可能会有帮助。见第13.2.2节“删除语法”。</p><p></p></li><li class="listitem"><p>
                        Using <code class="literal">SQL_BUFFER_RESULT</code> with
                        <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements can help
                        to make the duration of table locks shorter. See
                        <a class="xref" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax">Section&nbsp;13.2.9, “SELECT Syntax”</a>.
                    </p><p style="color:blue;">对select语句使用sql_buffer_result有助于缩短表锁的持续时间。参见第13.2.9节“选择语法”。</p><p></p></li><li class="listitem"><p>
                        Splitting table contents into separate tables may help, by
                        allowing queries to run against columns in one table,
                        while updates are confined to columns in a different
                        table.
                    </p><p style="color:blue;">将表内容拆分为单独的表可能会有所帮助，因为允许对一个表中的列运行查询，而更新仅限于另一个表中的列。</p><p></p></li><li class="listitem"><p>
                        You could change the locking code in
                        <code class="filename">mysys/thr_lock.c</code> to use a single
                        queue. In this case, write locks and read locks would have
                        the same priority, which might help some applications.
                    </p><p style="color:blue;">可以将mysys/thr_lock.c中的锁定代码更改为使用单个队列。在这种情况下，写锁和读锁具有相同的优先级，这可能有助于某些应用程序。</p><p></p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="concurrent-inserts"></a>8.11.3&nbsp;Concurrent Inserts</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286869486944"></a><a class="indexterm" name="idm140286869485872"></a><p>
            The <code class="literal">MyISAM</code> storage engine supports concurrent
            inserts to reduce contention between readers and writers for a
            given table: If a <code class="literal">MyISAM</code> table has no holes
            in the data file (deleted rows in the middle), an
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statement can be executed
            to add rows to the end of the table at the same time that
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements are reading
            rows from the table. If there are multiple
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements, they are
            queued and performed in sequence, concurrently with the
            <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements. The results of
            a concurrent <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> may not be
            visible immediately.
        </p><p style="color:blue;">myisam存储引擎支持并发插入，以减少给定表的读写器之间的争用：如果myisam表的数据文件中没有孔（中间的已删除行），则可以执行insert语句，在select语句从表中读取行的同时将行添加到表的末尾。如果有多个insert语句，它们将与select语句同时排队并按顺序执行。并发插入的结果可能无法立即显示。</p><p></p><p>
            The <a class="link" href="server-administration.html#sysvar_concurrent_insert"><code class="literal">concurrent_insert</code></a> system
            variable can be set to modify the concurrent-insert processing.
            By default, the variable is set to <code class="literal">AUTO</code> (or
            1) and concurrent inserts are handled as just described. If
            <a class="link" href="server-administration.html#sysvar_concurrent_insert"><code class="literal">concurrent_insert</code></a> is set to
            <code class="literal">NEVER</code> (or 0), concurrent inserts are
            disabled. If the variable is set to <code class="literal">ALWAYS</code>
            (or 2), concurrent inserts at the end of the table are permitted
            even for tables that have deleted rows. See also the description
            of the <a class="link" href="server-administration.html#sysvar_concurrent_insert"><code class="literal">concurrent_insert</code></a> system
            variable.
        </p><p style="color:blue;">可以设置concurrent_insert系统变量来修改并发插入处理。默认情况下，变量被设置为auto（或1），并发插入的处理如前所述。如果concurrent_insert设置为never（或0），则禁用concurrent insert。如果变量设置为ALWAYS（或2），则即使已删除行的表也允许在表末尾进行并发插入。另请参见concurrent_insert系统变量的说明。</p><p></p><p>
            If you are using the binary log, concurrent inserts are
            converted to normal inserts for <code class="literal">CREATE ...
            SELECT</code> or
            <a class="link" href="sql-syntax.html#insert-select" title="13.2.5.1&nbsp;INSERT ... SELECT Syntax"><code class="literal">INSERT ...
                SELECT</code></a> statements. This is done to ensure that you can
            re-create an exact copy of your tables by applying the log
            during a backup operation. See <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>. In
            addition, for those statements a read lock is placed on the
            selected-from table such that inserts into that table are
            blocked. The effect is that concurrent inserts for that table
            must wait as well.
        </p><p style="color:blue;">如果使用的是二进制日志，则并发插入将转换为普通插入以创建…选择或插入…选择语句。这样做是为了确保可以通过在备份操作期间应用日志来重新创建表的精确副本。见第5.4.4节“二进制日志”。此外，对于这些语句，将在“从表中选择”上放置一个读锁，以便阻止插入到该表中。其结果是该表的并发插入也必须等待。</p><p></p><p>
            With <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a>, if you specify
            <code class="literal">CONCURRENT</code> with a <code class="literal">MyISAM</code>
            table that satisfies the condition for concurrent inserts (that
            is, it contains no free blocks in the middle), other sessions
            can retrieve data from the table while <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
            DATA</code></a> is executing. Use of the
            <code class="literal">CONCURRENT</code> option affects the performance of
            <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> a bit, even if no other
            session is using the table at the same time.
        </p><p style="color:blue;">对于加载数据，如果指定与满足并发插入条件（即中间不包含空闲块）的myisam表并发，则其他会话可以在执行加载数据时从表中检索数据。使用concurrent选项会稍微影响加载数据的性能，即使没有其他会话同时使用该表。</p><p></p><p>
            If you specify <code class="literal">HIGH_PRIORITY</code>, it overrides
            the effect of the
            <a class="link" href="server-administration.html#sysvar_low_priority_updates"><code class="option">--low-priority-updates</code></a> option if
            the server was started with that option. It also causes
            concurrent inserts not to be used.
        </p><p style="color:blue;">如果指定high_priority，则当服务器使用该选项启动时，它将覆盖--low priority updates选项的效果。它还导致不使用并发插入。</p><p></p><p>
            For <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
            TABLE</code></a>, the difference between <code class="literal">READ
            LOCAL</code> and <code class="literal">READ</code> is that
            <code class="literal">READ LOCAL</code> permits nonconflicting
            <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> statements (concurrent
            inserts) to execute while the lock is held. However, this cannot
            be used if you are going to manipulate the database using
            processes external to the server while you hold the lock.
        </p><p style="color:blue;">对于锁表，read local和read的区别在于，read local允许在保持锁的同时执行非冲突的insert语句（并发插入）。但是，如果要在持有锁的同时使用服务器外部的进程来操作数据库，则不能使用此选项。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="metadata-locking"></a>8.11.4&nbsp;Metadata Locking</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286869450160"></a><a class="indexterm" name="idm140286869449088"></a><a class="indexterm" name="idm140286869447600"></a><p>
            MySQL uses metadata locking to manage concurrent access to
            database objects and to ensure data consistency. Metadata
            locking applies not just to tables, but also to schemas, stored
            programs (procedures, functions, triggers, scheduled events),
            tablespaces, user locks acquired with the
            <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a> function (see
            <a class="xref" href="functions.html#locking-functions" title="12.14&nbsp;Locking Functions">Section&nbsp;12.14, “Locking Functions”</a>), and locks acquired with
            the locking service described in
            <a class="xref" href="extending-mysql.html#locking-service" title="28.3.1&nbsp;The Locking Service">Section&nbsp;28.3.1, “The Locking Service”</a>.
        </p><p style="color:blue;">mysql使用元数据锁定来管理对数据库对象的并发访问并确保数据一致性。元数据锁定不仅适用于表，还适用于模式、存储程序（过程、函数、触发器、计划事件）、表空间、使用get_lock（）函数获取的用户锁（请参见第12.14节“锁定函数”）和使用第28.3.1节“锁定服务”中描述的锁定服务获取的锁。</p><p></p><p>
            The Performance Schema
            <a class="link" href="performance-schema.html#metadata-locks-table" title="25.12.12.1&nbsp;The metadata_locks Table"><code class="literal">metadata_locks</code></a> table exposes
            metadata lock information, which can be useful for seeing which
            sessions hold locks, are blocked waiting for locks, and so
            forth. For details, see <a class="xref" href="performance-schema.html#metadata-locks-table" title="25.12.12.1&nbsp;The metadata_locks Table">Section&nbsp;25.12.12.1, “The metadata_locks Table”</a>.
        </p><p style="color:blue;">performance schema metadata_locks表公开元数据锁信息，这对于查看哪些会话持有锁、哪些会话被阻止等待锁等非常有用。有关详细信息，请参见第25.12.12.1节“元数据锁定表”。</p><p></p><p>
            Metadata locking does involve some overhead, which increases as
            query volume increases. Metadata contention increases the more
            that multiple queries attempt to access the same objects.
        </p><p style="color:blue;">元数据锁定确实涉及一些开销，这会随着查询量的增加而增加。元数据争用增加了多个查询试图访问相同对象的次数。</p><p></p><p>
            Metadata locking is not a replacement for the table definition
            cache, and its mutexes and locks differ from the
            <code class="literal">LOCK_open</code> mutex. The following discussion
            provides some information about how metadata locking works.
        </p><p style="color:blue;">元数据锁定不能替代表定义缓存，它的互斥量和锁与lock_open互斥量不同。下面的讨论提供了一些有关元数据锁定工作方式的信息。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#metadata-lock-acquisition" title="Metadata Lock Acquisition">Metadata Lock Acquisition</a></p><p style="color:blue;">元数据锁获取</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#metadata-lock-release" title="Metadata Lock Release">Metadata Lock Release</a></p><p style="color:blue;">元数据锁释放</p><p></p></li></ul>
            </div>

            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="metadata-lock-acquisition"></a>Metadata Lock Acquisition</h4>

                        </div>

                    </div>

                </div>
                <p>
                    If there are multiple waiters for a given lock, the
                    highest-priority lock request is satisfied first, with an
                    exception related to the
                    <a class="link" href="server-administration.html#sysvar_max_write_lock_count"><code class="literal">max_write_lock_count</code></a> system
                    variable. Write lock requests have higher priority than read
                    lock requests. However, if
                    <a class="link" href="server-administration.html#sysvar_max_write_lock_count"><code class="literal">max_write_lock_count</code></a> is set
                    to some low value (say, 10), read lock requests may be
                    preferred over pending write lock requests if the read lock
                    requests have already been passed over in favor of 10 write
                    lock requests. Normally this behavior does not occur because
                    <a class="link" href="server-administration.html#sysvar_max_write_lock_count"><code class="literal">max_write_lock_count</code></a> by
                    default has a very large value.
                </p><p style="color:blue;">如果给定锁有多个等待者，则首先满足最高优先级的锁请求，但与max_write_lock_count系统变量相关的异常除外。写锁请求的优先级高于读锁请求。但是，如果将max_write_lock_count设置为某个较低的值（例如10），则如果读锁请求已经被传递给10个写锁请求，则读锁请求可能优先于挂起的写锁请求。通常不会发生此行为，因为默认情况下max_write_lock_count有一个非常大的值。</p><p></p><p>
                Statements acquire metadata locks one by one, not
                simultaneously, and perform deadlock detection in the process.
            </p><p style="color:blue;">语句逐个（而不是同时）获取元数据锁，并在过程中执行死锁检测。</p><p></p><p>
                DML statements normally acquire locks in the order in which
                tables are mentioned in the statement.
            </p><p style="color:blue;">DML语句通常按照语句中提到表的顺序获取锁。</p><p></p><p>
                DDL statements, <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>,
                and other similar statements try to reduce the number of
                possible deadlocks between concurrent DDL statements by
                acquiring locks on explicitly named tables in name order.
                Locks might be acquired in a different order for implicitly
                used tables (such as tables in foreign key relationships that
                also must be locked).
            </p><p style="color:blue;">ddl语句、锁表和其他类似的语句试图通过按名称顺序获取显式命名表的锁来减少并发ddl语句之间可能出现的死锁数。对于隐式使用的表（例如，外键关系中也必须锁定的表），可以按不同的顺序获取锁。</p><p></p><p>
                For example, <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a> is a
                DDL statement that acquires locks in name order:
            </p><p style="color:blue;">例如，rename table是一个ddl语句，它按名称顺序获取锁：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        This <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a> statement
                        renames <code class="literal">tbla</code> to something else, and
                        renames <code class="literal">tblc</code> to
                        <code class="literal">tbla</code>:
                    </p><p style="color:blue;">此RENAME TABLE语句将TBLA重命名为其他名称，并将TBLC重命名为TBLA：</p><p></p><pre data-lang="sql" class="programlisting">RENAME TABLE tbla TO tbld, tblc TO tbla;
</pre><p>
                        The statement acquires metadata locks, in order, on
                        <code class="literal">tbla</code>, <code class="literal">tblc</code>, and
                        <code class="literal">tbld</code> (because <code class="literal">tbld</code>
                        follows <code class="literal">tblc</code> in name order):
                    </p><p style="color:blue;">语句按顺序获取tbla、tblc和tbld上的元数据锁（因为tbld按名称顺序跟随tblc）：</p><p></p></li><li class="listitem"><p>
                        This slightly different statement also renames
                        <code class="literal">tbla</code> to something else, and renames
                        <code class="literal">tblc</code> to <code class="literal">tbla</code>:
                    </p><p style="color:blue;">这个稍有不同的语句还将tbla重命名为其他名称，并将tblc重命名为tbla：</p><p></p><pre data-lang="sql" class="programlisting">RENAME TABLE tbla TO tblb, tblc TO tbla;
</pre><p>
                        In this case, the statement acquires metadata locks, in
                        order, on <code class="literal">tbla</code>,
                        <code class="literal">tblb</code>, and <code class="literal">tblc</code>
                        (because <code class="literal">tblb</code> precedes
                        <code class="literal">tblc</code> in name order):
                    </p><p style="color:blue;">在这种情况下，语句按顺序获取tbla、tblb和tblc上的元数据锁（因为tblb在名称顺序上先于tblc）：</p><p></p></li></ul>
                </div>
                <p>
                    Both statements acquire locks on <code class="literal">tbla</code> and
                    <code class="literal">tblc</code>, in that order, but differ in whether
                    the lock on the remaining table name is acquired before or
                    after <code class="literal">tblc</code>.
                </p><p style="color:blue;">这两个语句都按这个顺序获取tbla和tblc上的锁，但在剩余表名上的锁是在tblc之前还是之后获取方面有所不同。</p><p></p><p>
                Metadata lock acquisition order can make a difference in
                operation outcome when multiple transactions execute
                concurrently, as the following example illustrates.
            </p><p style="color:blue;">当多个事务同时执行时，元数据锁获取顺序可以影响操作结果，如下例所示。</p><p></p><p>
                Begin with two tables <code class="literal">x</code> and
                <code class="literal">x_new</code> that have identical structure. Three
                clients issue statements that involve these tables:
            </p><p style="color:blue;">从具有相同结构的两个表x和x_new开始。三个客户机发出涉及这些表的语句：</p><p></p><p>
                Client 1:
            </p><p style="color:blue;">客户1：</p><p></p><pre data-lang="sql" class="programlisting">LOCK TABLE x WRITE, x_new WRITE;
</pre><p>
                The statement requests and acquires write locks in name order
                on <code class="literal">x</code> and <code class="literal">x_new</code>.
            </p><p style="color:blue;">语句按名称顺序请求并获取x和x_new上的写锁。</p><p></p><p>
                Client 2:
            </p><p style="color:blue;">客户2：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO x VALUES(1);
</pre><p>
                The statement requests and blocks waiting for a write lock on
                <code class="literal">x</code>.
            </p><p style="color:blue;">语句请求并阻塞等待X上的写锁。</p><p></p><p>
                Client 3:
            </p><p style="color:blue;">客户3：</p><p></p><pre data-lang="sql" class="programlisting">RENAME TABLE x TO x_old, x_new TO x;
</pre><p>
                The statement requests exclusive locks in name order on
                <code class="literal">x</code>, <code class="literal">x_new</code>, and
                <code class="literal">x_old</code>, but blocks waiting for the lock on
                <code class="literal">x</code>.
            </p><p style="color:blue;">语句按名称顺序在x、x新和x旧上请求独占锁，但阻塞等待x上的锁。</p><p></p><p>
                Client 1:
            </p><p style="color:blue;">客户1：</p><p></p><pre data-lang="sql" class="programlisting">UNLOCK TABLES;
</pre><p>
                The statement releases the write locks on <code class="literal">x</code>
                and <code class="literal">x_new</code>. The exclusive lock request for
                <code class="literal">x</code> by Client 3 has higher priority than the
                write lock request by Client 2, so Client 3 acquires its lock
                on <code class="literal">x</code>, then also on <code class="literal">x_new</code>
                and <code class="literal">x_old</code>, performs the renaming, and
                releases its locks. Client 2 then acquires its lock on
                <code class="literal">x</code>, performs the insert, and releases its
                lock.
            </p><p style="color:blue;">语句释放x和x_new上的写锁。客户机3对x的独占锁请求的优先级高于客户机2的写锁请求，因此客户机3获取其对x的锁，然后在x新和x旧上执行重命名并释放其锁。然后，客户机2获取其对x的锁，执行插入并释放其锁。</p><p></p><p>
                Lock acquisition order results in the
                <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a> executing before
                the <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>. The
                <code class="literal">x</code> into which the insert occurs is the table
                that was named <code class="literal">x_new</code> when Client 2 issued
                the insert and was renamed to <code class="literal">x</code> by Client
                3:
            </p><p style="color:blue;">锁定获取顺序导致在插入之前执行重命名表。发生插入的x是在客户机2发出插入时命名为x_new并由客户机3重命名为x的表：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM x;</code></strong>
+------+
| i    |
+------+
|    1 |
+------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM x_old;</code></strong>
Empty set (0.01 sec)
</pre><p>
                Now begin instead with tables named <code class="literal">x</code> and
                <code class="literal">new_x</code> that have identical structure. Again,
                three clients issue statements that involve these tables:
            </p><p style="color:blue;">现在从名为x的表和具有相同结构的new_x开始。同样，有三个客户机发出涉及这些表的语句：</p><p></p><p>
                Client 1:
            </p><p style="color:blue;">客户1：</p><p></p><pre data-lang="sql" class="programlisting">LOCK TABLE x WRITE, new_x WRITE;
</pre><p>
                The statement requests and acquires write locks in name order
                on <code class="literal">new_x</code> and <code class="literal">x</code>.
            </p><p style="color:blue;">语句按名称顺序请求并获取新x和x上的写锁。</p><p></p><p>
                Client 2:
            </p><p style="color:blue;">客户2：</p><p></p><pre data-lang="sql" class="programlisting">INSERT INTO x VALUES(1);
</pre><p>
                The statement requests and blocks waiting for a write lock on
                <code class="literal">x</code>.
            </p><p style="color:blue;">语句请求并阻塞等待X上的写锁。</p><p></p><p>
                Client 3:
            </p><p style="color:blue;">客户3：</p><p></p><pre data-lang="sql" class="programlisting">RENAME TABLE x TO old_x, new_x TO x;
</pre><p>
                The statement requests exclusive locks in name order on
                <code class="literal">new_x</code>, <code class="literal">old_x</code>, and
                <code class="literal">x</code>, but blocks waiting for the lock on
                <code class="literal">new_x</code>.
            </p><p style="color:blue;">语句按名称顺序对new_x、old_x和x请求排他锁，但阻塞等待new_x上的锁。</p><p></p><p>
                Client 1:
            </p><p style="color:blue;">客户1：</p><p></p><pre data-lang="sql" class="programlisting">UNLOCK TABLES;
</pre><p>
                The statement releases the write locks on <code class="literal">x</code>
                and <code class="literal">new_x</code>. For <code class="literal">x</code>, the
                only pending request is by Client 2, so Client 2 acquires its
                lock, performs the insert, and releases the lock. For
                <code class="literal">new_x</code>, the only pending request is by
                Client 3, which is permitted to acquire that lock (and also
                the lock on <code class="literal">old_x</code>). The rename operation
                still blocks for the lock on <code class="literal">x</code> until the
                Client 2 insert finishes and releases its lock. Then Client 3
                acquires the lock on <code class="literal">x</code>, performs the
                rename, and releases its lock.
            </p><p style="color:blue;">语句释放x和new_x上的写锁。对于x，唯一挂起的请求是由客户机2发出的，因此客户机2获取其锁，执行插入并释放锁。对于new_x，唯一挂起的请求是客户端3，它被允许获取该锁（以及旧_x上的锁）。重命名操作仍然会阻塞X上的锁，直到客户端2插入完成并释放其锁。然后客户机3获取x上的锁，执行重命名并释放其锁。</p><p></p><p>
                In this case, lock acquisition order results in the
                <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> executing before the
                <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a>. The
                <code class="literal">x</code> into which the insert occurs is the
                original <code class="literal">x</code>, now renamed to
                <code class="literal">old_x</code> by the rename operation:
            </p><p style="color:blue;">在这种情况下，锁定获取顺序会导致在重命名表之前执行insert。发生插入的x是原始x，现在通过重命名操作重命名为旧x：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM x;</code></strong>
Empty set (0.01 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM old_x;</code></strong>
+------+
| i    |
+------+
|    1 |
+------+
</pre><p>
                If order of lock acquisition in concurrent statements makes a
                difference to an application in operation outcome, as in the
                preceding example, you may be able to adjust the table names
                to affect the order of lock acquisition.
            </p><p style="color:blue;">如果并发语句中的锁获取顺序对操作结果中的应用程序有影响，如前例所示，则可以调整表名以影响锁获取顺序。</p><p></p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="metadata-lock-release"></a>Metadata Lock Release</h4>

                        </div>

                    </div>

                </div>
                <p>
                    To ensure transaction serializability, the server must not
                    permit one session to perform a data definition language (DDL)
                    statement on a table that is used in an uncompleted explicitly
                    or implicitly started transaction in another session. The
                    server achieves this by acquiring metadata locks on tables
                    used within a transaction and deferring release of those locks
                    until the transaction ends. A metadata lock on a table
                    prevents changes to the table's structure. This locking
                    approach has the implication that a table that is being used
                    by a transaction within one session cannot be used in DDL
                    statements by other sessions until the transaction ends.
                </p><p style="color:blue;">为确保事务可序列化，服务器不得允许一个会话对另一个会话中未完成的显式或隐式启动的事务中使用的表执行数据定义语言（DDL）语句。服务器通过获取事务中使用的表的元数据锁并将这些锁的释放推迟到事务结束时来实现。表上的元数据锁防止更改表的结构。这种锁定方法意味着在一个会话中由事务使用的表在事务结束之前不能被其他会话在ddl语句中使用。</p><p></p><p>
                This principle applies not only to transactional tables, but
                also to nontransactional tables. Suppose that a session begins
                a transaction that uses transactional table
                <code class="literal">t</code> and nontransactional table
                <code class="literal">nt</code> as follows:
            </p><p style="color:blue;">这个原则不仅适用于事务表，也适用于非事务表。假设会话开始使用事务表t和非事务表nt的事务，如下所示：</p><p></p><pre data-lang="sql" class="programlisting">START TRANSACTION;
SELECT * FROM t;
SELECT * FROM nt;
</pre><p>
                The server holds metadata locks on both <code class="literal">t</code>
                and <code class="literal">nt</code> until the transaction ends. If
                another session attempts a DDL or write lock operation on
                either table, it blocks until metadata lock release at
                transaction end. For example, a second session blocks if it
                attempts any of these operations:
            </p><p style="color:blue;">在事务结束之前，服务器在t和nt上保持元数据锁。如果另一个会话尝试对任意一个表执行DDL或写锁操作，它将阻塞，直到事务结束时释放元数据锁。例如，如果第二个会话尝试执行以下任何操作，则它将阻塞：</p><p></p><pre data-lang="sql" class="programlisting">DROP TABLE t;
ALTER TABLE t ...;
DROP TABLE nt;
ALTER TABLE nt ...;
LOCK TABLE t ... WRITE;
</pre><p>
                The same behavior applies for The
                <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES ...
                    READ</code></a>. That is, explicitly or implicitly started
                transactions that update any table (transactional or
                nontransactional) will block and be blocked by <code class="literal">LOCK
                TABLES ... READ</code> for that table.
            </p><p style="color:blue;">同样的行为也适用于锁表…阅读。也就是说，显式或隐式启动的更新任何表（事务性或非事务性）的事务将被锁表阻塞…读那张桌子。</p><p></p><p>
                If the server acquires metadata locks for a statement that is
                syntactically valid but fails during execution, it does not
                release the locks early. Lock release is still deferred to the
                end of the transaction because the failed statement is written
                to the binary log and the locks protect log consistency.
            </p><p style="color:blue;">如果服务器获取语法有效但在执行期间失败的语句的元数据锁，则不会提前释放锁。锁释放仍然推迟到事务结束，因为失败的语句被写入二进制日志，锁保护日志一致性。</p><p></p><p>
                In autocommit mode, each statement is in effect a complete
                transaction, so metadata locks acquired for the statement are
                held only to the end of the statement.
            </p><p style="color:blue;">在autocommit模式下，每条语句实际上是一个完整的事务，因此为语句获取的元数据锁只保留到语句的末尾。</p><p></p><p>
                Metadata locks acquired during a
                <a class="link" href="sql-syntax.html#prepare" title="13.5.1&nbsp;PREPARE Syntax"><code class="literal">PREPARE</code></a> statement are released
                once the statement has been prepared, even if preparation
                occurs within a multiple-statement transaction.
            </p><p style="color:blue;">在prepare语句期间获取的元数据锁在语句准备完成后释放，即使准备发生在多语句事务中。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="external-locking"></a>8.11.5&nbsp;External Locking</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286869333376"></a><a class="indexterm" name="idm140286869332304"></a><p>
            External locking is the use of file system locking to manage
            contention for <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> database
            tables by multiple processes. External locking is used in
            situations where a single process such as the MySQL server
            cannot be assumed to be the only process that requires access to
            tables. Here are some examples:
        </p><p style="color:blue;">外部锁定是使用文件系统锁定来管理多个进程对myisam数据库表的争用。外部锁定用于不能假设只有一个进程（如mysql服务器）需要访问表的情况。下面是一些例子：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you run multiple servers that use the same database
                    directory (not recommended), each server must have external
                    locking enabled.
                </p><p style="color:blue;">如果运行多个使用相同数据库目录的服务器（不推荐），则每个服务器都必须启用外部锁定。</p><p></p></li><li class="listitem"><p>
                    If you use <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> to perform table
                    maintenance operations on
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables, you must either
                    ensure that the server is not running, or that the server
                    has external locking enabled so that it locks table files as
                    necessary to coordinate with <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>
                    for access to the tables. The same is true for use of
                    <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> to pack
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables.
                </p><p style="color:blue;">如果使用myisamchk对myisam表执行表维护操作，则必须确保服务器未运行，或者服务器已启用外部锁定，以便根据需要锁定表文件，以便与myisamchk协调访问表。使用myisam pack打包myisam表也是如此。</p><p></p><p>
                    If the server is run with external locking enabled, you can
                    use <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> at any time for read
                    operations such a checking tables. In this case, if the
                    server tries to update a table that
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> is using, the server will wait
                    for <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> to finish before it
                    continues.
                </p><p style="color:blue;">如果服务器在启用外部锁定的情况下运行，则可以随时使用myisamchk执行读取操作，例如检查表。在这种情况下，如果服务器试图更新myisamchk正在使用的表，则服务器将等待myisamchk完成后再继续。</p><p></p><p>
                    If you use <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> for write operations
                    such as repairing or optimizing tables, or if you use
                    <a class="link" href="programs.html#myisampack" title="4.6.5&nbsp;myisampack — Generate Compressed, Read-Only MyISAM Tables"><span class="command"><strong>myisampack</strong></span></a> to pack tables, you
                    <span class="emphasis"><em>must</em></span> always ensure that the
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> server is not using the table. If
                    you do not stop <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>, at least do a
                    <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin flush-tables</strong></span></a> before you run
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>. Your tables <span class="emphasis"><em>may
            become corrupted</em></span> if the server and
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> access the tables
                    simultaneously.
                </p><p style="color:blue;">如果使用myisamchk执行诸如修复或优化表之类的写操作，或者使用myisampack打包表，则必须始终确保mysqld服务器不使用该表。如果不停止mysqld，至少在运行myisamchk之前先刷新mysqladmin表。如果服务器和myisamchk同时访问表，则您的表可能会损坏。</p><p></p></li></ul>
            </div>
            <p>
                With external locking in effect, each process that requires
                access to a table acquires a file system lock for the table
                files before proceeding to access the table. If all necessary
                locks cannot be acquired, the process is blocked from accessing
                the table until the locks can be obtained (after the process
                that currently holds the locks releases them).
            </p><p style="color:blue;">当外部锁定生效时，需要访问表的每个进程在继续访问表之前获取表文件的文件系统锁。如果无法获取所有必需的锁，则会阻止进程访问表，直到可以获取锁为止（在当前持有锁的进程释放锁之后）。</p><p></p><p>
            External locking affects server performance because the server
            must sometimes wait for other processes before it can access
            tables.
        </p><p style="color:blue;">外部锁定会影响服务器性能，因为服务器有时必须等待其他进程才能访问表。</p><p></p><p>
            External locking is unnecessary if you run a single server to
            access a given data directory (which is the usual case) and if
            no other programs such as <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> need to
            modify tables while the server is running. If you only
            <span class="emphasis"><em>read</em></span> tables with other programs, external
            locking is not required, although <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>
            might report warnings if the server changes tables while
            <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> is reading them.
        </p><p style="color:blue;">如果运行单个服务器来访问给定的数据目录（通常是这种情况），并且如果服务器运行时没有其他程序（如myisamchk）需要修改表，则不需要外部锁定。如果只使用其他程序读取表，则不需要外部锁定，尽管myisamchk在myisamchk读取表时，如果服务器更改表，则可能会报告警告。</p><p></p><p>
            With external locking disabled, to use
            <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>, you must either stop the server
            while <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> executes or else lock and
            flush the tables before running <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>.
            (See <a class="xref" href="optimization.html#system-optimization" title="8.12.1&nbsp;System Factors">Section&nbsp;8.12.1, “System Factors”</a>.) To avoid this
            requirement, use the <a class="link" href="sql-syntax.html#check-table" title="13.7.2.2&nbsp;CHECK TABLE Syntax"><code class="literal">CHECK TABLE</code></a>
            and <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> statements to
            check and repair <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables.
        </p><p style="color:blue;">在禁用外部锁定的情况下，若要使用myisamchk，必须在myisamchk执行时停止服务器，或者在运行myisamchk之前锁定并刷新表。（见8.12.1节，“系统因素”。）为避免此要求，请使用检查表和修复表语句检查和修复myisam表。</p><p></p><p>
            For <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>, external locking is controlled by
            the value of the
            <a class="link" href="server-administration.html#sysvar_skip_external_locking"><code class="literal">skip_external_locking</code></a> system
            variable. When this variable is enabled, external locking is
            disabled, and vice versa. External locking is disabled by
            default.
        </p><p style="color:blue;">对于mysqld，外部锁定由skip_external_locking系统变量的值控制。启用此变量时，将禁用外部锁定，反之亦然。默认情况下禁用外部锁定。</p><p></p><p>
            Use of external locking can be controlled at server startup by
            using the <a class="link" href="server-administration.html#option_mysqld_external-locking"><code class="option">--external-locking</code></a> or
            <a class="link" href="server-administration.html#option_mysqld_external-locking"><code class="option">--skip-external-locking</code></a>
            option.
        </p><p style="color:blue;">外部锁定的使用可以在服务器启动时通过使用--external locking或--skip external locking选项进行控制。</p><p></p><p>
            If you do use external locking option to enable updates to
            <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables from many MySQL
            processes, you must ensure that the following conditions are
            satisfied:
        </p><p style="color:blue;">如果确实使用外部锁定选项从许多mysql进程对myisam表进行更新，则必须确保满足以下条件：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    Do not use the query cache for queries that use tables that
                    are updated by another process.
                </p><p style="color:blue;">对于使用由其他进程更新的表的查询，不要使用查询缓存。</p><p></p></li><li class="listitem"><p>
                    Do not start the server with the
                    <a class="link" href="server-administration.html#sysvar_delay_key_write"><code class="literal">delay_key_write</code></a> system
                    variable set to <code class="literal">ALL</code> or use the
                    <code class="literal">DELAY_KEY_WRITE=1</code> table option for any
                    shared tables. Otherwise, index corruption can occur.
                </p><p style="color:blue;">不要在DELAY U KEY U WRITE系统变量设置为ALL时启动服务器，或对任何共享表使用DELAY U KEY U WRITE=1表选项。否则，可能会发生索引损坏。</p><p></p></li></ul>
            </div>
            <p>
                The easiest way to satisfy these conditions is to always use
                <a class="link" href="server-administration.html#option_mysqld_external-locking"><code class="option">--external-locking</code></a> together with
                <a class="link" href="server-administration.html#sysvar_delay_key_write"><code class="option">--delay-key-write=OFF</code></a> and
                <a class="link" href="server-administration.html#sysvar_query_cache_size"><code class="option">--query-cache-size=0</code></a>. (This is
                not done by default because in many setups it is useful to have
                a mixture of the preceding options.)
            </p><p style="color:blue;">满足这些条件的最简单方法是始终使用--external locking和--delay key write=off和--query cache size=0。（默认情况下不会这样做，因为在许多设置中，混合使用前面的选项很有用。）</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="optimizing-server"></a>8.12&nbsp;Optimizing the MySQL Server</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#system-optimization">8.12.1 System Factors</a></span></dt><dt><span class="section"><a href="optimization.html#disk-issues">8.12.2 Optimizing Disk I/O</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links">8.12.3 Using Symbolic Links</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-memory">8.12.4 Optimizing Memory Use</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-network">8.12.5 Optimizing Network Use</a></span></dt></dl>
        </div>
        <p>
            This section discusses optimization techniques for the database
            server, primarily dealing with system configuration rather than
            tuning SQL statements. The information in this section is
            appropriate for DBAs who want to ensure performance and
            scalability across the servers they manage; for developers
            constructing installation scripts that include setting up the
            database; and people running MySQL themselves for development,
            testing, and so on who want to maximize their own productivity.
        </p><p style="color:blue;">本节讨论数据库服务器的优化技术，主要处理系统配置，而不是优化sql语句。本节中的信息适合于希望在它们管理的服务器上确保性能和可伸缩性的DBA；对于开发人员构建安装脚本（包括建立数据库）；以及运行MySQL自身的人进行开发、测试等，他们想要最大化自己的生产力。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="system-optimization"></a>8.12.1&nbsp;System Factors</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286869271200"></a><a class="indexterm" name="idm140286869269712"></a><a class="indexterm" name="idm140286869268640"></a><p>
            Some system-level factors can affect performance in a major way:
        </p><p style="color:blue;">一些系统级因素可能会在很大程度上影响性能：</p><p></p><a class="indexterm" name="idm140286869266672"></a>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you have enough RAM, you could remove all swap devices.
                    Some operating systems use a swap device in some contexts
                    even if you have free memory.
                </p><p style="color:blue;">如果你有足够的内存，你可以删除所有的交换设备。有些操作系统在某些情况下使用交换设备，即使您有空闲内存。</p><p></p></li><li class="listitem"><p>
                    Avoid external locking for
                    <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> tables. The default is
                    for external locking to be disabled. The
                    <a class="link" href="server-administration.html#option_mysqld_external-locking"><code class="option">--external-locking</code></a> and
                    <a class="link" href="server-administration.html#option_mysqld_external-locking"><code class="option">--skip-external-locking</code></a>
                    options explicitly enable and disable external locking.
                </p><p style="color:blue;">避免对myisam表进行外部锁定。默认设置是禁用外部锁定。--external locking和--skip external locking选项显式地启用和禁用外部锁定。</p><p></p><p>
                    Disabling external locking does not affect MySQL's
                    functionality as long as you run only one server. Just
                    remember to take down the server (or lock and flush the
                    relevant tables) before you run
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a>. On some systems it is
                    mandatory to disable external locking because it does not
                    work, anyway.
                </p><p style="color:blue;">只要只运行一台服务器，禁用外部锁定不会影响mysql的功能。在运行myisamchk之前，请记住关闭服务器（或者锁定并刷新相关的表）。在某些系统上，必须禁用外部锁定，因为它无论如何都不工作。</p><p></p><p>
                    The only case in which you cannot disable external locking
                    is when you run multiple MySQL <span class="emphasis"><em>servers</em></span>
                    (not clients) on the same data, or if you run
                    <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> to check (not repair) a table
                    without telling the server to flush and lock the tables
                    first. Note that using multiple MySQL servers to access the
                    same data concurrently is generally <span class="emphasis"><em>not</em></span>
                    recommended, except when using NDB Cluster.
                </p><p style="color:blue;">唯一不能禁用外部锁定的情况是在同一数据上运行多个mysql服务器（而不是客户端），或者运行myisamchk来检查（而不是修复）表，而不告诉服务器先刷新和锁定表。注意，通常不建议使用多个mysql服务器同时访问同一数据，除非使用ndb集群。</p><p></p><p>
                    The <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a> and
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">UNLOCK
                        TABLES</code></a> statements use internal locking, so you can
                    use them even if external locking is disabled.
                </p><p style="color:blue;">lock tables和unlock tables语句使用内部锁定，因此即使外部锁定被禁用，也可以使用它们。</p><p></p></li></ul>
            </div>

        </div>

        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="disk-issues"></a>8.12.2&nbsp;Optimizing Disk I/O</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286869250912"></a><a class="indexterm" name="idm140286869249840"></a><a class="indexterm" name="idm140286869248352"></a>
            <div class="itemizedlist">
                <p>
                    This section describes ways to configure storage devices when
                    you can devote more and faster storage hardware to the
                    database server. For information about optimizing an
                    <code class="literal">InnoDB</code> configuration to improve I/O
                    performance, see <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                </p><p style="color:blue;">本节介绍在可以将更多更快的存储硬件用于数据库服务器时配置存储设备的方法。有关优化InnoDB配置以提高I/O性能的信息，请参阅8.5.8节“优化InnoDB磁盘I/O”。</p><p></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Disk seeks are a huge performance bottleneck. This problem
                becomes more apparent when the amount of data starts to grow
                so large that effective caching becomes impossible. For
                large databases where you access data more or less randomly,
                you can be sure that you need at least one disk seek to read
                and a couple of disk seeks to write things. To minimize this
                problem, use disks with low seek times.
            </p><p style="color:blue;">磁盘查找是一个巨大的性能瓶颈。当数据量开始增长到无法进行有效缓存时，这个问题就变得更加明显。对于随机访问数据的大型数据库，您可以确保至少需要一个磁盘seek来读取数据，而需要两个磁盘seek来写入数据。要最小化此问题，请使用寻道时间较短的磁盘。</p><p></p></li><li class="listitem"><p>
                Increase the number of available disk spindles (and thereby
                reduce the seek overhead) by either symlinking files to
                different disks or striping the disks:
            </p><p style="color:blue;">通过将文件符号链接到不同的磁盘或将磁盘条带化，增加可用磁盘轴的数量（从而减少查找开销）：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        Using symbolic links
                    </p><p style="color:blue;">使用符号链接</p><p></p><p>
                        This means that, for <code class="literal">MyISAM</code> tables,
                        you symlink the index file and data files from their
                        usual location in the data directory to another disk
                        (that may also be striped). This makes both the seek and
                        read times better, assuming that the disk is not used
                        for other purposes as well. See
                        <a class="xref" href="optimization.html#symbolic-links" title="8.12.3&nbsp;Using Symbolic Links">Section&nbsp;8.12.3, “Using Symbolic Links”</a>.
                    </p><p style="color:blue;">这意味着，对于myisam表，可以将索引文件和数据文件从它们在数据目录中的通常位置符号链接到另一个磁盘（该磁盘也可能是条带化的）。这使得查找和读取时间都更好，假设磁盘也不用于其他目的。见第8.12.3节“使用符号链接”。</p><p></p><p>
                        Symbolic links are not supported for use with
                        <code class="literal">InnoDB</code> tables. However, it is
                        possible to place <code class="literal">InnoDB</code> data and log
                        files on different physical disks. For more information,
                        see <a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.8&nbsp;Optimizing InnoDB Disk I/O">Section&nbsp;8.5.8, “Optimizing InnoDB Disk I/O”</a>.
                    </p><p style="color:blue;">符号链接不支持与innodb表一起使用。但是，可以将innodb数据和日志文件放在不同的物理磁盘上。有关更多信息，请参阅第8.5.8节“优化InnoDB磁盘I/O”。</p><p></p></li><li class="listitem"><p>
                        <a class="indexterm" name="idm140286869235568"></a>

                        Striping
                    </p><p style="color:blue;">条纹</p><p></p><p>
                        Striping means that you have many disks and put the
                        first block on the first disk, the second block on the
                        second disk, and the <em class="replaceable"><code>N</code></em>-th
                        block on the (<code class="literal"><em class="replaceable"><code>N</code></em> MOD
                        <em class="replaceable"><code>number_of_disks</code></em></code>)
                        disk, and so on. This means if your normal data size is
                        less than the stripe size (or perfectly aligned), you
                        get much better performance. Striping is very dependent
                        on the operating system and the stripe size, so
                        benchmark your application with different stripe sizes.
                        See <a class="xref" href="optimization.html#custom-benchmarks" title="8.13.2&nbsp;Using Your Own Benchmarks">Section&nbsp;8.13.2, “Using Your Own Benchmarks”</a>.
                    </p><p style="color:blue;">分条意味着您有许多磁盘，将第一个块放在第一个磁盘上，第二个块放在第二个磁盘上，第n个块放在（n mod number_of_disks）磁盘上，依此类推。这意味着，如果您的正常数据大小小于条带大小（或完全对齐），您将获得更好的性能。条带化非常依赖于操作系统和条带大小，因此使用不同的条带大小对应用程序进行基准测试。参见第8.13.2节“使用自己的基准”。</p><p></p><p>
                        The speed difference for striping is
                        <span class="emphasis"><em>very</em></span> dependent on the parameters.
                        Depending on how you set the striping parameters and
                        number of disks, you may get differences measured in
                        orders of magnitude. You have to choose to optimize for
                        random or sequential access.
                    </p><p style="color:blue;">条纹的速度差很大程度上取决于参数。根据设置条带化参数的方式和磁盘数量，您可能会得到按数量级测量的差异。您必须选择优化随机或顺序访问。</p><p></p></li></ul>
                </div>
            </li><li class="listitem"><p>
                For reliability, you may want to use RAID 0+1 (striping plus
                mirroring), but in this case, you need 2 ×
                <em class="replaceable"><code>N</code></em> drives to hold
                <em class="replaceable"><code>N</code></em> drives of data. This is
                probably the best option if you have the money for it.
                However, you may also have to invest in some
                volume-management software to handle it efficiently.
            </p><p style="color:blue;">为了提高可靠性，您可能希望使用raid 0+1（分条和镜像），但在这种情况下，您需要2×n个驱动器来容纳n个数据驱动器。如果你有钱的话，这可能是最好的选择。但是，您可能还需要投资一些卷管理软件来有效地处理它。</p><p></p></li><li class="listitem"><p>
                A good option is to vary the RAID level according to how
                critical a type of data is. For example, store
                semi-important data that can be regenerated on a RAID 0
                disk, but store really important data such as host
                information and logs on a RAID 0+1 or RAID
                <em class="replaceable"><code>N</code></em> disk. RAID
                <em class="replaceable"><code>N</code></em> can be a problem if you have
                many writes, due to the time required to update the parity
                bits.
            </p><p style="color:blue;">一个好的选择是根据数据类型的关键程度来改变RAID级别。例如，存储可以在raid 0磁盘上重新生成的半重要数据，但存储真正重要的数据，如主机信息和raid 0+1或raid n磁盘上的日志。由于更新奇偶校验位所需的时间，如果有许多写操作，则raid n可能是一个问题。</p><p></p></li><li class="listitem"><p>
                You can also set the parameters for the file system that the
                database uses:
            </p><p style="color:blue;">还可以为数据库使用的文件系统设置参数：</p><p></p><p>
                If you do not need to know when files were last accessed
                (which is not really useful on a database server), you can
                mount your file systems with the <code class="option">-o noatime</code>
                option. That skips updates to the last access time in inodes
                on the file system, which avoids some disk seeks.
            </p><p style="color:blue;">如果不需要知道上次访问文件的时间（这在数据库服务器上不是很有用），可以使用-o noatime选项挂载文件系统。这将跳过文件系统上inode中最后一次访问时间的更新，从而避免一些磁盘查找。</p><p></p><p>
                On many operating systems, you can set a file system to be
                updated asynchronously by mounting it with the <code class="option">-o
                async</code> option. If your computer is reasonably
                stable, this should give you better performance without
                sacrificing too much reliability. (This flag is on by
                default on Linux.)
            </p><p style="color:blue;">在许多操作系统上，您可以通过使用-o async选项装载文件系统，将其设置为异步更新。如果你的电脑相当稳定，这应该给你更好的性能，而不牺牲太多的可靠性。（此标志在Linux上默认为打开。）</p><p></p></li></ul>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="disk-issues-nfs"></a>Using NFS with MySQL</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Caution is advised when considering using NFS with MySQL.
                    Potential issues, which vary by operating system and NFS
                    version, include:
                </p><p style="color:blue;">在考虑将nfs与mysql结合使用时，请注意。根据操作系统和nfs版本的不同，潜在的问题包括：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        MySQL data and log files placed on NFS volumes becoming
                        locked and unavailable for use. Locking issues may occur
                        in cases where multiple instances of MySQL access the same
                        data directory or where MySQL is shut down improperly, due
                        to a power outage, for example. NFS version 4 addresses
                        underlying locking issues with the introduction of
                        advisory and lease-based locking. However, sharing a data
                        directory among MySQL instances is not recommended.
                    </p><p style="color:blue;">放在nfs卷上的mysql数据和日志文件将被锁定，无法使用。例如，当多个mysql实例访问同一个数据目录或由于断电而导致mysql不正常关闭时，可能会发生锁定问题。nfs version 4通过引入咨询和基于租约的锁定来解决底层锁定问题。但是，不建议在mysql实例之间共享数据目录。</p><p></p></li><li class="listitem"><p>
                        Data inconsistencies introduced due to messages received
                        out of order or lost network traffic. To avoid this issue,
                        use TCP with <code class="literal">hard</code> and
                        <code class="literal">intr</code> mount options.
                    </p><p style="color:blue;">由于接收到的消息不正常或网络流量丢失而导致的数据不一致。要避免此问题，请将TCP与hard和intr mount选项结合使用。</p><p></p></li><li class="listitem"><p>
                        Maximum file size limitations. NFS Version 2 clients can
                        only access the lowest 2GB of a file (signed 32 bit
                        offset). NFS Version 3 clients support larger files (up to
                        64 bit offsets). The maximum supported file size also
                        depends on the local file system of the NFS server.
                    </p><p style="color:blue;">最大文件大小限制。nfs版本2客户端只能访问文件的最低2GB（有符号的32位偏移量）。nfs version 3客户端支持更大的文件（最多64位偏移量）。最大支持的文件大小也取决于NFS服务器的本地文件系统。</p><p></p></li></ul>
                </div>
                <p>
                    Using NFS within a professional SAN environment or other
                    storage system tends to offer greater reliability than using
                    NFS outside of such an environment. However, NFS within a SAN
                    environment may be slower than directly attached or
                    bus-attached non-rotational storage.
                </p><p style="color:blue;">在专业SAN环境或其他存储系统中使用nfs往往比在此类环境之外使用nfs提供更高的可靠性。但是，SAN环境中的nfs可能比直接连接或总线连接的非旋转存储慢。</p><p></p><p>
                If you choose to use NFS, NFS Version 4 or later is
                recommended, as is testing your NFS setup thoroughly before
                deploying into a production environment.
            </p><p style="color:blue;">如果选择使用nfs，建议使用nfs版本4或更高版本，因为在部署到生产环境之前，需要彻底测试nfs设置。</p><p></p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="symbolic-links"></a>8.12.3&nbsp;Using Symbolic Links</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#symbolic-links-to-databases">8.12.3.1 Using Symbolic Links for Databases on Unix</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links-to-tables">8.12.3.2 Using Symbolic Links for MyISAM Tables on Unix</a></span></dt><dt><span class="section"><a href="optimization.html#windows-symbolic-links">8.12.3.3 Using Symbolic Links for Databases on Windows</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286869211616"></a><a class="indexterm" name="idm140286869210544"></a><p>
            You can move databases or tables from the database directory to
            other locations and replace them with symbolic links to the new
            locations. You might want to do this, for example, to move a
            database to a file system with more free space or increase the
            speed of your system by spreading your tables to different
            disks.
        </p><p style="color:blue;">可以将数据库或表从数据库目录移动到其他位置，并用指向新位置的符号链接替换它们。例如，您可能希望这样做，以便将数据库移动到具有更多可用空间的文件系统，或者通过将表分散到不同的磁盘来提高系统的速度。</p><p></p><p>
            For <code class="literal">InnoDB</code> tables, use the <code class="literal">DATA
            DIRECTORY</code> clause on the <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE
            TABLE</code></a> statement instead of symbolic links, as
            explained in <a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.6.3.6&nbsp;Creating a Tablespace Outside of the Data Directory">Section&nbsp;14.6.3.6, “Creating a Tablespace Outside of the Data Directory”</a>. This new
            feature is a supported, cross-platform technique.
        </p><p style="color:blue;">对于innodb表，使用create table语句中的data directory子句，而不是符号链接，如14.6.3.6节“在数据目录之外创建表空间”所述。这个新特性是一种受支持的跨平台技术。</p><p></p><p>
            The recommended way to do this is to symlink entire database
            directories to a different disk. Symlink
            <code class="literal">MyISAM</code> tables only as a last resort.
        </p><p style="color:blue;">建议的方法是将整个数据库目录符号链接到另一个磁盘。symlink myisam表只能作为最后手段。</p><p></p><p>
            To determine the location of your data directory, use this
            statement:
        </p><p style="color:blue;">要确定数据目录的位置，请使用以下语句：</p><p></p><pre data-lang="sql" class="programlisting">SHOW VARIABLES LIKE 'datadir';
</pre>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="symbolic-links-to-databases"></a>8.12.3.1&nbsp;Using Symbolic Links for Databases on Unix</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286869200448"></a><a class="indexterm" name="idm140286869198960"></a><p>
                On Unix, the way to symlink a database is first to create a
                directory on some disk where you have free space and then to
                create a soft link to it from the MySQL data directory.
            </p><p style="color:blue;">在unix上，对数据库进行符号链接的方法是，首先在某个有可用空间的磁盘上创建一个目录，然后从mysql数据目录创建到该目录的软链接。</p><p></p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>mkdir /dr1/databases/test</code></strong>
shell&gt; <strong class="userinput"><code>ln -s /dr1/databases/test <em class="replaceable"><code>/path/to/datadir</code></em></code></strong>
</pre><p>
                MySQL does not support linking one directory to multiple
                databases. Replacing a database directory with a symbolic link
                works as long as you do not make a symbolic link between
                databases. Suppose that you have a database
                <code class="literal">db1</code> under the MySQL data directory, and
                then make a symlink <code class="literal">db2</code> that points to
                <code class="literal">db1</code>:
            </p><p style="color:blue;">MySQL不支持将一个目录链接到多个数据库。只要不在数据库之间建立符号链接，就可以用符号链接替换数据库目录。假设在mysql数据目录下有一个数据库db1，然后创建一个指向db1的symlink db2：</p><p></p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>/path/to/datadir</code></em></code></strong>
shell&gt; <strong class="userinput"><code>ln -s db1 db2</code></strong>
</pre><p>
                The result is that, for any table <code class="literal">tbl_a</code> in
                <code class="literal">db1</code>, there also appears to be a table
                <code class="literal">tbl_a</code> in <code class="literal">db2</code>. If one
                client updates <code class="literal">db1.tbl_a</code> and another client
                updates <code class="literal">db2.tbl_a</code>, problems are likely to
                occur.
            </p><p style="color:blue;">结果是，对于db1中的任何表tbl_a，在db2中似乎也有一个表tbl_a。如果一个客户机更新db1.tbl_a，而另一个客户机更新db2.tbl_a，则可能会出现问题。</p><p></p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="symbolic-links-to-tables"></a>8.12.3.2&nbsp;Using Symbolic Links for MyISAM Tables on Unix</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286869182704"></a><a class="indexterm" name="idm140286869181216"></a><p>
                Symlinks are fully supported only for
                <code class="literal">MyISAM</code> tables. For files used by tables for
                other storage engines, you may get strange problems if you try
                to use symbolic links. For <code class="literal">InnoDB</code> tables,
                use the alternative technique explained in
                <a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.6.3.6&nbsp;Creating a Tablespace Outside of the Data Directory">Section&nbsp;14.6.3.6, “Creating a Tablespace Outside of the Data Directory”</a> instead.
            </p><p style="color:blue;">只有myisam表才完全支持符号链接。对于表用于其他存储引擎的文件，如果尝试使用符号链接，可能会遇到奇怪的问题。对于innodb表，使用第14.6.3.6节“在数据目录之外创建表空间”中解释的替代技术。</p><p></p><p>
                Do not symlink tables on systems that do not have a fully
                operational <code class="literal">realpath()</code> call. (Linux and
                Solaris support <code class="literal">realpath()</code>). To determine
                whether your system supports symbolic links, check the value
                of the <a class="link" href="server-administration.html#sysvar_have_symlink"><code class="literal">have_symlink</code></a> system
                variable using this statement:
            </p><p style="color:blue;">不要在没有完全可操作realpath（）调用的系统上对表进行符号链接。（Linux和solaris支持realpath（））。要确定系统是否支持符号链接，请使用以下语句检查have_symlink系统变量的值：</p><p></p><pre data-lang="sql" class="programlisting">SHOW VARIABLES LIKE 'have_symlink';
</pre><p>
                The handling of symbolic links for <code class="literal">MyISAM</code>
                tables works as follows:
            </p><p style="color:blue;">myisam表的符号链接处理如下：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        In the data directory, you always have the table format
                        (<code class="filename">.frm</code>) file, the data
                        (<code class="filename">.MYD</code>) file, and the index
                        (<code class="filename">.MYI</code>) file. The data file and index
                        file can be moved elsewhere and replaced in the data
                        directory by symlinks. The format file cannot.
                    </p><p style="color:blue;">在数据目录中，始终有表格式（.frm）文件、数据（.myd）文件和索引（.myi）文件。数据文件和索引文件可以移动到其他位置，并在数据目录中用符号链接替换。格式文件不能。</p><p></p></li><li class="listitem"><p>
                        You can symlink the data file and the index file
                        independently to different directories.
                    </p><p style="color:blue;">您可以将数据文件和索引文件独立地符号链接到不同的目录。</p><p></p></li><li class="listitem"><p>
                        To instruct a running MySQL server to perform the
                        symlinking, use the <code class="literal">DATA DIRECTORY</code> and
                        <code class="literal">INDEX DIRECTORY</code> options to
                        <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>. See
                        <a class="xref" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax">Section&nbsp;13.1.18, “CREATE TABLE Syntax”</a>. Alternatively, if
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> is not running, symlinking can
                        be accomplished manually using <span class="command"><strong>ln -s</strong></span>
                        from the command line.
                    </p><p style="color:blue;">要指示正在运行的mysql服务器执行符号链接，请使用data directory和index directory选项创建表。参见第13.1.18节“创建表语法”。或者，如果mysqld没有运行，可以从命令行使用ln-s手动完成符号链接。</p><p></p>
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                The path used with either or both of the <code class="literal">DATA
                                DIRECTORY</code> and <code class="literal">INDEX
                                DIRECTORY</code> options may not include the MySQL
                                <code class="literal">data</code> directory. (Bug #32167)
                            </p><p style="color:blue;">与数据目录和索引目录选项之一或两者一起使用的路径可能不包括mysql数据目录。（错误32167）</p><p></p>
                        </div>
                    </li><li class="listitem"><p>
                        <a class="link" href="programs.html#myisamchk" title="4.6.3&nbsp;myisamchk — MyISAM Table-Maintenance Utility"><span class="command"><strong>myisamchk</strong></span></a> does not replace a symlink
                        with the data file or index file. It works directly on the
                        file to which the symlink points. Any temporary files are
                        created in the directory where the data file or index file
                        is located. The same is true for the
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                        <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>, and
                        <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a> statements.
                    </p><p style="color:blue;">myisamchk不会用数据文件或索引文件替换符号链接。它直接作用于符号链接指向的文件。在数据文件或索引文件所在的目录中创建任何临时文件。alter table、optimize table和repair table语句也是如此。</p><p></p></li><li class="listitem">
                        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                            <div class="admon-title">
                                Note
                            </div>
                            <p>
                                When you drop a table that is using symlinks,
                                <span class="emphasis"><em>both the symlink and the file to which the
                symlink points are dropped</em></span>. This is an
                                extremely good reason <span class="emphasis"><em>not</em></span> to run
                                <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> as the <code class="literal">root</code>
                                operating system user or permit operating system users
                                to have write access to MySQL database directories.
                            </p><p style="color:blue;">当删除使用符号链接的表时，符号链接和符号链接指向的文件都会被删除。这是不以根操作系统用户身份运行mysqld或允许操作系统用户对mysql数据库目录具有写访问权限的一个非常好的理由。</p><p></p>
                        </div>
                    </li><li class="listitem"><p>
                        If you rename a table with
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                            ... RENAME</code></a> or <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME
                        TABLE</code></a> and you do not move the table to another
                        database, the symlinks in the database directory are
                        renamed to the new names and the data file and index file
                        are renamed accordingly.
                    </p><p style="color:blue;">如果使用alter table重命名表…重命名或重命名表，并且不将表移动到其他数据库，数据库目录中的符号链接将重命名为新名称，数据文件和索引文件也将相应重命名。</p><p></p></li><li class="listitem"><p>
                        If you use
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE
                            ... RENAME</code></a> or <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME
                        TABLE</code></a> to move a table to another database, the
                        table is moved to the other database directory. If the
                        table name changed, the symlinks in the new database
                        directory are renamed to the new names and the data file
                        and index file are renamed accordingly.
                    </p><p style="color:blue;">如果使用alter table…重命名或重命名表若要将表移动到另一个数据库，该表将移动到另一个数据库目录。如果表名更改，则新数据库目录中的符号链接将重命名为新名称，数据文件和索引文件也将相应重命名。</p><p></p></li><li class="listitem"><p>
                        If you are not using symlinks, start
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> with the
                        <a class="link" href="server-administration.html#option_mysqld_symbolic-links"><code class="option">--skip-symbolic-links</code></a>
                        option to ensure that no one can use
                        <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> to drop or rename a file outside
                        of the data directory.
                    </p><p style="color:blue;">如果不使用符号链接，请使用--skip symbolic links选项启动mysqld，以确保没有人可以使用mysqld删除或重命名数据目录之外的文件。</p><p></p></li></ul>
                </div>
                <p>
                    These table symlink operations are not supported:
                </p><p style="color:blue;">不支持以下表符号链接操作：</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> ignores the
                        <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
                        DIRECTORY</code> table options.
                    </p><p style="color:blue;">alter table忽略数据目录和索引目录表选项。</p><p></p></li><li class="listitem"><p>
                        As indicated previously, only the data and index files can
                        be symbolic links. The <code class="filename">.frm</code> file must
                        <span class="emphasis"><em>never</em></span> be a symbolic link. Attempting
                        to do this (for example, to make one table name a synonym
                        for another) produces incorrect results. Suppose that you
                        have a database <code class="literal">db1</code> under the MySQL
                        data directory, a table <code class="literal">tbl1</code> in this
                        database, and in the <code class="literal">db1</code> directory you
                        make a symlink <code class="literal">tbl2</code> that points to
                        <code class="literal">tbl1</code>:
                    </p><p style="color:blue;">如前所述，只有数据和索引文件可以是符号链接。.frm文件不能是符号链接。尝试这样做（例如，使一个表名成为另一个表名的同义词）会产生不正确的结果。假设在mysql数据目录下有一个数据库db1，在这个数据库中有一个表tbl1，在db1目录中有一个指向tbl1的符号链接tbl2：</p><p></p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>/path/to/datadir</code></em>/db1</code></strong>
shell&gt; <strong class="userinput"><code>ln -s tbl1.frm tbl2.frm</code></strong>
shell&gt; <strong class="userinput"><code>ln -s tbl1.MYD tbl2.MYD</code></strong>
shell&gt; <strong class="userinput"><code>ln -s tbl1.MYI tbl2.MYI</code></strong>
</pre><p>
                        Problems result if one thread reads
                        <code class="literal">db1.tbl1</code> and another thread updates
                        <code class="literal">db1.tbl2</code>:
                    </p><p style="color:blue;">如果一个线程读取db1.tbl1，而另一个线程更新db1.tbl2，则会出现问题：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                The query cache is <span class="quote">“<span class="quote">fooled</span>”</span> (it has no
                                way of knowing that <code class="literal">tbl1</code> has not
                                been updated, so it returns outdated results).
                            </p><p style="color:blue;">查询缓存被“愚弄”（它无法知道tbl1尚未更新，因此返回过时的结果）。</p><p></p></li><li class="listitem"><p>
                                <code class="literal">ALTER</code> statements on
                                <code class="literal">tbl2</code> fail.
                            </p><p style="color:blue;">TBL2上的alter语句失败。</p><p></p></li></ul>
                        </div>
                    </li></ul>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="windows-symbolic-links"></a>8.12.3.3&nbsp;Using Symbolic Links for Databases on Windows</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286869113248"></a><a class="indexterm" name="idm140286869112208"></a><a class="indexterm" name="idm140286869110720"></a><a class="indexterm" name="idm140286869109632"></a><p>
                On Windows, symbolic links can be used for database
                directories. This enables you to put a database directory at a
                different location (for example, on a different disk) by
                setting up a symbolic link to it. Use of database symlinks on
                Windows is similar to their use on Unix, although the
                procedure for setting up the link differs.
            </p><p style="color:blue;">在windows上，符号链接可用于数据库目录。这使您能够通过设置指向数据库目录的符号链接，将其放置在不同的位置（例如，在不同的磁盘上）。在windows上使用数据库符号链接与在unix上使用类似，尽管设置链接的过程不同。</p><p></p><p>
                Suppose that you want to place the database directory for a
                database named <code class="literal">mydb</code> at
                <code class="filename">D:\data\mydb</code>. To do this, create a
                symbolic link in the MySQL data directory that points to
                <code class="filename">D:\data\mydb</code>. However, before creating
                the symbolic link, make sure that the
                <code class="filename">D:\data\mydb</code> directory exists by creating
                it if necessary. If you already have a database directory
                named <code class="filename">mydb</code> in the data directory, move it
                to <code class="filename">D:\data</code>. Otherwise, the symbolic link
                will be ineffective. To avoid problems, make sure that the
                server is not running when you move the database directory.
            </p><p style="color:blue;">假设要将名为mydb的数据库的数据库目录放在d:\ d at a\mydb。为此，请在mysql数据目录中创建指向d:\ data\mydb的符号链接。但是，在创建符号链接之前，如果需要，请通过创建d:\ data\mydb目录来确保该目录存在。如果数据目录中已经有一个名为mydb的数据库目录，请将其移到d:.data。否则，符号链接将无效。为避免出现问题，请确保移动数据库目录时服务器未运行。</p><p></p><p>
                On Windows, you can create a symlink using the
                <span class="command"><strong>mklink</strong></span> command. This command requires
                administrative privileges.
            </p><p style="color:blue;">在windows上，可以使用mklink命令创建符号链接。此命令需要管理权限。</p><p></p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        Change location into the data directory:
                    </p><p style="color:blue;">将位置更改为数据目录：</p><p></p><pre data-lang="terminal" class="programlisting">C:\&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>\path\to\datadir</code></em></code></strong>
</pre></li><li class="listitem"><p>
                        In the data directory, create a symlink named
                        <code class="filename">mydb</code> that points to the location of
                        the database directory:
                    </p><p style="color:blue;">在数据目录中，创建一个名为mydb的符号链接，该符号链接指向数据库目录的位置：</p><p></p><pre data-lang="terminal" class="programlisting">C:\&gt; <strong class="userinput"><code>mklink /d mydb D:\data\mydb</code></strong>
</pre></li></ol>
                </div>
                <p>
                    After this, all tables created in the database
                    <code class="literal">mydb</code> are created in
                    <code class="filename">D:\data\mydb</code>.
                </p><p style="color:blue;">在此之后，在数据库mydb中创建的所有表都将在d:\ data\mydb中创建。</p><p></p>
            </div>

        </div>

        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-memory"></a>8.12.4&nbsp;Optimizing Memory Use</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#memory-use">8.12.4.1 How MySQL Uses Memory</a></span></dt><dt><span class="section"><a href="optimization.html#large-page-support">8.12.4.2 Enabling Large Page Support</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286869090528"></a>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="memory-use"></a>8.12.4.1&nbsp;How MySQL Uses Memory</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286869087936"></a><p>
                MySQL allocates buffers and caches to improve performance of
                database operations. The default configuration is designed to
                permit a MySQL server to start on a virtual machine that has
                approximately 512MB of RAM. You can improve MySQL performance
                by increasing the values of certain cache and buffer-related
                system variables. You can also modify the default
                configuration to run MySQL on systems with limited memory.
            </p><p style="color:blue;">mysql分配缓冲区和缓存以提高数据库操作的性能。默认配置被设计为允许MySQL服务器在虚拟机上启动，该虚拟机具有大约512MB的RAM。通过增加某些与缓存和缓冲区相关的系统变量的值，可以提高mysql的性能。您还可以修改默认配置，以便在内存有限的系统上运行mysql。</p><p></p><p>
                The following list describes some of the ways that MySQL uses
                memory. Where applicable, relevant system variables are
                referenced. Some items are storage engine or feature specific.
            </p><p style="color:blue;">下面的列表描述了mysql使用内存的一些方式。如适用，参考相关系统变量。有些项目是存储引擎或功能特定的。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        The <code class="literal">InnoDB</code> buffer pool is a memory area
                        that holds cached <code class="literal">InnoDB</code> data for
                        tables, indexes, and other auxiliary buffers. For
                        efficiency of high-volume read operations, the buffer pool
                        is divided into <a class="link" href="glossary.html#glos_page" title="page">pages</a>
                        that can potentially hold multiple rows. For efficiency of
                        cache management, the buffer pool is implemented as a
                        linked list of pages; data that is rarely used is aged out
                        of the cache, using a variation of the
                        <a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> algorithm. For more
                        information, see <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool" title="14.5.1&nbsp;Buffer Pool">Section&nbsp;14.5.1, “Buffer Pool”</a>.
                    </p><p style="color:blue;">innodb缓冲池是一个内存区域，它为表、索引和其他辅助缓冲区保存缓存的innodb数据。为了提高大容量读取操作的效率，缓冲池被划分为可能包含多行的页。为了提高缓存管理的效率，缓冲池被实现为一个链接的页面列表；很少使用的数据将使用lru算法的变体从缓存中老化。有关更多信息，请参阅第14.5.1节“缓冲池”。</p><p></p><p>
                        The size of the buffer pool is important for system
                        performance:
                    </p><p style="color:blue;">缓冲池的大小对于系统性能很重要：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                <code class="literal">InnoDB</code> allocates memory for the
                                entire buffer pool at server startup, using
                                <code class="literal">malloc()</code> operations. The
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                                system variable defines the buffer pool size.
                                Typically, a recommended
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                                value is 50 to 75 percent of system memory.
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size"><code class="literal">innodb_buffer_pool_size</code></a>
                                can be configured dynamically, while the server is
                                running. For more information, see
                                <a class="xref" href="innodb-storage-engine.html#innodb-buffer-pool-resize" title="14.8.3.1&nbsp;Configuring InnoDB Buffer Pool Size">Section&nbsp;14.8.3.1, “Configuring InnoDB Buffer Pool Size”</a>.
                            </p><p style="color:blue;">InnoDB在服务器启动时使用malloc（）操作为整个缓冲池分配内存。innodb_buffer_pool_size系统变量定义缓冲池大小。通常，建议的innodb_buffer_pool_size值是系统内存的50%到75%。可以在服务器运行时动态配置innodb_buffer_pool_size。有关更多信息，请参阅14.8.3.1节，“配置innodb缓冲池大小”。</p><p></p></li><li class="listitem"><p>
                                On systems with a large amount of memory, you can
                                improve concurrency by dividing the buffer pool into
                                multiple
                                <a class="link" href="glossary.html#glos_buffer_pool_instance" title="buffer pool instance">buffer pool
                                    instances</a>. The
                                <a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances"><code class="literal">innodb_buffer_pool_instances</code></a>
                                system variable defines the number of buffer pool
                                instances.
                            </p><p style="color:blue;">在具有大量内存的系统上，可以通过将缓冲池划分为多个缓冲池实例来提高并发性。innodb_buffer_pool_instances系统变量定义缓冲池实例的数量。</p><p></p></li><li class="listitem"><p>
                                A buffer pool that is too small may cause excessive
                                churning as pages are flushed from the buffer pool
                                only to be required again a short time later.
                            </p><p style="color:blue;">缓冲池太小可能会导致过度的搅动，因为页面从缓冲池中刷新后不久将再次需要。</p><p></p></li><li class="listitem"><p>
                                A buffer pool that is too large may cause swapping due
                                to competition for memory.
                            </p><p style="color:blue;">缓冲池太大可能会由于内存竞争而导致交换。</p><p></p></li></ul>
                        </div>
                    </li><li class="listitem"><p>
                        All threads share the <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>
                        key buffer. The
                        <a class="link" href="server-administration.html#sysvar_key_buffer_size"><code class="literal">key_buffer_size</code></a> system
                        variable determines its size.
                    </p><p style="color:blue;">所有线程共享myisam密钥缓冲区。KEY U BUFFER U SIZE系统变量决定其大小。</p><p></p><p>
                        For each <code class="literal">MyISAM</code> table the server opens,
                        the index file is opened once; the data file is opened
                        once for each concurrently running thread that accesses
                        the table. For each concurrent thread, a table structure,
                        column structures for each column, and a buffer of size
                        <code class="literal">3 * <em class="replaceable"><code>N</code></em></code> are
                        allocated (where <em class="replaceable"><code>N</code></em> is the
                        maximum row length, not counting
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns). A
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> column requires five
                        to eight bytes plus the length of the
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> data. The
                        <code class="literal">MyISAM</code> storage engine maintains one
                        extra row buffer for internal use.
                    </p><p style="color:blue;">对于服务器打开的每个myisam表，索引文件打开一次；对于访问该表的每个并发运行线程，数据文件打开一次。对于每个并发线程，分配一个表结构、每个列的列结构和大小为3×N的缓冲器（其中N是最大行长度，而不计算BULB列）。blob列需要5到8个字节加上blob数据的长度。myisam存储引擎维护一个额外的行缓冲区供内部使用。</p><p></p></li><li class="listitem"><p>
                        The <a class="link" href="server-administration.html#sysvar_myisam_use_mmap"><code class="literal">myisam_use_mmap</code></a>
                        system variable can be set to 1 to enable memory-mapping
                        for all <code class="literal">MyISAM</code> tables.
                    </p><p style="color:blue;">myisam_use_mmap系统变量可以设置为1，以启用所有myisam表的内存映射。</p><p></p></li><li class="listitem"><p>
                        If an internal in-memory temporary table becomes too large
                        (as determined using the
                        <a class="link" href="server-administration.html#sysvar_tmp_table_size"><code class="literal">tmp_table_size</code></a> and
                        <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a>
                        system variables), MySQL automatically converts the table
                        from in-memory to on-disk format. On-disk temporary tables
                        use the storage engine defined by the
                        <a class="link" href="server-administration.html#sysvar_internal_tmp_disk_storage_engine"><code class="literal">internal_tmp_disk_storage_engine</code></a>
                        system variable. You can increase the permissible
                        temporary table size as described in
                        <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4&nbsp;Internal Temporary Table Use in MySQL">Section&nbsp;8.4.4, “Internal Temporary Table Use in MySQL”</a>.
                    </p><p style="color:blue;">如果内存中的临时表太大（使用tmp_table_size和max_heap_table_size系统变量确定），mysql会自动将表从内存格式转换为磁盘格式。磁盘上临时表使用由内部磁盘存储引擎系统变量定义的存储引擎。您可以增加允许的临时表大小，如8.4.4节“MySQL中的内部临时表使用”所述。</p><p></p><p>
                        For <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> tables explicitly
                        created with <a class="link" href="sql-syntax.html#create-table" title="13.1.18&nbsp;CREATE TABLE Syntax"><code class="literal">CREATE TABLE</code></a>,
                        only the
                        <a class="link" href="server-administration.html#sysvar_max_heap_table_size"><code class="literal">max_heap_table_size</code></a>
                        system variable determines how large a table can grow, and
                        there is no conversion to on-disk format.
                    </p><p style="color:blue;">对于使用CREATE TABLE显式创建的内存表，只有MAX U HEAP U TABLE U SIZE系统变量确定表可以增长多大，并且不转换为磁盘格式。</p><p></p></li><li class="listitem"><p>
                        The <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">MySQL Performance
                        Schema</a> is a feature for monitoring MySQL server
                        execution at a low level. The Performance Schema
                        dynamically allocates memory incrementally, scaling its
                        memory use to actual server load, instead of allocating
                        required memory during server startup. Once memory is
                        allocated, it is not freed until the server is restarted.
                        For more information, see
                        <a class="xref" href="performance-schema.html#performance-schema-memory-model" title="25.17&nbsp;The Performance Schema Memory-Allocation Model">Section&nbsp;25.17, “The Performance Schema Memory-Allocation Model”</a>.
                    </p><p style="color:blue;">mysql性能模式是一个在低级别监视mysql服务器执行的特性。性能模式以增量方式动态分配内存，将其内存使用量扩展到实际的服务器负载，而不是在服务器启动期间分配所需的内存。一旦分配了内存，就不会释放它，直到服务器重新启动。有关更多信息，请参阅25.17节，“性能模式内存分配模型”。</p><p></p></li><li class="listitem"><p>
                        Each thread that the server uses to manage client
                        connections requires some thread-specific space. The
                        following list indicates these and which system variables
                        control their size:
                    </p><p style="color:blue;">服务器用于管理客户端连接的每个线程都需要一些特定于线程的空间。下表显示了这些以及哪些系统变量控制其大小：</p><p></p>
                        <div class="itemizedlist">
                            <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                A stack
                                (<a class="link" href="server-administration.html#sysvar_thread_stack"><code class="literal">thread_stack</code></a>)
                            </p><p style="color:blue;">堆栈（线程堆栈）</p><p></p></li><li class="listitem"><p>
                                A connection buffer
                                (<a class="link" href="server-administration.html#sysvar_net_buffer_length"><code class="literal">net_buffer_length</code></a>)
                            </p><p style="color:blue;">连接缓冲区（网络缓冲区长度）</p><p></p></li><li class="listitem"><p>
                                A result buffer
                                (<a class="link" href="server-administration.html#sysvar_net_buffer_length"><code class="literal">net_buffer_length</code></a>)
                            </p><p style="color:blue;">结果缓冲区（净缓冲区长度）</p><p></p></li></ul>
                        </div>
                        <p>
                            The connection buffer and result buffer each begin with a
                            size equal to
                            <a class="link" href="server-administration.html#sysvar_net_buffer_length"><code class="literal">net_buffer_length</code></a> bytes,
                            but are dynamically enlarged up to
                            <a class="link" href="server-administration.html#sysvar_max_allowed_packet"><code class="literal">max_allowed_packet</code></a> bytes
                            as needed. The result buffer shrinks to
                            <a class="link" href="server-administration.html#sysvar_net_buffer_length"><code class="literal">net_buffer_length</code></a> bytes
                            after each SQL statement. While a statement is running, a
                            copy of the current statement string is also allocated.
                        </p><p style="color:blue;">连接缓冲区和结果缓冲区的大小都以等于net_buffer_length bytes的大小开始，但会根据需要动态放大到最大允许的_packet bytes。结果缓冲区在每个sql语句之后收缩为net_buffer_length字节。在语句运行时，还将分配当前语句字符串的副本。</p><p></p><p>
                            Each connection thread uses memory for computing statement
                            digests. The server allocates
                            <a class="link" href="server-administration.html#sysvar_max_digest_length"><code class="literal">max_digest_length</code></a> bytes
                            per session. See
                            <a class="xref" href="performance-schema.html#performance-schema-statement-digests" title="25.10&nbsp;Performance Schema Statement Digests">Section&nbsp;25.10, “Performance Schema Statement Digests”</a>.
                        </p><p style="color:blue;">每个连接线程都使用内存来计算语句摘要。服务器为每个会话分配最大摘要长度字节。见第25.10节“性能模式语句摘要”。</p><p></p></li><li class="listitem"><p>
                        All threads share the same base memory.
                    </p><p style="color:blue;">所有线程共享相同的基本内存。</p><p></p></li><li class="listitem"><p>
                        When a thread is no longer needed, the memory allocated to
                        it is released and returned to the system unless the
                        thread goes back into the thread cache. In that case, the
                        memory remains allocated.
                    </p><p style="color:blue;">当线程不再需要时，分配给它的内存将被释放并返回给系统，除非线程返回到线程缓存中。在这种情况下，内存仍然被分配。</p><p></p></li><li class="listitem"><p>
                        Each request that performs a sequential scan of a table
                        allocates a <span class="firstterm">read
              buffer</span>. The
                        <a class="link" href="server-administration.html#sysvar_read_buffer_size"><code class="literal">read_buffer_size</code></a> system
                        variable determines the buffer size.
                    </p><p style="color:blue;">对表执行顺序扫描的每个请求都分配一个读缓冲区。READ U BUFFER U SIZE系统变量决定缓冲区大小。</p><p></p></li><li class="listitem"><p>
                        When reading rows in an arbitrary sequence (for example,
                        following a sort), a
                        <span class="firstterm">random-read buffer</span>
                        may be allocated to avoid disk seeks. The
                        <a class="link" href="server-administration.html#sysvar_read_rnd_buffer_size"><code class="literal">read_rnd_buffer_size</code></a>
                        system variable determines the buffer size.
                    </p><p style="color:blue;">当以任意顺序（例如，在排序之后）读取行时，可以分配随机读取缓冲区以避免磁盘查找。READ RND BUFFER SIZE系统变量决定缓冲区大小。</p><p></p></li><li class="listitem"><p>
                        All joins are executed in a single pass, and most joins
                        can be done without even using a temporary table. Most
                        temporary tables are memory-based hash tables. Temporary
                        tables with a large row length (calculated as the sum of
                        all column lengths) or that contain
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> columns are stored on
                        disk.
                    </p><p style="color:blue;">所有连接都是在一个过程中执行的，而且大多数连接甚至不需要使用临时表就可以完成。大多数临时表是基于内存的哈希表。具有较大行长度（计算为所有列长度之和）或包含blob列的临时表存储在磁盘上。</p><p></p></li><li class="listitem"><p>
                        Most requests that perform a sort allocate a sort buffer
                        and zero to two temporary files depending on the result
                        set size. See <a class="xref" href="error-handling.html#temporary-files" title="B.4.3.5&nbsp;Where MySQL Stores Temporary Files">Section&nbsp;B.4.3.5, “Where MySQL Stores Temporary Files”</a>.
                    </p><p style="color:blue;">大多数执行排序的请求根据结果集大小分配一个排序缓冲区和零到两个临时文件。参见第B.4.3.5节，“MySQL存储临时文件的位置”。</p><p></p></li><li class="listitem"><p>
                        Almost all parsing and calculating is done in thread-local
                        and reusable memory pools. No memory overhead is needed
                        for small items, thus avoiding the normal slow memory
                        allocation and freeing. Memory is allocated only for
                        unexpectedly large strings.
                    </p><p style="color:blue;">几乎所有的解析和计算都是在线程本地和可重用的内存池中完成的。小项目不需要内存开销，从而避免了正常的缓慢内存分配和释放。内存只分配给意外的大字符串。</p><p></p></li><li class="listitem"><p>
                        For each table having <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a>
                        columns, a buffer is enlarged dynamically to read in
                        larger <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> values. If you
                        scan a table, the buffer grows as large as the largest
                        <a class="link" href="data-types.html#blob" title="11.4.3&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> value.
                    </p><p style="color:blue;">对于具有blob列的每个表，都会动态地扩大缓冲区以读取更大的blob值。如果扫描一个表，缓冲区的大小将与最大blob值一样大。</p><p></p></li><li class="listitem"><p>
                        MySQL requires memory and descriptors for the table cache.
                        Handler structures for all in-use tables are saved in the
                        table cache and managed as <span class="quote">“<span class="quote">First In, First
              Out</span>”</span> (FIFO). The
                        <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> system
                        variable defines the initial table cache size; see
                        <a class="xref" href="optimization.html#table-cache" title="8.4.3.1&nbsp;How MySQL Opens and Closes Tables">Section&nbsp;8.4.3.1, “How MySQL Opens and Closes Tables”</a>.
                    </p><p style="color:blue;">mysql需要表缓存的内存和描述符。所有在用表的处理程序结构都保存在表缓存中，并作为“先进先出”（fifo）进行管理。table_open_cache系统变量定义初始表缓存大小；请参阅8.4.3.1节“MySQL如何打开和关闭表”。</p><p></p><p>
                        MySQL also requires memory for the table definition cache.
                        The
                        <a class="link" href="server-administration.html#sysvar_table_definition_cache"><code class="literal">table_definition_cache</code></a>
                        system variable defines the number of table definitions
                        (from <code class="filename">.frm</code> files) that can be stored
                        in the table definition cache. If you use a large number
                        of tables, you can create a large table definition cache
                        to speed up the opening of tables. The table definition
                        cache takes less space and does not use file descriptors,
                        unlike the table cache.
                    </p><p style="color:blue;">mysql还需要表定义缓存的内存。table_definition_cache系统变量定义可以存储在表定义缓存中的表定义（来自.frm文件）的数量。如果使用大量表，可以创建大型表定义缓存以加快表的打开速度。与表缓存不同，表定义缓存占用的空间较少，并且不使用文件描述符。</p><p></p></li><li class="listitem"><p>
                        A <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> statement or
                        <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin flush-tables</strong></span></a> command closes
                        all tables that are not in use at once and marks all
                        in-use tables to be closed when the currently executing
                        thread finishes. This effectively frees most in-use
                        memory. <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> does
                        not return until all tables have been closed.
                    </p><p style="color:blue;">flush tables语句或mysqladmin flush tables命令会立即关闭所有未使用的表，并在当前执行线程完成时将所有正在使用的表标记为关闭。这有效地释放了大部分在用内存。在关闭所有表之前，刷新表不会返回。</p><p></p></li><li class="listitem"><p>
                        The server caches information in memory as a result of
                        <a class="link" href="sql-syntax.html#grant" title="13.7.1.4&nbsp;GRANT Syntax"><code class="literal">GRANT</code></a>,
                        <a class="link" href="sql-syntax.html#create-user" title="13.7.1.2&nbsp;CREATE USER Syntax"><code class="literal">CREATE USER</code></a>,
                        <a class="link" href="sql-syntax.html#create-server" title="13.1.17&nbsp;CREATE SERVER Syntax"><code class="literal">CREATE SERVER</code></a>, and
                        <a class="link" href="sql-syntax.html#install-plugin" title="13.7.3.3&nbsp;INSTALL PLUGIN Syntax"><code class="literal">INSTALL PLUGIN</code></a> statements.
                        This memory is not released by the corresponding
                        <a class="link" href="sql-syntax.html#revoke" title="13.7.1.6&nbsp;REVOKE Syntax"><code class="literal">REVOKE</code></a>,
                        <a class="link" href="sql-syntax.html#drop-user" title="13.7.1.3&nbsp;DROP USER Syntax"><code class="literal">DROP USER</code></a>,
                        <a class="link" href="sql-syntax.html#drop-server" title="13.1.28&nbsp;DROP SERVER Syntax"><code class="literal">DROP SERVER</code></a>, and
                        <a class="link" href="sql-syntax.html#uninstall-plugin" title="13.7.3.4&nbsp;UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL PLUGIN</code></a>
                        statements, so for a server that executes many instances
                        of the statements that cause caching, there will be an
                        increase in memory use. This cached memory can be freed
                        with <a class="link" href="sql-syntax.html#flush-privileges"><code class="literal">FLUSH PRIVILEGES</code></a>.
                    </p><p style="color:blue;">由于grant、create user、create server和install plugin语句，服务器将信息缓存在内存中。相应的revoke、drop user、drop server和uninstall plugin语句不会释放此内存，因此对于执行导致缓存的语句的多个实例的服务器，内存使用将增加。可以使用刷新权限释放此缓存内存。</p><p></p></li></ul>
                </div>
                <p>
                    <span class="command"><strong>ps</strong></span> and other system status programs may
                    report that <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> uses a lot of memory.
                    This may be caused by thread stacks on different memory
                    addresses. For example, the Solaris version of
                    <span class="command"><strong>ps</strong></span> counts the unused memory between stacks
                    as used memory. To verify this, check available swap with
                    <code class="literal">swap -s</code>. We test <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a>
                    with several memory-leakage detectors (both commercial and
                    Open Source), so there should be no memory leaks.
                </p><p style="color:blue;">ps和其他系统状态程序可能会报告mysqld使用了大量内存。这可能是由不同内存地址上的线程堆栈引起的。例如，ps的solaris版本将堆栈之间的未使用内存计算为已使用内存。要验证这一点，请使用swap-s检查可用的swap。我们使用多个内存泄漏检测器（商业和开放源码）测试mysqld，因此应该不会出现内存泄漏。</p><p></p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="monitor-mysql-memory-use"></a>Monitoring MySQL Memory Usage</h5>
                            </div>
                        </div>
                    </div>
                    <a class="indexterm" name="idm140286868977392"></a><a class="indexterm" name="idm140286868975904"></a><p>
                    The following example demonstrates how to use
                    <a class="link" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Performance Schema</a>
                    and <a class="link" href="sys-schema.html" title="Chapter&nbsp;26&nbsp;MySQL sys Schema">sys schema</a> to monitor
                    MySQL memory usage.
                </p><p style="color:blue;">下面的示例演示如何使用性能模式和sys模式监视mysql内存使用。</p><p></p><p>
                    Most Performance Schema memory instrumentation is disabled
                    by default. Instruments can be enabled by updating the
                    <code class="literal">ENABLED</code> column of the Performance Schema
                    <a class="link" href="performance-schema.html#setup-instruments-table" title="25.12.2.3&nbsp;The setup_instruments Table"><code class="literal">setup_instruments</code></a> table. Memory
                    instruments have names in the form of
                    <code class="literal">memory/<em class="replaceable"><code>code_area</code></em>/<em class="replaceable"><code>instrument_name</code></em></code>,
                    where <em class="replaceable"><code>code_area</code></em> is a value such
                    as <code class="literal">sql</code> or <code class="literal">innodb</code>, and
                    <em class="replaceable"><code>instrument_name</code></em> is the instrument
                    detail.
                </p><p style="color:blue;">默认情况下，大多数性能架构内存检测都被禁用。可以通过更新性能架构设置仪表表的“已启用”列来启用仪表。内存仪器的名称是memory/code_area/instrument_name，其中code_area是一个值，如sql或innodb，instrument_name是仪器的详细信息。</p><p></p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            To view available MySQL memory instruments, query the
                            Performance Schema
                            <a class="link" href="performance-schema.html#setup-instruments-table" title="25.12.2.3&nbsp;The setup_instruments Table"><code class="literal">setup_instruments</code></a> table.
                            The following query returns hundreds of memory
                            instruments for all code areas.
                        </p><p style="color:blue;">要查看可用的mysql内存工具，请查询performance schema setup_instruments表。以下查询返回所有代码区域的数百个内存工具。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%memory%';</code></strong></pre><p>
                            You can narrow results by specifying a code area. For
                            example, you can limit results to
                            <code class="literal">InnoDB</code> memory instruments by
                            specifying <code class="literal">innodb</code> as the code area.
                        </p><p style="color:blue;">可以通过指定代码区域来缩小结果范围。例如，通过指定innodb作为代码区域，可以将结果限制为innodb内存工具。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%memory/innodb%';</code></strong>
+-------------------------------------------+---------+-------+
| NAME                                      | ENABLED | TIMED |
+-------------------------------------------+---------+-------+
| memory/innodb/adaptive hash index         | NO      | NO    |
| memory/innodb/buf_buf_pool                | NO      | NO    |
| memory/innodb/dict_stats_bg_recalc_pool_t | NO      | NO    |
| memory/innodb/dict_stats_index_map_t      | NO      | NO    |
| memory/innodb/dict_stats_n_diff_on_level  | NO      | NO    |
| memory/innodb/other                       | NO      | NO    |
| memory/innodb/row_log_buf                 | NO      | NO    |
| memory/innodb/row_merge_sort              | NO      | NO    |
| memory/innodb/std                         | NO      | NO    |
| memory/innodb/trx_sys_t::rw_trx_ids       | NO      | NO    |
...
</pre><p>
                            Depending on your MySQL installation, code areas may
                            include <code class="literal">performance_schema</code>,
                            <code class="literal">sql</code>, <code class="literal">client</code>,
                            <code class="literal">innodb</code>, <code class="literal">myisam</code>,
                            <code class="literal">csv</code>, <code class="literal">memory</code>,
                            <code class="literal">blackhole</code>,
                            <code class="literal">archive</code>,
                            <code class="literal">partition</code>, and others.
                        </p><p style="color:blue;">根据mysql的安装，代码区域可能包括performance_schema、sql、client、innodb、myisam、csv、memory、blackhole、archive、partition等。</p><p></p></li><li class="listitem"><p>
                            To enable memory instruments, add a
                            <code class="literal">performance-schema-instrument</code> rule to
                            your MySQL configuration file. For example, to enable
                            all memory instruments, add this rule to your
                            configuration file and restart the server:
                        </p><p style="color:blue;">要启用内存工具，请将性能架构工具规则添加到mysql配置文件中。例如，要启用所有内存工具，请将此规则添加到配置文件中并重新启动服务器：</p><p></p><pre data-lang="ini" class="programlisting">performance-schema-instrument='memory/%=COUNTED'</pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    Enabling memory instruments at startup ensures that
                                    memory allocations that occur at startup are counted.
                                </p><p style="color:blue;">在启动时启用内存工具可确保对启动时发生的内存分配进行计数。</p><p></p>
                            </div>
                            <p>
                                After restarting the server, the
                                <code class="literal">ENABLED</code> column of the Performance
                                Schema <a class="link" href="performance-schema.html#setup-instruments-table" title="25.12.2.3&nbsp;The setup_instruments Table"><code class="literal">setup_instruments</code></a>
                                table should report <code class="literal">YES</code> for memory
                                instruments that you enabled. The
                                <code class="literal">TIMED</code> column in the
                                <a class="link" href="performance-schema.html#setup-instruments-table" title="25.12.2.3&nbsp;The setup_instruments Table"><code class="literal">setup_instruments</code></a> table is
                                ignored for memory instruments because memory operations
                                are not timed.
                            </p><p style="color:blue;">重新启动服务器后，performance schema setup_instruments表的enabled列应为已启用的内存工具报告yes。由于内存操作未计时，因此忽略内存仪器的setup_instruments表中的timed列。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.setup_instruments</code></strong>
       <strong class="userinput"><code>WHERE NAME LIKE '%memory/innodb%';</code></strong>
+-------------------------------------------+---------+-------+
| NAME                                      | ENABLED | TIMED |
+-------------------------------------------+---------+-------+
| memory/innodb/adaptive hash index         | NO      | NO    |
| memory/innodb/buf_buf_pool                | NO      | NO    |
| memory/innodb/dict_stats_bg_recalc_pool_t | NO      | NO    |
| memory/innodb/dict_stats_index_map_t      | NO      | NO    |
| memory/innodb/dict_stats_n_diff_on_level  | NO      | NO    |
| memory/innodb/other                       | NO      | NO    |
| memory/innodb/row_log_buf                 | NO      | NO    |
| memory/innodb/row_merge_sort              | NO      | NO    |
| memory/innodb/std                         | NO      | NO    |
| memory/innodb/trx_sys_t::rw_trx_ids       | NO      | NO    |
...
</pre></li><li class="listitem"><p>
                            Query memory instrument data. In this example, memory
                            instrument data is queried in the Performance Schema
                            <a class="link" href="performance-schema.html#memory-summary-tables" title="25.12.15.9&nbsp;Memory Summary Tables"><code class="literal">memory_summary_global_by_event_name</code></a>
                            table, which summarizes data by
                            <code class="literal">EVENT_NAME</code>. The
                            <code class="literal">EVENT_NAME</code> is the name of the
                            instrument.
                        </p><p style="color:blue;">查询内存仪表数据。在本例中，在性能模式memory_summary_global_by_event_name表中查询内存仪表数据，该表按event_name汇总数据。事件名称是仪器的名称。</p><p></p><p>
                            The following query returns memory data for the
                            <code class="literal">InnoDB</code> buffer pool. For column
                            descriptions, see
                            <a class="xref" href="performance-schema.html#memory-summary-tables" title="25.12.15.9&nbsp;Memory Summary Tables">Section&nbsp;25.12.15.9, “Memory Summary Tables”</a>.
                        </p><p style="color:blue;">以下查询返回innodb缓冲池的内存数据。有关列说明，请参阅第25.12.15.9节“内存摘要表”。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.memory_summary_global_by_event_name</code></strong>
       <strong class="userinput"><code>WHERE EVENT_NAME LIKE 'memory/innodb/buf_buf_pool'\G</code></strong>
                  EVENT_NAME: memory/innodb/buf_buf_pool
                 COUNT_ALLOC: 1
                  COUNT_FREE: 0
   SUM_NUMBER_OF_BYTES_ALLOC: 137428992
    SUM_NUMBER_OF_BYTES_FREE: 0
              LOW_COUNT_USED: 0
          CURRENT_COUNT_USED: 1
             HIGH_COUNT_USED: 1
    LOW_NUMBER_OF_BYTES_USED: 0
CURRENT_NUMBER_OF_BYTES_USED: 137428992
   HIGH_NUMBER_OF_BYTES_USED: 137428992
</pre><p>
                            The same underlying data can be queried using the
                            <a class="link" href="sys-schema.html" title="Chapter&nbsp;26&nbsp;MySQL sys Schema"><code class="literal">sys</code></a> schema
                            <a class="link" href="sys-schema.html#sys-memory-global-by-current-bytes" title="26.4.3.19&nbsp;The memory_global_by_current_bytes and x$memory_global_by_current_bytes Views"><code class="literal">memory_global_by_current_bytes</code></a>
                            table, which shows current memory usage within the
                            server globally, broken down by allocation type.
                        </p><p style="color:blue;">可以使用sys schema memory_global_by_current_bytes表查询相同的底层数据，该表按分配类型全局显示服务器内的当前内存使用情况。</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM sys.memory_global_by_current_bytes</code></strong>
       <strong class="userinput"><code>WHERE event_name LIKE 'memory/innodb/buf_buf_pool'\G</code></strong>
*************************** 1. row ***************************
       event_name: memory/innodb/buf_buf_pool
    current_count: 1
    current_alloc: 131.06 MiB
current_avg_alloc: 131.06 MiB
       high_count: 1
       high_alloc: 131.06 MiB
   high_avg_alloc: 131.06 MiB
</pre><p>
                            This <a class="link" href="sys-schema.html" title="Chapter&nbsp;26&nbsp;MySQL sys Schema"><code class="literal">sys</code></a> schema query
                            aggregates currently allocated memory
                            (<code class="literal">current_alloc</code>) by code area:
                        </p><p style="color:blue;">此sys schema查询按代码区域聚合当前分配的内存（当前分配的内存）：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SUBSTRING_INDEX(event_name,'/',2) AS</code></strong>
       <strong class="userinput"><code>code_area, sys.format_bytes(SUM(current_alloc))</code></strong>
       <strong class="userinput"><code>AS current_alloc</code></strong>
       <strong class="userinput"><code>FROM sys.x$memory_global_by_current_bytes</code></strong>
       <strong class="userinput"><code>GROUP BY SUBSTRING_INDEX(event_name,'/',2)</code></strong>
       <strong class="userinput"><code>ORDER BY SUM(current_alloc) DESC;</code></strong>
+---------------------------+---------------+
| code_area                 | current_alloc |
+---------------------------+---------------+
| memory/innodb             | 843.24 MiB    |
| memory/performance_schema | 81.29 MiB     |
| memory/mysys              | 8.20 MiB      |
| memory/sql                | 2.47 MiB      |
| memory/memory             | 174.01 KiB    |
| memory/myisam             | 46.53 KiB     |
| memory/blackhole          | 512 bytes     |
| memory/federated          | 512 bytes     |
| memory/csv                | 512 bytes     |
| memory/vio                | 496 bytes     |
+---------------------------+---------------+
</pre><p>
                            For more information about
                            <a class="link" href="sys-schema.html" title="Chapter&nbsp;26&nbsp;MySQL sys Schema"><code class="literal">sys</code></a> schema, see
                            <a class="xref" href="sys-schema.html" title="Chapter&nbsp;26&nbsp;MySQL sys Schema">Chapter&nbsp;26, <i>MySQL sys Schema</i></a>.
                        </p><p style="color:blue;">有关sys schema的更多信息，请参阅第26章mysql sys schema。</p><p></p></li></ol>
                    </div>

                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="large-page-support"></a>8.12.4.2&nbsp;Enabling Large Page Support</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286868909280"></a><p>
                Some hardware/operating system architectures support memory
                pages greater than the default (usually 4KB). The actual
                implementation of this support depends on the underlying
                hardware and operating system. Applications that perform a lot
                of memory accesses may obtain performance improvements by
                using large pages due to reduced Translation Lookaside Buffer
                (TLB) misses.
            </p><p style="color:blue;">一些硬件/操作系统架构支持大于默认值（通常为4KB）的内存页。这种支持的实际实现取决于底层硬件和操作系统。由于减少了translation lookaside buffer（tlb）未命中，执行大量内存访问的应用程序可以通过使用大页面来获得性能改进。</p><p></p><p>
                In MySQL, large pages can be used by InnoDB, to allocate
                memory for its buffer pool and additional memory pool.
            </p><p style="color:blue;">在mysql中，innodb可以使用大页面为其缓冲池和额外的内存池分配内存。</p><p></p><p>
                Standard use of large pages in MySQL attempts to use the
                largest size supported, up to 4MB. Under Solaris, a
                <span class="quote">“<span class="quote">super large pages</span>”</span> feature enables uses of pages
                up to 256MB. This feature is available for recent SPARC
                platforms. It can be enabled or disabled by using the
                <a class="link" href="server-administration.html#option_mysqld_super-large-pages"><code class="option">--super-large-pages</code></a> or
                <a class="link" href="server-administration.html#option_mysqld_super-large-pages"><code class="option">--skip-super-large-pages</code></a>
                option.
            </p><p style="color:blue;">在mysql中标准地使用大页面会尝试使用支持的最大大小（最多4mb）。在solaris下，一个“超大页面”特性允许使用高达256mb的页面。此功能可用于最近的SPARC平台。可以使用--super large pages或--skip super large pages选项启用或禁用它。</p><p></p><p>
                MySQL also supports the Linux implementation of large page
                support (which is called HugeTLB in Linux).
            </p><p style="color:blue;">mysql还支持linux实现的大页面支持（在linux中称为hugetlb）。</p><p></p><p>
                Before large pages can be used on Linux, the kernel must be
                enabled to support them and it is necessary to configure the
                HugeTLB memory pool. For reference, the HugeTBL API is
                documented in the
                <code class="filename">Documentation/vm/hugetlbpage.txt</code> file of
                your Linux sources.
            </p><p style="color:blue;">在linux上使用大页面之前，必须启用内核来支持它们，并且必须配置hugetlb内存池。作为参考，hugetbl api被记录在linux源代码的documentation/vm/hugetlbpage.txt文件中。</p><p></p><p>
                The kernel for some recent systems such as Red Hat Enterprise
                Linux appear to have the large pages feature enabled by
                default. To check whether this is true for your kernel, use
                the following command and look for output lines containing
                <span class="quote">“<span class="quote">huge</span>”</span>:
            </p><p style="color:blue;">一些最新系统（如Red Hat Enterprise Linux）的内核在默认情况下似乎启用了大页面功能。要检查这是否适用于内核，请使用以下命令并查找包含“hugger”的输出行：</p><p></p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>cat /proc/meminfo | grep -i huge</code></strong>
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       4096 kB
</pre><p>
                The nonempty command output indicates that large page support
                is present, but the zero values indicate that no pages are
                configured for use.
            </p><p style="color:blue;">非空命令输出表示存在大页支持，但零值表示未配置任何页供使用。</p><p></p><p>
                If your kernel needs to be reconfigured to support large
                pages, consult the <code class="filename">hugetlbpage.txt</code> file
                for instructions.
            </p><p style="color:blue;">如果需要重新配置内核以支持大页面，请参阅hugetlbpage.txt文件以获取说明。</p><p></p><p>
                Assuming that your Linux kernel has large page support
                enabled, configure it for use by MySQL using the following
                commands. Normally, you put these in an
                <code class="filename">rc</code> file or equivalent startup file that
                is executed during the system boot sequence, so that the
                commands execute each time the system starts. The commands
                should execute early in the boot sequence, before the MySQL
                server starts. Be sure to change the allocation numbers and
                the group number as appropriate for your system.
            </p><p style="color:blue;">假设您的linux内核启用了大页面支持，使用以下命令将其配置为供mysql使用。通常，您会将它们放入rc文件或在系统启动序列期间执行的等效启动文件中，以便每次系统启动时执行命令。在mysql服务器启动之前，这些命令应该在启动序列的早期执行。请确保根据您的系统更改分配号码和组号码。</p><p></p><pre data-lang="terminal" class="programlisting"># Set the number of pages to be used.
# Each page is normally 2MB, so a value of 20 = 40MB.
# This command actually allocates memory, so this much
# memory must be available.
echo 20 &gt; /proc/sys/vm/nr_hugepages

# Set the group number that is permitted to access this
# memory (102 in this case). The mysql user must be a
# member of this group.
echo 102 &gt; /proc/sys/vm/hugetlb_shm_group

# Increase the amount of shmem permitted per segment
# (12G in this case).
echo 1560281088 &gt; /proc/sys/kernel/shmmax

# Increase total amount of shared memory.  The value
# is the number of pages. At 4KB/page, 4194304 = 16GB.
echo 4194304 &gt; /proc/sys/kernel/shmall
</pre><p>
                For MySQL usage, you normally want the value of
                <code class="literal">shmmax</code> to be close to the value of
                <code class="literal">shmall</code>.
            </p><p style="color:blue;">对于mysql的使用，通常希望shmmax的值接近shmall的值。</p><p></p><p>
                To verify the large page configuration, check
                <code class="filename">/proc/meminfo</code> again as described
                previously. Now you should see some nonzero values:
            </p><p style="color:blue;">要验证大页面配置，请按照前面的说明再次检查/proc/meminfo。现在您应该看到一些非零值：</p><p></p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>cat /proc/meminfo | grep -i huge</code></strong>
HugePages_Total:      20
HugePages_Free:       20
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       4096 kB
</pre><p>
                The final step to make use of the
                <code class="literal">hugetlb_shm_group</code> is to give the
                <code class="literal">mysql</code> user an <span class="quote">“<span class="quote">unlimited</span>”</span>
                value for the memlock limit. This can be done either by
                editing <code class="filename">/etc/security/limits.conf</code> or by
                adding the following command to your
                <a class="link" href="programs.html#mysqld-safe" title="4.3.2&nbsp;mysqld_safe — MySQL Server Startup Script"><span class="command"><strong>mysqld_safe</strong></span></a> script:
            </p><p style="color:blue;">使用hugetlb_shm_组的最后一步是为mysql用户提供memlock限制的“无限”值。这可以通过编辑/etc/security/limits.conf或将以下命令添加到mysqld_safe脚本来完成：</p><p></p><pre data-lang="terminal" class="programlisting">ulimit -l unlimited
</pre><p>
                Adding the <span class="command"><strong>ulimit</strong></span> command to
                <a class="link" href="programs.html#mysqld-safe" title="4.3.2&nbsp;mysqld_safe — MySQL Server Startup Script"><span class="command"><strong>mysqld_safe</strong></span></a> causes the
                <code class="literal">root</code> user to set the memlock limit to
                <code class="literal">unlimited</code> before switching to the
                <code class="literal">mysql</code> user. (This assumes that
                <a class="link" href="programs.html#mysqld-safe" title="4.3.2&nbsp;mysqld_safe — MySQL Server Startup Script"><span class="command"><strong>mysqld_safe</strong></span></a> is started by
                <code class="literal">root</code>.)
            </p><p style="color:blue;">将ulimit命令添加到mysqld_safe会导致根用户在切换到mysql用户之前将memlock limit设置为unlimited。（这假设mysqld_safe由root启动。）</p><p></p><p>
                Large page support in MySQL is disabled by default. To enable
                it, start the server with the
                <a class="link" href="server-administration.html#option_mysqld_large-pages"><code class="option">--large-pages</code></a> option. For
                example, you can use the following lines in the server
                <code class="filename">my.cnf</code> file:
            </p><p style="color:blue;">mysql中的大页面支持在默认情况下是禁用的。要启用它，请使用--large pages选项启动服务器。例如，可以在server my.cnf文件中使用以下行：</p><p></p><pre data-lang="ini" class="programlisting">[mysqld]
large-pages
</pre><p>
                With this option, <code class="literal">InnoDB</code> uses large pages
                automatically for its buffer pool and additional memory pool.
                If <code class="literal">InnoDB</code> cannot do this, it falls back to
                use of traditional memory and writes a warning to the error
                log: <span class="errortext">Warning: Using conventional memory
          pool</span>
            </p><p style="color:blue;">有了这个选项，innodb会自动使用大页面作为缓冲池和附加内存池。如果innodb无法做到这一点，它将返回使用传统内存，并将警告写入错误日志：警告：使用传统内存池</p><p></p><p>
                To verify that large pages are being used, check
                <code class="literal">/proc/meminfo</code> again:
            </p><p style="color:blue;">要验证是否正在使用大页面，请再次检查/proc/meminfo：</p><p></p><pre data-lang="terminal" class="programlisting">shell&gt; <strong class="userinput"><code>cat /proc/meminfo | grep -i huge</code></strong>
HugePages_Total:      20
HugePages_Free:       20
HugePages_Rsvd:        2
HugePages_Surp:        0
Hugepagesize:       4096 kB
</pre>
            </div>

        </div>

        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="optimizing-network"></a>8.12.5&nbsp;Optimizing Network Use</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="optimization.html#client-connections">8.12.5.1 How MySQL Handles Client Connections</a></span></dt><dt><span class="section"><a href="optimization.html#host-cache">8.12.5.2 DNS Lookup Optimization and the Host Cache</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286868866304"></a>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="client-connections"></a>8.12.5.1&nbsp;How MySQL Handles Client Connections</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286868863728"></a><a class="indexterm" name="idm140286868862688"></a><a class="indexterm" name="idm140286868861616"></a><p>
                This section describes aspects of how the MySQL server manages
                client connections.
            </p><p style="color:blue;">本节介绍mysql服务器如何管理客户端连接的各个方面。</p><p></p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#client-connections-interfaces" title="Network Interfaces and Connection Manager Threads">Network Interfaces and Connection Manager Threads</a></p><p style="color:blue;">网络接口和连接管理器线程</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#client-connections-thread-management" title="Client Connection Thread Management">Client Connection Thread Management</a></p><p style="color:blue;">客户端连接线程管理</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#client-connections-volume-management" title="Connection Volume Management">Connection Volume Management</a></p><p style="color:blue;">连接卷管理</p><p></p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="client-connections-interfaces"></a>Network Interfaces and Connection Manager Threads</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The server is capable of listening for client connections on
                        multiple network interfaces. Connection manager threads
                        handle client connection requests on the network interfaces
                        that the server listens to:
                    </p><p style="color:blue;">服务器能够监听多个网络接口上的客户端连接。连接管理器线程处理服务器侦听的网络接口上的客户端连接请求：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            On all platforms, one manager thread handles TCP/IP
                            connection requests.
                        </p><p style="color:blue;">在所有平台上，一个管理器线程处理TCP/IP连接请求。</p><p></p></li><li class="listitem"><p>
                            On Unix, the same manager thread also handles Unix
                            socket file connection requests.
                        </p><p style="color:blue;">在unix上，同一个管理器线程还处理unix套接字文件连接请求。</p><p></p></li><li class="listitem"><p>
                            On Windows, a manager thread handles shared-memory
                            connection requests, and another handles named-pipe
                            connection requests.
                        </p><p style="color:blue;">在Windows上，管理器线程处理共享内存连接请求，另一个线程处理命名管道连接请求。</p><p></p></li></ul>
                    </div>
                    <p>
                        The server does not create threads to handle interfaces that
                        it does not listen to. For example, a Windows server that
                        does not have support for named-pipe connections enabled
                        does not create a thread to handle them.
                    </p><p style="color:blue;">服务器不会创建线程来处理它不侦听的接口。例如，不支持已启用命名管道连接的Windows服务器不会创建线程来处理它们。</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="client-connections-thread-management"></a>Client Connection Thread Management</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Connection manager threads associate each client connection
                        with a thread dedicated to it that handles authentication
                        and request processing for that connection. Manager threads
                        create a new thread when necessary but try to avoid doing so
                        by consulting the thread cache first to see whether it
                        contains a thread that can be used for the connection. When
                        a connection ends, its thread is returned to the thread
                        cache if the cache is not full.
                    </p><p style="color:blue;">连接管理器线程将每个客户端连接与专用于它的线程相关联，该线程处理该连接的身份验证和请求处理。管理器线程在必要时创建一个新线程，但请尝试避免这样做，方法是首先咨询线程缓存，以查看它是否包含可用于连接的线程。连接结束时，如果缓存未满，则将其线程返回到线程缓存。</p><p></p><p>
                    In this connection thread model, there are as many threads
                    as there are clients currently connected, which has some
                    disadvantages when server workload must scale to handle
                    large numbers of connections. For example, thread creation
                    and disposal becomes expensive. Also, each thread requires
                    server and kernel resources, such as stack space. To
                    accommodate a large number of simultaneous connections, the
                    stack size per thread must be kept small, leading to a
                    situation where it is either too small or the server
                    consumes large amounts of memory. Exhaustion of other
                    resources can occur as well, and scheduling overhead can
                    become significant.
                </p><p style="color:blue;">在这种连接线程模型中，线程数量与当前连接的客户机数量一样多，这在服务器工作负载必须扩展以处理大量连接时有一些缺点。例如，线程的创建和处理变得非常昂贵。此外，每个线程都需要服务器和内核资源，如堆栈空间。为了容纳大量的同时连接，每个线程的堆栈大小必须保持较小，从而导致堆栈太小或服务器占用大量内存的情况。其他资源的耗尽也会发生，调度开销会变得非常大。</p><p></p><p>
                    MySQL Enterprise Edition includes a thread pool plugin that provides an
                    alternative thread-handling model designed to reduce
                    overhead and improve performance. It implements a thread
                    pool that increases server performance by efficiently
                    managing statement execution threads for large numbers of
                    client connections. See <a class="xref" href="server-administration.html#thread-pool" title="5.5.3&nbsp;MySQL Enterprise Thread Pool">Section&nbsp;5.5.3, “MySQL Enterprise Thread Pool”</a>.
                </p><p style="color:blue;">mysql企业版包括一个线程池插件，它提供了一个替代的线程处理模型，旨在减少开销和提高性能。它实现了一个线程池，通过有效地管理大量客户端连接的语句执行线程来提高服务器性能。参见第5.5.3节“MySQL企业线程池”。</p><p></p><p>
                    To control and monitor how the server manages threads that
                    handle client connections, several system and status
                    variables are relevant. (See
                    <a class="xref" href="server-administration.html#server-system-variables" title="5.1.7&nbsp;Server System Variables">Section&nbsp;5.1.7, “Server System Variables”</a>, and
                    <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>.)
                </p><p style="color:blue;">为了控制和监视服务器如何管理处理客户端连接的线程，有几个系统和状态变量是相关的。（请参阅第5.1.7节“服务器系统变量”和第5.1.9节“服务器状态变量”。）</p><p></p><p>
                    The <a class="link" href="server-administration.html#sysvar_thread_cache_size"><code class="literal">thread_cache_size</code></a>
                    system variable determines the thread cache size. By
                    default, the server autosizes the value at startup, but it
                    can be set explicitly to override this default. A value of 0
                    disables caching, which causes a thread to be set up for
                    each new connection and disposed of when the connection
                    terminates. To enable <em class="replaceable"><code>N</code></em> inactive
                    connection threads to be cached, set
                    <a class="link" href="server-administration.html#sysvar_thread_cache_size"><code class="literal">thread_cache_size</code></a> to
                    <em class="replaceable"><code>N</code></em> at server startup or at
                    runtime. A connection thread becomes inactive when the
                    client connection with which it was associated terminates.
                </p><p style="color:blue;">thread_cache_size系统变量决定线程缓存大小。默认情况下，服务器在启动时自动调整该值，但可以显式设置该值以覆盖此默认值。值为0将禁用缓存，这将导致为每个新连接设置一个线程，并在连接终止时释放该线程。若要启用n个非活动连接线程进行缓存，请在服务器启动或运行时将“线程缓存大小”设置为n。当与其关联的客户端连接终止时，连接线程将变为非活动状态。</p><p></p><p>
                    To monitor the number of threads in the cache and how many
                    threads have been created because a thread could not be
                    taken from the cache, check the
                    <a class="link" href="server-administration.html#statvar_Threads_cached"><code class="literal">Threads_cached</code></a> and
                    <a class="link" href="server-administration.html#statvar_Threads_created"><code class="literal">Threads_created</code></a> status
                    variables.
                </p><p style="color:blue;">要监视缓存中的线程数以及由于无法从缓存中获取线程而创建的线程数，请检查threads_cached和threads_created状态变量。</p><p></p><p>
                    When the thread stack is too small, this limits the
                    complexity of the SQL statements which the server can
                    handle, the recursion depth of stored procedures, and other
                    memory-consuming actions. To set a stack size of
                    <em class="replaceable"><code>N</code></em> bytes for each thread, start
                    the server with
                    <a class="link" href="server-administration.html#sysvar_thread_stack"><code class="literal">thread_stack</code></a>. set to
                    <em class="replaceable"><code>N</code></em> at server startup.
                </p><p style="color:blue;">当线程堆栈太小时，这限制了服务器可以处理的SQL语句的复杂性、存储过程的递归深度和其他内存消耗操作。要为每个线程设置n字节的堆栈大小，请使用thread_stack启动服务器。在服务器启动时设置为n。</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="client-connections-volume-management"></a>Connection Volume Management</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        To control the maximum number of clients the server permits
                        to connect simultaneously, set the
                        <a class="link" href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a> system
                        variable at server startup or at runtime. It may be
                        necessary to increase
                        <a class="link" href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a> if more
                        clients attempt to connect simultaneously then the server is
                        configured to handle (see
                        <a class="xref" href="error-handling.html#too-many-connections" title="B.4.2.6&nbsp;Too many connections">Section&nbsp;B.4.2.6, “Too many connections”</a>).
                    </p><p style="color:blue;">为了控制服务器允许同时连接的最大数量的客户端，在服务器启动或运行时设置Max连接系统变量。如果有更多的客户端试图同时连接，则可能需要增加最大连接数，然后服务器被配置为处理（请参阅第B.4.2.6节“连接过多”）。</p><p></p><p>
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> actually permits
                    <a class="link" href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a>
                    + 1 client connections. The extra connection is reserved for
                    use by accounts that have the
                    <a class="link" href="security.html#priv_super"><code class="literal">SUPER</code></a> privilege. By granting
                    the privilege to administrators and not to normal users (who
                    should not need it), an administrator who also has the
                    <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a> privilege can connect
                    to the server and use <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                    PROCESSLIST</code></a> to diagnose problems even if the
                    maximum number of unprivileged clients are connected. See
                    <a class="xref" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax">Section&nbsp;13.7.5.29, “SHOW PROCESSLIST Syntax”</a>.
                </p><p style="color:blue;">mysqld实际上允许最大连接数+1个客户端连接。额外的连接被保留给拥有超级特权的帐户使用。通过授予管理员权限而不是普通用户（谁不需要它），拥有进程特权的管理员可以连接到服务器，并使用Sudio PrimeLIST来诊断问题，即使最大数量的非特权客户端被连接。见第13.7.5.29节“显示进程列表语法”。</p><p></p><p>
                    If the server refuses a connection because the
                    <a class="link" href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a> limit is
                    reached, it increments the
                    <a class="link" href="server-administration.html#statvar_Connection_errors_max_connections"><code class="literal">Connection_errors_max_connections</code></a>
                    status variable.
                </p><p style="color:blue;">如果服务器由于达到最大连接限制而拒绝连接，则会增加连接错误最大连接状态变量。</p><p></p><p>
                    The maximum number of connections MySQL supports (that is,
                    the maximum value to which
                    <a class="link" href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a> can be set)
                    depends on several factors:
                </p><p style="color:blue;">MySQL支持的最大连接数（即可以设置最大连接数的最大值）取决于以下几个因素：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The quality of the thread library on a given platform.
                        </p><p style="color:blue;">给定平台上线程库的质量。</p><p></p></li><li class="listitem"><p>
                            The amount of RAM available.
                        </p><p style="color:blue;">可用的RAM量。</p><p></p></li><li class="listitem"><p>
                            The amount of RAM is used for each connection.
                        </p><p style="color:blue;">每个连接使用的RAM数量。</p><p></p></li><li class="listitem"><p>
                            The workload from each connection.
                        </p><p style="color:blue;">每个连接的工作负载。</p><p></p></li><li class="listitem"><p>
                            The desired response time.
                        </p><p style="color:blue;">所需的响应时间。</p><p></p></li><li class="listitem"><p>
                            The number of file descriptors available.
                        </p><p style="color:blue;">可用的文件描述符数。</p><p></p></li></ul>
                    </div>
                    <p>
                        Linux or Solaris should be able to support at least 500 to
                        1000 simultaneous connections routinely and as many as
                        10,000 connections if you have many gigabytes of RAM
                        available and the workload from each is low or the response
                        time target undemanding.
                    </p><p style="color:blue;">linux或solaris应该能够支持至少500到1000个常规的同时连接，如果有许多千兆字节的ram可用，并且每个ram的工作负载很低，或者响应时间目标要求不高，那么最多可以支持10000个连接。</p><p></p><p>
                    Increasing the
                    <a class="link" href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a> value
                    increases the number of file descriptors that
                    <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> requires. If the required number
                    of descriptors are not available, the server reduces the
                    value of <a class="link" href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a>.
                    For comments on file descriptor limits, see
                    <a class="xref" href="optimization.html#table-cache" title="8.4.3.1&nbsp;How MySQL Opens and Closes Tables">Section&nbsp;8.4.3.1, “How MySQL Opens and Closes Tables”</a>.
                </p><p style="color:blue;">增加max_connections值会增加mysqld所需的文件描述符数量。如果所需数量的描述符不可用，服务器将减少max_connections的值。有关文件描述符限制的注释，请参阅8.4.3.1节“MySQL如何打开和关闭表”。</p><p></p><p>
                    Increasing the
                    <a class="link" href="server-administration.html#sysvar_open_files_limit"><code class="literal">open_files_limit</code></a> system
                    variable may be necessary, which may also require raising
                    the operating system limit on how many file descriptors can
                    be used by MySQL. Consult your operating system
                    documentation to determine whether it is possible to
                    increase the limit and how to do so. See also
                    <a class="xref" href="error-handling.html#not-enough-file-handles" title="B.4.2.17&nbsp;File Not Found and Similar Errors">Section&nbsp;B.4.2.17, “File Not Found and Similar Errors”</a>.
                </p><p style="color:blue;">可能需要增加open_files_limit系统变量，这可能还需要提高mysql可以使用多少文件描述符的操作系统限制。请参阅操作系统文档，以确定是否可以增加限制以及如何增加限制。另见第B.4.2.17节，“未找到文件和类似错误”。</p><p></p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="host-cache"></a>8.12.5.2&nbsp;DNS Lookup Optimization and the Host Cache</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286868800576"></a><a class="indexterm" name="idm140286868799520"></a><a class="indexterm" name="idm140286868798448"></a><p>
                The MySQL server maintains a host cache in memory that
                contains information about clients: IP address, host name, and
                error information. The Performance Schema
                <a class="link" href="performance-schema.html#host-cache-table" title="25.12.16.1&nbsp;The host_cache Table"><code class="literal">host_cache</code></a> table exposes the
                contents of the host cache so that it can be examined using
                <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statements. This may
                help you diagnose the causes of connection problems. See
                <a class="xref" href="performance-schema.html#host-cache-table" title="25.12.16.1&nbsp;The host_cache Table">Section&nbsp;25.12.16.1, “The host_cache Table”</a>.
            </p><p style="color:blue;">mysql服务器在内存中维护一个主机缓存，其中包含有关客户端的信息：ip地址、主机名和错误信息。性能架构主机缓存表公开主机缓存的内容，以便可以使用select语句对其进行检查。这可能有助于诊断连接问题的原因。见第25.12.16.1节“主机缓存表”。</p><p></p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The server uses the host cache only for nonlocal TCP
                        connections. It does not use the cache for TCP connections
                        established using a loopback interface address (for example,
                        <code class="literal">127.0.0.1</code> or <code class="literal">::1</code>), or
                        for connections established using a Unix socket file, named
                        pipe, or shared memory.
                    </p><p style="color:blue;">服务器仅对非本地TCP连接使用主机缓存。它不为使用环回接口地址（例如127.0.0.1或：：1）建立的TCP连接使用缓存，也不为使用Unix套接字文件、命名管道或共享内存建立的连接使用缓存。</p><p></p>
                </div>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="optimization.html#host-cache-operation" title="Host Cache Operation">Host Cache Operation</a></p><p style="color:blue;">主机缓存操作</p><p></p></li><li class="listitem"><p><a class="xref" href="optimization.html#host-cache-configuration" title="Host Cache Configuration">Host Cache Configuration</a></p><p style="color:blue;">主机缓存配置</p><p></p></li></ul>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="host-cache-operation"></a>Host Cache Operation</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The server uses the host cache for several purposes:
                    </p><p style="color:blue;">服务器将主机缓存用于多种目的：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            By caching the results of IP-to-host name lookups, the
                            server avoids doing a Domain Name System (DNS) lookup
                            for each client connection. Instead, for a given host,
                            it needs to perform a lookup only for the first
                            connection from that host.
                        </p><p style="color:blue;">通过缓存IP到主机名查找的结果，服务器可以避免对每个客户端连接执行域名系统（DNS）查找。相反，对于给定的主机，它只需要对来自该主机的第一个连接执行查找。</p><p></p></li><li class="listitem"><p>
                            The cache contains information about errors that occur
                            during the connection process. Some errors are
                            considered <span class="quote">“<span class="quote">blocking.</span>”</span> If too many of these
                            occur successively from a given host without a
                            successful connection, the server blocks further
                            connections from that host. The
                            <a class="link" href="server-administration.html#sysvar_max_connect_errors"><code class="literal">max_connect_errors</code></a>
                            system variable determines the permitted number of
                            successive errors before blocking occurs (see
                            <a class="xref" href="error-handling.html#blocked-host" title="B.4.2.5&nbsp;Host 'host_name' is blocked">Section&nbsp;B.4.2.5, “Host 'host_name' is blocked”</a>).
                        </p><p style="color:blue;">缓存包含有关连接过程中发生的错误的信息。有些错误被认为是“阻塞”。如果有太多的错误是从一个给定的主机连续发生的，而没有成功的连接，服务器会阻塞从该主机的进一步连接。MAX U CONNECT U ERRORS系统变量确定阻塞发生前允许的连续错误数（请参阅第B.4.2.5节，“主机'主机名'被阻塞”）。</p><p></p></li></ul>
                    </div>
                    <p>
                        For each new client connection, the server uses the client
                        IP address to check whether the client host name is in the
                        host cache. If so, the server refuses or continues to
                        process the connection request depending on whether or not
                        the host is blocked. If the host is not in the cache, the
                        server attempts to resolve the host name. First, it resolves
                        the IP address to a host name and resolves that host name
                        back to an IP address. Then it compares the result to the
                        original IP address to ensure that they are the same. The
                        server stores information about the result of this operation
                        in the host cache. If the cache is full, the least recently
                        used entry is discarded.
                    </p><p style="color:blue;">对于每个新的客户端连接，服务器使用客户端IP地址来检查客户端主机名是否在主机缓存中。如果是，服务器将拒绝或继续处理连接请求，具体取决于主机是否被阻止。如果主机不在缓存中，服务器将尝试解析主机名。首先，它将IP地址解析为主机名，并将该主机名解析回IP地址。然后将结果与原始IP地址进行比较，以确保它们相同。服务器将有关此操作结果的信息存储在主机缓存中。如果缓存已满，则丢弃最近使用最少的项。</p><p></p><p>
                    The server handles entries in the host cache like this:
                </p><p style="color:blue;">服务器处理主机缓存中的条目，如下所示：</p><p></p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            When the first TCP client connection reaches the server
                            from a given IP address, a new cache entry is created to
                            record the client IP, host name, and client lookup
                            validation flag. Initially, the host name is set to
                            <code class="literal">NULL</code> and the flag is false. This
                            entry is also used for subsequent client TCP connections
                            from the same originating IP.
                        </p><p style="color:blue;">当第一个TCP客户端连接从给定的IP地址到达服务器时，将创建一个新的缓存条目，以记录客户端IP、主机名和客户端查找验证标志。最初，主机名设置为null，标志为false。此项还用于来自同一原始IP的后续客户端TCP连接。</p><p></p></li><li class="listitem"><p>
                            If the validation flag for the client IP entry is false,
                            the server attempts an IP-to-host name-to-IP DNS
                            resolution. If that is successful, the host name is
                            updated with the resolved host name and the validation
                            flag is set to true. If resolution is unsuccessful, the
                            action taken depends on whether the error is permanent
                            or transient. For permanent failures, the host name
                            remains <code class="literal">NULL</code> and the validation flag
                            is set to true. For transient failures, the host name
                            and validation flag remain unchanged. (In this case,
                            another DNS resolution attempt occurs the next time a
                            client connects from this IP.)
                        </p><p style="color:blue;">如果客户端IP项的验证标志为false，服务器将尝试IP到主机名到IP DNS的解析。如果成功，将使用解析的主机名更新主机名，并将验证标志设置为true。如果解析失败，则所采取的操作取决于错误是永久性的还是暂时性的。对于永久性失败，主机名保持为空，验证标志设置为true。对于暂时性失败，主机名和验证标志保持不变。（在这种情况下，下次客户端从此IP连接时，将尝试另一个DNS解析。）</p><p></p></li><li class="listitem"><p>
                            If an error occurs while processing an incoming client
                            connection from a given IP address, the server updates
                            the corresponding error counters in the entry for that
                            IP. For a description of the errors recorded, see
                            <a class="xref" href="performance-schema.html#host-cache-table" title="25.12.16.1&nbsp;The host_cache Table">Section&nbsp;25.12.16.1, “The host_cache Table”</a>.
                        </p><p style="color:blue;">如果在处理来自给定IP地址的传入客户端连接时发生错误，服务器将更新该IP条目中相应的错误计数器。有关记录的错误的说明，请参阅第25.12.16.1节“主机缓存表”。</p><p></p></li></ol>
                    </div>
                    <p>
                        The server performs host name resolution using the
                        <code class="function">gethostbyaddr()</code> and
                        <code class="function">gethostbyname()</code> system calls.
                    </p><p style="color:blue;">服务器使用gethostbyaddr（）和gethostbyname（）系统调用执行主机名解析。</p><p></p><p>
                    To unblock blocked hosts, flush the host cache by executing
                    a <a class="link" href="sql-syntax.html#flush-hosts"><code class="literal">FLUSH HOSTS</code></a> statement, a
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> statement that
                    truncates the Performance Schema
                    <a class="link" href="performance-schema.html#host-cache-table" title="25.12.16.1&nbsp;The host_cache Table"><code class="literal">host_cache</code></a> table, or a
                    <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin flush-hosts</strong></span></a> command.
                    <a class="link" href="sql-syntax.html#flush-hosts"><code class="literal">FLUSH HOSTS</code></a> and
                    <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin flush-hosts</strong></span></a> require the
                    <a class="link" href="security.html#priv_reload"><code class="literal">RELOAD</code></a> privilege.
                    <a class="link" href="sql-syntax.html#truncate-table" title="13.1.34&nbsp;TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> requires the
                    <a class="link" href="security.html#priv_drop"><code class="literal">DROP</code></a> privilege for the
                    <a class="link" href="performance-schema.html#host-cache-table" title="25.12.16.1&nbsp;The host_cache Table"><code class="literal">host_cache</code></a> table.
                </p><p style="color:blue;">要解除阻止被阻止的主机，请通过执行flush hosts语句、截断性能架构主机缓存表的truncate table语句或mysqladmin flush hosts命令来刷新主机缓存。刷新主机和mysqladmin刷新主机需要重新加载权限。truncate table需要主机缓存表的drop权限。</p><p></p><p>
                    It is possible for a blocked host to become unblocked even
                    without flushing the host cache if activity from other hosts
                    has occurred since the last connection attempt from the
                    blocked host. This can occur because the server discards the
                    least recently used cache entry to make room for a new entry
                    if the cache is full when a connection arrives from a client
                    IP not in the cache. If the discarded entry is for a blocked
                    host, that host becomes unblocked.
                </p><p style="color:blue;">如果自上次尝试从被阻止的主机进行连接后发生了来自其他主机的活动，则即使不刷新主机缓存，被阻止的主机也可能被解除阻止。这可能是因为当连接从不在缓存中的客户端IP到达时，如果缓存已满，服务器将丢弃最近使用最少的缓存条目，以便为新条目腾出空间。如果丢弃的条目是针对被阻止主机的，则该主机将被解除阻止。</p><p></p><p>
                    Some connection errors are not associated with TCP
                    connections, occur very early in the connection process
                    (even before an IP address is known), or are not specific to
                    any particular IP address (such as out-of-memory
                    conditions). For information about these errors, check the
                    <a class="link" href="server-administration.html#statvar_Connection_errors_xxx"><code class="literal">Connection_errors_<em class="replaceable"><code>xxx</code></em></code></a>
                    status variables (see
                    <a class="xref" href="server-administration.html#server-status-variables" title="5.1.9&nbsp;Server Status Variables">Section&nbsp;5.1.9, “Server Status Variables”</a>).
                </p><p style="color:blue;">某些连接错误与TCP连接无关，在连接过程的早期发生（甚至在已知IP地址之前），或者不是特定于任何特定IP地址（例如内存不足情况）。有关这些错误的信息，请检查连接错误状态变量（请参阅第5.1.9节“服务器状态变量”）。</p><p></p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="host-cache-configuration"></a>Host Cache Configuration</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The host cache is enabled by default. The
                        <a class="link" href="server-administration.html#sysvar_host_cache_size"><code class="literal">host_cache_size</code></a> system
                        variable controls its size, as well as the size of the
                        Performance Schema <a class="link" href="performance-schema.html#host-cache-table" title="25.12.16.1&nbsp;The host_cache Table"><code class="literal">host_cache</code></a>
                        table that exposes the cache contents. The cache size can be
                        set at server startup and changed at runtime. For example,
                        to set the size to 100 at startup, put these lines in the
                        server <code class="filename">my.cnf</code> file:
                    </p><p style="color:blue;">默认情况下启用主机缓存。HOST U CACHE U SIZE系统变量控制其大小以及公开缓存内容的性能架构HOST U CACHE表的大小。缓存大小可以在服务器启动时设置，也可以在运行时更改。例如，要在启动时将大小设置为100，请将这些行放在server my.cnf文件中：</p><p></p><pre data-lang="ini" class="programlisting">[mysqld]
host_cache_size=200
</pre><p>
                    To change the size to 300 at runtime, do this:
                </p><p style="color:blue;">要在运行时将大小更改为300，请执行以下操作：</p><p></p><pre data-lang="sql" class="programlisting">SET GLOBAL host_cache_size=300;
</pre><p>
                    Setting <code class="literal">host_cache_size</code> to 0, either at
                    server startup or at runtime, disables the host cache. With
                    the cache disabled, the server performs a DNS lookup every
                    time a client connects.
                </p><p style="color:blue;">在服务器启动或运行时，将主机缓存大小设置为0将禁用主机缓存。禁用缓存后，服务器在每次客户端连接时执行DNS查找。</p><p></p><p>
                    Changing the cache size at runtime causes an implicit
                    <a class="link" href="sql-syntax.html#flush-hosts"><code class="literal">FLUSH HOSTS</code></a> operation that
                    clears the host cache, truncates the
                    <a class="link" href="performance-schema.html#host-cache-table" title="25.12.16.1&nbsp;The host_cache Table"><code class="literal">host_cache</code></a> table, and unblocks
                    any blocked hosts.
                </p><p style="color:blue;">在运行时更改缓存大小会导致隐式刷新主机操作，该操作会清除主机缓存、截断主机缓存表并取消阻止任何被阻止的主机。</p><p></p><p>
                    Using the <a class="link" href="server-administration.html#option_mysqld_skip-host-cache"><code class="option">--skip-host-cache</code></a>
                    option is similar to setting the
                    <a class="link" href="server-administration.html#sysvar_host_cache_size"><code class="literal">host_cache_size</code></a> system
                    variable to 0, but
                    <a class="link" href="server-administration.html#sysvar_host_cache_size"><code class="literal">host_cache_size</code></a> is more
                    flexible because it can also be used to resize, enable, and
                    disable the host cache at runtime, not just at server
                    startup. Starting the server with
                    <a class="link" href="server-administration.html#option_mysqld_skip-host-cache"><code class="option">--skip-host-cache</code></a> does not
                    prevent changes to the value of
                    <a class="link" href="server-administration.html#sysvar_host_cache_size"><code class="literal">host_cache_size</code></a>, but such
                    changes have no effect and the cache is not re-enabled even
                    if <a class="link" href="server-administration.html#sysvar_host_cache_size"><code class="literal">host_cache_size</code></a> is set
                    larger than 0 at runtime.
                </p><p style="color:blue;">使用--skip host cache选项类似于将host_cache_size系统变量设置为0，但host_cache_size更灵活，因为它还可以用于在运行时调整、启用和禁用主机缓存，而不仅仅是在服务器启动时。使用--skip host cache启动服务器不会阻止对主机缓存大小值的更改，但这些更改不会产生任何效果，即使在运行时主机缓存大小设置为大于0，也不会重新启用缓存。</p><p></p><p>
                    To disable DNS host name lookups, start the server with the
                    <a class="link" href="server-administration.html#option_mysqld_skip-name-resolve"><code class="option">--skip-name-resolve</code></a> option.
                    In this case, the server uses only IP addresses and not host
                    names to match connecting hosts to rows in the MySQL grant
                    tables. Only accounts specified in those tables using IP
                    addresses can be used. (A client may not be able to connect
                    if no account exists that specifies the client IP address.)
                </p><p style="color:blue;">要禁用DNS主机名查找，请使用--skip name resolve选项启动服务器。在这种情况下，服务器只使用IP地址而不使用主机名来将连接主机与MySQL授权表中的行匹配。只能使用这些表中使用IP地址指定的帐户。（如果不存在指定客户端IP地址的帐户，则客户端可能无法连接。）</p><p></p><p>
                    If you have a very slow DNS and many hosts, you might be
                    able to improve performance either by disabling DNS lookups
                    with <a class="link" href="server-administration.html#option_mysqld_skip-name-resolve"><code class="option">--skip-name-resolve</code></a> or
                    by increasing the value of
                    <a class="link" href="server-administration.html#sysvar_host_cache_size"><code class="literal">host_cache_size</code></a> to make the
                    host cache larger.
                </p><p style="color:blue;">如果dns速度非常慢，并且有许多主机，则可以使用--skip name resolve禁用dns查找，或者增加主机缓存大小的值以使主机缓存更大，从而提高性能。</p><p></p><p>
                    To disallow TCP/IP connections entirely, start the server
                    with the <a class="link" href="server-administration.html#option_mysqld_skip-networking"><code class="option">--skip-networking</code></a>
                    option.
                </p><p style="color:blue;">要完全禁止TCP/IP连接，请使用--skip networking选项启动服务器。</p><p></p>
                </div>

            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="optimize-benchmarking"></a>8.13&nbsp;Measuring Performance (Benchmarking)</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#select-benchmarking">8.13.1 Measuring the Speed of Expressions and Functions</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">8.13.2 Using Your Own Benchmarks</a></span></dt><dt><span class="section"><a href="optimization.html#monitoring-performance-schema">8.13.3 Measuring Performance with performance_schema</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286868726512"></a><p>
        To measure performance, consider the following factors:
    </p><p style="color:blue;">要衡量绩效，请考虑以下因素：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                Whether you are measuring the speed of a single operation on a
                quiet system, or how a set of operations (a
                <span class="quote">“<span class="quote">workload</span>”</span>) works over a period of time. With
                simple tests, you usually test how changing one aspect (a
                configuration setting, the set of indexes on a table, the SQL
                clauses in a query) affects performance. Benchmarks are
                typically long-running and elaborate performance tests, where
                the results could dictate high-level choices such as hardware
                and storage configuration, or how soon to upgrade to a new
                MySQL version.
            </p><p style="color:blue;">无论您是在一个安静的系统上测量单个操作的速度，还是在一段时间内一组操作（“工作负载”）是如何工作的。通过简单的测试，通常可以测试更改一个方面（配置设置、表上的索引集、查询中的sql子句）如何影响性能。基准测试通常是长时间运行的、精心设计的性能测试，测试结果可能会指示诸如硬件和存储配置之类的高级选择，或者决定升级到新的mysql版本的时间。</p><p></p></li><li class="listitem"><p>
                For benchmarking, sometimes you must simulate a heavy database
                workload to get an accurate picture.
            </p><p style="color:blue;">对于基准测试，有时必须模拟繁重的数据库工作负载才能获得准确的结果。</p><p></p></li><li class="listitem"><p>
                Performance can vary depending on so many different factors
                that a difference of a few percentage points might not be a
                decisive victory. The results might shift the opposite way
                when you test in a different environment.
            </p><p style="color:blue;">表现可能因许多不同的因素而有所不同，相差几个百分点可能不是决定性的胜利。当您在不同的环境中进行测试时，结果可能会发生相反的变化。</p><p></p></li><li class="listitem"><p>
                Certain MySQL features help or do not help performance
                depending on the workload. For completeness, always test
                performance with those features turned on and turned off. The
                two most important features to try with each workload are the
                <a class="link" href="optimization.html#query-cache" title="8.10.3&nbsp;The MySQL Query Cache">MySQL query cache</a>, and the
                <a class="link" href="innodb-storage-engine.html#innodb-adaptive-hash" title="14.5.3&nbsp;Adaptive Hash Index">adaptive hash
                    index</a> for <code class="literal">InnoDB</code> tables.
            </p><p style="color:blue;">根据工作负载的不同，某些mysql特性对性能有帮助或没有帮助。为了完整性，请始终在打开和关闭这些功能的情况下测试性能。每个工作负载要尝试的两个最重要的特性是mysql查询缓存和innodb表的自适应散列索引。</p><p></p></li></ul>
        </div>
        <p>
            This section progresses from simple and direct measurement
            techniques that a single developer can do, to more complicated
            ones that require additional expertise to perform and interpret
            the results.
        </p><p style="color:blue;">本节将从单个开发人员可以完成的简单和直接的度量技术，发展到需要额外专业知识才能执行和解释结果的更复杂的度量技术。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="select-benchmarking"></a>8.13.1&nbsp;Measuring the Speed of Expressions and Functions</h3>
                    </div>
                </div>
            </div>
            <p>
                To measure the speed of a specific MySQL expression or function,
                invoke the <a class="link" href="functions.html#function_benchmark"><code class="literal">BENCHMARK()</code></a> function
                using the <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client program. Its syntax is
                <a class="link" href="functions.html#function_benchmark"><code class="literal">BENCHMARK(<em class="replaceable"><code>loop_count</code></em>,<em class="replaceable"><code>expr</code></em>)</code></a>.
                The return value is always zero, but <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a>
                prints a line displaying approximately how long the statement
                took to execute. For example:
            </p><p style="color:blue;">要测量特定mysql表达式或函数的速度，请使用mysql客户端程序调用benchmark（）函数。它的语法是benchmark（loop_count，expr）。返回值总是为零，但MySQL打印一行，显示语句执行所需的时间。例如：</p><p></p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT BENCHMARK(1000000,1+1);</code></strong>
+------------------------+
| BENCHMARK(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</pre><p>
            This result was obtained on a Pentium II 400MHz system. It shows
            that MySQL can execute 1,000,000 simple addition expressions in
            0.32 seconds on that system.
        </p><p style="color:blue;">这一结果是在奔腾II 400MHz系统上获得的。它表明mysql可以在0.32秒内在该系统上执行1000000个简单的加法表达式。</p><p></p><p>
            The built-in MySQL functions are typically highly optimized, but
            there may be some exceptions.
            <a class="link" href="functions.html#function_benchmark"><code class="literal">BENCHMARK()</code></a> is an excellent tool
            for finding out if some function is a problem for your queries.
        </p><p style="color:blue;">内置的mysql函数通常是高度优化的，但也可能有一些例外。benchmark（）是一个很好的工具，它可以帮助您判断某个函数是否是查询的问题。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="custom-benchmarks"></a>8.13.2&nbsp;Using Your Own Benchmarks</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286868703232"></a><a class="indexterm" name="idm140286868702192"></a><p>
            Benchmark your application and database to find out where the
            bottlenecks are. After fixing one bottleneck (or by replacing it
            with a <span class="quote">“<span class="quote">dummy</span>”</span> module), you can proceed to identify
            the next bottleneck. Even if the overall performance for your
            application currently is acceptable, you should at least make a
            plan for each bottleneck and decide how to solve it if someday
            you really need the extra performance.
        </p><p style="color:blue;">对应用程序和数据库进行基准测试，找出瓶颈所在。在修复了一个瓶颈（或者用一个“虚拟”模块替换它）之后，您可以继续识别下一个瓶颈。即使您的应用程序的总体性能目前是可以接受的，您至少应该为每个瓶颈制定一个计划，并决定如何解决它，如果有一天您真的需要额外的性能。</p><p></p><p>
            A free benchmark suite is the Open Source Database Benchmark,
            available at <a class="ulink" href="http://osdb.sourceforge.net/" target="_top">http://osdb.sourceforge.net/</a>.
        </p><p style="color:blue;">免费的基准测试套件是开源数据库基准测试，可在http://osdb.sourceforge.net/上获得。</p><p></p><p>
            It is very common for a problem to occur only when the system is
            very heavily loaded. We have had many customers who contact us
            when they have a (tested) system in production and have
            encountered load problems. In most cases, performance problems
            turn out to be due to issues of basic database design (for
            example, table scans are not good under high load) or problems
            with the operating system or libraries. Most of the time, these
            problems would be much easier to fix if the systems were not
            already in production.
        </p><p style="color:blue;">只有当系统负载很重时才会出现问题，这是很常见的。我们有很多客户在生产中有一个（经过测试的）系统并遇到负载问题时与我们联系。在大多数情况下，性能问题是由于基本数据库设计问题（例如，在高负载下表扫描不好）或操作系统或库的问题造成的。大多数情况下，如果系统还没有投入生产，这些问题将更容易解决。</p><p></p><p>
            To avoid problems like this, benchmark your whole application
            under the worst possible load:
        </p><p style="color:blue;">为了避免此类问题，请在最坏的负载下对整个应用程序进行基准测试：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    The <a class="link" href="programs.html#mysqlslap" title="4.5.8&nbsp;mysqlslap — Load Emulation Client"><span class="command"><strong>mysqlslap</strong></span></a> program can be helpful for
                    simulating a high load produced by multiple clients issuing
                    queries simultaneously. See <a class="xref" href="programs.html#mysqlslap" title="4.5.8&nbsp;mysqlslap — Load Emulation Client">Section&nbsp;4.5.8, “<span class="command"><strong>mysqlslap</strong></span> — Load Emulation Client”</a>.
                </p><p style="color:blue;">mysqlslap程序有助于模拟多个客户机同时发出查询所产生的高负载。参见第4.5.8节“mysqlslap-加载仿真客户端”。</p><p></p></li><li class="listitem"><p>
                    You can also try benchmarking packages such as SysBench and
                    DBT2, available at
                    <a class="ulink" href="https://launchpad.net/sysbench" target="_top">https://launchpad.net/sysbench</a>, and
                    <a class="ulink" href="http://osdldbt.sourceforge.net/#dbt2" target="_top">http://osdldbt.sourceforge.net/#dbt2</a>.
                </p><p style="color:blue;">您还可以尝试基准测试包，如sysbench和dbt2，可在https://launchpad.net/sysbench和http://osdldbt.sourceforge.net/dbt2上找到。</p><p></p></li></ul>
            </div>
            <p>
                These programs or packages can bring a system to its knees, so
                be sure to use them only on your development systems.
            </p><p style="color:blue;">这些程序或包会使系统崩溃，因此请确保仅在开发系统上使用它们。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="monitoring-performance-schema"></a>8.13.3&nbsp;Measuring Performance with performance_schema</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286868689632"></a><p>
            You can query the tables in the
            <code class="literal">performance_schema</code> database to see real-time
            information about the performance characteristics of your server
            and the applications it is running. See
            <a class="xref" href="performance-schema.html" title="Chapter&nbsp;25&nbsp;MySQL Performance Schema">Chapter&nbsp;25, <i>MySQL Performance Schema</i></a> for details.
        </p><p style="color:blue;">您可以查询performance_schema数据库中的表，以查看有关服务器及其运行的应用程序的性能特征的实时信息。详见第25章mysql性能模式。</p><p></p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="thread-information"></a>8.14&nbsp;Examining Thread Information</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="optimization.html#thread-commands">8.14.1 Thread Command Values</a></span></dt><dt><span class="section"><a href="optimization.html#general-thread-states">8.14.2 General Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-thread-states">8.14.3 Query Cache Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#master-thread-states">8.14.4 Replication Master Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#slave-io-thread-states">8.14.5 Replication Slave I/O Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#slave-sql-thread-states">8.14.6 Replication Slave SQL Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#slave-connection-thread-states">8.14.7 Replication Slave Connection Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-cluster-thread-states">8.14.8 NDB Cluster Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#event-scheduler-thread-states">8.14.9 Event Scheduler Thread States</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286868684752"></a><a class="indexterm" name="idm140286868683296"></a><a class="indexterm" name="idm140286868681808"></a><p>
        When you are attempting to ascertain what your MySQL server is
        doing, it can be helpful to examine the process list, which is the
        set of threads currently executing within the server. Process list
        information is available from these sources:
    </p><p style="color:blue;">当您试图确定mysql服务器正在做什么时，检查进程列表会很有帮助，它是服务器中当前正在执行的线程集。过程列表信息可从以下来源获得：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                The <code class="literal">SHOW [FULL] PROCESSLIST</code> statement:
                <a class="xref" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax">Section&nbsp;13.7.5.29, “SHOW PROCESSLIST Syntax”</a>
            </p><p style="color:blue;">show[full]processlist语句：第13.7.5.29节，“show processlist syntax”</p><p></p></li><li class="listitem"><p>
                The <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a> statement:
                <a class="xref" href="sql-syntax.html#show-profiles" title="13.7.5.31&nbsp;SHOW PROFILES Syntax">Section&nbsp;13.7.5.31, “SHOW PROFILES Syntax”</a>
            </p><p style="color:blue;">show profile语句：第13.7.5.31节，“show profiles syntax”</p><p></p></li><li class="listitem"><p>
                The <code class="literal">INFORMATION_SCHEMA</code>
                <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">PROCESSLIST</code></a> table:
                <a class="xref" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table">Section&nbsp;24.18, “The INFORMATION_SCHEMA PROCESSLIST Table”</a>
            </p><p style="color:blue;">information_schema processlist表：第24.18节“information_schema processlist表”</p><p></p></li><li class="listitem"><p>
                The <a class="link" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server"><span class="command"><strong>mysqladmin processlist</strong></span></a> command:
                <a class="xref" href="programs.html#mysqladmin" title="4.5.2&nbsp;mysqladmin — Client for Administering a MySQL Server">Section&nbsp;4.5.2, “<span class="command"><strong>mysqladmin</strong></span> — Client for Administering a MySQL Server”</a>
            </p><p style="color:blue;">mysqladmin processlist命令：第4.5.2节，“mysqladmin-用于管理mysql服务器的客户端”</p><p></p></li><li class="listitem"><p>
                The Performance Schema <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a>
                table, stage tables, and lock tables:
                <a class="xref" href="performance-schema.html#performance-schema-miscellaneous-tables" title="25.12.16&nbsp;Performance Schema Miscellaneous Tables">Section&nbsp;25.12.16, “Performance Schema Miscellaneous Tables”</a>,
                <a class="xref" href="performance-schema.html#performance-schema-stage-tables" title="25.12.5&nbsp;Performance Schema Stage Event Tables">Section&nbsp;25.12.5, “Performance Schema Stage Event Tables”</a>,
                <a class="xref" href="performance-schema.html#performance-schema-lock-tables" title="25.12.12&nbsp;Performance Schema Lock Tables">Section&nbsp;25.12.12, “Performance Schema Lock Tables”</a>.
            </p><p style="color:blue;">性能模式线程表、阶段表和锁表：第25.12.16节，“性能模式杂项表”，第25.12.5节，“性能模式阶段事件表”，第25.12.12节，“性能模式锁表”。</p><p></p></li><li class="listitem"><p>
                The <code class="literal">sys</code> schema
                <a class="link" href="sys-schema.html#sys-processlist" title="26.4.3.22&nbsp;The processlist and x$processlist Views"><code class="literal">processlist</code></a> view, which presents
                information from the Performance Schema
                <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> table in a more
                accessible format: <a class="xref" href="sys-schema.html#sys-processlist" title="26.4.3.22&nbsp;The processlist and x$processlist Views">Section&nbsp;26.4.3.22, “The processlist and x$processlist Views”</a>
            </p><p style="color:blue;">sys schema processlist视图，它以更易访问的格式显示来自performance schema threads表的信息：第26.4.3.22节，“processlist和x$processlist视图”</p><p></p></li><li class="listitem"><p>
                The <code class="literal">sys</code> schema
                <a class="link" href="sys-schema.html#sys-session" title="26.4.3.33&nbsp;The session and x$session Views"><code class="literal">session</code></a> view, which presents
                information about user sessions (like the
                <code class="literal">sys</code> schema
                <a class="link" href="sys-schema.html#sys-processlist" title="26.4.3.22&nbsp;The processlist and x$processlist Views"><code class="literal">processlist</code></a> view, but with
                background processes filtered out):
                <a class="xref" href="sys-schema.html#sys-session" title="26.4.3.33&nbsp;The session and x$session Views">Section&nbsp;26.4.3.33, “The session and x$session Views”</a>
            </p><p style="color:blue;">sys schema session视图，它显示有关用户会话的信息（类似于sys schema processlist视图，但是过滤掉了后台进程）：第26.4.3.33节，“会话和x$session视图”</p><p></p></li></ul>
        </div>
        <p>
            Access to <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> does not require a
            mutex and has minimal impact on server performance.
            <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code></a> and
            <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> have negative
            performance consequences because they require a mutex.
            <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> also shows information about
            background threads, which
            <a class="link" href="information-schema.html#processlist-table" title="24.18&nbsp;The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code></a> and
            <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW PROCESSLIST</code></a> do not. This means
            that <a class="link" href="performance-schema.html#threads-table" title="25.12.16.3&nbsp;The threads Table"><code class="literal">threads</code></a> can be used to monitor
            activity the other thread information sources cannot.
        </p><p style="color:blue;">对线程的访问不需要互斥锁，对服务器性能的影响最小。information_schema.processlist和show processlist由于需要互斥锁而导致性能下降。threads还显示有关后台线程的信息，schema.processlist和show processlist不显示这些信息。这意味着线程可以用来监视其他线程信息源不能监视的活动。</p><p></p><p>
        You can always view information about your own threads. To view
        information about threads being executed for other accounts, you
        must have the <a class="link" href="security.html#priv_process"><code class="literal">PROCESS</code></a> privilege.
    </p><p style="color:blue;">您始终可以查看有关自己线程的信息。若要查看有关为其他帐户执行的线程的信息，必须具有“进程”权限。</p><p></p><p>
        Each process list entry contains several pieces of information:
    </p><p style="color:blue;">每个流程列表条目包含若干信息：</p><p></p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">Id</code> is the connection identifier for the
                client associated with the thread.
            </p><p style="color:blue;">id是与线程关联的客户端的连接标识符。</p><p></p></li><li class="listitem"><p>
                <code class="literal">User</code> and <code class="literal">Host</code> indicate
                the account associated with the thread.
            </p><p style="color:blue;">用户和主机指示与线程关联的帐户。</p><p></p></li><li class="listitem"><p>
                <code class="literal">db</code> is the default database for the thread,
                or <code class="literal">NULL</code> if none is selected.
            </p><p style="color:blue;">db是线程的默认数据库，如果未选择任何数据库，则为空。</p><p></p></li><li class="listitem"><p>
                <code class="literal">Command</code> and <code class="literal">State</code>
                indicate what the thread is doing.
            </p><p style="color:blue;">命令和状态指示线程正在执行的操作。</p><p></p><p>
                Most states correspond to very quick operations. If a thread
                stays in a given state for many seconds, there might be a
                problem that needs to be investigated.
            </p><p style="color:blue;">大多数状态对应于非常快速的操作。如果一个线程在一个给定的状态下停留了很多秒，可能有一个问题需要调查。</p><p></p></li><li class="listitem"><p>
                <code class="literal">Time</code> indicates how long the thread has been
                in its current state. The thread's notion of the current time
                may be altered in some cases: The thread can change the time
                with <a class="link" href="sql-syntax.html#set-variable" title="13.7.4.1&nbsp;SET Syntax for Variable Assignment"><code class="literal">SET
                TIMESTAMP = <em class="replaceable"><code>value</code></em></code></a>. For a
                thread running on a slave that is processing events from the
                master, the thread time is set to the time found in the events
                and thus reflects current time on the master and not the
                slave.
            </p><p style="color:blue;">时间指示线程处于当前状态的时间。在某些情况下，线程对当前时间的概念可能会改变：线程可以使用set timestamp=value更改时间。对于在从机上运行的、正在从机上处理事件的线程，线程时间设置为在事件中找到的时间，从而反映主机上而不是从机上的当前时间。</p><p></p></li><li class="listitem"><p>
                <code class="literal">Info</code> contains the text of the statement
                being executed by the thread, or <code class="literal">NULL</code> if it
                is not executing one. By default, this value contains only the
                first 100 characters of the statement. To see the complete
                statements, use
                <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW FULL
                    PROCESSLIST</code></a>.
            </p><p style="color:blue;">INFO包含线程正在执行的语句的文本，如果不执行，则为空。默认情况下，此值仅包含语句的前100个字符。要查看完整的语句，请使用show full processlist。</p><p></p></li></ul>
        </div>
        <p>
            The following sections list the possible
            <code class="literal">Command</code> values, and <code class="literal">State</code>
            values grouped by category. The meaning for some of these values
            is self-evident. For others, additional description is provided.
        </p><p style="color:blue;">以下部分列出了可能的命令值和按类别分组的状态值。其中一些价值观的意义不言而喻。对于其他人，提供了附加说明。</p><p></p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="thread-commands"></a>8.14.1&nbsp;Thread Command Values</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286868622608"></a><p>
            A thread can have any of the following
            <code class="literal">Command</code> values:
        </p><p style="color:blue;">线程可以具有以下任何命令值：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868619584"></a>

                    <a class="indexterm" name="idm140286868618096"></a>

                    <code class="literal">Binlog Dump</code>
                </p><p style="color:blue;">binlog转储</p><p></p><p>
                    This is a thread on a master server for sending binary log
                    contents to a slave server.
                </p><p style="color:blue;">这是主服务器上用于向从服务器发送二进制日志内容的线程。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868614624"></a>

                    <a class="indexterm" name="idm140286868613136"></a>

                    <code class="literal">Change user</code>
                </p><p style="color:blue;">更改用户</p><p></p><p>
                    The thread is executing a change-user operation.
                </p><p style="color:blue;">线程正在执行更改用户操作。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868609712"></a>

                    <a class="indexterm" name="idm140286868608224"></a>

                    <code class="literal">Close stmt</code>
                </p><p style="color:blue;">关闭stmt</p><p></p><p>
                    The thread is closing a prepared statement.
                </p><p style="color:blue;">线程正在关闭准备好的语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868604816"></a>

                    <a class="indexterm" name="idm140286868603328"></a>

                    <code class="literal">Connect</code>
                </p><p style="color:blue;">连接</p><p></p><p>
                    A replication slave is connected to its master.
                </p><p style="color:blue;">复制从设备连接到其主设备。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868599920"></a>

                    <a class="indexterm" name="idm140286868598432"></a>

                    <code class="literal">Connect Out</code>
                </p><p style="color:blue;">接出</p><p></p><p>
                    A replication slave is connecting to its master.
                </p><p style="color:blue;">复制从设备正在连接到其主设备。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868595008"></a>

                    <a class="indexterm" name="idm140286868593520"></a>

                    <code class="literal">Create DB</code>
                </p><p style="color:blue;">创建数据库</p><p></p><p>
                    The thread is executing a create-database operation.
                </p><p style="color:blue;">线程正在执行创建数据库操作。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868590096"></a>

                    <a class="indexterm" name="idm140286868588608"></a>

                    <code class="literal">Daemon</code>
                </p><p style="color:blue;">守护进程</p><p></p><p>
                    This thread is internal to the server, not a thread that
                    services a client connection.
                </p><p style="color:blue;">此线程是服务器的内部线程，而不是为客户端连接提供服务的线程。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868585136"></a>

                    <a class="indexterm" name="idm140286868583648"></a>

                    <code class="literal">Debug</code>
                </p><p style="color:blue;">调试</p><p></p><p>
                    The thread is generating debugging information.
                </p><p style="color:blue;">线程正在生成调试信息。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868580240"></a>

                    <a class="indexterm" name="idm140286868578752"></a>

                    <code class="literal">Delayed insert</code>
                </p><p style="color:blue;">延迟插入</p><p></p><p>
                    The thread is a delayed-insert handler.
                </p><p style="color:blue;">线程是延迟插入处理程序。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868575344"></a>

                    <a class="indexterm" name="idm140286868573856"></a>

                    <code class="literal">Drop DB</code>
                </p><p style="color:blue;">下降分贝</p><p></p><p>
                    The thread is executing a drop-database operation.
                </p><p style="color:blue;">线程正在执行删除数据库操作。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868570432"></a>

                    <a class="indexterm" name="idm140286868568944"></a>

                    <code class="literal">Error</code>
                </p><p style="color:blue;">错误</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868566000"></a>

                    <a class="indexterm" name="idm140286868564512"></a>

                    <code class="literal">Execute</code>
                </p><p style="color:blue;">执行</p><p></p><p>
                    The thread is executing a prepared statement.
                </p><p style="color:blue;">线程正在执行准备好的语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868561104"></a>

                    <a class="indexterm" name="idm140286868559616"></a>

                    <code class="literal">Fetch</code>
                </p><p style="color:blue;">取回</p><p></p><p>
                    The thread is fetching the results from executing a prepared
                    statement.
                </p><p style="color:blue;">线程正在从执行准备好的语句中获取结果。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868556160"></a>

                    <a class="indexterm" name="idm140286868554672"></a>

                    <code class="literal">Field List</code>
                </p><p style="color:blue;">字段列表</p><p></p><p>
                    The thread is retrieving information for table columns.
                </p><p style="color:blue;">线程正在检索表列的信息。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868551248"></a>

                    <a class="indexterm" name="idm140286868549760"></a>

                    <code class="literal">Init DB</code>
                </p><p style="color:blue;">初始数据库</p><p></p><p>
                    The thread is selecting a default database.
                </p><p style="color:blue;">线程正在选择默认数据库。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868546352"></a>

                    <a class="indexterm" name="idm140286868544864"></a>

                    <code class="literal">Kill</code>
                </p><p style="color:blue;">杀戮</p><p></p><p>
                    The thread is killing another thread.
                </p><p style="color:blue;">这条线正在杀死另一条线。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868541456"></a>

                    <a class="indexterm" name="idm140286868539968"></a>

                    <code class="literal">Long Data</code>
                </p><p style="color:blue;">长数据</p><p></p><p>
                    The thread is retrieving long data in the result of
                    executing a prepared statement.
                </p><p style="color:blue;">线程在执行准备好的语句的结果中检索长数据。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868536512"></a>

                    <a class="indexterm" name="idm140286868535024"></a>

                    <code class="literal">Ping</code>
                </p><p style="color:blue;">发出砰的声响</p><p></p><p>
                    The thread is handling a server-ping request.
                </p><p style="color:blue;">线程正在处理服务器ping请求。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868531616"></a>

                    <a class="indexterm" name="idm140286868530128"></a>

                    <code class="literal">Prepare</code>
                </p><p style="color:blue;">准备</p><p></p><p>
                    The thread is preparing a prepared statement.
                </p><p style="color:blue;">线程正在准备一个准备好的语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868526720"></a>

                    <a class="indexterm" name="idm140286868525232"></a>

                    <code class="literal">Processlist</code>
                </p><p style="color:blue;">进程列表</p><p></p><p>
                    The thread is producing information about server threads.
                </p><p style="color:blue;">线程正在生成有关服务器线程的信息。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868521808"></a>

                    <a class="indexterm" name="idm140286868520320"></a>

                    <code class="literal">Query</code>
                </p><p style="color:blue;">查询</p><p></p><p>
                    The thread is executing a statement.
                </p><p style="color:blue;">线程正在执行语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868516912"></a>

                    <a class="indexterm" name="idm140286868515424"></a>

                    <code class="literal">Quit</code>
                </p><p style="color:blue;">退出</p><p></p><p>
                    The thread is terminating.
                </p><p style="color:blue;">线程正在终止。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868512032"></a>

                    <a class="indexterm" name="idm140286868510544"></a>

                    <code class="literal">Refresh</code>
                </p><p style="color:blue;">刷新</p><p></p><p>
                    The thread is flushing table, logs, or caches, or resetting
                    status variable or replication server information.
                </p><p style="color:blue;">线程正在刷新表、日志或缓存，或者正在重置状态变量或复制服务器信息。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868507056"></a>

                    <a class="indexterm" name="idm140286868505568"></a>

                    <code class="literal">Register Slave</code>
                </p><p style="color:blue;">寄存器从机</p><p></p><p>
                    The thread is registering a slave server.
                </p><p style="color:blue;">线程正在注册从属服务器。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868502160"></a>

                    <a class="indexterm" name="idm140286868500672"></a>

                    <code class="literal">Reset stmt</code>
                </p><p style="color:blue;">重置stmt</p><p></p><p>
                    The thread is resetting a prepared statement.
                </p><p style="color:blue;">线程正在重置准备好的语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868497264"></a>

                    <a class="indexterm" name="idm140286868495776"></a>

                    <code class="literal">Set option</code>
                </p><p style="color:blue;">设置选项</p><p></p><p>
                    The thread is setting or resetting a client
                    statement-execution option.
                </p><p style="color:blue;">线程正在设置或重置客户端语句执行选项。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868492320"></a>

                    <a class="indexterm" name="idm140286868490832"></a>

                    <code class="literal">Shutdown</code>
                </p><p style="color:blue;">关闭</p><p></p><p>
                    The thread is shutting down the server.
                </p><p style="color:blue;">线程正在关闭服务器。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868487424"></a>

                    <a class="indexterm" name="idm140286868485936"></a>

                    <code class="literal">Sleep</code>
                </p><p style="color:blue;">睡觉</p><p></p><p>
                    The thread is waiting for the client to send a new statement
                    to it.
                </p><p style="color:blue;">线程正在等待客户端向其发送新语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868482496"></a>

                    <a class="indexterm" name="idm140286868481008"></a>

                    <code class="literal">Statistics</code>
                </p><p style="color:blue;">统计</p><p></p><p>
                    The thread is producing server-status information.
                </p><p style="color:blue;">线程正在生成服务器状态信息。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868477584"></a>

                    <a class="indexterm" name="idm140286868476096"></a>

                    <code class="literal">Table Dump</code>
                </p><p style="color:blue;">表转储</p><p></p><p>
                    The thread is sending table contents to a slave server.
                </p><p style="color:blue;">线程正在将表内容发送到从属服务器。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868472672"></a>

                    <a class="indexterm" name="idm140286868471184"></a>

                    <code class="literal">Time</code>
                </p><p style="color:blue;">时间</p><p></p><p>
                    Unused.
                </p><p style="color:blue;">未使用。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="general-thread-states"></a>8.14.2&nbsp;General Thread States</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286868466976"></a><p>
            The following list describes thread <code class="literal">State</code>
            values that are associated with general query processing and not
            more specialized activities such as replication. Many of these
            are useful only for finding bugs in the server.
        </p><p style="color:blue;">下表描述了与常规查询处理相关联的线程状态值，而不是与复制等更专门的活动相关联的线程状态值。其中许多只对查找服务器中的错误有用。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868463360"></a>

                    <a class="indexterm" name="idm140286868461872"></a>

                    <code class="literal">After create</code>
                </p><p style="color:blue;">创建后</p><p></p><p>
                    This occurs when the thread creates a table (including
                    internal temporary tables), at the end of the function that
                    creates the table. This state is used even if the table
                    could not be created due to some error.
                </p><p style="color:blue;">当线程在创建表的函数末尾创建表（包括内部临时表）时，会发生这种情况。即使由于某些错误而无法创建表，也会使用此状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868458256"></a>

                    <a class="indexterm" name="idm140286868456768"></a>

                    <code class="literal">Analyzing</code>
                </p><p style="color:blue;">分析</p><p></p><p>
                    The thread is calculating a <code class="literal">MyISAM</code> table
                    key distributions (for example, for
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>).
                </p><p style="color:blue;">线程正在计算myisam表键分布（例如，对于analyze表）。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868451376"></a>

                    <a class="indexterm" name="idm140286868449888"></a>

                    <code class="literal">checking permissions</code>
                </p><p style="color:blue;">检查权限</p><p></p><p>
                    The thread is checking whether the server has the required
                    privileges to execute the statement.
                </p><p style="color:blue;">线程正在检查服务器是否具有执行该语句所需的权限。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868446416"></a>

                    <a class="indexterm" name="idm140286868444928"></a>

                    <code class="literal">Checking table</code>
                </p><p style="color:blue;">检查表</p><p></p><p>
                    The thread is performing a table check operation.
                </p><p style="color:blue;">线程正在执行表检查操作。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868441504"></a>

                    <a class="indexterm" name="idm140286868440016"></a>

                    <code class="literal">cleaning up</code>
                </p><p style="color:blue;">清理</p><p></p><p>
                    The thread has processed one command and is preparing to
                    free memory and reset certain state variables.
                </p><p style="color:blue;">线程已处理一个命令，正在准备释放内存并重置某些状态变量。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868436528"></a>

                    <a class="indexterm" name="idm140286868435040"></a>

                    <code class="literal">closing tables</code>
                </p><p style="color:blue;">结束表格</p><p></p><p>
                    The thread is flushing the changed table data to disk and
                    closing the used tables. This should be a fast operation. If
                    not, verify that you do not have a full disk and that the
                    disk is not in very heavy use.
                </p><p style="color:blue;">线程正在将已更改的表数据刷新到磁盘并关闭已使用的表。这应该是一个快速的行动。如果没有，请验证磁盘是否已满，以及磁盘是否未被大量使用。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868431424"></a>

                    <a class="indexterm" name="idm140286868429920"></a>

                    <code class="literal">converting HEAP to ondisk</code>
                </p><p style="color:blue;">将堆转换为ondisk</p><p></p><p>
                    The thread is converting an internal temporary table from a
                    <code class="literal">MEMORY</code> table to an on-disk table.
                </p><p style="color:blue;">线程正在将内部临时表从内存表转换为磁盘表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868425728"></a>

                    <a class="indexterm" name="idm140286868424240"></a>

                    <code class="literal">copy to tmp table</code>
                </p><p style="color:blue;">复制到tmp表</p><p></p><p>
                    The thread is processing an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> statement. This state occurs after the table
                    with the new structure has been created but before rows are
                    copied into it.
                </p><p style="color:blue;">线程正在处理alter table语句。此状态在创建具有新结构的表之后，但在将行复制到表中之前发生。</p><p></p><p>
                    For a thread in this state, the Performance Schema can be
                    used to obtain about the progress of the copy operation. See
                    <a class="xref" href="performance-schema.html#performance-schema-stage-tables" title="25.12.5&nbsp;Performance Schema Stage Event Tables">Section&nbsp;25.12.5, “Performance Schema Stage Event Tables”</a>.
                </p><p style="color:blue;">对于处于此状态的线程，可以使用性能架构获取有关复制操作进度的信息。见第25.12.5节“性能模式阶段事件表”。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868418160"></a>

                    <a class="indexterm" name="idm140286868416672"></a>

                    <code class="literal">Copying to group table</code>
                </p><p style="color:blue;">复制到组表</p><p></p><p>
                    If a statement has different <code class="literal">ORDER BY</code> and
                    <code class="literal">GROUP BY</code> criteria, the rows are sorted by
                    group and copied to a temporary table.
                </p><p style="color:blue;">如果语句具有不同的ORDERBY和GROUPBY条件，则行将按组排序并复制到临时表中。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868411760"></a>

                    <a class="indexterm" name="idm140286868410272"></a>

                    <code class="literal">Copying to tmp table</code>
                </p><p style="color:blue;">解决一例</p><p></p><p>
                    The server is copying to a temporary table in memory.
                </p><p style="color:blue;">服务器正在复制到内存中的临时表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868406848"></a>

                    <a class="indexterm" name="idm140286868405360"></a>

                    <code class="literal">altering table</code>
                </p><p style="color:blue;">变更表</p><p></p><p>
                    The server is in the process of executing an in-place
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>.
                </p><p style="color:blue;">服务器正在执行就地alter表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868400752"></a>

                    <a class="indexterm" name="idm140286868399248"></a>

                    <code class="literal">Copying to tmp table on disk</code>
                </p><p style="color:blue;">正在复制到磁盘上的tmp表</p><p></p><p>
                    The server is copying to a temporary table on disk. The
                    temporary result set has become too large (see
                    <a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4&nbsp;Internal Temporary Table Use in MySQL">Section&nbsp;8.4.4, “Internal Temporary Table Use in MySQL”</a>). Consequently,
                    the thread is changing the temporary table from in-memory to
                    disk-based format to save memory.
                </p><p style="color:blue;">服务器正在复制到磁盘上的临时表。临时结果集变得太大（请参阅8.4.4节，“MySQL中的内部临时表使用”）。因此，线程正在将临时表从内存格式更改为基于磁盘的格式以节省内存。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868394848"></a>

                    <a class="indexterm" name="idm140286868393360"></a>

                    <code class="literal">Creating index</code>
                </p><p style="color:blue;">创建索引</p><p></p><p>
                    The thread is processing <code class="literal">ALTER TABLE ... ENABLE
                    KEYS</code> for a <code class="literal">MyISAM</code> table.
                </p><p style="color:blue;">线程正在处理alter table…为myisam表启用键。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868388576"></a>

                    <a class="indexterm" name="idm140286868387088"></a>

                    <code class="literal">Creating sort index</code>
                </p><p style="color:blue;">创建排序索引</p><p></p><p>
                    The thread is processing a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> that is resolved using
                    an internal temporary table.
                </p><p style="color:blue;">线程正在处理使用内部临时表解析的选择。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868382400"></a>

                    <a class="indexterm" name="idm140286868380912"></a>

                    <code class="literal">creating table</code>
                </p><p style="color:blue;">创建表</p><p></p><p>
                    The thread is creating a table. This includes creation of
                    temporary tables.
                </p><p style="color:blue;">线程正在创建表。这包括创建临时表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868377456"></a>

                    <a class="indexterm" name="idm140286868375968"></a>

                    <code class="literal">Creating tmp table</code>
                </p><p style="color:blue;">创建tmp表</p><p></p><p>
                    The thread is creating a temporary table in memory or on
                    disk. If the table is created in memory but later is
                    converted to an on-disk table, the state during that
                    operation will be <code class="literal">Copying to tmp table on
                    disk</code>.
                </p><p style="color:blue;">线程正在内存或磁盘上创建临时表。如果表是在内存中创建的，但后来被转换为磁盘上的表，则该操作期间的状态将复制到磁盘上的tmp表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868371648"></a>

                    <a class="indexterm" name="idm140286868370128"></a>

                    <code class="literal">committing alter table to storage engine</code>
                </p><p style="color:blue;">将alter table提交到存储引擎</p><p></p><p>
                    The server has finished an in-place
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> and is committing
                    the result.
                </p><p style="color:blue;">服务器已完成就地alter表并正在提交结果。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868365392"></a>

                    <a class="indexterm" name="idm140286868363888"></a>

                    <code class="literal">deleting from main table</code>
                </p><p style="color:blue;">从主表中删除</p><p></p><p>
                    The server is executing the first part of a multiple-table
                    delete. It is deleting only from the first table, and saving
                    columns and offsets to be used for deleting from the other
                    (reference) tables.
                </p><p style="color:blue;">服务器正在执行多表删除的第一部分。它只从第一个表中删除，并保存用于从其他（引用）表中删除的列和偏移量。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868360256"></a>

                    <a class="indexterm" name="idm140286868358752"></a>

                    <code class="literal">deleting from reference tables</code>
                </p><p style="color:blue;">从引用表中删除</p><p></p><p>
                    The server is executing the second part of a multiple-table
                    delete and deleting the matched rows from the other tables.
                </p><p style="color:blue;">服务器正在执行多表删除的第二部分，并从其他表中删除匹配的行。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868355216"></a>

                    <a class="indexterm" name="idm140286868353712"></a>

                    <code class="literal">discard_or_import_tablespace</code>
                </p><p style="color:blue;">放弃或导入表空间</p><p></p><p>
                    The thread is processing an <code class="literal">ALTER TABLE ... DISCARD
                    TABLESPACE</code> or <code class="literal">ALTER TABLE ... IMPORT
                    TABLESPACE</code> statement.
                </p><p style="color:blue;">线程正在处理一个alter表…放弃表空间或更改表…导入表空间语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868348784"></a>

                    <a class="indexterm" name="idm140286868347328"></a>

                    <code class="literal">end</code>
                </p><p style="color:blue;">结束</p><p></p><p>
                    This occurs at the end but before the cleanup of
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#create-view" title="13.1.21&nbsp;CREATE VIEW Syntax"><code class="literal">CREATE VIEW</code></a>,
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, or
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements.
                </p><p style="color:blue;">这发生在alter table、create view、delete、insert、select或update语句的末尾，但在清除之前。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868336576"></a>

                    <a class="indexterm" name="idm140286868335088"></a>

                    <code class="literal">executing</code>
                </p><p style="color:blue;">执行</p><p></p><p>
                    The thread has begun executing a statement.
                </p><p style="color:blue;">线程已开始执行语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868331680"></a>

                    <a class="indexterm" name="idm140286868330176"></a>

                    <code class="literal">Execution of init_command</code>
                </p><p style="color:blue;">执行init_命令</p><p></p><p>
                    The thread is executing statements in the value of the
                    <code class="literal">init_command</code> system variable.
                </p><p style="color:blue;">线程正在执行init_命令系统变量值中的语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868325984"></a>

                    <a class="indexterm" name="idm140286868324496"></a>

                    <code class="literal">freeing items</code>
                </p><p style="color:blue;">释放项目</p><p></p><p>
                    The thread has executed a command. Some freeing of items
                    done during this state involves the query cache. This state
                    is usually followed by <code class="literal">cleaning up</code>.
                </p><p style="color:blue;">线程已执行命令。在此状态期间完成的某些项目释放涉及查询缓存。这种情况下通常会进行清理。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868320256"></a>

                    <a class="indexterm" name="idm140286868318768"></a>

                    <code class="literal">FULLTEXT initialization</code>
                </p><p style="color:blue;">全文初始化</p><p></p><p>
                    The server is preparing to perform a natural-language
                    full-text search.
                </p><p style="color:blue;">服务器正在准备执行自然语言全文搜索。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868315312"></a>

                    <a class="indexterm" name="idm140286868313824"></a>

                    <code class="literal">init</code>
                </p><p style="color:blue;">初始</p><p></p><p>
                    This occurs before the initialization of
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a>,
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a>,
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>, or
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> statements. Actions
                    taken by the server in this state include flushing the
                    binary log, the <code class="literal">InnoDB</code> log, and some
                    query cache cleanup operations.
                </p><p style="color:blue;">这发生在alter table、delete、insert、select或update语句初始化之前。服务器在此状态下采取的操作包括刷新二进制日志、innodb日志和一些查询缓存清理操作。</p><p></p><p>
                    For the <code class="literal">end</code> state, the following
                    operations could be happening:
                </p><p style="color:blue;">对于结束状态，可能会发生以下操作：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            Removing query cache entries after data in a table is
                            changed
                        </p><p style="color:blue;">更改表中的数据后删除查询缓存项</p><p></p></li><li class="listitem"><p>
                            Writing an event to the binary log
                        </p><p style="color:blue;">将事件写入二进制日志</p><p></p></li><li class="listitem"><p>
                            Freeing memory buffers, including for blobs
                        </p><p style="color:blue;">释放内存缓冲区，包括blob</p><p></p></li></ul>
                    </div>
                </li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868299232"></a>

                    <a class="indexterm" name="idm140286868297744"></a>

                    <code class="literal">Killed</code>
                </p><p style="color:blue;">被杀死的</p><p></p><p>
                    Someone has sent a <a class="link" href="sql-syntax.html#kill" title="13.7.6.4&nbsp;KILL Syntax"><code class="literal">KILL</code></a>
                    statement to the thread and it should abort next time it
                    checks the kill flag. The flag is checked in each major loop
                    in MySQL, but in some cases it might still take a short time
                    for the thread to die. If the thread is locked by some other
                    thread, the kill takes effect as soon as the other thread
                    releases its lock.
                </p><p style="color:blue;">有人已经向线程发送了kill语句，下次它检查kill标志时应该中止。在mysql的每个主循环中都会检查该标志，但在某些情况下，线程可能仍然需要很短的时间才能结束。如果线程被另一个线程锁定，则一旦另一个线程释放其锁，kill就会生效。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868292752"></a>

                    <a class="indexterm" name="idm140286868291264"></a>

                    <code class="literal">logging slow query</code>
                </p><p style="color:blue;">日志记录慢速查询</p><p></p><p>
                    The thread is writing a statement to the slow-query log.
                </p><p style="color:blue;">线程正在将语句写入慢速查询日志。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868287840"></a>

                    <a class="indexterm" name="idm140286868286352"></a>

                    <code class="literal">login</code>
                </p><p style="color:blue;">登录</p><p></p><p>
                    The initial state for a connection thread until the client
                    has been authenticated successfully.
                </p><p style="color:blue;">连接线程的初始状态，直到客户端成功通过身份验证。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868282880"></a>

                    <a class="indexterm" name="idm140286868281392"></a>

                    <code class="literal">manage keys</code>
                </p><p style="color:blue;">管理密钥</p><p></p><p>
                    The server is enabling or disabling a table index.
                </p><p style="color:blue;">服务器正在启用或禁用表索引。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868277968"></a>

                    <a class="indexterm" name="idm140286868276480"></a>

                    <code class="literal">NULL</code>
                </p><p style="color:blue;">无效的</p><p></p><p>
                    This state is used for the <a class="link" href="sql-syntax.html#show-processlist" title="13.7.5.29&nbsp;SHOW PROCESSLIST Syntax"><code class="literal">SHOW
                    PROCESSLIST</code></a> state.
                </p><p style="color:blue;">此状态用于显示进程列表状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868271840"></a>

                    <a class="indexterm" name="idm140286868270352"></a>

                    <code class="literal">Opening tables</code>
                </p><p style="color:blue;">打开表格</p><p></p><p>
                    The thread is trying to open a table. This is should be very
                    fast procedure, unless something prevents opening. For
                    example, an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a> or a
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK
                        TABLE</code></a> statement can prevent opening a table until
                    the statement is finished. It is also worth checking that
                    your <a class="link" href="server-administration.html#sysvar_table_open_cache"><code class="literal">table_open_cache</code></a> value
                    is large enough.
                </p><p style="color:blue;">线程正在试图打开一个表。这应该是非常快的程序，除非有什么东西阻止打开。例如，alter table或lock table语句可以阻止在语句完成之前打开表。还值得检查表打开缓存值是否足够大。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868263008"></a>

                    <a class="indexterm" name="idm140286868261520"></a>

                    <code class="literal">optimizing</code>
                </p><p style="color:blue;">优化</p><p></p><p>
                    The server is performing initial optimizations for a query.
                </p><p style="color:blue;">服务器正在对查询执行初始优化。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868258096"></a>

                    <a class="indexterm" name="idm140286868256608"></a>

                    <code class="literal">preparing</code>
                </p><p style="color:blue;">准备</p><p></p><p>
                    This state occurs during query optimization.
                </p><p style="color:blue;">此状态在查询优化期间发生。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868253200"></a>

                    <a class="indexterm" name="idm140286868251712"></a>

                    <code class="literal">Purging old relay logs</code>
                </p><p style="color:blue;">清除旧中继日志</p><p></p><p>
                    The thread is removing unneeded relay log files.
                </p><p style="color:blue;">线程正在删除不需要的中继日志文件。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868248288"></a>

                    <a class="indexterm" name="idm140286868246800"></a>

                    <code class="literal">query end</code>
                </p><p style="color:blue;">查询结束</p><p></p><p>
                    This state occurs after processing a query but before the
                    <code class="literal">freeing items</code> state.
                </p><p style="color:blue;">此状态发生在处理查询之后，但在释放项状态之前。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868242656"></a>

                    <a class="indexterm" name="idm140286868241168"></a>

                    <code class="literal">Receiving from client</code>
                </p><p style="color:blue;">从客户处接收</p><p></p><p>
                    The server is reading a packet from the client. This state
                    is called <code class="literal">Reading from net</code> prior to MySQL
                    5.7.8.
                </p><p style="color:blue;">服务器正在从客户端读取数据包。这种状态称为从MySQL5.7.8之前的网络读取。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868236976"></a>

                    <a class="indexterm" name="idm140286868235488"></a>

                    <code class="literal">Removing duplicates</code>
                </p><p style="color:blue;">删除重复项</p><p></p><p>
                    The query was using
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT
                        DISTINCT</code></a> in such a way that MySQL could not
                    optimize away the distinct operation at an early stage.
                    Because of this, MySQL requires an extra stage to remove all
                    duplicated rows before sending the result to the client.
                </p><p style="color:blue;">查询使用select distinct的方式使得mysql无法在早期优化distinct操作。因此，在将结果发送到客户端之前，mysql需要一个额外的阶段来删除所有重复的行。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868230608"></a>

                    <a class="indexterm" name="idm140286868229120"></a>

                    <code class="literal">removing tmp table</code>
                </p><p style="color:blue;">删除tmp表</p><p></p><p>
                    The thread is removing an internal temporary table after
                    processing a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a>
                    statement. This state is not used if no temporary table was
                    created.
                </p><p style="color:blue;">线程正在处理select语句后删除内部临时表。如果未创建临时表，则不使用此状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868224352"></a>

                    <a class="indexterm" name="idm140286868222864"></a>

                    <code class="literal">rename</code>
                </p><p style="color:blue;">重命名</p><p></p><p>
                    The thread is renaming a table.
                </p><p style="color:blue;">线程正在重命名表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868219472"></a>

                    <a class="indexterm" name="idm140286868217984"></a>

                    <code class="literal">rename result table</code>
                </p><p style="color:blue;">重命名结果表</p><p></p><p>
                    The thread is processing an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> statement, has created the new table, and is
                    renaming it to replace the original table.
                </p><p style="color:blue;">线程正在处理alter table语句，创建了新表，并正在重命名它以替换原始表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868213264"></a>

                    <a class="indexterm" name="idm140286868211776"></a>

                    <code class="literal">Reopen tables</code>
                </p><p style="color:blue;">重新打开表</p><p></p><p>
                    The thread got a lock for the table, but noticed after
                    getting the lock that the underlying table structure
                    changed. It has freed the lock, closed the table, and is
                    trying to reopen it.
                </p><p style="color:blue;">线程获得了表的锁，但在获得锁后注意到底层表结构已更改。它已经释放了锁，关闭了表，并试图重新打开它。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868208192"></a>

                    <a class="indexterm" name="idm140286868206704"></a>

                    <code class="literal">Repair by sorting</code>
                </p><p style="color:blue;">分类修复</p><p></p><p>
                    The repair code is using a sort to create indexes.
                </p><p style="color:blue;">修复代码正在使用排序创建索引。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868203280"></a>

                    <a class="indexterm" name="idm140286868201776"></a>

                    <code class="literal">preparing for alter table</code>
                </p><p style="color:blue;">准备更改表</p><p></p><p>
                    The server is preparing to execute an in-place
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>.
                </p><p style="color:blue;">服务器正在准备执行就地alter表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868197088"></a>

                    <a class="indexterm" name="idm140286868195600"></a>

                    <code class="literal">Repair done</code>
                </p><p style="color:blue;">修复完成</p><p></p><p>
                    The thread has completed a multithreaded repair for a
                    <code class="literal">MyISAM</code> table.
                </p><p style="color:blue;">线程已完成MyISAM表的多线程修复。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868191456"></a>

                    <a class="indexterm" name="idm140286868189968"></a>

                    <code class="literal">Repair with keycache</code>
                </p><p style="color:blue;">用keycache修复</p><p></p><p>
                    The repair code is using creating keys one by one through
                    the key cache. This is much slower than <code class="literal">Repair by
                    sorting</code>.
                </p><p style="color:blue;">修复代码使用通过密钥缓存逐个创建密钥。这比分类修复要慢得多。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868185760"></a>

                    <a class="indexterm" name="idm140286868184272"></a>

                    <code class="literal">Rolling back</code>
                </p><p style="color:blue;">回退</p><p></p><p>
                    The thread is rolling back a transaction.
                </p><p style="color:blue;">线程正在回滚事务。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868180864"></a>

                    <a class="indexterm" name="idm140286868179376"></a>

                    <code class="literal">Saving state</code>
                </p><p style="color:blue;">保存状态</p><p></p><p>
                    For <code class="literal">MyISAM</code> table operations such as
                    repair or analysis, the thread is saving the new table state
                    to the <code class="filename">.MYI</code> file header. State includes
                    information such as number of rows, the
                    <code class="literal">AUTO_INCREMENT</code> counter, and key
                    distributions.
                </p><p style="color:blue;">对于myisam表操作（如修复或分析），线程正在将新表状态保存到.myi文件头。状态包括行数、自动递增计数器和密钥分布等信息。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868173648"></a>

                    <a class="indexterm" name="idm140286868172144"></a>

                    <code class="literal">Searching rows for update</code>
                </p><p style="color:blue;">正在搜索更新行</p><p></p><p>
                    The thread is doing a first phase to find all matching rows
                    before updating them. This has to be done if the
                    <a class="link" href="sql-syntax.html#update" title="13.2.11&nbsp;UPDATE Syntax"><code class="literal">UPDATE</code></a> is changing the index
                    that is used to find the involved rows.
                </p><p style="color:blue;">线程正在执行第一个阶段，以便在更新所有匹配行之前找到它们。如果更新正在更改用于查找相关行的索引，则必须执行此操作。</p><p></p></li><li class="listitem"><p>
                    <code class="literal">Sending data</code>
                </p><p style="color:blue;">发送数据</p><p></p><p>
                    The thread is reading and processing rows for a
                    <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement, and sending
                    data to the client. Because operations occurring during this
                    state tend to perform large amounts of disk access (reads),
                    it is often the longest-running state over the lifetime of a
                    given query.
                </p><p style="color:blue;">线程正在读取和处理select语句的行，并向客户端发送数据。由于在此状态期间发生的操作倾向于执行大量磁盘访问（读取），因此它通常是给定查询生命周期中运行时间最长的状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868163904"></a>

                    <a class="indexterm" name="idm140286868162416"></a>

                    <code class="literal">Sending to client</code>
                </p><p style="color:blue;">发送到客户端</p><p></p><p>
                    The server is writing a packet to the client. This state is
                    called <code class="literal">Writing to net</code> prior to MySQL
                    5.7.8.
                </p><p style="color:blue;">服务器正在向客户端写入数据包。在mysql 5.7.8之前，这种状态被称为写入网络。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868158224"></a>

                    <a class="indexterm" name="idm140286868156736"></a>

                    <code class="literal">setup</code>
                </p><p style="color:blue;">设置</p><p></p><p>
                    The thread is beginning an <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER
                    TABLE</code></a> operation.
                </p><p style="color:blue;">线程正在开始一个alter table操作。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868152112"></a>

                    <a class="indexterm" name="idm140286868150624"></a>

                    <code class="literal">Sorting for group</code>
                </p><p style="color:blue;">分组排序</p><p></p><p>
                    The thread is doing a sort to satisfy a <code class="literal">GROUP
                    BY</code>.
                </p><p style="color:blue;">线程正在进行排序以满足group by。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868146512"></a>

                    <a class="indexterm" name="idm140286868145024"></a>

                    <code class="literal">Sorting for order</code>
                </p><p style="color:blue;">按顺序排序</p><p></p><p>
                    The thread is doing a sort to satisfy an <code class="literal">ORDER
                    BY</code>.
                </p><p style="color:blue;">线程正在进行排序以满足order by。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868140912"></a>

                    <a class="indexterm" name="idm140286868139424"></a>

                    <code class="literal">Sorting index</code>
                </p><p style="color:blue;">排序索引</p><p></p><p>
                    The thread is sorting index pages for more efficient access
                    during a <code class="literal">MyISAM</code> table optimization
                    operation.
                </p><p style="color:blue;">线程正在排序索引页，以便在myisam表优化操作期间进行更有效的访问。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868135232"></a>

                    <a class="indexterm" name="idm140286868133744"></a>

                    <code class="literal">Sorting result</code>
                </p><p style="color:blue;">排序结果</p><p></p><p>
                    For a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> statement, this
                    is similar to <code class="literal">Creating sort index</code>, but
                    for nontemporary tables.
                </p><p style="color:blue;">对于select语句，这类似于创建排序索引，但对于非临时表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868128368"></a>

                    <a class="indexterm" name="idm140286868126880"></a>

                    <code class="literal">statistics</code>
                </p><p style="color:blue;">统计学</p><p></p><p>
                    The server is calculating statistics to develop a query
                    execution plan. If a thread is in this state for a long
                    time, the server is probably disk-bound performing other
                    work.
                </p><p style="color:blue;">服务器正在计算统计数据以制定查询执行计划。如果一个线程长时间处于这种状态，则服务器可能是磁盘绑定的，正在执行其他工作。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868123296"></a>

                    <a class="indexterm" name="idm140286868122224"></a>

                    <a class="indexterm" name="idm140286868120736"></a>

                    <a class="indexterm" name="idm140286868119248"></a>

                    <code class="literal">System lock</code>
                </p><p style="color:blue;">系统锁定</p><p></p><p>
                    The thread has called <code class="literal">mysql_lock_tables()</code>
                    and the thread state has not been updated since. This is a
                    very general state that can occur for many reasons.
                </p><p style="color:blue;">线程已调用mysql_lock_tables（），此后未更新线程状态。这是一种非常普遍的状态，有很多原因。</p><p></p><p>
                    For example, the thread is going to request or is waiting
                    for an internal or external system lock for the table. This
                    can occur when <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> waits for
                    a table-level lock during execution of
                    <a class="link" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax"><code class="literal">LOCK TABLES</code></a>. If this state is
                    being caused by requests for external locks and you are not
                    using multiple <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> servers that are
                    accessing the same <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a>
                    tables, you can disable external system locks with the
                    <a class="link" href="server-administration.html#option_mysqld_external-locking"><code class="option">--skip-external-locking</code></a>
                    option. However, external locking is disabled by default, so
                    it is likely that this option will have no effect. For
                    <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a>, this state
                    means the thread is requesting the lock (not waiting for
                    it).
                </p><p style="color:blue;">例如，线程将请求或等待表的内部或外部系统锁。当innodb在执行锁表期间等待表级锁时，就会发生这种情况。如果此状态是由外部锁请求引起的，并且您没有使用正在访问同一myisam表的多个mysqld服务器，则可以使用--skip external locking选项禁用外部系统锁。但是，默认情况下会禁用外部锁定，因此此选项很可能没有效果。对于show profile，此状态表示线程正在请求锁（而不是等待锁）。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868106800"></a>

                    <a class="indexterm" name="idm140286868105312"></a>

                    <code class="literal">update</code>
                </p><p style="color:blue;">更新</p><p></p><p>
                    The thread is getting ready to start updating the table.
                </p><p style="color:blue;">线程正在准备开始更新表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868101888"></a>

                    <a class="indexterm" name="idm140286868100400"></a>

                    <code class="literal">Updating</code>
                </p><p style="color:blue;">更新</p><p></p><p>
                    The thread is searching for rows to update and is updating
                    them.
                </p><p style="color:blue;">线程正在搜索要更新的行并正在更新它们。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868096960"></a>

                    <a class="indexterm" name="idm140286868095472"></a>

                    <code class="literal">updating main table</code>
                </p><p style="color:blue;">更新主表</p><p></p><p>
                    The server is executing the first part of a multiple-table
                    update. It is updating only the first table, and saving
                    columns and offsets to be used for updating the other
                    (reference) tables.
                </p><p style="color:blue;">服务器正在执行多表更新的第一部分。它只更新第一个表，并保存用于更新其他（引用）表的列和偏移量。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868091872"></a>

                    <a class="indexterm" name="idm140286868090368"></a>

                    <code class="literal">updating reference tables</code>
                </p><p style="color:blue;">更新引用表</p><p></p><p>
                    The server is executing the second part of a multiple-table
                    update and updating the matched rows from the other tables.
                </p><p style="color:blue;">服务器正在执行多表更新的第二部分，并更新来自其他表的匹配行。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868086832"></a>

                    <a class="indexterm" name="idm140286868085344"></a>

                    <code class="literal">User lock</code>
                </p><p style="color:blue;">用户锁定</p><p></p><p>
                    The thread is going to request or is waiting for an advisory
                    lock requested with a
                    <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a> call. For
                    <a class="link" href="sql-syntax.html#show-profile" title="13.7.5.30&nbsp;SHOW PROFILE Syntax"><code class="literal">SHOW PROFILE</code></a>, this state
                    means the thread is requesting the lock (not waiting for
                    it).
                </p><p style="color:blue;">线程将请求或等待使用get-lock（）调用请求的通知锁。对于show profile，此状态表示线程正在请求锁（而不是等待锁）。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868079312"></a>

                    <a class="indexterm" name="idm140286868077824"></a>

                    <code class="literal">User sleep</code>
                </p><p style="color:blue;">用户睡眠</p><p></p><p>
                    The thread has invoked a
                    <a class="link" href="functions.html#function_sleep"><code class="literal">SLEEP()</code></a> call.
                </p><p style="color:blue;">线程调用了sleep（）调用。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868073200"></a>

                    <a class="indexterm" name="idm140286868071712"></a>

                    <code class="literal">Waiting for commit lock</code>
                </p><p style="color:blue;">等待提交锁</p><p></p><p>
                    <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH READ LOCK</code></a>
                    is waiting for a commit lock.
                </p><p style="color:blue;">具有读锁的刷新表正在等待提交锁。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868067072"></a>

                    <a class="indexterm" name="idm140286868065568"></a>

                    <code class="literal">Waiting for global read lock</code>
                </p><p style="color:blue;">正在等待全局读取锁定</p><p></p><p>
                    <a class="link" href="sql-syntax.html#flush-tables-with-read-lock"><code class="literal">FLUSH TABLES WITH READ LOCK</code></a>
                    is waiting for a global read lock or the global
                    <a class="link" href="server-administration.html#sysvar_read_only"><code class="literal">read_only</code></a> system variable
                    is being set.
                </p><p style="color:blue;">具有读取锁定的刷新表正在等待全局读取锁定，或者正在设置全局只读系统变量。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868059600"></a>

                    <a class="indexterm" name="idm140286868058112"></a>

                    <code class="literal">Waiting for tables</code>
                </p><p style="color:blue;">等桌子</p><p></p><p>
                    The thread got a notification that the underlying structure
                    for a table has changed and it needs to reopen the table to
                    get the new structure. However, to reopen the table, it must
                    wait until all other threads have closed the table in
                    question.
                </p><p style="color:blue;">线程收到一个通知，通知表的基础结构已更改，它需要重新打开表以获取新结构。但是，要重新打开表，它必须等到所有其他线程都关闭了该表。</p><p></p><p>
                    This notification takes place if another thread has used
                    <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> or one of the
                    following statements on the table in question:
                    <code class="literal">FLUSH TABLES
                        <em class="replaceable"><code>tbl_name</code></em></code>,
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>, or
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>.
                </p><p style="color:blue;">如果另一个线程使用了flush tables或有问题的表上的以下语句之一：flush tables tbl_name、alter table、rename table、repair table、analyze table或optimize table，则会发生此通知。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868045488"></a>

                    <a class="indexterm" name="idm140286868044000"></a>

                    <code class="literal">Waiting for table flush</code>
                </p><p style="color:blue;">等待桌面刷新</p><p></p><p>
                    The thread is executing <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH
                    TABLES</code></a> and is waiting for all threads to close
                    their tables, or the thread got a notification that the
                    underlying structure for a table has changed and it needs to
                    reopen the table to get the new structure. However, to
                    reopen the table, it must wait until all other threads have
                    closed the table in question.
                </p><p style="color:blue;">线程正在执行刷新表并等待所有线程关闭其表，或者线程收到一个通知，通知表的基础结构已更改，它需要重新打开表以获取新结构。但是，要重新打开表，它必须等到所有其他线程都关闭了该表。</p><p></p><p>
                    This notification takes place if another thread has used
                    <a class="link" href="sql-syntax.html#flush-tables"><code class="literal">FLUSH TABLES</code></a> or one of the
                    following statements on the table in question:
                    <code class="literal">FLUSH TABLES
                        <em class="replaceable"><code>tbl_name</code></em></code>,
                    <a class="link" href="sql-syntax.html#alter-table" title="13.1.8&nbsp;ALTER TABLE Syntax"><code class="literal">ALTER TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#rename-table" title="13.1.33&nbsp;RENAME TABLE Syntax"><code class="literal">RENAME TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#repair-table" title="13.7.2.5&nbsp;REPAIR TABLE Syntax"><code class="literal">REPAIR TABLE</code></a>,
                    <a class="link" href="sql-syntax.html#analyze-table" title="13.7.2.1&nbsp;ANALYZE TABLE Syntax"><code class="literal">ANALYZE TABLE</code></a>, or
                    <a class="link" href="sql-syntax.html#optimize-table" title="13.7.2.4&nbsp;OPTIMIZE TABLE Syntax"><code class="literal">OPTIMIZE TABLE</code></a>.
                </p><p style="color:blue;">如果另一个线程使用了flush tables或有问题的表上的以下语句之一：flush tables tbl_name、alter table、rename table、repair table、analyze table或optimize table，则会发生此通知。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286868030064"></a>

                    <a class="indexterm" name="idm140286868028560"></a>

                    <a class="indexterm" name="idm140286868027056"></a>

                    <a class="indexterm" name="idm140286868025552"></a>

                    <a class="indexterm" name="idm140286868024048"></a>

                    <a class="indexterm" name="idm140286868022544"></a>

                    <a class="indexterm" name="idm140286868021024"></a>

                    <a class="indexterm" name="idm140286868019504"></a>

                    <a class="indexterm" name="idm140286868017984"></a>

                    <a class="indexterm" name="idm140286868016464"></a>

                    <a class="indexterm" name="idm140286868014960"></a>

                    <a class="indexterm" name="idm140286868013456"></a>

                    <a class="indexterm" name="idm140286868011952"></a>

                    <a class="indexterm" name="idm140286868010448"></a>

                    <a class="indexterm" name="idm140286868008944"></a>

                    <code class="literal">Waiting for <em class="replaceable"><code>lock_type</code></em>
                        lock</code>
                </p><p style="color:blue;">等待锁类型锁</p><p></p><p>
                    The server is waiting to acquire a
                    <code class="literal">THR_LOCK</code> lock or a lock from the metadata
                    locking subsystem, where
                    <em class="replaceable"><code>lock_type</code></em> indicates the type of
                    lock.
                </p><p style="color:blue;">服务器正在等待从元数据锁定子系统获取thr_lock锁或锁，其中lock_type表示锁的类型。</p><p></p><p>
                    This state indicates a wait for a
                    <code class="literal">THR_LOCK</code>:
                </p><p style="color:blue;">此状态表示等待thr\u锁定：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">Waiting for table level lock</code>
                        </p><p style="color:blue;">等待表级锁</p><p></p></li></ul>
                    </div>
                    <p>
                        These states indicate a wait for a metadata lock:
                    </p><p style="color:blue;">这些状态表示等待元数据锁：</p><p></p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                            <code class="literal">Waiting for event metadata lock</code>
                        </p><p style="color:blue;">等待事件元数据锁</p><p></p></li><li class="listitem"><p>
                            <code class="literal">Waiting for global read lock</code>
                        </p><p style="color:blue;">正在等待全局读取锁定</p><p></p></li><li class="listitem"><p>
                            <code class="literal">Waiting for schema metadata lock</code>
                        </p><p style="color:blue;">正在等待架构元数据锁</p><p></p></li><li class="listitem"><p>
                            <code class="literal">Waiting for stored function metadata
                                lock</code>
                        </p><p style="color:blue;">正在等待存储的函数元数据锁</p><p></p></li><li class="listitem"><p>
                            <code class="literal">Waiting for stored procedure metadata
                                lock</code>
                        </p><p style="color:blue;">等待存储过程元数据锁</p><p></p></li><li class="listitem"><p>
                            <code class="literal">Waiting for table metadata lock</code>
                        </p><p style="color:blue;">正在等待表元数据锁</p><p></p></li><li class="listitem"><p>
                            <code class="literal">Waiting for trigger metadata lock</code>
                        </p><p style="color:blue;">等待触发器元数据锁</p><p></p></li></ul>
                    </div>
                    <p>
                        For information about table lock indicators, see
                        <a class="xref" href="optimization.html#internal-locking" title="8.11.1&nbsp;Internal Locking Methods">Section&nbsp;8.11.1, “Internal Locking Methods”</a>. For information about
                        metadata locking, see <a class="xref" href="optimization.html#metadata-locking" title="8.11.4&nbsp;Metadata Locking">Section&nbsp;8.11.4, “Metadata Locking”</a>. To
                        see which locks are blocking lock requests, use the
                        Performance Schema lock tables described at
                        <a class="xref" href="performance-schema.html#performance-schema-lock-tables" title="25.12.12&nbsp;Performance Schema Lock Tables">Section&nbsp;25.12.12, “Performance Schema Lock Tables”</a>.
                    </p><p style="color:blue;">有关表锁指示器的信息，请参阅第8.11.1节“内部锁定方法”。有关元数据锁定的信息，请参见第8.11.4节“元数据锁定”。要查看哪些锁正在阻止锁请求，请使用第25.12.12节“性能模式锁表”中描述的性能模式锁表。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867986656"></a>

                    <a class="indexterm" name="idm140286867985168"></a>

                    <code class="literal">Waiting on cond</code>
                </p><p style="color:blue;">等待条件</p><p></p><p>
                    A generic state in which the thread is waiting for a
                    condition to become true. No specific state information is
                    available.
                </p><p style="color:blue;">线程等待条件变为真的一般状态。没有可用的特定状态信息。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867981648"></a>

                    <a class="indexterm" name="idm140286867980160"></a>

                    <code class="literal">Writing to net</code>
                </p><p style="color:blue;">写入网络</p><p></p><p>
                    The server is writing a packet to the network. This state is
                    called <code class="literal">Sending to client</code> as of MySQL
                    5.7.8.
                </p><p style="color:blue;">服务器正在向网络写入数据包。从mysql 5.7.8开始，此状态称为发送到客户端。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="query-cache-thread-states"></a>8.14.3&nbsp;Query Cache Thread States</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286867975072"></a><a class="indexterm" name="idm140286867973584"></a><p>
            These thread states are associated with the query cache (see
            <a class="xref" href="optimization.html#query-cache" title="8.10.3&nbsp;The MySQL Query Cache">Section&nbsp;8.10.3, “The MySQL Query Cache”</a>).
        </p><p style="color:blue;">这些线程状态与查询缓存相关联（参见8.10.3节，“mysql查询缓存”）。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867970176"></a>

                    <a class="indexterm" name="idm140286867968672"></a>

                    <code class="literal">checking privileges on cached query</code>
                </p><p style="color:blue;">检查缓存查询的权限</p><p></p><p>
                    The server is checking whether the user has privileges to
                    access a cached query result.
                </p><p style="color:blue;">服务器正在检查用户是否具有访问缓存查询结果的权限。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867965168"></a>

                    <a class="indexterm" name="idm140286867963664"></a>

                    <code class="literal">checking query cache for query</code>
                </p><p style="color:blue;">正在检查查询缓存中的查询</p><p></p><p>
                    The server is checking whether the current query is present
                    in the query cache.
                </p><p style="color:blue;">服务器正在检查当前查询是否存在于查询缓存中。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867960176"></a>

                    <a class="indexterm" name="idm140286867958672"></a>

                    <code class="literal">invalidating query cache entries</code>
                </p><p style="color:blue;">使查询缓存项无效</p><p></p><p>
                    Query cache entries are being marked invalid because the
                    underlying tables have changed.
                </p><p style="color:blue;">由于基础表已更改，查询缓存项被标记为无效。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867955168"></a>

                    <a class="indexterm" name="idm140286867953664"></a>

                    <code class="literal">sending cached result to client</code>
                </p><p style="color:blue;">将缓存结果发送到客户端</p><p></p><p>
                    The server is taking the result of a query from the query
                    cache and sending it to the client.
                </p><p style="color:blue;">服务器正在从查询缓存中获取查询结果并将其发送到客户端。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867950160"></a>

                    <a class="indexterm" name="idm140286867948656"></a>

                    <code class="literal">storing result in query cache</code>
                </p><p style="color:blue;">将结果存储在查询缓存中</p><p></p><p>
                    The server is storing the result of a query in the query
                    cache.
                </p><p style="color:blue;">服务器正在将查询结果存储在查询缓存中。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867945184"></a>

                    <a class="indexterm" name="idm140286867943680"></a>

                    <code class="literal">Waiting for query cache lock</code>
                </p><p style="color:blue;">正在等待查询缓存锁定</p><p></p><p>
                    This state occurs while a session is waiting to take the
                    query cache lock. This can happen for any statement that
                    needs to perform some query cache operation, such as an
                    <a class="link" href="sql-syntax.html#insert" title="13.2.5&nbsp;INSERT Syntax"><code class="literal">INSERT</code></a> or
                    <a class="link" href="sql-syntax.html#delete" title="13.2.2&nbsp;DELETE Syntax"><code class="literal">DELETE</code></a> that invalidates the
                    query cache, a <a class="link" href="sql-syntax.html#select" title="13.2.9&nbsp;SELECT Syntax"><code class="literal">SELECT</code></a> that
                    looks for a cached entry,
                    <a class="link" href="sql-syntax.html#reset" title="13.7.6.6&nbsp;RESET Syntax"><code class="literal">RESET QUERY
                        CACHE</code></a>, and so forth.
                </p><p style="color:blue;">此状态在会话等待获取查询缓存锁时发生。任何需要执行某些查询缓存操作的语句都可能发生这种情况，例如使查询缓存失效的插入或删除、查找缓存项的选择、重置查询缓存等等。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="master-thread-states"></a>8.14.4&nbsp;Replication Master Thread States</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286867934160"></a><a class="indexterm" name="idm140286867932704"></a><p>
            The following list shows the most common states you may see in
            the <code class="literal">State</code> column for the master's
            <code class="literal">Binlog Dump</code> thread. If you see no
            <code class="literal">Binlog Dump</code> threads on a master server, this
            means that replication is not running; that is, that no slaves
            are currently connected.
        </p><p style="color:blue;">下表显示了在master的binlog转储线程的state列中可以看到的最常见状态。如果在主服务器上看不到binlog转储线程，这意味着复制没有运行；也就是说，当前没有连接从服务器。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867927648"></a>

                    <a class="indexterm" name="idm140286867926128"></a>

                    <code class="literal">Finished reading one binlog; switching to next
                        binlog</code>
                </p><p style="color:blue;">读取完一个binlog；切换到下一个binlog</p><p></p><p>
                    The thread has finished reading a binary log file and is
                    opening the next one to send to the slave.
                </p><p style="color:blue;">线程已完成读取二进制日志文件，并正在打开下一个日志文件以发送到从属服务器。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867922576"></a>

                    <a class="indexterm" name="idm140286867921040"></a>

                    <code class="literal">Master has sent all binlog to slave; waiting for
                        more updates</code>
                </p><p style="color:blue;">master已将所有binlog发送到slave；正在等待更多更新</p><p></p><p>
                    The thread has read all remaining updates from the binary
                    logs and sent them to the slave. The thread is now idle,
                    waiting for new events to appear in the binary log resulting
                    from new updates occurring on the master.
                </p><p style="color:blue;">线程已从二进制日志中读取所有剩余的更新，并将它们发送到从属服务器。线程现在处于空闲状态，等待新的事件出现在二进制日志中，这是由于主服务器上发生了新的更新。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867917312"></a>

                    <a class="indexterm" name="idm140286867915808"></a>

                    <code class="literal">Sending binlog event to slave</code>
                </p><p style="color:blue;">向从机发送binlog事件</p><p></p><p>
                    Binary logs consist of <span class="emphasis"><em>events</em></span>, where an
                    event is usually an update plus some other information. The
                    thread has read an event from the binary log and is now
                    sending it to the slave.
                </p><p style="color:blue;">二进制日志由事件组成，其中一个事件通常是一个更新加上一些其他信息。线程已经从二进制日志中读取了一个事件，现在正在将其发送到从服务器。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867911776"></a>

                    <a class="indexterm" name="idm140286867910272"></a>

                    <code class="literal">Waiting to finalize termination</code>
                </p><p style="color:blue;">等待完成终止</p><p></p><p>
                    A very brief state that occurs as the thread is stopping.
                </p><p style="color:blue;">线程停止时发生的非常短暂的状态。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="slave-io-thread-states"></a>8.14.5&nbsp;Replication Slave I/O Thread States</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286867905936"></a><a class="indexterm" name="idm140286867904480"></a><p>
            The following list shows the most common states you see in the
            <code class="literal">State</code> column for a slave server I/O thread.
            This state also appears in the <code class="literal">Slave_IO_State</code>
            column displayed by <a class="link" href="sql-syntax.html#show-slave-status" title="13.7.5.34&nbsp;SHOW SLAVE STATUS Syntax"><code class="literal">SHOW SLAVE
            STATUS</code></a>, so you can get a good view of what is
            happening by using that statement.
        </p><p style="color:blue;">下表显示了从服务器I/O线程在“状态”列中看到的最常见状态。此状态也出现在“显示从属状态”显示的“从属状态”列中，因此使用该语句可以很好地查看正在发生的事情。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867898896"></a>

                    <a class="indexterm" name="idm140286867897408"></a>

                    <code class="literal">Checking master version</code>
                </p><p style="color:blue;">检查主版本</p><p></p><p>
                    A state that occurs very briefly, after the connection to
                    the master is established.
                </p><p style="color:blue;">在建立与主机的连接后，一种非常短暂的状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867893936"></a>

                    <a class="indexterm" name="idm140286867892448"></a>

                    <code class="literal">Connecting to master</code>
                </p><p style="color:blue;">连接到主机</p><p></p><p>
                    The thread is attempting to connect to the master.
                </p><p style="color:blue;">线程正在尝试连接到主线程。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867889024"></a>

                    <a class="indexterm" name="idm140286867887520"></a>

                    <code class="literal">Queueing master event to the relay log</code>
                </p><p style="color:blue;">将主事件排队到中继日志</p><p></p><p>
                    The thread has read an event and is copying it to the relay
                    log so that the SQL thread can process it.
                </p><p style="color:blue;">线程已读取事件并将其复制到中继日志，以便SQL线程可以处理它。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867884000"></a>

                    <a class="indexterm" name="idm140286867882480"></a>

                    <code class="literal">Reconnecting after a failed binlog dump
                        request</code>
                </p><p style="color:blue;">在binlog转储请求失败后重新连接</p><p></p><p>
                    The thread is trying to reconnect to the master.
                </p><p style="color:blue;">线程正在尝试重新连接到主线程。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867878976"></a>

                    <a class="indexterm" name="idm140286867877456"></a>

                    <code class="literal">Reconnecting after a failed master event
                        read</code>
                </p><p style="color:blue;">读取失败的主事件后重新连接</p><p></p><p>
                    The thread is trying to reconnect to the master. When
                    connection is established again, the state becomes
                    <code class="literal">Waiting for master to send event</code>.
                </p><p style="color:blue;">线程正在尝试重新连接到主线程。当连接再次建立时，状态变为等待主服务器发送事件。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867873152"></a>

                    <a class="indexterm" name="idm140286867871648"></a>

                    <code class="literal">Registering slave on master</code>
                </p><p style="color:blue;">在主机上注册从机</p><p></p><p>
                    A state that occurs very briefly after the connection to the
                    master is established.
                </p><p style="color:blue;">在建立与主设备的连接后很短时间内发生的一种状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867868160"></a>

                    <a class="indexterm" name="idm140286867866672"></a>

                    <code class="literal">Requesting binlog dump</code>
                </p><p style="color:blue;">请求binlog转储</p><p></p><p>
                    A state that occurs very briefly, after the connection to
                    the master is established. The thread sends to the master a
                    request for the contents of its binary logs, starting from
                    the requested binary log file name and position.
                </p><p style="color:blue;">在建立与主机的连接后，一种非常短暂的状态。线程从请求的二进制日志文件名和位置开始，向主机发送有关其二进制日志内容的请求。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867863040"></a>

                    <a class="indexterm" name="idm140286867861536"></a>

                    <code class="literal">Waiting for its turn to commit</code>
                </p><p style="color:blue;">等待轮到它作出承诺</p><p></p><p>
                    A state that occurs when the slave thread is waiting for
                    older worker threads to commit if
                    <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">slave_preserve_commit_order</code></a>
                    is enabled.
                </p><p style="color:blue;">如果启用了从线程保留提交顺序，则在从线程等待较旧的工作线程提交时发生的状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867856736"></a>

                    <a class="indexterm" name="idm140286867855232"></a>

                    <code class="literal">Waiting for master to send event</code>
                </p><p style="color:blue;">等待主服务器发送事件</p><p></p><p>
                    The thread has connected to the master and is waiting for
                    binary log events to arrive. This can last for a long time
                    if the master is idle. If the wait lasts for
                    <a class="link" href="replication.html#sysvar_slave_net_timeout"><code class="literal">slave_net_timeout</code></a> seconds,
                    a timeout occurs. At that point, the thread considers the
                    connection to be broken and makes an attempt to reconnect.
                </p><p style="color:blue;">线程已连接到主线程，正在等待二进制日志事件到达。如果主机空闲，这种情况可能会持续很长时间。如果等待持续从网络超时秒，则发生超时。此时，线程认为连接已断开，并尝试重新连接。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867850192"></a>

                    <a class="indexterm" name="idm140286867848736"></a>

                    <code class="literal">Waiting for master update</code>
                </p><p style="color:blue;">正在等待主更新</p><p></p><p>
                    The initial state before <code class="literal">Connecting to
                    master</code>.
                </p><p style="color:blue;">连接到主机前的初始状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867844592"></a>

                    <a class="indexterm" name="idm140286867843088"></a>

                    <code class="literal">Waiting for slave mutex on exit</code>
                </p><p style="color:blue;">在退出时等待从互斥体</p><p></p><p>
                    A state that occurs briefly as the thread is stopping.
                </p><p style="color:blue;">线程停止时短暂出现的状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867839632"></a>

                    <a class="indexterm" name="idm140286867838096"></a>

                    <code class="literal">Waiting for the slave SQL thread to free enough
                        relay log space</code>
                </p><p style="color:blue;">等待从SQL线程释放足够的中继日志空间</p><p></p><p>
                    You are using a nonzero
                    <a class="link" href="replication.html#sysvar_relay_log_space_limit"><code class="literal">relay_log_space_limit</code></a>
                    value, and the relay logs have grown large enough that their
                    combined size exceeds this value. The I/O thread is waiting
                    until the SQL thread frees enough space by processing relay
                    log contents so that it can delete some relay log files.
                </p><p style="color:blue;">您正在使用一个非零的中继日志空间限制值，并且中继日志的大小已经增长到足以使其组合大小超过此值。I/O线程正在等待，直到SQL线程通过处理中继日志内容释放足够的空间，以便它可以删除一些中继日志文件。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867832992"></a>

                    <a class="indexterm" name="idm140286867831504"></a>

                    <code class="literal">Waiting to reconnect after a failed binlog dump
                        request</code>
                </p><p style="color:blue;">在binlog转储请求失败后等待重新连接</p><p></p><p>
                    If the binary log dump request failed (due to
                    disconnection), the thread goes into this state while it
                    sleeps, then tries to reconnect periodically. The interval
                    between retries can be specified using the
                    <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement.
                </p><p style="color:blue;">如果二进制日志转储请求失败（由于断开连接），则线程在休眠时进入此状态，然后尝试定期重新连接。可以使用change master to语句指定重试间隔。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867826576"></a>

                    <a class="indexterm" name="idm140286867825056"></a>

                    <code class="literal">Waiting to reconnect after a failed master event
                        read</code>
                </p><p style="color:blue;">读取失败的主事件后等待重新连接</p><p></p><p>
                    An error occurred while reading (due to disconnection). The
                    thread is sleeping for the number of seconds set by the
                    <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement
                    (default 60) before attempting to reconnect.
                </p><p style="color:blue;">读取时出错（由于断开连接）。在尝试重新连接之前，线程正在休眠由change master to语句设置的秒数（默认值60）。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="slave-sql-thread-states"></a>8.14.6&nbsp;Replication Slave SQL Thread States</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286867819232"></a><a class="indexterm" name="idm140286867817776"></a><p>
            The following list shows the most common states you may see in
            the <code class="literal">State</code> column for a slave server SQL
            thread:
        </p><p style="color:blue;">下表显示了从服务器SQL线程的“状态”列中可能看到的最常见状态：</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867814288"></a>

                    <a class="indexterm" name="idm140286867812800"></a>

                    <code class="literal">Killing slave</code>
                </p><p style="color:blue;">杀戮奴隶</p><p></p><p>
                    The thread is processing a <code class="literal">STOP SLAVE</code>
                    statement.
                </p><p style="color:blue;">线程正在处理stop slave语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867808672"></a>

                    <a class="indexterm" name="idm140286867807136"></a>

                    <code class="literal">Making temporary file (append) before replaying
                        LOAD DATA INFILE</code>
                </p><p style="color:blue;">在重放加载数据填充之前生成临时文件（追加）</p><p></p><p>
                    The thread is executing a <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                    DATA</code></a> statement and is appending the data to a
                    temporary file containing the data from which the slave will
                    read rows.
                </p><p style="color:blue;">线程正在执行一个load data语句，并将数据追加到一个临时文件中，该文件包含从机将从中读取行的数据。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867802288"></a>

                    <a class="indexterm" name="idm140286867800752"></a>

                    <code class="literal">Making temporary file (create) before replaying
                        LOAD DATA INFILE</code>
                </p><p style="color:blue;">在重放加载数据填充之前生成临时文件（创建）</p><p></p><p>
                    The thread is executing a <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD
                    DATA</code></a> statement and is creating a temporary file
                    containing the data from which the slave will read rows.
                    This state can only be encountered if the original
                    <a class="link" href="sql-syntax.html#load-data" title="13.2.6&nbsp;LOAD DATA Syntax"><code class="literal">LOAD DATA</code></a> statement was
                    logged by a master running a version of MySQL lower than
                    MySQL 5.0.3.
                </p><p style="color:blue;">线程正在执行加载数据语句，并正在创建一个临时文件，其中包含从机将从中读取行的数据。只有当原始加载数据语句由运行低于mysql 5.0.3版本的mysql的主服务器记录时，才会遇到此状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867794528"></a>

                    <a class="indexterm" name="idm140286867793024"></a>

                    <code class="literal">Reading event from the relay log</code>
                </p><p style="color:blue;">从中继日志读取事件</p><p></p><p>
                    The thread has read an event from the relay log so that the
                    event can be processed.
                </p><p style="color:blue;">线程已从中继日志中读取事件，以便可以处理该事件。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867789536"></a>

                    <a class="indexterm" name="idm140286867788016"></a>

                    <code class="literal">Slave has read all relay log; waiting for more
                        updates</code>
                </p><p style="color:blue;">从服务器已读取所有中继日志；正在等待更多更新</p><p></p><p>
                    The thread has processed all events in the relay log files,
                    and is now waiting for the I/O thread to write new events to
                    the relay log.
                </p><p style="color:blue;">线程已处理中继日志文件中的所有事件，现在正在等待I/O线程将新事件写入中继日志。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867784416"></a>

                    <a class="indexterm" name="idm140286867782912"></a>

                    <code class="literal">Waiting for an event from Coordinator</code>
                </p><p style="color:blue;">等待协调员的事件</p><p></p><p>
                    Using the multithreaded slave
                    (<a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a> is
                    greater than 1), one of the slave worker threads is waiting
                    for an event from the coordinator thread.
                </p><p style="color:blue;">使用多线程从线程（slave_parallel_workers大于1），其中一个从线程正在等待来自协调线程的事件。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867778032"></a>

                    <a class="indexterm" name="idm140286867776576"></a>

                    <code class="literal">Waiting for slave mutex on exit</code>
                </p><p style="color:blue;">在退出时等待从互斥</p><p></p><p>
                    A very brief state that occurs as the thread is stopping.
                </p><p style="color:blue;">线程停止时发生的非常短暂的状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867773120"></a>

                    <a class="indexterm" name="idm140286867771600"></a>

                    <code class="literal">Waiting for Slave Workers to free pending
                        events</code>
                </p><p style="color:blue;">等待奴隶工人释放挂起的事件</p><p></p><p>
                    This waiting action occurs when the total size of events
                    being processed by Workers exceeds the size of the
                    <a class="link" href="replication.html#sysvar_slave_pending_jobs_size_max"><code class="literal">slave_pending_jobs_size_max</code></a>
                    system variable. The Coordinator resumes scheduling when the
                    size drops below this limit. This state occurs only when
                    <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">slave_parallel_workers</code></a> is
                    set greater than 0.
                </p><p style="color:blue;">当工作进程正在处理的事件的总大小超过slave_pending_jobs_size_max系统变量的大小时，将发生此等待操作。当大小低于此限制时，协调器将恢复调度。只有当slave_parallel_workers设置为大于0时，才会发生此状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867765264"></a>

                    <a class="indexterm" name="idm140286867763808"></a>

                    <code class="literal">Waiting for the next event in relay log</code>
                </p><p style="color:blue;">等待中继日志中的下一个事件</p><p></p><p>
                    The initial state before <code class="literal">Reading event from the
                    relay log</code>.
                </p><p style="color:blue;">从中继日志读取事件之前的初始状态。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867759648"></a>

                    <a class="indexterm" name="idm140286867758112"></a>

                    <code class="literal">Waiting until MASTER_DELAY seconds after master
                        executed event</code>
                </p><p style="color:blue;">等待主机执行事件后的主机延迟秒数</p><p></p><p>
                    The SQL thread has read an event but is waiting for the
                    slave delay to lapse. This delay is set with the
                    <code class="literal">MASTER_DELAY</code> option of
                    <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a>.
                </p><p style="color:blue;">SQL线程已读取事件，但正在等待从属延迟失效。此延迟是通过“将主控更改为”的“主控延迟”选项设置的。</p><p></p></li></ul>
            </div>
            <p>
                The <code class="literal">Info</code> column for the SQL thread may also
                show the text of a statement. This indicates that the thread has
                read an event from the relay log, extracted the statement from
                it, and may be executing it.
            </p><p style="color:blue;">sql线程的info列也可以显示语句的文本。这表示线程已从中继日志中读取事件，从中提取语句，并可能正在执行该语句。</p><p></p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="slave-connection-thread-states"></a>8.14.7&nbsp;Replication Slave Connection Thread States</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286867750208"></a><a class="indexterm" name="idm140286867748720"></a><p>
            These thread states occur on a replication slave but are
            associated with connection threads, not with the I/O or SQL
            threads.
        </p><p style="color:blue;">这些线程状态发生在复制从机上，但与连接线程关联，而不是与I/O或SQL线程关联。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867745040"></a>

                    <a class="indexterm" name="idm140286867743552"></a>

                    <code class="literal">Changing master</code>
                </p><p style="color:blue;">更改主控形状</p><p></p><p>
                    The thread is processing a <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE
                    MASTER TO</code></a> statement.
                </p><p style="color:blue;">线程正在处理一个change master to语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867738960"></a>

                    <a class="indexterm" name="idm140286867737472"></a>

                    <code class="literal">Killing slave</code>
                </p><p style="color:blue;">杀戮奴隶</p><p></p><p>
                    The thread is processing a <code class="literal">STOP SLAVE</code>
                    statement.
                </p><p style="color:blue;">线程正在处理stop slave语句。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867733344"></a>

                    <a class="indexterm" name="idm140286867731840"></a>

                    <code class="literal">Opening master dump table</code>
                </p><p style="color:blue;">打开主转储表</p><p></p><p>
                    This state occurs after <code class="literal">Creating table from master
                    dump</code>.
                </p><p style="color:blue;">此状态在从主转储创建表之后发生。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867727680"></a>

                    <a class="indexterm" name="idm140286867726176"></a>

                    <code class="literal">Reading master dump table data</code>
                </p><p style="color:blue;">读取主转储表数据</p><p></p><p>
                    This state occurs after <code class="literal">Opening master dump
                    table</code>.
                </p><p style="color:blue;">此状态在打开主转储表后发生。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867722032"></a>

                    <a class="indexterm" name="idm140286867720512"></a>

                    <code class="literal">Rebuilding the index on master dump table</code>
                </p><p style="color:blue;">在主转储表上重建索引</p><p></p><p>
                    This state occurs after <code class="literal">Reading master dump table
                    data</code>.
                </p><p style="color:blue;">此状态在读取主转储表数据后发生。</p><p></p></li></ul>
            </div>

        </div>

        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="mysql-cluster-thread-states"></a>8.14.8&nbsp;NDB Cluster Thread States</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286867715376"></a><a class="indexterm" name="idm140286867713888"></a>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867710832"></a>

                    <a class="indexterm" name="idm140286867709328"></a>

                    <code class="literal">Committing events to binlog</code>
                </p><p style="color:blue;">将事件提交到binlog</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867706352"></a>

                    <a class="indexterm" name="idm140286867704848"></a>

                    <code class="literal">Opening mysql.ndb_apply_status</code>
                </p><p style="color:blue;">正在打开mysql.ndb_apply_状态</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867701872"></a>

                    <a class="indexterm" name="idm140286867700384"></a>

                    <code class="literal">Processing events</code>
                </p><p style="color:blue;">处理事件</p><p></p><p>
                    The thread is processing events for binary logging.
                </p><p style="color:blue;">线程正在处理二进制日志记录的事件。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867696960"></a>

                    <a class="indexterm" name="idm140286867695456"></a>

                    <code class="literal">Processing events from schema table</code>
                </p><p style="color:blue;">处理架构表中的事件</p><p></p><p>
                    The thread is doing the work of schema replication.
                </p><p style="color:blue;">线程正在执行架构复制的工作。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867692000"></a>

                    <a class="indexterm" name="idm140286867690512"></a>

                    <code class="literal">Shutting down</code>
                </p><p style="color:blue;">关闭</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867687568"></a>

                    <a class="indexterm" name="idm140286867686048"></a>

                    <code class="literal">Syncing ndb table schema operation and
                        binlog</code>
                </p><p style="color:blue;">同步ndb表架构操作和binlog</p><p></p><p>
                    This is used to have a correct binary log of schema
                    operations for NDB.
                </p><p style="color:blue;">这用于为ndb提供正确的模式操作二进制日志。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867682512"></a>

                    <a class="indexterm" name="idm140286867680976"></a>

                    <code class="literal">Waiting for allowed to take ndbcluster global
                        schema lock</code>
                </p><p style="color:blue;">正在等待允许获取NdbCluster全局架构锁</p><p></p><p>
                    The thread is waiting for permission to take a global schema
                    lock.
                </p><p style="color:blue;">线程正在等待获取全局架构锁的权限。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867677440"></a>

                    <a class="indexterm" name="idm140286867675936"></a>

                    <code class="literal">Waiting for event from ndbcluster</code>
                </p><p style="color:blue;">正在等待来自ndbcluster的事件</p><p></p><p>
                    The server is acting as an SQL node in an NDB Cluster, and
                    is connected to a cluster management node.
                </p><p style="color:blue;">服务器在ndb集群中充当sql节点，并连接到集群管理节点。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867672416"></a>

                    <a class="indexterm" name="idm140286867670912"></a>

                    <code class="literal">Waiting for first event from ndbcluster</code>
                </p><p style="color:blue;">正在等待来自ndbcluster的第一个事件</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867667936"></a>

                    <a class="indexterm" name="idm140286867666400"></a>

                    <code class="literal">Waiting for ndbcluster binlog update to reach
                        current position</code>
                </p><p style="color:blue;">等待ndbcluster binlog更新到达当前位置</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867663344"></a>

                    <a class="indexterm" name="idm140286867661824"></a>

                    <code class="literal">Waiting for ndbcluster global schema lock</code>
                </p><p style="color:blue;">正在等待NdbCluster全局架构锁定</p><p></p><p>
                    The thread is waiting for a global schema lock held by
                    another thread to be released.
                </p><p style="color:blue;">线程正在等待释放另一个线程持有的全局架构锁。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867658288"></a>

                    <a class="indexterm" name="idm140286867656784"></a>

                    <code class="literal">Waiting for ndbcluster to start</code>
                </p><p style="color:blue;">正在等待NdbCluster启动</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867653808"></a>

                    <a class="indexterm" name="idm140286867652304"></a>

                    <code class="literal">Waiting for schema epoch</code>
                </p><p style="color:blue;">等待模式纪元</p><p></p><p>
                    The thread is waiting for a schema epoch (that is, a global
                    checkpoint).
                </p><p style="color:blue;">线程正在等待模式纪元（即全局检查点）。</p><p></p></li></ul>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="event-scheduler-thread-states"></a>8.14.9&nbsp;Event Scheduler Thread States</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286867647872"></a><a class="indexterm" name="idm140286867646384"></a><p>
            These states occur for the Event Scheduler thread, threads that
            are created to execute scheduled events, or threads that
            terminate the scheduler.
        </p><p style="color:blue;">这些状态发生在事件计划程序线程、为执行计划事件而创建的线程或终止计划程序的线程上。</p><p></p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867643552"></a>

                    <a class="indexterm" name="idm140286867642064"></a>

                    <code class="literal">Clearing</code>
                </p><p style="color:blue;">清理</p><p></p><p>
                    The scheduler thread or a thread that was executing an event
                    is terminating and is about to end.
                </p><p style="color:blue;">调度程序线程或正在执行事件的线程正在终止并即将结束。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867638592"></a>

                    <a class="indexterm" name="idm140286867637104"></a>

                    <code class="literal">Initialized</code>
                </p><p style="color:blue;">已初始化</p><p></p><p>
                    The scheduler thread or a thread that will execute an event
                    has been initialized.
                </p><p style="color:blue;">调度程序线程或将执行事件的线程已初始化。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867633648"></a>

                    <a class="indexterm" name="idm140286867632144"></a>

                    <code class="literal">Waiting for next activation</code>
                </p><p style="color:blue;">等待下次激活</p><p></p><p>
                    The scheduler has a nonempty event queue but the next
                    activation is in the future.
                </p><p style="color:blue;">调度程序有一个非空事件队列，但下一次激活是在将来。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867628656"></a>

                    <a class="indexterm" name="idm140286867627152"></a>

                    <code class="literal">Waiting for scheduler to stop</code>
                </p><p style="color:blue;">正在等待计划程序停止</p><p></p><p>
                    The thread issued <code class="literal">SET GLOBAL
                    event_scheduler=OFF</code> and is waiting for the
                    scheduler to stop.
                </p><p style="color:blue;">线程发出set global event_scheduler=off，正在等待调度程序停止。</p><p></p></li><li class="listitem"><p>
                    <a class="indexterm" name="idm140286867622944"></a>

                    <a class="indexterm" name="idm140286867621456"></a>

                    <code class="literal">Waiting on empty queue</code>
                </p><p style="color:blue;">等待空队列</p><p></p><p>
                    The scheduler's event queue is empty and it is sleeping.
                </p><p style="color:blue;">调度程序的事件队列为空且处于休眠状态。</p><p></p></li></ul>
            </div>

        </div>

    </div>

</div>
<div class="copyright-footer">

</div>
<div class="navfooter">
    <hr>
    <table width="100%" summary="Navigation footer">
        <tbody><tr>
            <td width="40%" align="left"><a accesskey="p" href="backup-and-recovery.html">Prev</a></td>
            <td width="20%" align="center"><a accesskey="u" href="">Up</a></td>
            <td width="40%" align="right">&nbsp;<a accesskey="n" href="language-structure.html">Next</a></td>
        </tr>
        <tr>
            <td width="40%" align="left" valign="top">Chapter&nbsp;7 Backup and Recovery</td>
            <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
            <td width="40%" align="right" valign="top">Chapter&nbsp;9 Language Structure</td>
        </tr>
        </tbody></table>
</div>


</body></html>