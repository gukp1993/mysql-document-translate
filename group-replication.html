<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Chapter&nbsp;17 Group Replication</title>
    <link rel="stylesheet" href="mvl.css" type="text/css">
    <meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2">
    <link rel="start" href="index.html" title="{book-title}">
    <link rel="up" href="" title="">
    <link rel="prev" href="replication.html" title="Chapter&nbsp;16 Replication">
    <link rel="next" href="mysql-shell-userguide.html" title="Chapter&nbsp;18 MySQL Shell">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script></head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
    <table width="100%" summary="Navigation header">
        <tbody><tr>
            <th colspan="3" align="center">Chapter&nbsp;17 Group Replication</th>
        </tr>
        <tr>
            <td width="20%" align="left"><a accesskey="p" href="replication.html">Prev</a>&nbsp;</td>
            <th width="60%" align="center"></th>
            <td width="20%" align="right">&nbsp;<a accesskey="n" href="mysql-shell-userguide.html">Next</a></td>
        </tr>
        </tbody></table>
    <hr>
</div>
<div class="chapter">
    <div class="titlepage">
        <div>
            <div>
                <h1 class="title"><a name="group-replication"></a>Chapter&nbsp;17&nbsp;Group Replication</h1>

            </div>

        </div>

    </div>
    <div class="toc">
        <p><b>Table of Contents</b></p><p style="color:blue;">目录</p><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-background">17.1 Group Replication Background</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-replication-technologies">17.1.1 Replication Technologies</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-use-cases">17.1.2 Group Replication Use Cases</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-details">17.1.3 Group Replication Details</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-getting-started">17.2 Getting Started</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-single-primary-mode">17.2.1 Deploying Group Replication in Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-deploying-locally">17.2.2 Deploying Group Replication Locally</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-monitoring">17.3 Monitoring Group Replication</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-server-states">17.3.1 Group Replication Server States</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-members">17.3.2 The replication_group_members Table</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-member-stats">17.3.3 The replication_group_member_stats Table</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-operations">17.4 Group Replication Operations</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-multi-primary-or-single-primary-mode">17.4.1 Deploying in Multi-Primary or Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-tuning-recovery">17.4.2 Tuning Recovery</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-network-partitioning">17.4.3 Network Partitioning</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-enterprise-backup">17.4.4 Using MySQL Enterprise Backup with Group Replication</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-security">17.5 Group Replication Security</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-ip-address-whitelisting">17.5.1 Group Replication IP Address Whitelisting</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-secure-socket-layer-support-ssl">17.5.2 Group Replication Secure Socket Layer (SSL) Support</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-virtual-private-networks-vpn">17.5.3 Group Replication and Virtual Private Networks (VPNs)</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-options">17.6 Group Replication System Variables</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-requirements-and-limitations">17.7 Requirements and Limitations</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-requirements">17.7.1 Group Replication Requirements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-limitations">17.7.2 Group Replication Limitations</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-frequently-asked-questions">17.8 Frequently Asked Questions</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-technical-details">17.9 Group Replication Technical Details</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-plugin-architecture">17.9.1 Group Replication Plugin Architecture</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-the-group">17.9.2 The Group</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-data-manipulation-statements">17.9.3 Data Manipulation Statements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-data-definition-statements">17.9.4 Data Definition Statements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery">17.9.5 Distributed Recovery</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-observability">17.9.6 Observability</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-performance">17.9.7 Group Replication Performance</a></span></dt></dl></dd></dl>
    </div>
    <a class="indexterm" name="idm140286791125744"></a><a class="indexterm" name="idm140286791124672"></a><p>
    This chapter explains MySQL Group Replication and how to install,
    configure and monitor groups. MySQL Group Replication is a MySQL
    Server plugin that enables you to create elastic, highly-available,
    fault-tolerant replication topologies.
</p><p style="color:blue;">本章介绍mysql组复制以及如何安装、配置和监视组。mysql group replication是一个mysql服务器插件，它允许您创建弹性、高可用、容错的复制拓扑。</p><p>
    Groups can operate in a single-primary mode with automatic primary
    election, where only one server accepts updates at a time.
    Alternatively, for more advanced users, groups can be deployed in
    multi-primary mode, where all servers can accept updates, even if
    they are issued concurrently.
</p><p style="color:blue;">组可以在单一主模式下操作，并自动进行主选择，其中一次只有一台服务器接受更新。或者，对于更高级的用户，可以在多主模式下部署组，其中所有服务器都可以接受更新，即使它们是并发发布的。</p><p>
    There is a built-in group membership service that keeps the view of
    the group consistent and available for all servers at any given
    point in time. Servers can leave and join the group and the view is
    updated accordingly. Sometimes servers can leave the group
    unexpectedly, in which case the failure detection mechanism detects
    this and notifies the group that the view has changed. This is all
    automatic.
</p><p style="color:blue;">有一个内置的组成员身份服务，它保持组视图的一致性，并且在任何给定时间点对所有服务器都可用。服务器可以离开并加入组，并且相应地更新视图。有时服务器会意外地离开组，在这种情况下，故障检测机制会检测到这一点并通知组视图已更改。这是全自动的。</p><p>
    The chapter is structured as follows:
</p><p style="color:blue;">本章结构如下：</p>
    <div class="itemizedlist">
        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="xref" href="group-replication.html#group-replication-background" title="17.1&nbsp;Group Replication Background">Section&nbsp;17.1, “Group Replication Background”</a> provides an
            introduction to groups and how Group Replication works.
        </p><p style="color:blue;">第17.1节“组复制背景”介绍了组和组复制的工作原理。</p></li><li class="listitem"><p>
            <a class="xref" href="group-replication.html#group-replication-getting-started" title="17.2&nbsp;Getting Started">Section&nbsp;17.2, “Getting Started”</a> explains how
            to configure multiple MySQL Server instances to create a group.
        </p><p style="color:blue;">第17.2节“入门”介绍如何配置多个mysql服务器实例来创建组。</p></li><li class="listitem"><p>
            <a class="xref" href="group-replication.html#group-replication-monitoring" title="17.3&nbsp;Monitoring Group Replication">Section&nbsp;17.3, “Monitoring Group Replication”</a> explains how to
            monitor a group.
        </p><p style="color:blue;">第17.3节“监视组复制”说明如何监视组。</p></li><li class="listitem"><p>
            <a class="xref" href="group-replication.html#group-replication-operations" title="17.4&nbsp;Group Replication Operations">Section&nbsp;17.4, “Group Replication Operations”</a> explains how to
            work with a group.
        </p><p style="color:blue;">第17.4节“组复制操作”说明如何使用组。</p></li><li class="listitem"><p>
            <a class="xref" href="group-replication.html#group-replication-security" title="17.5&nbsp;Group Replication Security">Section&nbsp;17.5, “Group Replication Security”</a> explains how to
            secure a group.
        </p><p style="color:blue;">第17.5节“组复制安全性”解释了如何保护组。</p></li><li class="listitem"><p>
            <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/group-replication-upgrade.html" target="_top">Upgrading Group Replication</a> explains how to
            upgrade a group.
        </p><p style="color:blue;">升级组复制说明如何升级组。</p></li><li class="listitem"><p>
            <a class="xref" href="group-replication.html#group-replication-technical-details" title="17.9&nbsp;Group Replication Technical Details">Section&nbsp;17.9, “Group Replication Technical Details”</a> provides
            in-depth information about how Group Replication works.
        </p><p style="color:blue;">第17.9节“组复制技术详细信息”提供了有关组复制如何工作的深入信息。</p></li></ul>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="group-replication-background"></a>17.1&nbsp;Group Replication Background</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-replication-technologies">17.1.1 Replication Technologies</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-use-cases">17.1.2 Group Replication Use Cases</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-details">17.1.3 Group Replication Details</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286791107232"></a><p>
        This section provides background information on MySQL Group
        Replication.


    </p><p style="color:blue;">本节提供有关mysql组复制的背景信息。</p><p>
        The most common way to create a fault-tolerant system is to resort
        to making components redundant, in other words the component can be
        removed and the system should continue to operate as expected. This
        creates a set of challenges that raise complexity of such systems to
        a whole different level. Specifically, replicated databases have to
        deal with the fact that they require maintenance and administration
        of several servers instead of just one. Moreover, as servers are
        cooperating together to create the group several other classic
        distributed systems problems have to be dealt with, such as network
        partitioning or split brain scenarios.
    </p><p style="color:blue;">创建容错系统最常见的方法是使组件冗余，换句话说，可以删除组件，系统应继续按预期运行。这就产生了一系列挑战，使这种系统的复杂性提高到一个不同的水平。具体来说，复制数据库必须处理这样一个事实，即它们需要维护和管理多个服务器，而不仅仅是一个服务器。此外，当服务器协同创建组时，还必须处理其他几个典型的分布式系统问题，例如网络划分或拆分大脑场景。</p><p>
        Therefore, the ultimate challenge is to fuse the logic of the
        database and data replication with the logic of having several
        servers coordinated in a consistent and simple way. In other words,
        to have multiple servers agreeing on the state of the system and the
        data on each and every change that the system goes through. This can
        be summarized as having servers reaching agreement on each database
        state transition, so that they all progress as one single database
        or alternatively that they eventually converge to the same state.
        Meaning that they need to operate as a (distributed) state machine.
    </p><p style="color:blue;">因此，最终的挑战是将数据库和数据复制的逻辑与以一致和简单的方式协调多个服务器的逻辑相结合。换句话说，让多个服务器同意系统的状态以及系统所经历的每一次更改的数据。这可以概括为让服务器就每个数据库状态转换达成一致，以便它们都作为一个数据库进行，或者最终聚合到相同的状态。这意味着它们需要作为（分布式）状态机运行。</p><p>
        MySQL Group Replication provides distributed state machine
        replication with strong coordination between servers. Servers
        coordinate themselves automatically when they are part of the same
        group. The group can operate in a single-primary mode with automatic
        primary election, where only one server accepts updates at a time.
        Alternatively, for more advanced users the group can be deployed in
        multi-primary mode, where all servers can accept updates, even if
        they are issued concurrently. This power comes at the expense of
        applications having to work around the limitations imposed by such
        deployments.
    </p><p style="color:blue;">mysql组复制提供了分布式状态机复制，服务器之间具有很强的协调性。当服务器属于同一组时，它们会自动进行协调。该组可以在单一主模式下操作，并自动进行主选择，其中一次只有一台服务器接受更新。或者，对于更高级的用户，可以在多主模式下部署组，其中所有服务器都可以接受更新，即使它们是并发发布的。这种能力的代价是应用程序必须克服这种部署带来的限制。</p><p>
        There is a built-in group membership service that keeps the view of
        the group consistent and available for all servers at any given
        point in time. Servers can leave and join the group and the view is
        updated accordingly. Sometimes servers can leave the group
        unexpectedly, in which case the failure detection mechanism detects
        this and notifies the group that the view has changed. This is all
        automatic.
    </p><p style="color:blue;">有一个内置的组成员身份服务，它保持组视图的一致性，并且在任何给定时间点对所有服务器都可用。服务器可以离开并加入组，并且相应地更新视图。有时服务器会意外地离开组，在这种情况下，故障检测机制会检测到这一点并通知组视图已更改。这是全自动的。</p><p>
        For a transaction to commit, the majority of the group have to agree
        on the order of a given transaction in the global sequence of
        transactions. Deciding to commit or abort a transaction is done by
        each server individually, but all servers make the same decision. If
        there is a network partition, resulting in a split where members are
        unable to reach agreement, then the system does not progress until
        this issue is resolved. Hence there is also a built-in, automatic,
        split-brain protection mechanism.
    </p><p style="color:blue;">要提交事务，大多数组成员必须就给定事务在全局事务序列中的顺序达成一致。决定提交或中止事务是由每个服务器单独完成的，但所有服务器都做出相同的决定。如果存在网络分区，导致成员无法达成协议的拆分，则在解决此问题之前，系统不会继续运行。因此也有一个内置的，自动的，分裂的大脑保护机制。</p><p>
        All of this is powered by the provided Group Communication System
        (GCS) protocols. These provide a failure detection mechanism, a
        group membership service, and safe and completely ordered message
        delivery. All these properties are key to creating a system which
        ensures that data is consistently replicated across the group of
        servers. At the very core of this technology lies an implementation
        of the Paxos algorithm. It acts as the group communication engine.
    </p><p style="color:blue;">所有这些都是由提供的组通信系统（GCS）协议提供的。它们提供了故障检测机制、组成员服务以及安全且完全有序的消息传递。所有这些属性都是创建一个系统的关键，该系统确保数据在整个服务器组中一致复制。该技术的核心是paxos算法的实现。它充当组通信引擎。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-replication-technologies"></a>17.1.1&nbsp;Replication Technologies</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-primary-secondary-replication">17.1.1.1 Primary-Secondary Replication</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-summary">17.1.1.2 Group Replication</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286791097392"></a><a class="indexterm" name="idm140286791095888"></a><p>
            Before getting into the details of MySQL Group Replication, this
            section introduces some background concepts and an overview of how
            things work. This provides some context to help understand what is
            required for Group Replication and what the differences are
            between classic asynchronous MySQL Replication and Group
            Replication.
        </p><p style="color:blue;">在详细介绍mysql组复制之前，本节将介绍一些背景概念和工作原理的概述。这提供了一些上下文来帮助理解组复制所需的内容以及经典异步mysql复制和组复制之间的区别。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-primary-secondary-replication"></a>17.1.1.1&nbsp;Primary-Secondary Replication</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286791092432"></a><a class="indexterm" name="idm140286791090928"></a><p>
                Traditional MySQL Replication provides a simple
                Primary-Secondary approach to replication. There is a primary
                (master) and there is one or more secondaries (slaves). The
                primary executes transactions, commits them and then they are
                later (thus asynchronously) sent to the secondaries to be either
                re-executed (in statement-based replication) or applied (in
                row-based replication). It is a shared-nothing system, where all
                servers have a full copy of the data by default.
            </p><p style="color:blue;">传统的mysql复制提供了一种简单的主从复制方法。有一个主（主）和一个或多个辅助（从）。主服务器执行事务，提交它们，然后将它们（因此是异步的）发送到次要服务器，以便重新执行（基于语句的复制）或应用（基于行的复制）。这是一个无共享系统，默认情况下，所有服务器都有数据的完整副本。</p>
                <div class="figure">
                    <a name="idm140286791088480"></a><p class="title"><b>Figure&nbsp;17.1&nbsp;MySQL Asynchronous Replication</b></p><p style="color:blue;">图17.1 MySQL异步复制</p>
                    <div class="figure-contents">

                        <div class="mediaobject">
                            <img src="images/async-replication-diagram.png" width="911" height="315" alt="A transaction received by the master is executed, written to the binary log, then committed, and a response is sent to the client application. The record from the binary log is sent to the relay logs on Slave 1 and Slave 2 before the commit takes place on the master. On each of the slaves, the transaction is applied, written to the slave's binary log, and committed. The commit on the master and the commits on the slaves are all independent and asynchronous.">
                        </div>

                    </div>

                </div>
                <br class="figure-break"><p>
                There is also semisynchronous replication, which adds one
                synchronization step to the protocol. This means that the
                Primary waits, at commit time, for the secondary to acknowledge
                that it has <span class="emphasis"><em>received</em></span> the transaction. Only
                then does the Primary resume the commit operation.
            </p><p style="color:blue;">还有半同步复制，它在协议中增加了一个同步步骤。这意味着主服务器在提交时等待次服务器确认它已收到事务。只有这样，主服务器才能恢复提交操作。</p>
                <div class="figure">
                    <a name="idm140286791080240"></a><p class="title"><b>Figure&nbsp;17.2&nbsp;MySQL Semisynchronous Replication</b></p><p style="color:blue;">图17.2 MySQL半同步复制</p>
                    <div class="figure-contents">

                        <div class="mediaobject">
                            <img src="images/semisync-replication-diagram.png" width="911" height="316" alt="A transaction received by the master is executed and written to the binary log. The record from the binary log is sent to the relay logs on Slave 1 and Slave 2. The master then waits for an acknowledgement from the slaves. When both of the slaves have returned the acknowledgement, the master commits the transaction, and a response is sent to the client application. After each slave has returned its acknowlegement, it applies the transaction, writes it to the binary log, and commits it. The commit on the master depends on the acknowledgement from the slaves, but the commits on the slaves are independent from each other and from the commit on the master.">
                        </div>

                    </div>

                </div>
                <br class="figure-break"><p>
                In the two pictures above, you can see a diagram of the classic
                asynchronous MySQL Replication protocol (and its semisynchronous
                variant as well). Diagonal arrows represent messages exchanged
                between servers or messages exchanged between servers and the
                client application.
            </p><p style="color:blue;">在上面的两张图片中，您可以看到经典的异步mysql复制协议（以及它的半同步变体）的图表。对角箭头表示服务器之间交换的消息或服务器与客户端应用程序之间交换的消息。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-summary"></a>17.1.1.2&nbsp;Group Replication</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791070816"></a><p>
                Group Replication is a technique that can be used to implement
                fault-tolerant systems. The replication group is a set of
                servers that each have their own entire copy of the data (a
                shared-nothing replication scheme), and interact with each other
                through message passing. The communication layer provides a set
                of guarantees such as atomic message and total order message
                delivery. These are very powerful properties that translate into
                very useful abstractions that one can resort to build more
                advanced database replication solutions.
            </p><p style="color:blue;">组复制是一种可用于实现容错系统的技术。复制组是一组服务器，每个服务器都有自己的数据完整副本（无共享复制方案），并通过消息传递相互交互。通信层提供一组保证，如原子消息和总订单消息传递。这些非常强大的属性转化为非常有用的抽象，可以用来构建更高级的数据库复制解决方案。</p><p>
                MySQL Group Replication builds on top of such properties and
                abstractions and implements a multi-master update everywhere
                replication protocol. A replication group is formed by multiple
                servers and each server in the group may execute transactions
                independently at any time. However, all read-write transactions
                commit only after they have been approved by the group. In other
                words, for any read-write transaction the group needs to decide
                whether it commits or not, so the commit operation is not a
                unilateral decision from the originating server. Read-only
                transactions need no coordination within the group and commit
                immediately.
            </p><p style="color:blue;">mysql组复制建立在这些属性和抽象之上，并实现一个多主更新无处不在的复制协议。复制组由多台服务器组成，组中的每台服务器可以随时独立执行事务。但是，所有读写事务只有在经过组批准后才提交。换句话说，对于任何读写事务，组需要决定是否提交，因此提交操作不是来自原始服务器的单方面决定。只读事务不需要在组内进行协调并立即提交。</p><p>
                When a read-write transaction is ready to commit at the
                originating server, the server atomically broadcasts the write
                values (the rows that were changed) and the corresponding write
                set (the unique identifiers of the rows that were updated).
                Because the transaction is sent through an atomic broadcast,
                either all servers in the group receive the transaction or none
                do. If they receive it, then they all receive it in the same
                order with respect to other transactions that were sent before.
                All servers therefore receive the same set of transactions in
                the same order, and a global total order is established for the
                transactions.
            </p><p style="color:blue;">当读写事务准备在原始服务器上提交时，服务器会自动广播写值（已更改的行）和相应的写集（已更新行的唯一标识符）。因为事务是通过原子广播发送的，所以组中的所有服务器要么都接收事务，要么都不接收。如果他们收到了，那么他们都会按照与之前发送的其他交易相同的顺序收到它。因此，所有服务器以相同的顺序接收相同的事务集，并为事务建立全局总顺序。</p><p>
                However, there may be conflicts between transactions that
                execute concurrently on different servers. Such conflicts are
                detected by inspecting and comparing the write sets of two
                different and concurrent transactions, in a process called
                <span class="emphasis"><em>certification</em></span>. During certification,
                conflict detection is carried out at row level: if two
                concurrent transactions, that executed on different servers,
                update the same row, then there is a conflict. The conflict
                resolution procedure states that the transaction that was
                ordered first commits on all servers, and the transaction
                ordered second aborts, and is therefore rolled back on the
                originating server and dropped by the other servers in the
                group. For example, if t1 and t2 execute concurrently at
                different sites, both changing the same row, and t2 is ordered
                before t1, then t2 wins the conflict and t1 is rolled back. This
                is in fact a distributed first commit wins rule. Note that if
                two transactions are bound to conflict more often than not, then
                it is a good practice to start them on the same server, where
                they have a chance to synchronize on the local lock manager
                instead of being rolled back as a result of certification.
            </p><p style="color:blue;">但是，在不同服务器上并发执行的事务之间可能存在冲突。这种冲突是通过检查和比较两个不同的并发事务的写集来检测的，这个过程称为认证。在认证过程中，冲突检测是在行级别进行的：如果在不同服务器上执行的两个并发事务更新同一行，则存在冲突。冲突解决过程声明，首先在所有服务器上提交已排序的事务，然后再中止已排序的事务，并因此在原始服务器上回滚，然后由组中的其他服务器丢弃。例如，如果T1和T2在不同的站点上同时执行，同时更改同一行，并且T2在T1之前排序，那么T2将赢得冲突并回滚T1。这实际上是一个分布式的首次提交获胜规则。请注意，如果两个事务经常会发生冲突，那么最好在同一服务器上启动它们，这样它们就有机会在本地锁管理器上同步，而不是由于证书而回滚。</p><p>
                For applying and externalizing the certified transactions, Group
                Replication permits servers to deviate from the agreed order of
                the transactions if this does not break consistency and
                validity. Group Replication is an eventual consistency system,
                meaning that as soon as the incoming traffic slows down or
                stops, all group members have the same data content. While
                traffic is flowing, transactions can be externalized in a
                slightly different order, or externalized on some members before
                the others. For example, in multi-primary mode, a local
                transaction might be externalized immediately following
                certification, although a remote transaction that is earlier in
                the global order has not yet been applied. This is permitted
                when the certification process has established that there is no
                conflict between the transactions. In single-primary mode, on
                the primary server, there is a small chance that concurrent,
                non-conflicting local transactions might be committed and
                externalized in a different order from the global order agreed
                by Group Replication. On the secondaries, which do not accept
                writes from clients, transactions are always committed and
                externalized in the agreed order.
            </p><p style="color:blue;">对于应用和外部化经认证的事务，组复制允许服务器在不破坏一致性和有效性的情况下偏离商定的事务顺序。组复制是一个最终的一致性系统，这意味着只要传入的流量减慢或停止，所有组成员都具有相同的数据内容。当流量在流动时，事务可以按照稍有不同的顺序外部化，或者在某些成员上外部化，然后在其他成员上外部化。例如，在多主模式下，本地事务可能在认证后立即被外部化，尽管全局顺序较早的远程事务尚未应用。当认证过程确定交易之间没有冲突时，这是允许的。在单主模式下，在主服务器上，以不同于组复制同意的全局顺序的顺序提交和外部化并发的、不冲突的本地事务的可能性很小。在不接受来自客户的写操作的第二方，事务总是按照约定的顺序提交和外部化。</p><p>
                The following figure depicts the MySQL Group Replication
                protocol and by comparing it to MySQL Replication (or even MySQL
                semisynchronous replication) you can see some differences. Note
                that some underlying consensus and Paxos related messages are
                missing from this picture for the sake of clarity.
            </p><p style="color:blue;">下图描述了mysql组复制协议，通过将其与mysql复制（甚至mysql半同步复制）进行比较，您可以看到一些差异。请注意，为了清晰起见，此图中缺少一些基本共识和paxos相关消息。</p>
                <div class="figure">
                    <a name="idm140286791060320"></a><p class="title"><b>Figure&nbsp;17.3&nbsp;MySQL Group Replication Protocol</b></p><p style="color:blue;">图17.3 MySQL组复制协议</p>
                    <div class="figure-contents">

                        <div class="mediaobject">
                            <img src="images/gr-replication-diagram.png" width="898" height="375" alt="A transaction received by Master 1 is executed. Master 1 then sends a message to the replication group, consisting of itself, Master 2, and Master 3. When all three members have reached consensus, they certify the transaction. Master 1 then writes the transaction to its binary log, commits it, and sends a response to the client application. Masters 2 and 3 write the transaction to their relay logs, then apply it, write it to the binary log, and commit it.">
                        </div>

                    </div>

                </div>
                <br class="figure-break">
            </div>

        </div>

        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-use-cases"></a>17.1.2&nbsp;Group Replication Use Cases</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-examples-of-use-case-scenarios">17.1.2.1 Examples of Use Case Scenarios</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286791051712"></a><p>
            Group Replication enables you to create fault-tolerant systems
            with redundancy by replicating the system state to a set of
            servers. Even if some of the servers subsequently fail, as long it
            is not all or a majority, the system is still available. Depending
            on the number of servers which fail the group might have degraded
            performance or scalability, but it is still available. Server
            failures are isolated and independent. They are tracked by a group
            membership service which relies on a distributed failure detector
            that is able to signal when any servers leave the group, either
            voluntarily or due to an unexpected halt. There is a distributed
            recovery procedure to ensure that when servers join the group they
            are brought up to date automatically. There is no need for server
            fail-over, and the multi-master update everywhere nature ensures
            that even updates are not blocked in the event of a single server
            failure. To summarize, MySQL Group Replication guarantees that the
            database service is continuously available.
        </p><p style="color:blue;">组复制使您能够通过将系统状态复制到一组服务器来创建具有冗余的容错系统。即使一些服务器随后出现故障，只要不是全部或大部分，系统仍然可用。根据失败的服务器数量，组的性能或可伸缩性可能会降低，但它仍然可用。服务器故障是独立的。它们由一个组成员服务跟踪，该服务依赖于一个分布式故障检测器，该检测器能够在任何服务器自愿或由于意外停止而离开组时发出信号。有一个分布式恢复过程来确保服务器加入组时自动更新它们。不需要服务器故障转移，而且多主更新无处不在的特性确保即使是更新也不会在单个服务器发生故障时被阻止。总之，mysql组复制保证数据库服务持续可用。</p><p>
            It is important to understand that although the database service
            is available, in the event of a server crash, those clients
            connected to it must be redirected, or failed over, to a different
            server. This is not something Group Replication attempts to
            resolve. A connector, load balancer, router, or some form of
            middleware are more suitable to deal with this issue. For example
            see <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router 8.0</a>.


        </p><p style="color:blue;">必须了解，虽然数据库服务可用，但在服务器崩溃时，必须将连接到该服务的客户端重定向或故障转移到其他服务器。这不是组复制试图解决的问题。连接器、负载平衡器、路由器或某种形式的中间件更适合处理此问题。例如，请参见mysql router 8.0。</p><p>
            To summarize, MySQL Group Replication provides a highly available,
            highly elastic, dependable MySQL service.
        </p><p style="color:blue;">总之，mysql组复制提供了一个高可用、高弹性、可靠的mysql服务。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-examples-of-use-case-scenarios"></a>17.1.2.1&nbsp;Examples of Use Case Scenarios</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286791043408"></a><p>
                The following examples are typical use cases for Group
                Replication.
            </p><p style="color:blue;">以下示例是组复制的典型用例。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="emphasis"><em>Elastic Replication</em></span> - Environments that
                        require a very fluid replication infrastructure, where the
                        number of servers has to grow or shrink dynamically and with
                        as few side-effects as possible. For instance, database
                        services for the cloud.
                    </p><p style="color:blue;">弹性复制—需要非常灵活的复制基础架构的环境，其中服务器的数量必须动态增长或收缩，并且尽可能减少副作用。例如，云的数据库服务。</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Highly Available Shards</em></span> - Sharding is a
                        popular approach to achieve write scale-out. Use MySQL Group
                        Replication to implement highly available shards, where each
                        shard maps to a replication group.
                    </p><p style="color:blue;">高可用碎片-碎片化是实现写扩展的一种流行方法。使用mysql group replication实现高可用碎片，其中每个碎片映射到一个复制组。</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Alternative to Master-Slave replication</em></span>
                        - In certain situations, using a single master server makes
                        it a single point of contention. Writing to an entire group
                        may prove more scalable under certain circumstances.


                    </p><p style="color:blue;">主-从复制的替代方案-在某些情况下，使用单个主服务器使其成为单个争用点。在某些情况下，向整个组写入数据可能会更具伸缩性。</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Autonomic Systems</em></span> - Additionally, you
                        can deploy MySQL Group Replication purely for the automation
                        that is built into the replication protocol (described
                        already in this and previous chapters).


                    </p><p style="color:blue;">自主系统-此外，您可以部署mysql组复制，这纯粹是为了实现复制协议中内置的自动化（在本章和前几章中已经介绍过）。</p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-details"></a>17.1.3&nbsp;Group Replication Details</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-group-membership">17.1.3.1 Group Membership</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-failure-detection">17.1.3.2 Failure Detection</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-fault-tolerance">17.1.3.3 Fault-tolerance</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286791032304"></a><p>
            This section presents details about some of the services that
            Group Replication builds on.
        </p><p style="color:blue;">本节介绍了有关组复制所基于的某些服务的详细信息。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-group-membership"></a>17.1.3.1&nbsp;Group Membership</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286791029136"></a><a class="indexterm" name="idm140286791027648"></a><p>
                In MySQL Group Replication, a set of servers forms a replication
                group. A group has a name, which takes the form of a UUID. The
                group is dynamic and servers can leave (either voluntarily or
                involuntarily) and join it at any time. The group adjusts itself
                whenever servers join or leave.
            </p><p style="color:blue;">在mysql组复制中，一组服务器构成一个复制组。组有一个名称，其形式为uuid。该组是动态的，服务器可以随时离开（自愿或非自愿）并加入它。每当服务器加入或离开时，组会自动调整。</p><p>
                If a server joins the group, it automatically brings itself up
                to date by fetching the missing state from an existing server.
                If a server leaves the group, for instance it was taken down for
                maintenance, the remaining servers notice that it has left and
                reconfigure the group automatically.
            </p><p style="color:blue;">如果一个服务器加入了该组，它就可以通过从现有服务器中获取丢失的状态来自动更新自己。如果某个服务器离开组（例如，它是为了维护而被取下的），则其余的服务器会注意到它已经离开并自动重新配置该组。</p><p>
                Group Replication has a group membership service that defines
                which servers are online and participating in the group. The
                list of online servers is referred to as a
                <span class="emphasis"><em>view</em></span>. Every server in the group has a
                consistent view of which servers are the members participating
                actively in the group at a given moment in time.
            </p><p style="color:blue;">组复制具有组成员身份服务，该服务定义哪些服务器处于联机状态并参与组。联机服务器的列表称为视图。组中的每个服务器都有一个一致的视图，可以看到哪些服务器是在给定时间内积极参与组的成员。</p><p>
                Group members must agree not only on transaction commits, but
                also on which is the current view. If existing members agree
                that a new server should become part of the group, the group is
                reconfigured to integrate that server in it, which triggers a
                view change. If a server leaves the group, either voluntarily or
                not, the group dynamically rearranges its configuration and a
                view change is triggered.
            </p><p style="color:blue;">组成员不仅必须就事务提交达成一致，而且还必须就当前视图达成一致。如果现有成员同意一个新的服务器应该成为该组的一部分，则将该组重新配置为将该服务器集成在其中，从而触发视图更改。如果服务器自愿或不自愿离开组，则组将动态重新排列其配置并触发视图更改。</p><p>
                In the case where a member leaves the group voluntarily, it
                first initiates a dynamic group reconfiguration, during which
                all members have to agree on a new view without the leaving
                server. However, if a member leaves the group involuntarily, for
                example because it has stopped unexpectedly or the network
                connection is down, it cannot initiate the reconfiguration. In
                this situation, Group Replication's failure detection mechanism
                recognizes after a short period of time that the member has
                left, and a reconfiguration of the group without the failed
                member is proposed. As with a member that leaves voluntarily,
                the reconfiguration requires agreement from the majority of
                servers in the group. However, if the group is not able to reach
                agreement, for example because it partitioned in such a way that
                there is no majority of servers online, the system is not able
                to dynamically change the configuration, and blocks to prevent a
                split-brain situation. This situation requires intervention from
                an administrator.
            </p><p style="color:blue;">在成员自愿离开组的情况下，它首先启动动态组重新配置，在此过程中，所有成员必须在不离开服务器的情况下就新视图达成一致。但是，如果某个成员非自愿离开组，例如因为它意外停止或网络连接断开，则它无法启动重新配置。在这种情况下，组复制的故障检测机制会在成员离开后的一段短时间内识别出该成员，并建议在没有失败成员的情况下重新配置该组。与自愿离开的成员一样，重新配置需要得到组中大多数服务器的同意。然而，如果该组无法达成一致，例如，由于其分区方式使得没有大多数服务器在线，则系统无法动态更改配置，并阻止出现拆分大脑的情况。这种情况需要管理员的干预。</p><p>
                It is possible for a member to go offline for a short time, then
                attempt to rejoin the group again before the failure detection
                mechanism has detected its failure, and before the group has
                been reconfigured to remove the member. In this situation, the
                rejoining member forgets its previous state, but if other
                members send it messages that are intended for its pre-crash
                state, this can cause issues including possible data
                inconsistency. If a member in this situation participates in
                XCom's consensus protocol, it could potentially cause XCom to
                deliver different values for the same consensus round, by making
                a different decision before and after failure.
            </p><p style="color:blue;">成员可能会脱机很短时间，然后在故障检测机制检测到其故障之前，以及在重新配置组以删除该成员之前，再次尝试重新加入该组。在这种情况下，重新加入的成员会忘记其先前的状态，但如果其他成员向其发送的消息是针对其崩溃前状态的，则这可能会导致包括可能的数据不一致在内的问题。如果这种情况下的一个成员参与xcom的协商一致协议，它可能会导致xcom在失败之前和失败之后做出不同的决策，从而为同一协商一致回合提供不同的值。</p><p>
                To counter this possibility, from MySQL 5.7.22, servers are
                given a unique identifier when they join a group. This enables
                Group Replication to be aware of the situation where a new
                incarnation of the same server (with the same address but a new
                identifier) is trying to join the group while its old
                incarnation is still listed as a member. The new incarnation is
                blocked from joining the group until the old incarnation can be
                removed by a reconfiguration. If Group Replication is stopped
                and restarted on the server, the member becomes a new
                incarnation and cannot rejoin until the suspicion times out.
            </p><p style="color:blue;">为了应对这种可能性，在mysql 5.7.22中，服务器在加入组时被赋予一个唯一的标识符。这使组复制能够了解这样的情况：同一服务器的新化身（具有相同的地址，但有一个新的标识符）试图加入组，而其旧化身仍列为成员。新的化身被阻止加入这个团体，直到旧的化身可以被重新配置移除。如果组复制在服务器上停止并重新启动，则该成员将成为新的化身，并且在怀疑超时之前无法重新加入。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-failure-detection"></a>17.1.3.2&nbsp;Failure Detection</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286791017520"></a><a class="indexterm" name="idm140286791016032"></a><p>
                Group Replication includes a failure detection mechanism that is
                able to find and report which servers are silent and as such
                assumed to be dead. At a high level, the failure detector is a
                distributed service that provides information about which
                servers may be dead (suspicions). Suspicions are triggered when
                servers go mute. When server A does not receive messages from
                server B during a given period, a timeout occurs and a suspicion
                is raised. Later if the group agrees that the suspicions are
                probably true, then the group decides that a given server has
                indeed failed. This means that the remaining members in the
                group take a coordinated decision to exclude a given member.
            </p><p style="color:blue;">组复制包括一个故障检测机制，该机制能够查找和报告哪些服务器处于静默状态，因此假设这些服务器已死亡。在较高级别上，故障检测器是一个分布式服务，它提供有关哪些服务器可能已死亡（怀疑）的信息。当服务器静音时会触发怀疑。当服务器A在给定时间段内未从服务器B接收到消息时，将发生超时并引发怀疑。稍后，如果该组同意怀疑可能是真的，则该组将确定给定服务器确实已失败。这意味着组中的其余成员将采取协调一致的决定来排除给定的成员。</p><p>
                Suspicions are triggered when servers go mute. When server A
                does not receive messages from server B during a given period, a
                timeout occurs and a suspicion is raised.
            </p><p style="color:blue;">当服务器静音时会触发怀疑。当服务器A在给定时间段内未从服务器B接收到消息时，将发生超时并引发怀疑。</p><p>
                If a server gets isolated from the rest of the group, then it
                suspects that all others have failed. Being unable to secure
                agreement with the group (as it cannot secure a quorum), its
                suspicion does not have consequences. When a server is isolated
                from the group in this way, it is unable to execute any local
                transactions.
            </p><p style="color:blue;">如果服务器与组中的其他服务器隔离，则它怀疑所有其他服务器都已失败。由于无法确保与集团达成协议（因为集团无法确保法定人数），其怀疑不会产生任何后果。当服务器以这种方式与组隔离时，它无法执行任何本地事务。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-fault-tolerance"></a>17.1.3.3&nbsp;Fault-tolerance</h4>

                        </div>

                    </div>

                </div>
                <p>
                    MySQL Group Replication builds on an implementation of the Paxos
                    distributed algorithm to provide distributed coordination
                    between servers. As such, it requires a majority of servers to
                    be active to reach quorum and thus make a decision. This has
                    direct impact on the number of failures the system can tolerate
                    without compromising itself and its overall functionality. The
                    number of servers (n) needed to tolerate <code class="literal">f</code>
                    failures is then <code class="literal">n = 2 x f + 1</code>.
                </p><p style="color:blue;">mysql组复制构建在paxos分布式算法的实现之上，以提供服务器之间的分布式协调。因此，它要求大多数服务器处于活动状态才能达到仲裁，从而做出决定。这直接影响到系统在不影响自身和整体功能的情况下能够容忍的故障数量。容忍f故障所需的服务器数量（n）为n=2 x f+1。</p><p>
                In practice this means that to tolerate one failure the group
                must have three servers in it. As such if one server fails,
                there are still two servers to form a majority (two out of
                three) and allow the system to continue to make decisions
                automatically and progress. However, if a second server fails
                <span class="emphasis"><em>involuntarily</em></span>, then the group (with one
                server left) blocks, because there is no majority to reach a
                decision.
            </p><p style="color:blue;">实际上，这意味着要容忍一个故障，组中必须有三个服务器。因此，如果一台服务器出现故障，仍有两台服务器构成多数（三台服务器中的两台），并允许系统继续自动作出决定并继续进行。但是，如果第二台服务器非自愿地失败，那么组（只剩下一台服务器）就会阻塞，因为没有多数人可以做出决定。</p><p>
                The following is a small table illustrating the formula above.
            </p><p style="color:blue;">下面是一个小表格，说明了上面的公式。</p>
                <div class="informaltable">
                    <table summary="Relationship between replication group size, the number of servers that constitute a majority, and the number of instant failures that can be tolerated."><colgroup><col width="0.23%"><col width="0.18%"><col width="0.59%"></colgroup><thead><tr>
                        <th scope="col"><p>
                            Group Size
                        </p><p style="color:blue;">组大小</p></th>
                        <th scope="col"><p>
                            Majority
                        </p><p style="color:blue;">多数</p></th>
                        <th scope="col"><p>
                            Instant Failures Tolerated
                        </p><p style="color:blue;">可容忍的瞬间故障</p></th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">零</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            2
                        </p><p style="color:blue;">二</p></td>
                        <td><p>
                            2
                        </p><p style="color:blue;">2个</p></td>
                        <td><p>
                            0
                        </p><p style="color:blue;">零</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            3
                        </p><p style="color:blue;">三</p></td>
                        <td><p>
                            2
                        </p><p style="color:blue;">2个</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            4
                        </p><p style="color:blue;">四</p></td>
                        <td><p>
                            3
                        </p><p style="color:blue;">三</p></td>
                        <td><p>
                            1
                        </p><p style="color:blue;">1个</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            5
                        </p><p style="color:blue;">五</p></td>
                        <td><p>
                            3
                        </p><p style="color:blue;">三</p></td>
                        <td><p>
                            2
                        </p><p style="color:blue;">2个</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            6
                        </p><p style="color:blue;">6个</p></td>
                        <td><p>
                            4
                        </p><p style="color:blue;">四</p></td>
                        <td><p>
                            2
                        </p><p style="color:blue;">2个</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            7
                        </p><p style="color:blue;">七</p></td>
                        <td><p>
                            4
                        </p><p style="color:blue;">4个</p></td>
                        <td><p>
                            3
                        </p><p style="color:blue;">三</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The next Chapter covers technical aspects of Group Replication.


                </p><p style="color:blue;">下一章将介绍组复制的技术方面。</p>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="group-replication-getting-started"></a>17.2&nbsp;Getting Started</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-single-primary-mode">17.2.1 Deploying Group Replication in Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-deploying-locally">17.2.2 Deploying Group Replication Locally</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286790969472"></a><p>
        MySQL Group Replication is provided as a plugin to MySQL server, and
        each server in a group requires configuration and installation of
        the plugin. This section provides a detailed tutorial with the steps
        required to create a replication group with at least three members.
    </p><p style="color:blue;">mysql组复制作为mysql服务器的插件提供，组中的每台服务器都需要配置和安装该插件。本节提供了一个详细的教程，介绍创建至少包含三个成员的复制组所需的步骤。</p>
        <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">

            <div class="admon-title">
                Tip
            </div>
            <p>
                An alternative way to deploy multiple instances of MySQL is by
                using InnoDB cluster, which uses Group Replication and wraps it
                in a programmatic environment that enables you to easily work with
                groups of MySQL server instances in the
                <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/en/" target="_top">MySQL Shell 8.0 (part of MySQL 8.0)</a>. In addition, InnoDB cluster
                interfaces seamlessly with MySQL Router and simplifies deploying MySQL
                with high availability. See
                <a class="xref" href="mysql-innodb-cluster-userguide.html" title="Chapter&nbsp;20&nbsp;InnoDB Cluster">Chapter&nbsp;20, <i>InnoDB Cluster</i></a>.
            </p><p style="color:blue;">部署多个mysql实例的另一种方法是使用innodb cluster，它使用组复制，并将其包装在编程环境中，使您能够轻松地使用mysql shell 8.0（mysql 8.0的一部分）中的mysql服务器实例组。此外，InnoDB集群与MySQL路由器无缝对接，简化了MySQL的高可用性部署。见第20章，InnoDB集群。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-deploying-in-single-primary-mode"></a>17.2.1&nbsp;Deploying Group Replication in Single-Primary Mode</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-getting-started-deploying-instances">17.2.1.1 Deploying Instances for Group Replication</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-configuring-instances">17.2.1.2 Configuring an Instance for Group Replication</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-user-credentials">17.2.1.3 User Credentials</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-launching">17.2.1.4 Launching Group Replication</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-bootstrap">17.2.1.5 Bootstrapping the Group</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-adding-instances">17.2.1.6 Adding Instances to the Group</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286790963440"></a><p>
            Each of the MySQL server instances in a group can run on an
            independent physical host machine, which is the recommended way to
            deploy Group Replication. This section explains how to create a
            replication group with three MySQL Server instances, each running
            on a different host machine. See
            <a class="xref" href="group-replication.html#group-replication-deploying-locally" title="17.2.2&nbsp;Deploying Group Replication Locally">Section&nbsp;17.2.2, “Deploying Group Replication Locally”</a> for
            information about deploying multiple MySQL server instances
            running Group Replication on the same host machine, for example
            for testing purposes.
        </p><p style="color:blue;">组中的每个mysql服务器实例都可以在独立的物理主机上运行，这是部署组复制的推荐方法。本节介绍如何创建一个复制组，其中包含三个mysql服务器实例，每个实例运行在不同的主机上。有关在同一主机上部署运行组复制的多个mysql服务器实例的信息（例如，出于测试目的），请参见第17.2.2节“在本地部署组复制”。</p>
            <div class="figure">
                <a name="idm140286790960192"></a><p class="title"><b>Figure&nbsp;17.4&nbsp;Group Architecture</b></p><p style="color:blue;">图17.4集团架构</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/gr-3-server-group.png" width="312" height="332" alt="Three server instances, S1, S2, and S3, are deployed as an interconnected group, and clients communicate with each of the server instances.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            This tutorial explains how to get and deploy MySQL Server with the
            Group Replication plugin, how to configure each server instance
            before creating a group, and how to use Performance Schema
            monitoring to verify that everything is working correctly.
        </p><p style="color:blue;">本教程介绍如何使用组复制插件获取和部署mysql服务器，如何在创建组之前配置每个服务器实例，以及如何使用性能模式监视来验证一切正常工作。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-getting-started-deploying-instances"></a>17.2.1.1&nbsp;Deploying Instances for Group Replication</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286790951568"></a><p>
                The first step is to deploy at least three instances of MySQL
                Server, this procedure demonstrates using multiple hosts for the
                instances, named s1, s2 and s3. It is assumed that MySQL Server
                was installed on each of the hosts, see
                <a class="xref" href="installing.html" title="Chapter&nbsp;2&nbsp;Installing and Upgrading MySQL">Chapter&nbsp;2, <i>Installing and Upgrading MySQL</i></a>. Group Replication is a built-in
                MySQL plugin provided with MySQL Server 5.7.17 and later. For
                more background information on MySQL plugins, see
                <a class="xref" href="server-administration.html#server-plugins" title="5.5&nbsp;MySQL Server Plugins">Section&nbsp;5.5, “MySQL Server Plugins”</a>.
            </p><p style="color:blue;">第一步是部署至少三个mysql服务器实例，此过程演示如何为实例使用多个主机，分别命名为s1、s2和s3。假设每个主机上都安装了mysql服务器，请参阅第2章，安装和升级mysql。组复制是MySQLServer5.7.17及更高版本提供的内置MySQL插件。有关mysql插件的更多背景信息，请参见5.5节“mysql服务器插件”。</p><p>
                In this example, three instances are used for the group, which
                is the minimum number of instances to create a group. Adding
                more instances increases the fault tolerance of the group. For
                example if the group consists of three members, in event of
                failure of one instance the group can continue. But in the event
                of another failure the group can no longer continue processing
                write transactions. By adding more instances, the number of
                servers which can fail while the group continues to process
                transactions also increases. The maximum number of instances
                which can be used in a group is nine. For more information see
                <a class="xref" href="group-replication.html#group-replication-failure-detection" title="17.1.3.2&nbsp;Failure Detection">Section&nbsp;17.1.3.2, “Failure Detection”</a>.
            </p><p style="color:blue;">在本例中，组使用三个实例，这是创建组的最小实例数。添加更多实例会增加组的容错性。例如，如果组由三个成员组成，则在一个实例失败时，组可以继续。但在另一个失败的情况下，该组不能再继续处理写事务。通过添加更多实例，可以在组继续处理事务时失败的服务器数量也会增加。可以在组中使用的实例的最大数目是九。有关更多信息，请参见第17.1.3.2节“故障检测”。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-configuring-instances"></a>17.2.1.2&nbsp;Configuring an Instance for Group Replication</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286790944448"></a><p>
                This section explains the configuration settings required for
                MySQL Server instances that you want to use for Group
                Replication. For background information, see
                <a class="xref" href="group-replication.html#group-replication-requirements-and-limitations" title="17.7&nbsp;Requirements and Limitations">Section&nbsp;17.7, “Requirements and Limitations”</a>.
            </p><p style="color:blue;">本节介绍要用于组复制的mysql服务器实例所需的配置设置。背景资料见第17.7节“要求和限制”。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-storage-engines" title="Storage Engines">Storage Engines</a></p><p style="color:blue;">存储引擎</p></li><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-configure-replication-framework" title="Replication Framework">Replication Framework</a></p><p style="color:blue;">复制框架</p></li><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-configure-plugin" title="Group Replication Settings">Group Replication Settings</a></p><p style="color:blue;">组复制设置</p></li></ul>
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="group-replication-storage-engines"></a>Storage Engines</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        For Group Replication, data must be stored in the InnoDB
                        transactional storage engine (for details of why, see
                        <a class="xref" href="group-replication.html#group-replication-requirements" title="17.7.1&nbsp;Group Replication Requirements">Section&nbsp;17.7.1, “Group Replication Requirements”</a>). The use of
                        other storage engines, including the temporary
                        <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> storage engine, might
                        cause errors in Group Replication. Set the
                        <a class="link" href="server-administration.html#sysvar_disabled_storage_engines"><code class="literal">disabled_storage_engines</code></a>
                        system variable as follows to prevent their use:
                    </p><p style="color:blue;">对于组复制，数据必须存储在innodb事务性存储引擎中（有关原因的详细信息，请参阅第17.7.1节“组复制要求”）。使用其他存储引擎（包括临时内存存储引擎）可能会导致组复制中出现错误。按如下所示设置DISABLED U STORAGE U ENGINES系统变量以防止其使用：</p><pre data-lang="ini" class="programlisting">disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"
</pre><p>
                    Note that with the <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2&nbsp;The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> storage
                    engine disabled, when you are upgrading a MySQL instance to a
                    release where <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a> is still used
                    (before MySQL 8.0.16), <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a> might
                    fail with an error. To handle this, you can re-enable that
                    storage engine while you run <a class="link" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a>,
                    then disable it again when you restart the server. For more
                    information, see <a class="xref" href="programs.html#mysql-upgrade" title="4.4.7&nbsp;mysql_upgrade — Check and Upgrade MySQL Tables">Section&nbsp;4.4.7, “<span class="command"><strong>mysql_upgrade</strong></span> — Check and Upgrade MySQL Tables”</a>.
                </p><p style="color:blue;">请注意，在禁用myisam存储引擎的情况下，将mysql实例升级到仍在使用mysql_upgrade的版本（在mysql 8.0.16之前）时，mysql_upgrade可能会失败并出现错误。要处理此问题，可以在运行mysql_upgrade时重新启用该存储引擎，然后在重新启动服务器时再次禁用它。有关详细信息，请参阅4.4.7节，“mysql_upgrade-检查和升级mysql表”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="group-replication-configure-replication-framework"></a>Replication Framework</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The following settings configure replication according to the
                        MySQL Group Replication requirements.
                    </p><p style="color:blue;">以下设置根据mysql组复制要求配置复制。</p><pre data-lang="ini" class="programlisting">server_id=1
gtid_mode=ON
enforce_gtid_consistency=ON
master_info_repository=TABLE
relay_log_info_repository=TABLE
binlog_checksum=NONE
log_slave_updates=ON
log_bin=binlog
binlog_format=ROW
</pre><p>
                    These settings configure the server to use the unique
                    identifier number 1, to enable global transaction identifiers
                    and to store replication metadata in system tables instead of
                    files. Additionally, it instructs the server to turn on binary
                    logging, use row-based format and disable binary log event
                    checksums. For more details see
                    <a class="xref" href="group-replication.html#group-replication-requirements" title="17.7.1&nbsp;Group Replication Requirements">Section&nbsp;17.7.1, “Group Replication Requirements”</a>.
                </p><p style="color:blue;">这些设置将服务器配置为使用唯一标识符1，启用全局事务标识符，并将复制元数据存储在系统表而不是文件中。此外，它还指示服务器启用二进制日志记录、使用基于行的格式和禁用二进制日志事件校验和。有关更多详细信息，请参阅第17.7.1节“组复制要求”。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="group-replication-configure-plugin"></a>Group Replication Settings</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        At this point the option file ensures that the server is
                        configured and is instructed to instantiate the replication
                        infrastructure under a given configuration. The following
                        section configures the Group Replication settings for the
                        server.
                    </p><p style="color:blue;">此时，选项文件确保服务器已配置，并指示在给定配置下实例化复制基础结构。以下部分配置服务器的组复制设置。</p><pre data-lang="ini" class="programlisting">plugin_load_add='group_replication.so
transaction_write_set_extraction=XXHASH64
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot=off
group_replication_local_address= "s1:33061"
group_replication_group_seeds= "s1:33061,s2:33061,s3:33061"
group_replication_bootstrap_group=off
</pre>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="option">plugin-load-add</code> adds the Group
                            Replication plugin to the list of plugins which the server
                            loads at startup. This is preferable in a production
                            deployment to installing the plugin manually.
                        </p><p style="color:blue;">plugin load add将组复制插件添加到服务器在启动时加载的插件列表中。在生产部署中，这比手动安装插件更可取。</p></li><li class="listitem"><p>
                            Configuring
                            <a class="link" href="group-replication.html#sysvar_group_replication_group_name"><code class="literal">group_replication_group_name</code></a>
                            tells the plugin that the group that it is joining, or
                            creating, is named
                            "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa".
                        </p><p style="color:blue;">配置group_replication_group_name告诉插件它正在加入或创建的组名为“aaaa aaaa-aaaa-aaaa-aaaa-aaaa-aaaa-aaaaaaaa”。</p><p>
                            The value of
                            <a class="link" href="group-replication.html#sysvar_group_replication_group_name"><code class="literal">group_replication_group_name</code></a>
                            must be a valid UUID. This UUID is used internally when
                            setting GTIDs for Group Replication events in the binary
                            log. You can use <code class="literal">SELECT UUID()</code> to
                            generate a UUID.
                        </p><p style="color:blue;">组复制组名的值必须是有效的uuid。在为二进制日志中的组复制事件设置gtid时，在内部使用此uuid。可以使用select uuid（）生成uuid。</p></li><li class="listitem"><p>
                            Configuring the
                            <a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot"><code class="literal">group_replication_start_on_boot</code></a>
                            variable to <code class="literal">off</code> instructs the plugin to
                            not start operations automatically when the server starts.
                            This is important when setting up Group Replication as it
                            ensures you can configure the server before manually
                            starting the plugin. Once the member is configured you can
                            set
                            <a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot"><code class="literal">group_replication_start_on_boot</code></a>
                            to <code class="literal">on</code> so that Group Replication starts
                            automatically upon server boot.
                        </p><p style="color:blue;">将group_replication_start_on_boot变量配置为off会指示插件在服务器启动时不会自动启动操作。这在设置组复制时很重要，因为它确保您可以在手动启动插件之前配置服务器。配置成员后，可以将group_replication_start_on_boot设置为on，以便组复制在服务器启动时自动启动。</p></li><li class="listitem"><p>
                            Configuring
                            <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                            sets the network address and port which the member uses
                            for internal communication with other members in the
                            group. Group Replication uses this address for internal
                            member-to-member connections involving remote instances of
                            the group communication engine (XCom, a Paxos variant).
                        </p><p style="color:blue;">配置组复制本地地址设置成员用于与组中其他成员进行内部通信的网络地址和端口。组复制将此地址用于涉及组通信引擎（xcom，paxos变体）的远程实例的内部成员到成员的连接。</p>
                            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Important
                                </div>
                                <p>
                                    This address must be different to the
                                    <a class="link" href="server-administration.html#sysvar_hostname"><code class="literal">hostname</code></a> and
                                    <a class="link" href="server-administration.html#sysvar_port"><code class="literal">port</code></a> used for SQL and
                                    it must not be used for client applications. It must be
                                    only be used for internal communication between the
                                    members of the group while running Group Replication.
                                </p><p style="color:blue;">此地址必须与用于SQL的主机名和端口不同，并且不能用于客户端应用程序。它只能用于运行组复制时组成员之间的内部通信。</p>
                            </div>
                            <p>
                                The network address configured by
                                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                                must be resolvable by all group members. For example, if
                                each server instance is on a different machine with a
                                fixed network address, you could use the IP address of the
                                machine, such as 10.0.0.1. If you use a host name, you
                                must use a fully qualified name, and ensure it is
                                resolvable through DNS, correctly configured
                                <code class="literal">/etc/hosts</code> files, or other name
                                resolution processes. From MySQL 8.0.14, IPv6 addresses
                                (or host names that resolve to them) can be used as well
                                as IPv4 addresses. A group can contain a mix of members
                                using IPv6 and members using IPv4. For more information on
                                Group Replication support for IPv6 networks and on mixed
                                IPv4 and IPv6 groups, see
                                <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/group-replication-ipv6.html" target="_top">Support For IPv6 And For Mixed IPv6 And IPv4 Groups</a>.
                            </p><p style="color:blue;">由组复制本地地址配置的网络地址必须可由所有组成员解析。例如，如果每个服务器实例位于具有固定网络地址的不同计算机上，则可以使用该计算机的IP地址，例如10.0.0.1。如果使用主机名，则必须使用完全限定的名称，并确保可以通过dns、正确配置的/etc/hosts文件或其他名称解析过程对其进行解析。在mysql 8.0.14中，可以使用ipv6地址（或解析为这些地址的主机名）和ipv4地址。组可以包含使用IPv6的成员和使用IPv4的成员的组合。有关IPv6网络以及IPv4和IPv6混合组的组复制支持的详细信息，请参阅对IPv6的支持以及对IPv6和IPv4混合组的支持。</p><p>
                                The recommended port for
                                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                                is 33061.
                                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                                is used by Group Replication as the unique identifier for
                                a group member within the replication group. You can use
                                the same port for all members of a replication group as
                                long as the host names or IP addresses are all different,
                                as demonstrated in this tutorial. Alternatively you can
                                use the same host name or IP address for all members as
                                long as the ports are all different, for example as shown
                                in <a class="xref" href="group-replication.html#group-replication-deploying-locally" title="17.2.2&nbsp;Deploying Group Replication Locally">Section&nbsp;17.2.2, “Deploying Group Replication Locally”</a>.
                            </p><p style="color:blue;">组复制本地地址的建议端口是33061。组复制使用组复制本地地址作为复制组内组成员的唯一标识符。只要主机名或IP地址都不同，就可以对复制组的所有成员使用同一端口，如本教程所示。或者，您可以为所有成员使用相同的主机名或IP地址，只要端口都不同，例如，如17.2.2节“在本地部署组复制”中所示。</p></li><li class="listitem"><p>
                            Configuring
                            <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
                            sets the hostname and port of the group members which are
                            used by the new member to establish its connection to the
                            group. These members are called the seed members. Once the
                            connection is established, the group membership
                            information is listed at
                            <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>.
                            Usually the
                            <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
                            list contains the <code class="literal">hostname:port</code> of each
                            of the group member's
                            <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>,
                            but this is not obligatory and a subset of the group
                            members can be chosen as seeds.
                        </p><p style="color:blue;">配置group_replication_group_seeds设置组成员的主机名和端口，新成员使用这些主机名和端口来建立与组的连接。这些成员称为种子成员。建立连接后，组成员身份信息将列在Performance_schema.replication_group_members中。通常，group_replication_group_seeds列表包含组成员的每个group_replication_local_地址的主机名：端口，但这不是必需的，可以选择组成员的子集作为种子。</p>
                            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Important
                                </div>
                                <p>
                                    The <code class="literal">hostname:port</code> listed in
                                    <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
                                    is the seed member's internal network address,
                                    configured by
                                    <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                                    and not the SQL <code class="literal">hostname:port</code> used
                                    for client connections, and shown for example in
                                    <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
                                    table.
                                </p><p style="color:blue;">组复制组种子中列出的hostname:port是种子成员的内部网络地址，由组复制本地地址配置，而不是用于客户端连接的sql hostname:port，例如显示在performance_schema.replication_group_member s表中。</p>
                            </div>
                            <p>
                                The server that starts the group does not make use of this
                                option, since it is the initial server and as such, it is
                                in charge of bootstrapping the group. In other words, any
                                existing data which is on the server bootstrapping the
                                group is what is used as the data for the next joining
                                member. The second server joining asks the one and only
                                member in the group to join, any missing data on the
                                second server is replicated from the donor data on the
                                bootstrapping member, and then the group expands. The
                                third server joining can ask any of these two to join,
                                data is synchronized to the new member, and then the group
                                expands again. Subsequent servers repeat this procedure
                                when joining.
                            </p><p style="color:blue;">启动组的服务器不使用此选项，因为它是初始服务器，因此负责引导组。换句话说，在服务器上引导该组的任何现有数据是用作下一个加入成员的数据。第二个服务器加入请求组中唯一的成员加入，第二个服务器上丢失的数据将从引导成员上的捐助数据复制，然后组将展开。第三个服务器加入可以要求这两个成员中的任何一个加入，数据被同步到新成员，然后组再次扩展。后续服务器在加入时重复此过程。</p>
                            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Warning
                                </div>
                                <p>
                                    When joining multiple servers at the same time, make
                                    sure that they point to seed members that are already in
                                    the group. Do not use members that are also joining the
                                    group as seeds, because they might not yet be in the
                                    group when contacted.
                                </p><p style="color:blue;">同时加入多个服务器时，请确保它们指向已在组中的种子成员。不要使用同时加入组的成员作为种子，因为当联系他们时，他们可能还不在组中。</p><p>
                                It is good practice to start the bootstrap member first,
                                and let it create the group. Then make it the seed
                                member for the rest of the members that are joining.
                                This ensures that there is a group formed when joining
                                the rest of the members.
                            </p><p style="color:blue;">最好先启动引导成员，然后让它创建组。然后让它成为其他加入的成员的种子成员。这样可以确保在加入其他成员时形成一个组。</p><p>
                                Creating a group and joining multiple members at the
                                same time is not supported. It might work, but chances
                                are that the operations race and then the act of joining
                                the group ends up in an error or a time out.
                            </p><p style="color:blue;">不支持同时创建组和加入多个成员。它可能会起作用，但很有可能是操作竞争，然后加入组的行为最终会出现错误或超时。</p>
                            </div>
                        </li><li class="listitem"><p>
                            Configuring
                            <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
                            instructs the plugin whether to bootstrap the group or
                            not. In this case, even though s1 is the first member of
                            the group we set this variable to off in the option file.
                            Instead we configure
                            <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
                            when the instance is running, to ensure that only one
                            member actually bootstraps the group.
                        </p><p style="color:blue;">配置组复制引导组指示插件是否引导该组。在这种情况下，即使s1是组的第一个成员，我们在选项文件中将此变量设置为off。相反，我们在实例运行时配置group_replication_bootstrap_group，以确保只有一个成员实际引导该组。</p>
                            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Important
                                </div>
                                <p>
                                    The
                                    <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
                                    variable must only be enabled on one server instance
                                    belonging to a group at any time, usually the first time
                                    you bootstrap the group (or in case the entire group is
                                    brought down and back up again). If you bootstrap the
                                    group multiple times, for example when multiple server
                                    instances have this option set, then they could create
                                    an artificial split brain scenario, in which two
                                    distinct groups with the same name exist. Always set
                                    <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=off</code></a>
                                    after the first server instance comes online.
                                </p><p style="color:blue;">GROUP_REPLICATION_BOOTSTRAP_GROUP变量在任何时候都只能在属于某个组的一个服务器实例上启用，通常是在第一次引导该组时（或者在整个组被关闭并再次备份的情况下）。如果您多次引导该组，例如当多个服务器实例具有此选项集时，则它们可以创建一个人工分割脑场景，其中存在两个具有相同名称的不同组。在第一个服务器实例联机后，始终将group_replication_bootstrap_group=off设置为关闭。</p>
                            </div>
                        </li></ul>
                    </div>
                    <p>
                        Configuration for all servers in the group is quite similar.
                        You need to change the specifics about each server (for
                        example <a class="link" href="server-administration.html#sysvar_server_id"><code class="literal">server_id</code></a>,
                        <a class="link" href="server-administration.html#sysvar_datadir"><code class="literal">datadir</code></a>,
                        <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>).
                        This is illustrated later in this tutorial.
                    </p><p style="color:blue;">组中所有服务器的配置都非常相似。您需要更改每个服务器的详细信息（例如服务器ID、数据目录、组复制本地地址）。本教程稍后将对此进行说明。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-user-credentials"></a>17.2.1.3&nbsp;User Credentials</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286790859712"></a><p>
                Group Replication uses the asynchronous replication protocol to
                achieve
                <a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5&nbsp;Distributed Recovery">Section&nbsp;17.9.5, “Distributed Recovery”</a>,
                synchronizing group members before joining them to the group.
                The distributed recovery process relies on a replication channel
                named <code class="literal">group_replication_recovery</code> which is
                used to transfer transactions from donor members to members that
                join the group. Therefore you need to set up a replication user
                with the correct permissions so that Group Replication can
                establish direct member-to-member recovery replication channels.
            </p><p style="color:blue;">组复制使用异步复制协议来实现第17.9.5节“分布式恢复”，在将组成员加入组之前对其进行同步。分布式恢复过程依赖于名为group_replication_recovery的复制通道，该通道用于将事务从捐助成员传输到加入组的成员。因此，您需要设置具有正确权限的复制用户，以便组复制可以建立直接的成员到成员恢复复制通道。</p><p>
                Start the MySQL server instance and then connect a client to it.
                Create a MySQL user with the
                <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION-SLAVE</code></a> privilege. This
                process can be captured in the binary log and then you can rely
                on distributed recovery to replicate the statements used to
                create the user. Alternatively, you can disable binary logging
                using <code class="literal">SET SQL_LOG_BIN=0;</code> and then create the
                user manually on each member, for example if you want to avoid
                the changes being propagated to other server instances. If you
                do decide to disable binary logging, ensure you renable it once
                you have configured the user.
            </p><p style="color:blue;">启动mysql服务器实例，然后将客户端连接到它。使用replication-slave权限创建一个mysql用户。这个过程可以在二进制日志中捕获，然后您可以依赖分布式恢复来复制用于创建用户的语句。或者，可以使用set sql_log_bin=0；禁用二进制日志记录，然后在每个成员上手动创建用户，例如，如果希望避免将更改传播到其他服务器实例。如果您决定禁用二进制日志记录，请确保在配置用户后重新启用它。</p><p>
                In the following example the user
                <em class="replaceable"><code>rpl_user</code></em> with the password
                <em class="replaceable"><code>password</code></em> is shown. When configuring
                your servers use a suitable user name and password.
            </p><p style="color:blue;">在下面的示例中，将显示具有密码密码的用户rpl_user。配置服务器时，请使用适当的用户名和密码。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE USER <em class="replaceable"><code>rpl_user</code></em>@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
mysql&gt; <strong class="userinput"><code>FLUSH PRIVILEGES;</code></strong>
</pre><p>
                If binary logging was disabled, enable it again once the user
                has been created using <code class="literal">SET SQL_LOG_BIN=1;</code>.
            </p><p style="color:blue;">如果禁用了二进制日志记录，请在使用set sql_log_bin=1；创建用户后再次启用它。</p><p>
                Once the user has been configured, use the
                <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement to
                configure the server to use the given credentials for the
                <code class="literal">group_replication_recovery</code> replication
                channel the next time it needs to recover its state from another
                member. Issue the following, replacing
                <em class="replaceable"><code>rpl_user</code></em> and
                <em class="replaceable"><code>password</code></em> with the values used when
                creating the user.
            </p><p style="color:blue;">配置用户后，使用change master to语句将服务器配置为在下次需要从另一个成员恢复其状态时使用组复制恢复复制通道的给定凭据。发出以下命令，用创建用户时使用的值替换rpl_user和password。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
		      FOR CHANNEL 'group_replication_recovery';</code></strong>
      </pre><p>
                Distributed recovery is the first step taken by a server that
                joins the group and does not have the same set of transactions
                as the group members. If these credentials are not set correctly
                for the <code class="literal">group_replication_recovery</code>
                replication channel and the <code class="literal">rpl_user</code> as
                shown, the server cannot connect to the donor members and run
                the distributed recovery process to gain synchrony with the
                other group members, and hence ultimately cannot join the group.
                See <a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5&nbsp;Distributed Recovery">Section&nbsp;17.9.5, “Distributed Recovery”</a>.
            </p><p style="color:blue;">分布式恢复是加入组且与组成员没有相同事务集的服务器所采取的第一步。如果未为组复制复制通道和RPL用户正确设置这些凭据（如图所示），服务器将无法连接到捐助成员并运行分布式恢复过程以与其他组成员同步，因此最终无法加入组。见第17.9.5节“分布式恢复”。</p><p>
                Similarly, if the server cannot correctly identify the other
                members via the server's <code class="literal">hostname</code> the
                recovery process can fail. It is recommended that operating
                systems running MySQL have a properly configured unique
                <code class="literal">hostname</code>, either using DNS or local settings.
                This <code class="literal">hostname</code> can be verified in the
                <code class="literal">Member_host</code> column of the
                <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
                table. If multiple group members externalize a default
                <code class="literal">hostname</code> set by the operating system, there
                is a chance of the member not resolving to the correct member
                address and not being able to join the group. In such a
                situation use <a class="link" href="replication.html#sysvar_report_host"><code class="literal">report_host</code></a> to
                configure a unique <code class="literal">hostname</code> to be
                externalized by each of the servers.
            </p><p style="color:blue;">类似地，如果服务器无法通过服务器的主机名正确标识其他成员，则恢复过程可能会失败。建议运行mysql的操作系统使用dns或本地设置正确配置唯一主机名。可以在performance_schema.replication_group_members表的member_host列中验证此主机名。如果多个组成员将操作系统设置的默认主机名外部化，则该成员可能无法解析为正确的成员地址，也无法加入该组。在这种情况下，使用report_host配置每个服务器外部化的唯一主机名。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-launching"></a>17.2.1.4&nbsp;Launching Group Replication</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286790827440"></a><p>
                Once server s1 has been configured and started, install the
                Group Replication plugin. If you used
                <code class="literal">plugin_load_add='group_replication.so</code> in the
                option file then the Group Replication plugin is installed and
                you can proceed to the next step. In the event that you decide
                to install the plugin manually, connect to the server and issue
                the following:
            </p><p style="color:blue;">配置并启动服务器s1后，安装组复制插件。如果在选项文件中使用plugin_load_add='group_replication.so，则会安装组复制插件，您可以继续执行下一步。如果决定手动安装插件，请连接到服务器并发出以下命令：</p><pre data-lang="sql" class="programlisting"><strong class="userinput"><code>INSTALL PLUGIN group_replication SONAME 'group_replication.so';</code></strong></pre>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        The <code class="literal">mysql.session</code> user must exist before
                        you can load Group Replication.
                        <code class="literal">mysql.session</code> was added in MySQL version
                        5.7.19. If your data dictionary was initialized using an
                        earlier version you must perform the MySQL upgrade procedure
                        (see <a class="xref" href="installing.html#upgrading" title="2.11&nbsp;Upgrading MySQL">Section&nbsp;2.11, “Upgrading MySQL”</a>). If the upgrade is not run,
                        Group Replication fails to start with the error message
                        <span class="errortext">There was an error when trying to access the server
          with user: mysql.session@localhost. Make sure the user is
          present in the server and that mysql_upgrade was ran after a
          server update.</span>.
                    </p><p style="color:blue;">在加载组复制之前，必须存在MySQL会话用户。mysql版本5.7.19中添加了mysql.session。如果数据字典是使用早期版本初始化的，则必须执行mysql升级过程（请参阅2.11节“升级mysql”）。如果未运行升级，则组复制无法启动，并显示错误消息尝试使用以下用户访问服务器时出错：mysql.session@localhost。确保服务器中存在用户，并且mysql_升级是在服务器更新后运行的。</p>
                </div>
                <p>
                    To check that the plugin was installed successfully, issue
                    <code class="literal">SHOW PLUGINS;</code> and check the output. It should
                    show something like this:
                </p><p style="color:blue;">要检查插件是否已成功安装，请发出show plugins；并检查输出。它应该显示如下内容：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW PLUGINS;</code></strong>
+----------------------------+----------+--------------------+----------------------+-------------+
| Name                       | Status   | Type               | Library              | License     |
+----------------------------+----------+--------------------+----------------------+-------------+
| binlog                     | ACTIVE   | STORAGE ENGINE     | NULL                 | PROPRIETARY |

(...)

| group_replication          | ACTIVE   | GROUP REPLICATION  | group_replication.so | PROPRIETARY |
+----------------------------+----------+--------------------+----------------------+-------------+</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-bootstrap"></a>17.2.1.5&nbsp;Bootstrapping the Group</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The process of starting a group for the first time is called
                    bootstrapping. You use the
                    <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
                    system variable to bootstrap a group. The bootstrap should only
                    be done by a single server, the one that starts the group and
                    only once. This is why the value of the
                    <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
                    option was not stored in the instance's option file. If it is
                    saved in the option file, upon restart the server automatically
                    bootstraps a second group with the same name. This would result
                    in two distinct groups with the same name. The same reasoning
                    applies to stopping and restarting the plugin with this option
                    set to <code class="literal">ON</code>. Therefore to safely bootstrap the
                    group, connect to s1 and issue:
                </p><p style="color:blue;">第一次启动组的过程称为引导。使用GROUP U REPLICATION U BOOTSTRAP U GROUP系统变量引导组。引导只能由一台服务器完成，即启动组的服务器，并且只能启动一次。这就是为什么group_replication_bootstrap_group选项的值没有存储在实例的选项文件中。如果它保存在选项文件中，则在重新启动服务器时，会自动引导另一个同名组。这将导致两个具有相同名称的不同组。同样的道理也适用于在该选项设置为on时停止和重新启动插件。因此，要安全引导组，请连接到s1并发出：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_bootstrap_group=ON;</code></strong>
mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_bootstrap_group=OFF;</code></strong>
</pre><p>
                Once the <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a>
                statement returns, the group has been started. You can check
                that the group is now created and that there is one member in
                it:
            </p><p style="color:blue;">一旦start group_replication语句返回，组就已经启动。您可以检查组是否已创建，以及其中是否有一个成员：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE  |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| group_replication_applier | ce9be252-2b71-11e6-b8f4-00212844f856 |   s1        |       3306  | ONLINE        |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
</pre><p>
                The information in this table confirms that there is a member in
                the group with the unique identifier
                <code class="literal">ce9be252-2b71-11e6-b8f4-00212844f856</code>, that it
                is <code class="literal">ONLINE</code> and is at <code class="literal">s1</code>
                listening for client connections on port
                <code class="literal">3306</code>.
            </p><p style="color:blue;">此表中的信息确认组中存在唯一标识符为ce9be252-2b71-11e6-b8f4-00212844f856的成员，该成员处于联机状态，并且正在s1侦听端口3306上的客户端连接。</p><p>
                For the purpose of demonstrating that the server is indeed in a
                group and that it is able to handle load, create a table and add
                some content to it.
            </p><p style="color:blue;">为了证明服务器确实在一个组中并且能够处理负载，创建一个表并向其中添加一些内容。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE DATABASE test;</code></strong>
mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES (1, 'Luis');</code></strong>
</pre><p>
                Check the content of table <code class="literal">t1</code> and the binary
                log.
            </p><p style="color:blue;">检查表T1和二进制日志的内容。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+----+------+
| c1 | c2   |
+----+------+
|  1 | Luis |
+----+------+

mysql&gt; <strong class="userinput"><code>SHOW BINLOG EVENTS;</code></strong>
+---------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------+
| Log_name      | Pos | Event_type     | Server_id | End_log_pos | Info                                                               |
+---------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------+
| binlog.000001 |   4 | Format_desc    |         1 |         123 | Server ver: 5.7.29-log, Binlog ver: 4                              |
| binlog.000001 | 123 | Previous_gtids |         1 |         150 |                                                                    |
| binlog.000001 | 150 | Gtid           |         1 |         211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'  |
| binlog.000001 | 211 | Query          |         1 |         270 | BEGIN                                                              |
| binlog.000001 | 270 | View_change    |         1 |         369 | view_id=14724817264259180:1                                        |
| binlog.000001 | 369 | Query          |         1 |         434 | COMMIT                                                             |
| binlog.000001 | 434 | Gtid           |         1 |         495 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'  |
| binlog.000001 | 495 | Query          |         1 |         585 | CREATE DATABASE test                                               |
| binlog.000001 | 585 | Gtid           |         1 |         646 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'  |
| binlog.000001 | 646 | Query          |         1 |         770 | use `test`; CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL) |
| binlog.000001 | 770 | Gtid           |         1 |         831 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4'  |
| binlog.000001 | 831 | Query          |         1 |         899 | BEGIN                                                              |
| binlog.000001 | 899 | Table_map      |         1 |         942 | table_id: 108 (test.t1)                                            |
| binlog.000001 | 942 | Write_rows     |         1 |         984 | table_id: 108 flags: STMT_END_F                                    |
| binlog.000001 | 984 | Xid            |         1 |        1011 | COMMIT /* xid=38 */                                                |
+---------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------+
</pre><p>
                As seen above, the database and the table objects were created
                and their corresponding DDL statements were written to the
                binary log. Also, the data was inserted into the table and
                written to the binary log. The importance of the binary log
                entries is illustrated in the following section when the group
                grows and distributed recovery is executed as new members try to
                catch up and become online.
            </p><p style="color:blue;">如上所示，创建了数据库和表对象，并将其相应的ddl语句写入二进制日志。此外，数据被插入表中并写入二进制日志。当组增长并在新成员试图赶上并联机时执行分布式恢复时，二进制日志项的重要性将在下一节中说明。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-adding-instances"></a>17.2.1.6&nbsp;Adding Instances to the Group</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286790783840"></a><p>
                At this point, the group has one member in it, server s1, which
                has some data in it. It is now time to expand the group by
                adding the other two servers configured previously.
            </p><p style="color:blue;">此时，组中有一个成员，服务器s1，其中包含一些数据。现在是时候通过添加前面配置的其他两个服务器来扩展组了。</p>
                <div class="section">

                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="group-replication-adding-a-second-instance"></a>17.2.1.6.1&nbsp;Adding a Second Instance</h5>
                            </div>
                        </div>
                    </div>
                    <a class="indexterm" name="idm140286790780496"></a><p>
                    In order to add a second instance, server s2, first create the
                    configuration file for it. The configuration is similar to the
                    one used for server s1, except for things such as the
                    <a class="link" href="server-administration.html#sysvar_server_id"><code class="literal">server_id</code></a>. These different
                    lines are highlighted in the listing below.
                </p><p style="color:blue;">为了添加第二个实例，服务器s2，首先为其创建配置文件。该配置与服务器s1使用的配置类似，除了服务器id之类的内容外。下面的列表中突出显示了这些不同的行。</p><pre data-lang="ini" class="programlisting">[mysqld]

#
# Disable other storage engines
#
disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"

#
# Replication configuration parameters
#
server_id=2
gtid_mode=ON
enforce_gtid_consistency=ON
master_info_repository=TABLE
relay_log_info_repository=TABLE
binlog_checksum=NONE
log_slave_updates=ON
log_bin=binlog
binlog_format=ROW

#
# Group Replication configuration
#
transaction_write_set_extraction=XXHASH64
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot=off
group_replication_local_address= "s2:33061"
group_replication_group_seeds= "s1:33061,s2:33061,s3:33061"
group_replication_bootstrap_group= off
</pre><p>
                    Similar to the procedure for server s1, with the option file
                    in place you launch the server. Then configure the recovery
                    credentials as follows. The commands are the same as used when
                    setting up server s1 as the user is shared within the group.
                    This member needs to have the same replication user configured
                    in <a class="xref" href="group-replication.html#group-replication-user-credentials" title="17.2.1.3&nbsp;User Credentials">Section&nbsp;17.2.1.3, “User Credentials”</a>. If
                    you are relying on distributed recovery to configure the user
                    on all members, when s2 connects to the seed s1 the
                    replication user is relicated to s1. If you did not have
                    binary logging enabled when you configured the user
                    credentials on s1, you must create the replication user on s2.
                    In this case, connect to s2 and issue:
                </p><p style="color:blue;">类似于服务器s1的过程，在选项file就位的情况下启动服务器。然后按如下方式配置恢复凭据。当用户在组中共享时，这些命令与设置服务器s1时使用的命令相同。此成员需要在第17.2.1.3节“用户凭据”中配置相同的复制用户。如果依赖分布式恢复在所有成员上配置用户，则当s2连接到种子s1时，复制用户将重新分配到s1。如果在s1上配置用户凭据时未启用二进制日志记录，则必须在s2上创建复制用户。在这种情况下，连接到s2并发出：</p><pre data-lang="sql" class="programlisting"><strong class="userinput"><code>SET SQL_LOG_BIN=0;</code></strong>
<strong class="userinput"><code>CREATE USER <em class="replaceable"><code>rpl_user</code></em>@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
<strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
<strong class="userinput"><code>SET SQL_LOG_BIN=1;</code></strong>
<strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
	FOR CHANNEL 'group_replication_recovery';
</code></strong></pre><p>
                    If necessary, install the Group Replication plugin, see
                    <a class="xref" href="group-replication.html#group-replication-launching" title="17.2.1.4&nbsp;Launching Group Replication">Section&nbsp;17.2.1.4, “Launching Group Replication”</a>.
                </p><p style="color:blue;">如有必要，请安装组复制插件，请参阅第17.2.1.4节“启动组复制”。</p><p>
                    Start Group Replication and s2 starts the process of joining
                    the group.
                </p><p style="color:blue;">启动组复制，s2启动加入组的过程。</p><pre data-lang="sql" class="programlisting">mysql&gt; START GROUP_REPLICATION;
</pre><p>
                    Unlike the previous steps that were the same as those executed
                    on s1, here there is a difference in that you do
                    <span class="emphasis"><em>not</em></span> need to boostrap the group because
                    the group already exiists. In other words on s2
                    <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
                    is set to off, and you do not issue <code class="literal">SET GLOBAL
                    group_replication_bootstrap_group=ON;</code> before
                    starting Group Replication, because the group has already been
                    created and bootstrapped by server s1. At this point server s2
                    only needs to be added to the already existing group.
                </p><p style="color:blue;">与之前在S1上执行的步骤不同，这里有一个不同之处在于，您不需要对组进行分组，因为该组已经退出了。换句话说，在s2 group_replication_bootstrap_group上设置为off，并且在启动组复制之前不发出set global group_replication_bootstrap_group=on，因为该组已由服务器s1创建并引导。此时服务器S2只需要添加到已经存在的组中。</p>
                    <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Tip
                        </div>
                        <p>
                            When Group Replication starts successfully and the server
                            joins the group it checks the
                            <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> variable.
                            By setting <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a>
                            to ON in the member's configuration file, you can
                            ensure that servers which fail when starting Group
                            Replication for any reason do not accept transactions. If
                            the server should join the group as read-write instance, for
                            example as the primary in a single-primary group or as a
                            member of a multi-primary group, when the
                            <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> variable is
                            set to ON then it is set to OFF upon joining the group.
                        </p><p style="color:blue;">当组复制成功启动并且服务器加入组时，它将检查super_read_only变量。通过在成员的配置文件中将super_read_only设置为on，可以确保启动组复制时因任何原因失败的服务器不接受事务。如果服务器应作为读写实例加入组，例如作为单个主组中的主组或作为多个主组的成员，则当super_read_only变量设置为on时，则在加入组时将其设置为off。</p>
                    </div>
                    <p>
                        Checking the
                        <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
                        table again shows that there are now two
                        <span class="emphasis"><em>ONLINE</em></span> servers in the group.
                    </p><p style="color:blue;">再次检查performance_schema.replication_group_members表将显示组中现在有两个联机服务器。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE  |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| group_replication_applier | 395409e1-6dfa-11e6-970b-00212844f856 |   s1        |        3306 | ONLINE        |
| group_replication_applier | ac39f1e6-6dfa-11e6-a69d-00212844f856 |   s2        |        3306 | ONLINE        |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
</pre><p>
                    When s2 attempted to join the group,
                    <a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5&nbsp;Distributed Recovery">Section&nbsp;17.9.5, “Distributed Recovery”</a>
                    ensured that s2 applied the same transactions which s1 had
                    applied. Once this process completed, s2 could join the group
                    as a member, and at this point it is marked as ONLINE. In
                    other words it must have already caught up with server s1
                    automatically. Once s2 is ONLINE, it then begins to process
                    transactions with the group. Verify that s2 has indeed
                    synchronized with server s1 as follows.
                </p><p style="color:blue;">当s2试图加入该组时，第17.9.5节“分布式恢复”确保s2应用了与s1相同的事务。此过程完成后，s2可以作为成员加入组，此时它被标记为联机。换句话说，它一定已经自动赶上了服务器s1。一旦s2上线，它就开始处理与集团的交易。验证s2是否确实已与服务器s1同步，如下所示。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW DATABASES LIKE 'test';</code></strong>
+-----------------+
| Database (test) |
+-----------------+
| test            |
+-----------------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.t1;</code></strong>
+----+------+
| c1 | c2   |
+----+------+
|  1 | Luis |
+----+------+

mysql&gt; <strong class="userinput"><code>SHOW BINLOG EVENTS;</code></strong>
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| Log_name      | Pos  | Event_type     | Server_id | End_log_pos | Info                                                               |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| binlog.000001 |    4 | Format_desc    |         2 |         123 | Server ver: 5.7.29-log, Binlog ver: 4                              |
| binlog.000001 |  123 | Previous_gtids |         2 |         150 |                                                                    |
| binlog.000001 |  150 | Gtid           |         1 |         211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'  |
| binlog.000001 |  211 | Query          |         1 |         270 | BEGIN                                                              |
| binlog.000001 |  270 | View_change    |         1 |         369 | view_id=14724832985483517:1                                        |
| binlog.000001 |  369 | Query          |         1 |         434 | COMMIT                                                             |
| binlog.000001 |  434 | Gtid           |         1 |         495 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'  |
| binlog.000001 |  495 | Query          |         1 |         585 | CREATE DATABASE test                                               |
| binlog.000001 |  585 | Gtid           |         1 |         646 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'  |
| binlog.000001 |  646 | Query          |         1 |         770 | use `test`; CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL) |
| binlog.000001 |  770 | Gtid           |         1 |         831 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4'  |
| binlog.000001 |  831 | Query          |         1 |         890 | BEGIN                                                              |
| binlog.000001 |  890 | Table_map      |         1 |         933 | table_id: 108 (test.t1)                                            |
| binlog.000001 |  933 | Write_rows     |         1 |         975 | table_id: 108 flags: STMT_END_F                                    |
| binlog.000001 |  975 | Xid            |         1 |        1002 | COMMIT /* xid=30 */                                                |
| binlog.000001 | 1002 | Gtid           |         1 |        1063 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5'  |
| binlog.000001 | 1063 | Query          |         1 |        1122 | BEGIN                                                              |
| binlog.000001 | 1122 | View_change    |         1 |        1261 | view_id=14724832985483517:2                                        |
| binlog.000001 | 1261 | Query          |         1 |        1326 | COMMIT                                                             |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
</pre><p>
                    As seen above, the second server has been added to the group
                    and it has replicated the changes from server s1 automatically
                    using distributed recovery. In other words, the transactions
                    applied on s1 up to the point in time that s2 joined the group
                    have been replicated to s2.
                </p><p style="color:blue;">如上所示，第二台服务器已添加到组中，并且它已使用分布式恢复自动从服务器s1复制更改。换言之，在s1上应用到s2加入组的时间点的事务已复制到s2。</p>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="group-replication-adding-additional-instances"></a>17.2.1.6.2&nbsp;Adding Additional Instances</h5>

                            </div>

                        </div>

                    </div>
                    <a class="indexterm" name="idm140286790737296"></a><p>
                    Adding additional instances to the group is essentially the
                    same sequence of steps as adding the second server, except
                    that the configuration has to be changed as it had to be for
                    server s2. To summarise the required commands:
                </p><p style="color:blue;">向组中添加其他实例与添加第二个服务器的步骤基本相同，只是必须更改服务器s2的配置。总结所需的命令：</p><p>
                    <span class="emphasis"><em>1. Create the configuration file</em></span>
                </p><p style="color:blue;">一。创建配置文件</p><pre data-lang="ini" class="programlisting">[mysqld]

#
# Disable other storage engines
#
disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"

#
# Replication configuration parameters
#
server_id=3
gtid_mode=ON
enforce_gtid_consistency=ON
master_info_repository=TABLE
relay_log_info_repository=TABLE
binlog_checksum=NONE
log_slave_updates=ON
log_bin=binlog
binlog_format=ROW

#
# Group Replication configuration
#
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot=off
group_replication_local_address= "s3:33061"
group_replication_group_seeds= "s1:33061,s2:33061,s3:33061"
group_replication_bootstrap_group= off
</pre><p>
          <span class="emphasis"><em>2. Start the server and connect to it. Configure the
          recovery credentials for the group_replication_recovery
          channel.</em></span>
                </p><p style="color:blue;">2.启动服务器并连接到它。为组复制恢复通道配置恢复凭据。</p><pre data-lang="sql" class="programlisting">SET SQL_LOG_BIN=0;
CREATE USER <em class="replaceable"><code>rpl_user</code></em>@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
GRANT REPLICATION SLAVE ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';
FLUSH PRIVILEGES;
SET SQL_LOG_BIN=1;
CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>'  \\
FOR CHANNEL 'group_replication_recovery';</pre><p>
          <span class="emphasis"><em>4. Install the Group Replication plugin and start
          it.</em></span>
                </p><p style="color:blue;">四。安装组复制插件并启动它。</p><pre data-lang="sql" class="programlisting">INSTALL PLUGIN group_replication SONAME 'group_replication.so';
START GROUP_REPLICATION;</pre><p>
                    At this point server s3 is booted and running, has joined the
                    group and caught up with the other servers in the group.
                    Consulting the
                    <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
                    table again confirms this is the case.
                </p><p style="color:blue;">此时，服务器s3启动并运行，已加入组并赶上组中的其他服务器。查阅performance_schema.replication_group_members表再次确认是这种情况。</p><pre data-lang="sql" class="programlisting">mysql&gt; SELECT * FROM performance_schema.replication_group_members;
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE  |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| group_replication_applier | 395409e1-6dfa-11e6-970b-00212844f856 |   s1        |       3306  | ONLINE        |
| group_replication_applier | 7eb217ff-6df3-11e6-966c-00212844f856 |   s3        |       3306  | ONLINE        |
| group_replication_applier | ac39f1e6-6dfa-11e6-a69d-00212844f856 |   s2        |       3306  | ONLINE        |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
</pre><p>
                    Issuing this same query on server s2 or server s1 yields the
                    same result. Also, you can verify that server s3 has caught
                    up:
                </p><p style="color:blue;">在服务器s2或服务器s1上发出相同的查询会产生相同的结果。此外，还可以验证服务器s3是否已赶上：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW DATABASES LIKE 'test';</code></strong>
+-----------------+
| Database (test) |
+-----------------+
| test            |
+-----------------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.t1;</code></strong>
+----+------+
| c1 | c2   |
+----+------+
|  1 | Luis |
+----+------+

mysql&gt; <strong class="userinput"><code>SHOW BINLOG EVENTS;</code></strong>
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| Log_name      | Pos  | Event_type     | Server_id | End_log_pos | Info                                                               |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| binlog.000001 |    4 | Format_desc    |         3 |         123 | Server ver: 5.7.29-log, Binlog ver: 4                              |
| binlog.000001 |  123 | Previous_gtids |         3 |         150 |                                                                    |
| binlog.000001 |  150 | Gtid           |         1 |         211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'  |
| binlog.000001 |  211 | Query          |         1 |         270 | BEGIN                                                              |
| binlog.000001 |  270 | View_change    |         1 |         369 | view_id=14724832985483517:1                                        |
| binlog.000001 |  369 | Query          |         1 |         434 | COMMIT                                                             |
| binlog.000001 |  434 | Gtid           |         1 |         495 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'  |
| binlog.000001 |  495 | Query          |         1 |         585 | CREATE DATABASE test                                               |
| binlog.000001 |  585 | Gtid           |         1 |         646 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'  |
| binlog.000001 |  646 | Query          |         1 |         770 | use `test`; CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL) |
| binlog.000001 |  770 | Gtid           |         1 |         831 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4'  |
| binlog.000001 |  831 | Query          |         1 |         890 | BEGIN                                                              |
| binlog.000001 |  890 | Table_map      |         1 |         933 | table_id: 108 (test.t1)                                            |
| binlog.000001 |  933 | Write_rows     |         1 |         975 | table_id: 108 flags: STMT_END_F                                    |
| binlog.000001 |  975 | Xid            |         1 |        1002 | COMMIT /* xid=29 */                                                |
| binlog.000001 | 1002 | Gtid           |         1 |        1063 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5'  |
| binlog.000001 | 1063 | Query          |         1 |        1122 | BEGIN                                                              |
| binlog.000001 | 1122 | View_change    |         1 |        1261 | view_id=14724832985483517:2                                        |
| binlog.000001 | 1261 | Query          |         1 |        1326 | COMMIT                                                             |
| binlog.000001 | 1326 | Gtid           |         1 |        1387 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:6'  |
| binlog.000001 | 1387 | Query          |         1 |        1446 | BEGIN                                                              |
| binlog.000001 | 1446 | View_change    |         1 |        1585 | view_id=14724832985483517:3                                        |
| binlog.000001 | 1585 | Query          |         1 |        1650 | COMMIT                                                             |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
</pre>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-deploying-locally"></a>17.2.2&nbsp;Deploying Group Replication Locally</h3>

                    </div>

                </div>

            </div>
            <p>


                The most common way to deploy Group Replication is using multiple
                server instances, to provide high availability. It is also
                possible to deploy Group Replication locally, for example for
                testing purposes. This section explains how you can deploy Group
                Replication locally.
            </p><p style="color:blue;">部署组复制的最常见方法是使用多个服务器实例，以提供高可用性。也可以在本地部署组复制，例如用于测试目的。本节说明如何在本地部署组复制。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    Group Replication is usually deployed on multiple hosts because
                    this ensures that high-availability is provided. The
                    instructions in this section are not suitable for production
                    deployments because all MySQL server instances are running on
                    the same single host. In the event of failure of this host, the
                    whole group fails. Therefore this information should be used for
                    testing purposes and it should not be used in a production
                    environments.
                </p><p style="color:blue;">组复制通常部署在多个主机上，因为这样可以确保提供高可用性。本节中的说明不适用于生产部署，因为所有mysql服务器实例都在同一台主机上运行。如果此主机发生故障，则整个组都将失败。因此，此信息应用于测试目的，不应在生产环境中使用。</p>
            </div>
            <p>
                This section explains how to create a replication group with three
                MySQL Server instances on one physical machine. This means that
                three data directories are needed, one per server instance, and
                that you need to configure each instance independently. This -
                procedure assumes that MySQL Server was downloaded and unpacked -
                into the directory named <code class="literal">mysql-5.7</code>. Each MySQL
                server instance requires a specific data directory. Create a
                directory named <code class="literal">data</code>, then in that directory
                create a subdirectory for each server instance, for example s1, s2
                and s3, and initialize each one.
            </p><p style="color:blue;">本节介绍如何在一台物理计算机上创建一个包含三个mysql服务器实例的复制组。这意味着需要三个数据目录，每个服务器实例一个，并且需要独立配置每个实例。此过程假定mysql服务器已下载并解压到名为mysql-5.7的目录中。每个mysql服务器实例都需要一个特定的数据目录。创建一个名为data的目录，然后在该目录中为每个服务器实例（例如s1、s2和s3）创建一个子目录，并初始化每个子目录。</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>mysql-5.7/bin/mysqld --initialize-insecure --basedir=$PWD/mysql-5.7 --datadir=$PWD/data/s1</code></strong>
<strong class="userinput"><code>mysql-5.7/bin/mysqld --initialize-insecure --basedir=$PWD/mysql-5.7 --datadir=$PWD/data/s2</code></strong>
<strong class="userinput"><code>mysql-5.7/bin/mysqld --initialize-insecure --basedir=$PWD/mysql-5.7 --datadir=$PWD/data/s3</code></strong>
</pre><p>
            Inside <code class="literal">data/s1</code>, <code class="literal">data/s2</code>,
            <code class="literal">data/s3</code> is an initialized data directory,
            containing the mysql system database and related tables and much
            more. To learn more about the initialization procedure, see
            <a class="xref" href="installing.html#data-directory-initialization" title="2.10.1&nbsp;Initializing the Data Directory">Section&nbsp;2.10.1, “Initializing the Data Directory”</a>.
        </p><p style="color:blue;">在data/s1、data/s2中，data/s3是一个初始化的数据目录，包含mysql系统数据库和相关表等。要了解有关初始化过程的更多信息，请参阅2.10.1节“初始化数据目录”。</p>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Warning
                </div>
                <p>
                    Do not use <code class="literal">-initialize-insecure</code> in production
                    environments, it is only used here to simplify the tutorial. For
                    more information on security settings, see
                    <a class="xref" href="group-replication.html#group-replication-security" title="17.5&nbsp;Group Replication Security">Section&nbsp;17.5, “Group Replication Security”</a>.
                </p><p style="color:blue;">不要在生产环境中使用-initialize unsecure，这里只用于简化教程。有关安全设置的详细信息，请参阅第17.5节“组复制安全性”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="configure-local-group-members"></a>Configuration of Local Group Replication Members</h4>

                        </div>

                    </div>

                </div>
                <p>
                    When you are following
                    <a class="xref" href="group-replication.html#group-replication-configuring-instances" title="17.2.1.2&nbsp;Configuring an Instance for Group Replication">Section&nbsp;17.2.1.2, “Configuring an Instance for Group Replication”</a>, you
                    need to add configuration for the data directories added in the
                    previous section. For example:
                </p><p style="color:blue;">当您遵循第17.2.1.2节“为组复制配置实例”时，需要为前一节中添加的数据目录添加配置。例如：</p><pre data-lang="ini" class="programlisting">[mysqld]

# server configuration
datadir=&lt;full_path_to_data&gt;/data/s1
basedir=&lt;full_path_to_bin&gt;/mysql-8.0/

port=24801
socket=&lt;full_path_to_sock_dir&gt;/s1.sock</pre><p>
                These settings configure MySQL server to use the data directory
                created earlier and which port the server should open and start
                listening for incoming connections.
            </p><p style="color:blue;">这些设置将mysql服务器配置为使用先前创建的数据目录，以及服务器应打开哪个端口并开始侦听传入连接。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        The non-default port of 24801 is used because in this tutorial
                        the three server instances use the same hostname. In a setup
                        with three different machines this would not be required.
                    </p><p style="color:blue;">使用非默认端口24801是因为在本教程中，三个服务器实例使用相同的主机名。在有三台不同机器的设置中，这是不需要的。</p>
                </div>
                <p>
                    Group Replication requires a network connection between the
                    members, which means that each member must be able to resolve
                    the network address of all of the other members. For example in
                    this tutorial all three instances run on one machine, so to
                    ensure that the members can contact each other you could add a
                    line to the option file such as
                    <a class="link" href="replication.html#sysvar_report_host"><code class="literal">report_host=127.0.0.1</code></a>.
                </p><p style="color:blue;">组复制需要成员之间的网络连接，这意味着每个成员必须能够解析所有其他成员的网络地址。例如，在本教程中，所有三个实例都在一台计算机上运行，因此为了确保成员之间可以相互联系，可以在选项文件中添加一行，例如report_host=127.0.0.1。</p><p>
                Then each member needs to be able to connect to the other
                members on their
                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>.
                For example in the option file of member s1 add:
            </p><p style="color:blue;">然后，每个成员都需要能够连接到其组复制本地地址上的其他成员。例如，在成员s1的选项文件中添加：</p><pre data-lang="ini" class="programlisting">group_replication_local_address= "127.0.0.1:24901"
group_replication_group_seeds= "127.0.0.1:24901,127.0.0.1:24902,127.0.0.1:24903"
</pre><p>
                This configures s1 to use port 24901 for internal group
                communication with seed members. For each server instance you
                want to add to the group, make these changes in the option file
                of the member. For each member you must ensure a unique address
                is specified, so use a unique port per instance for
                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>.
                Usually you want all members to be able to serve as seeds for
                members that are joining the group and have not got the
                transactions processed by the group. In this case, add all of
                the ports to
                <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
                as shown above.
            </p><p style="color:blue;">这将s1配置为使用端口24901与seed成员进行内部组通信。对于要添加到组中的每个服务器实例，在成员的选项文件中进行这些更改。对于每个成员，必须确保指定了唯一的地址，因此对组复制本地地址使用每个实例的唯一端口。通常，您希望所有成员都能够作为加入组的成员的种子，而这些成员没有得到组处理的事务。在这种情况下，将所有端口添加到组复制组种子，如上图所示。</p><p>
                The remaining steps of
                <a class="xref" href="group-replication.html#group-replication-deploying-in-single-primary-mode" title="17.2.1&nbsp;Deploying Group Replication in Single-Primary Mode">Section&nbsp;17.2.1, “Deploying Group Replication in Single-Primary Mode”</a>
                apply equally to a group which you have deployed locally in this
                way.
            </p><p style="color:blue;">第17.2.1节“以单一主模式部署组复制”的其余步骤同样适用于您以这种方式在本地部署的组。</p>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="group-replication-monitoring"></a>17.3&nbsp;Monitoring Group Replication</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-server-states">17.3.1 Group Replication Server States</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-members">17.3.2 The replication_group_members Table</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-member-stats">17.3.3 The replication_group_member_stats Table</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286790678352"></a><p>
        Use the Perfomance Schema tables to monitor Group Replication,
        assuming that the
        <a class="ulink" href="performance-schema-quick-start" target="_top">Performance
            Schema</a> is enabled. Group Replication adds the following
        tables:
    </p><p style="color:blue;">假设性能架构已启用，则使用performance架构表监视组复制。组复制添加以下表：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <a class="link" href="performance-schema.html#replication-group-member-stats-table" title="25.12.11.8&nbsp;The replication_group_member_stats Table"><code class="literal">performance_schema.replication_group_member_stats</code></a>
            </p><p style="color:blue;">性能模式。复制组成员状态</p></li><li class="listitem"><p>
                <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
            </p><p style="color:blue;">性能架构。复制组成员</p></li></ul>
        </div>
        <p>
            These Perfomance Schema replication tables also show information
            about Group Replication:
        </p><p style="color:blue;">这些性能架构复制表还显示有关组复制的信息：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <a class="link" href="performance-schema.html#replication-connection-status-table" title="25.12.11.2&nbsp;The replication_connection_status Table"><code class="literal">performance_schema.replication_connection_status</code></a>
                shows information regarding Group Replication, for example the
                transactions that have been received from the group and queued
                in the applier queue (the relay log).
            </p><p style="color:blue;">performance_schema.replication_connection_status显示有关组复制的信息，例如从组接收并在applier队列（中继日志）中排队的事务。</p></li><li class="listitem"><p>
                <a class="link" href="performance-schema.html#replication-applier-status-table" title="25.12.11.4&nbsp;The replication_applier_status Table"><code class="literal">performance_schema.replication_applier_status</code></a>
                shows the state of the Group Replication related channels and
                threads If there are many different worker threads applying
                transactions, then the worker tables can also be used to monitor
                what each worker thread is doing.
            </p><p style="color:blue;">performance_schema.replication_applier_status显示与组复制相关的通道和线程的状态如果有许多不同的工作线程应用事务，则工作表也可以用于监视每个工作线程正在执行的操作。</p></li></ul>
        </div>
        <p>
            The replication channels created by the Group Replication plugin are
            named:
        </p><p style="color:blue;">组复制插件创建的复制通道名为：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">group_replication_recovery</code> - This channel is
                used for the replication changes that are related to the
                distributed recovery phase.
            </p><p style="color:blue;">组复制恢复-此通道用于与分布式恢复阶段相关的复制更改。</p></li><li class="listitem"><p>
                <code class="literal">group_replication_applier</code> - This channel is
                used for the incoming changes from the group. This is the
                channel used to apply transactions coming directly from the
                group.
            </p><p style="color:blue;">组复制应用程序-此通道用于组的传入更改。这是用于应用直接来自组的事务的通道。</p></li></ul>
        </div>
        <p>
            The following sections describe how to interpret the information
            available.
        </p><p style="color:blue;">以下各节介绍如何解释可用的信息。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-server-states"></a>17.3.1&nbsp;Group Replication Server States</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286790659888"></a><p>
            There are various states that a server instance can be in. If
            servers are communicating properly, all report the same states for
            all servers. However, if there is a network partition, or a server
            leaves the group, then different information could be reported,
            depending on which server is queried. If the server has left the
            group then it cannot report updated information about the other
            servers' states. If there is a partition, such that quorum is
            lost, servers are not able to coordinate between themselves. As a
            consequence, they cannot guess what the status of different
            servers is. Therefore, instead of guessing their state they report
            that some servers are unreachable.
        </p><p style="color:blue;">服务器实例可以处于多种状态。如果服务器通信正常，则所有服务器都报告相同的状态。但是，如果存在网络分区，或者服务器离开组，则可以报告不同的信息，具体取决于查询的服务器。如果服务器已离开组，则无法报告有关其他服务器状态的更新信息。如果存在分区，导致仲裁丢失，则服务器无法在它们之间进行协调。因此，他们无法猜测不同服务器的状态。因此，他们不是猜测自己的状态，而是报告某些服务器无法访问。</p>
            <div class="table">
                <a name="idm140286790656496"></a><p class="title"><b>Table&nbsp;17.1&nbsp;Server State</b></p><p style="color:blue;">表17.1服务器状态</p>
                <div class="table-contents">
                    <table><colgroup><col width="38%"><col width="50%"><col width="12%"></colgroup><thead><tr>
                        <th scope="col"><p>
                            Field
                        </p><p style="color:blue;">字段</p></th>
                        <th scope="col"><p>
                            Description
                        </p><p style="color:blue;">说明</p></th>
                        <th scope="col"><p>
                            Group Synchronized
                        </p><p style="color:blue;">组已同步</p></th>
                    </tr></thead><tbody><tr>
                        <td scope="row"><p>
                            <code class="literal">ONLINE</code>
                        </p><p style="color:blue;">在线</p></td>
                        <td><p>
                            The member is ready to serve as a fully functional group
                            member, meaning that the client can connect and start
                            executing transactions.
                        </p><p style="color:blue;">该成员已准备好充当功能齐全的组成员，这意味着客户端可以连接并开始执行事务。</p></td>
                        <td><p>
                            Yes
                        </p><p style="color:blue;">是的</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            <code class="literal">RECOVERING</code>
                        </p><p style="color:blue;">恢复</p></td>
                        <td><p>
                            The member is in the process of becoming an active member
                            of the group and is currently going through the recovery
                            process, receiving state information from a donor.
                        </p><p style="color:blue;">该成员正在成为该小组的一个积极成员，目前正在进行恢复进程，从捐助者那里收到国家信息。</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">否</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            <code class="literal">OFFLINE</code>
                        </p><p style="color:blue;">离线</p></td>
                        <td><p>
                            The plugin is loaded but the member does not belong to any
                            group.
                        </p><p style="color:blue;">插件已加载，但该成员不属于任何组。</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">否</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            <code class="literal">ERROR</code>
                        </p><p style="color:blue;">错误</p></td>
                        <td><p>
                            The state of the member. Whenever there is an error on the
                            recovery phase or while applying changes, the server
                            enters this state.
                        </p><p style="color:blue;">成员国。每当恢复阶段出现错误或应用更改时，服务器将进入此状态。</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">不</p></td>
                    </tr><tr>
                        <td scope="row"><p>
                            <code class="literal">UNREACHABLE</code>
                        </p><p style="color:blue;">遥不可及</p></td>
                        <td><p>
                            Whenever the local failure detector suspects that a given
                            server is not reachable, because for example it was
                            disconnected involuntarily, it shows that server's state
                            as <code class="literal">UNREACHABLE</code>.
                        </p><p style="color:blue;">每当本地故障检测器怀疑某个给定的服务器不可访问时（例如，它是非自愿断开连接的），它会将该服务器的状态显示为不可访问。</p></td>
                        <td><p>
                            No
                        </p><p style="color:blue;">否</p></td>
                    </tr></tbody></table>
                </div>

            </div>
            <br class="table-break">
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    Once an instance enters <code class="literal">ERROR</code> state, the
                    <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> option is set
                    to <code class="literal">ON</code>. To leave the <code class="literal">ERROR</code>
                    state you must manually configure the instance with
                    <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only=OFF</code></a>.
                </p><p style="color:blue;">一旦实例进入错误状态，super_read_only选项将设置为on。要离开错误状态，必须手动将实例配置为super_read_only=off。</p>
            </div>
            <p>
                Note that Group Replication is <span class="emphasis"><em>not</em></span>
                synchronous, but eventually synchronous. More precisely,
                transactions are delivered to all group members in the same order,
                but their execution is not synchronized, meaning that after a
                transaction is accepted to be committed, each member commits at
                its own pace.
            </p><p style="color:blue;">请注意，组复制不是同步的，而是最终同步的。更准确地说，事务以相同的顺序传递给所有组成员，但它们的执行不同步，这意味着在接受提交事务后，每个成员都以自己的速度提交。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-replication-group-members"></a>17.3.2&nbsp;The replication_group_members Table</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286790616976"></a><p>
            The
            <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
            table is used for monitoring the status of the different server
            instances that are members of the group. The information in the
            table is updated whenever there is a view change, for example when
            the configuration of the group is dynamically changed when a new
            member joins. At that point, servers exchange some of their
            metadata to synchronize themselves and continue to cooperate
            together. The information is shared between all the server
            instances that are members of the replication group, so
            information on all the group members can be queried from any
            member. This table can be used to get a high level view of the
            state of a replication group, for example by issuing:
        </p><p style="color:blue;">performance_schema.replication_group_members表用于监视作为组成员的不同服务器实例的状态。每当视图发生更改时（例如，当新成员加入时动态更改组的配置时），表中的信息就会更新。在这一点上，服务器交换一些元数据以同步它们自己并继续协作。这些信息在作为复制组成员的所有服务器实例之间共享，因此可以从任何成员查询有关所有组成员的信息。此表可用于获取复制组状态的高级视图，例如通过发出：</p><pre data-lang="sql" class="programlisting"><strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+---------------------------+--------------------------------------+--------------+-------------+--------------+
| CHANNEL_NAME              | MEMBER_ID	                           | MEMBER_HOST  | MEMBER_PORT | MEMBER_STATE |
+---------------------------+--------------------------------------+--------------+-------------+--------------+
| group_replication_applier | 041f26d8-f3f3-11e8-adff-080027337932 | example1     |      3306   | ONLINE       |
| group_replication_applier | f60a3e10-f3f2-11e8-8258-080027337932 | example2     |      3306   | ONLINE       |
| group_replication_applier | fc890014-f3f2-11e8-a9fd-080027337932 | example3     |      3306   | ONLINE       |
+---------------------------+--------------------------------------+--------------+-------------+--------------+
</pre><p>
            Based on this result we can see that the group consists of three
            members, each member's host and port number which clients use to
            connect to the member, and the
            <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> of the member. The
            <code class="literal">MEMBER_STATE</code> column shows one of the
            <a class="xref" href="group-replication.html#group-replication-server-states" title="17.3.1&nbsp;Group Replication Server States">Section&nbsp;17.3.1, “Group Replication Server States”</a>, in this case it
            shows that all three members in this group are
            <code class="literal">ONLINE</code>, and the <code class="literal">MEMBER_ROLE</code>
            column shows that there are two secondaries, and a single primary.
            Therefore this group must be running in single-primary mode. The
            <code class="literal">MEMBER_VERSION</code> column can be useful when you
            are upgrading a group and are combining members running different
            MySQL versions. See
            <a class="xref" href="group-replication.html#group-replication-server-states" title="17.3.1&nbsp;Group Replication Server States">Section&nbsp;17.3.1, “Group Replication Server States”</a> for more
            information.
        </p><p style="color:blue;">根据这个结果，我们可以看到组由三个成员组成，每个成员的主机和端口号（客户端用来连接到该成员）以及该成员的服务器id。member_state列显示第17.3.1节“组复制服务器状态”中的一个，在本例中，它显示此组中的所有三个成员都处于联机状态，member_role列显示有两个辅助成员和一个主成员。因此，此组必须以单一主模式运行。在升级组和组合运行不同mysql版本的成员时，member_version列非常有用。有关详细信息，请参阅第17.3.1节“组复制服务器状态”。</p><p>
            For more information about the <code class="literal">Member_host</code>
            value and its impact on the distributed recovery process, see
            <a class="xref" href="group-replication.html#group-replication-user-credentials" title="17.2.1.3&nbsp;User Credentials">Section&nbsp;17.2.1.3, “User Credentials”</a>.
        </p><p style="color:blue;">有关成员主机值及其对分布式恢复过程的影响的详细信息，请参阅第17.2.1.3节“用户凭据”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-replication-group-member-stats"></a>17.3.3&nbsp;The replication_group_member_stats Table</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286790600752"></a><p>
            Each member in a replication group certifies and applies
            transactions received by the group. Statistics regarding the
            certifier and applier procedures are useful to understand how the
            applier queue is growing, how many conflicts have been found, how
            many transactions were checked, which transactions are committed
            everywhere, and so on.
        </p><p style="color:blue;">复制组中的每个成员都验证并应用该组接收到的事务。有关证明程序和applier过程的统计信息有助于了解applier队列是如何增长的、发现了多少冲突、检查了多少事务、在任何地方提交了哪些事务等等。</p><p>
            The
            <a class="link" href="performance-schema.html#replication-group-member-stats-table" title="25.12.11.8&nbsp;The replication_group_member_stats Table"><code class="literal">performance_schema.replication_group_member_stats</code></a>
            table provides group-level information related to the
            certification process, and also statistics for the transactions
            received and originated by each individual member of the
            replication group. The information is shared between all the
            server instances that are members of the replication group, so
            information on all the group members can be queried from any
            member. Note that refreshing of statistics for remote members is
            controlled by the message period specified in the
            <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/group-replication-options.html#sysvar_group_replication_flow_control_period" target="_top"><code class="literal">group_replication_flow_control_period</code></a>
            option, so these can differ slightly from the locally collected
            statistics for the member where the query is made. To use this
            table to monitor a Group Replication member, issue:
        </p><p style="color:blue;">performance_schema.replication_group_member_stats表提供与认证过程相关的组级信息，以及复制组每个成员接收和发起的事务的统计信息。这些信息在作为复制组成员的所有服务器实例之间共享，因此可以从任何成员查询有关所有组成员的信息。请注意，远程成员的统计信息刷新由group_replication_flow_control_period选项中指定的消息周期控制，因此这些统计信息可能与进行查询的成员的本地收集的统计信息略有不同。要使用此表监视组复制成员，请发出：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_member_stats\G</code></strong></pre><p>
            These fields are important for monitoring the performance of the
            members connected in the group. For example, suppose that one of
            the group’s members always reports a large number of
            transactions in its queue compared to other members. This means
            that the member is delayed and is not able to keep up to date with
            the other members of the group. Based on this information, you
            could decide to either remove the member from the group, or delay
            the processing of transactions on the other members of the group
            in order to reduce the number of queued transactions. This
            information can also help you to decide how to adjust the flow
            control of the Group Replication plugin, see
            <a class="xref" href="group-replication.html#group-replication-flow-control" title="17.9.7.3&nbsp;Flow Control">Section&nbsp;17.9.7.3, “Flow Control”</a>.
        </p><p style="color:blue;">这些字段对于监视组中连接的成员的性能非常重要。例如，假设组的一个成员总是报告队列中的大量事务，而不是其他成员。这意味着该成员被延迟，无法与该组的其他成员保持最新状态。根据此信息，您可以决定从组中删除该成员，或延迟处理组其他成员上的事务，以减少排队事务的数量。此信息还可以帮助您决定如何调整组复制插件的流控制，请参见第17.9.7.3节“流控制”。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="group-replication-operations"></a>17.4&nbsp;Group Replication Operations</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-multi-primary-or-single-primary-mode">17.4.1 Deploying in Multi-Primary or Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-tuning-recovery">17.4.2 Tuning Recovery</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-network-partitioning">17.4.3 Network Partitioning</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-enterprise-backup">17.4.4 Using MySQL Enterprise Backup with Group Replication</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286790589680"></a><p>
        This section describes the different modes of deploying Group
        Replication, explains common operations for managing groups and
        provides information about how to tune your groups.



        .
    </p><p style="color:blue;">本节介绍部署组复制的不同模式，解释管理组的常见操作，并提供有关如何优化组的信息。是的。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-deploying-in-multi-primary-or-single-primary-mode"></a>17.4.1&nbsp;Deploying in Multi-Primary or Single-Primary Mode</h3>

                    </div>

                </div>

            </div>

            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-single-primary-mode">17.4.1.1 Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-multi-primary-mode">17.4.1.2 Multi-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-find-primary">17.4.1.3 Finding the Primary</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286790585488"></a><a class="indexterm" name="idm140286790583968"></a><a class="indexterm" name="idm140286790582480"></a><p>
            Group Replication operates in the following different modes:

        </p><p style="color:blue;">组复制以以下不同模式运行：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    single-primary mode
                </p><p style="color:blue;">单一主模式</p></li><li class="listitem"><p>
                    multi-primary mode
                </p><p style="color:blue;">多主模式</p></li></ul>
            </div>
            <p>

                The default mode is single-primary. It is not possible to have
                members of the group deployed in different modes, for example one
                configured in multi-primary mode while another one is in
                single-primary mode. To switch between modes, the group and not
                the server, needs to be restarted with a different operating
                configuration. Regardless of the deployed mode, Group Replication
                does not handle client-side fail-over, that must be handled by the
                application itself, a connector or a middleware framework such as
                a proxy or <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router 8.0</a>.
            </p><p style="color:blue;">默认模式是单主模式。无法以不同模式部署组成员，例如一个配置为多主模式，而另一个配置为单主模式。要在模式之间切换，需要使用不同的操作配置重新启动组而不是服务器。无论采用何种部署模式，组复制都不会处理客户端故障转移，必须由应用程序本身、连接器或中间件框架（如代理服务器或mysql路由器8.0）处理。</p><p>
            When deployed in multi-primary mode, statements are checked to
            ensure they are compatible with the mode. The following checks are
            made when Group Replication is deployed in multi-primary mode:
        </p><p style="color:blue;">在多主模式下部署时，将检查语句以确保它们与模式兼容。在多主模式下部署组复制时进行以下检查：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If a transaction is executed under the SERIALIZABLE isolation
                    level, then its commit fails when synchronizing itself with
                    the group.
                </p><p style="color:blue;">如果事务是在可序列化的隔离级别下执行的，则其提交将在与组同步时失败。</p></li><li class="listitem"><p>
                    If a transaction executes against a table that has foreign
                    keys with cascading constraints, then the transaction fails to
                    commit when synchronizing itself with the group.
                </p><p style="color:blue;">如果事务针对具有外键且具有级联约束的表执行，则事务在与组同步时将无法提交。</p></li></ul>
            </div>
            <p>
                These checks can be deactivated by setting the option
                <a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks"><code class="literal">group_replication_enforce_update_everywhere_checks</code></a>
                to <code class="literal">FALSE</code>. When deploying in single-primary
                mode, this option <span class="emphasis"><em>must</em></span> be set to
                <code class="literal">FALSE</code>.
            </p><p style="color:blue;">可以通过将选项组“复制”“强制”“到处更新”“检查”设置为false来停用这些检查。在单主模式下部署时，此选项必须设置为false。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-single-primary-mode"></a>17.4.1.1&nbsp;Single-Primary Mode</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286790569248"></a><a class="indexterm" name="idm140286790567760"></a><p>
                In this mode the group has a single-primary server that is set
                to read-write mode. All the other members in the group are set
                to read-only mode (with
                <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super-read-only=ON</code></a>



                ). This happens automatically. The primary is typically the
                first server to bootstrap the group, all other servers that join
                automatically learn about the primary server and are set to read
                only.
            </p><p style="color:blue;">在此模式下，组有一个设置为读写模式的主服务器。组中的所有其他成员都设置为只读模式（super read only=on）。这是自动发生的。主服务器通常是引导组的第一个服务器，所有加入的其他服务器都会自动了解主服务器并设置为只读。</p>
                <div class="figure">
                    <a name="idm140286790563584"></a><p class="title"><b>Figure&nbsp;17.5&nbsp;New Primary Election</b></p><p style="color:blue;">图17.5新一轮初选</p>
                    <div class="figure-contents">

                        <div class="mediaobject">
                            <img src="images/single-primary-election.png" width="948" height="327" alt="Five server instances, S1, S2, S3, S4, and S5, are deployed as an interconnected group. Server S1 is the primary. Write clients are communicating with server S1, and a read client is communicating with server S4. Server S1 then fails, breaking communication with the write clients. Server S2 then takes over as the new primary, and the write clients now communicate with server S2.">
                        </div>

                    </div>

                </div>
                <br class="figure-break"><p>
                When in single-primary mode, some of the checks deployed in
                multi-primary mode are disabled, because the system enforces
                that only a single server writes to the group. For example,
                changes to tables that have cascading foreign keys are allowed,
                whereas in multi-primary mode they are not. Upon primary member
                failure, an automatic primary election mechanism chooses the new
                primary member. The election process is performed by looking at
                the new view, and ordering the potential new primaries based on
                the value of
                <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>.
                Assuming the group is operating with all members running the
                same MySQL version, then the member with the highest value for
                <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>
                is elected as the new primary. In the event that multiple
                servers have the same
                <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>,
                the servers are then prioritized based on their
                <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> in lexicographical
                order and by picking the first one. Once a new primary is
                elected, it is automatically set to read-write and the other
                secondaries remain as secondaries, and as such, read-only.
            </p><p style="color:blue;">当处于单主模式时，在多主模式下部署的某些检查将被禁用，因为系统强制仅一台服务器写入组。例如，允许对具有级联外键的表进行更改，而在多主模式下则不允许。在主要成员失败时，自动的主要选举机制选择新的主要成员。选举过程通过查看新视图，并根据组复制成员权重的值排序潜在的新初选。假设组在所有成员运行相同mysql版本的情况下运行，那么组复制成员权重值最高的成员将被选为新的主成员。在多个服务器具有相同的GypPrimeSimultPyMeMyLoad权重的情况下，服务器根据它们的Server uuID在字典顺序中的排序，并通过选择第一个服务器来确定优先级。一旦选择了一个新的主节点，它将自动设置为读写，而其他辅助节点将保持为辅助节点，因此也是只读的。</p><p>
                When a new primary is elected, it is only writable once it has
                processed all of the transactions that came from the old
                primary. This avoids possible concurrency issues between old
                transactions from the old primary and the new ones being
                executed on this member. It is a good practice to wait for the
                new primary to apply its replication related relay-log before
                re-routing client applications to it.
            </p><p style="color:blue;">当选择新的主节点时，它只有在处理了来自旧主节点的所有事务之后才可写。这避免了来自旧主节点的旧事务和在此成员上执行的新事务之间可能出现的并发问题。在将客户端应用程序重新路由到新主服务器之前，等待其应用与复制相关的中继日志是一个好的做法。</p><p>
                If the group is operating with members that are running
                different versions of MySQL then the election process can be
                impacted. For example, if any member does not support
                <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>,
                then the primary is chosen based on
                <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> order from the
                members of the lower major version. Alternatively, if all
                members running different MySQL versions do support
                <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>,
                the primary is chosen based on
                <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>
                from the members of the lower major version.
            </p><p style="color:blue;">如果组使用运行不同版本mysql的成员进行操作，则选举过程可能会受到影响。例如，如果任何成员不支持组复制成员权重，则根据较低主版本成员的服务器ID顺序选择主版本。或者，如果运行不同mysql版本的所有成员都支持group_replication_member_weight，则根据较低主版本成员的group_replication_member_weight选择主版本。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-multi-primary-mode"></a>17.4.1.2&nbsp;Multi-Primary Mode</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286790542400"></a><p>
                In multi-primary mode, there is no notion of a single primary.
                There is no need to engage an election procedure because there
                is no server playing any special role.
            </p><p style="color:blue;">在多主模式中，没有单一主模式的概念。不需要参与选举程序，因为没有服务器扮演任何特殊角色。</p>
                <div class="figure">
                    <a name="idm140286790540320"></a><p class="title"><b>Figure&nbsp;17.6&nbsp;Client Failover</b></p><p style="color:blue;">图17.6客户端故障转移</p>
                    <div class="figure-contents">

                        <div class="mediaobject">
                            <img src="images/multi-primary.png" width="948" height="327" alt="Five server instances, S1, S2, S3, S4, and S5, are deployed as an interconnected group. All of the servers are primaries. Write clients are communicating with servers S1 and S2, and a read client is communicating with server S4. Server S1 then fails, breaking communication with its write client. This client reconnects to server S3.">
                        </div>

                    </div>

                </div>
                <br class="figure-break"><p>
                All servers are set to read-write mode when joining the group.
            </p><p style="color:blue;">加入组时，所有服务器都设置为读写模式。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-find-primary"></a>17.4.1.3&nbsp;Finding the Primary</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following example shows how to find out which server is
                    currently the primary when deployed in single-primary mode.
                </p><p style="color:blue;">下面的示例演示如何在以单一主模式部署时找出当前哪个服务器是主服务器。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'group_replication_primary_member'</code></strong>
</pre>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-tuning-recovery"></a>17.4.2&nbsp;Tuning Recovery</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286790528528"></a><p>
            Whenever a new member joins a replication group, it connects to a
            suitable donor and fetches the data that it has missed up until
            the point it is declared online. This critical component in Group
            Replication is fault tolerant and configurable. The following
            section explains how recovery works and how to tune the settings
        </p><p style="color:blue;">每当新成员加入复制组时，它都会连接到合适的捐赠者，并获取它错过的数据，直到将其声明为联机为止。组内复制的这个关键组件是容错的和可配置的。以下部分说明恢复的工作原理以及如何调整设置</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="group-replication-donor-selection"></a>Donor Selection</h4>
                        </div>
                    </div>
                </div>
                <p>
                    A random donor is selected from the existing online members in
                    the group. This way there is a good chance that the same server
                    is not selected more than once when multiple members enter the
                    group.
                </p><p style="color:blue;">从该组中现有的在线成员中选择随机供体。这样，当多个成员进入组时，很可能不会多次选择同一服务器。</p><p>
                If the connection to the selected donor fails, a new connection
                is automatically attempted to a new candidate donor. Once the
                connection retry limit is reached the recovery procedure
                terminates with an error.
            </p><p style="color:blue;">如果与所选捐赠者的连接失败，将自动尝试与新的候选捐赠者建立新连接。一旦达到连接重试限制，恢复过程将终止并出现错误。</p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        A donor is picked randomly from the list of online members in
                        the current view.
                    </p><p style="color:blue;">捐赠者是从当前视图中的在线成员列表中随机选择的。</p>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="group-replication-enhanced-automatic-donor-switchover"></a>Enhanced Automatic Donor Switchover</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The other main point of concern in recovery as a whole is to
                    make sure that it copes with failures. Hence, Group Replication
                    provides robust error detection mechanisms. In earlier versions
                    of Group Replication, when reaching out to a donor, recovery
                    could only detect connection errors due to authentication issues
                    or some other problem. The reaction to such problematic
                    scenarios was to switch over to a new donor thus a new
                    connection attempt was made to a different member.


                </p><p style="color:blue;">整个经济复苏的另一个主要问题是确保它能应对失败。因此，组复制提供了健壮的错误检测机制。在早期版本的组复制中，当联系到捐赠者时，恢复只能检测到由于身份验证问题或某些其他问题导致的连接错误。对这种有问题的情况的反应是切换到一个新的捐赠者，从而尝试与另一个成员建立新的联系。</p><p>
                This behavior was extended to also cover other failure
                scenarios:
            </p><p style="color:blue;">此行为也扩展到了其他故障场景：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="emphasis"><em>Purged data scenarios</em></span> - If the selected
                        donor contains some purged data that is needed for the
                        recovery process then an error occurs. Recovery detects this
                        error and a new donor is selected.
                    </p><p style="color:blue;">清除的数据方案-如果选定的捐赠者包含恢复过程所需的某些清除的数据，则会发生错误。Recovery检测到此错误并选择了新的捐赠者。</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Duplicated data</em></span> - If a server joining
                        the group already contains some data that conflicts with the
                        data coming from the selected donor during recovery then an
                        error occurs. This could be caused by some errant
                        transactions present in the server joining the group.
                    </p><p style="color:blue;">重复数据-如果加入组的服务器已包含一些数据，这些数据在恢复过程中与来自选定捐赠者的数据冲突，则会发生错误。这可能是由于加入组的服务器中存在一些错误的事务造成的。</p><p>
                        One could argue that recovery should fail instead of
                        switching over to another donor, but in heterogeneous groups
                        there is chance that other members share the conflicting
                        transactions and others do not. For that reason, upon error,
                        recovery selects another donor from the group.
                    </p><p style="color:blue;">有人可能会争辩说，复苏应该失败，而不是转向另一个捐助者，但在不同的群体中，有可能其他成员共享冲突的交易，而其他成员则没有。因此，一旦出现错误，Recovery将从组中选择另一个捐赠者。</p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Other errors</em></span> - If any of the recovery
                        threads fail (receiver or applier threads fail) then an
                        error occurs and recovery switches over to a new donor.
                    </p><p style="color:blue;">其他错误-如果任何恢复线程失败（接收器或applier线程失败），则会发生错误，并将恢复切换到新的施主。</p></li></ul>
                </div>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Note
                    </div>
                    <p>
                        In case of some persistent failures or even transient failures
                        recovery automatically retries connecting to the same or a new
                        donor.
                    </p><p style="color:blue;">在某些持久性故障甚至暂时性故障的情况下，恢复会自动重试连接到同一个或新的捐赠者。</p>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="group-replication-donor-connection-retries"></a>Donor Connection Retries</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The recovery data transfer relies on the binary log and existing
                    MySQL replication framework, therefore it is possible that some
                    transient errors could cause errors in the receiver or applier
                    threads. In such cases, the donor switch over process has retry
                    functionality, similar to that found in regular replication.
                </p><p style="color:blue;">恢复数据传输依赖于二进制日志和现有的MySQL复制框架，因此一些瞬时错误可能会导致接收器或应用程序线程中的错误。在这种情况下，施主切换进程具有重试功能，类似于常规复制中的功能。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="group-replication-number-of-attempts"></a>Number of Attempts</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The number of attempts a server joining the group makes when
                    trying to connect to a donor from the pool of donors is 10. This
                    is configured through the
                    <a class="link" href="group-replication.html#sysvar_group_replication_recovery_retry_count"><code class="literal">group_replication_recovery_retry_count</code></a>
                    plugin variable . The following command sets the maximum number
                    of attempts to connect to a donor to 10.
                </p><p style="color:blue;">加入组的服务器尝试从捐助者池连接到捐助者时所做的尝试次数为10。这是通过组复制恢复重试计数插件变量配置的。下面的命令将连接到供体的尝试的最大数量设置为10。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_recovery_retry_count= 10;</code></strong>
</pre><p>
                Note that this accounts for the global number of attempts that
                the server joining the group makes connecting to each one of the
                suitable donors.
            </p><p style="color:blue;">请注意，这是加入组的服务器连接到每个合适的捐赠者的全局尝试次数。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="group-replication-sleep-routines"></a>Sleep Routines</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The
                    <a class="link" href="group-replication.html#sysvar_group_replication_recovery_reconnect_interval"><code class="literal">group_replication_recovery_reconnect_interval</code></a>
                    plugin variable defines how much time the recovery process
                    should sleep between donor connection attempts. This variable
                    has its default set to 60 seconds and you can change this value
                    dynamically. The following command sets the recovery donor
                    connection retry interval to 120 seconds.
                </p><p style="color:blue;">group_replication_recovery_reconnect_interval plugin变量定义恢复进程在捐助者连接尝试之间的睡眠时间。此变量的默认设置为60秒，您可以动态更改此值。以下命令将恢复捐助者连接重试间隔设置为120秒。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_recovery_reconnect_interval= 120;</code></strong>
</pre><p>
                Note, however, that recovery does not sleep after every donor
                connection attempt. As the server joining the group is
                connecting to different servers and not to the same one over and
                over again, it can assume that the problem that affects server A
                does not affect server B. As such, recovery suspends only when
                it has gone through all the possible donors. Once the server
                joining the group has tried to connect to all the suitable
                donors in the group and none remains, the recovery process
                sleeps for the number of seconds configured by the
                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_reconnect_interval"><code class="literal">group_replication_recovery_reconnect_interval</code></a>
                variable.
            </p><p style="color:blue;">但是，请注意，在每次尝试连接捐赠者之后，恢复不会休眠。由于加入组的服务器一次又一次地连接到不同的服务器，而不是同一个服务器，因此可以假定影响服务器A的问题不会影响服务器B。因此，只有当恢复经过所有可能的捐助者之后，恢复才会暂停。一旦加入组的服务器尝试连接到组中所有合适的捐赠者，但没有任何捐赠者，恢复过程将休眠由组复制恢复重新连接间隔变量配置的秒数。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-network-partitioning"></a>17.4.3&nbsp;Network Partitioning</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286790496512"></a><p>
            The group needs to achieve consensus whenever a change that needs
            to be replicated happens. This is the case for regular
            transactions but is also required for group membership changes and
            some internal messaging that keeps the group consistent. Consensus
            requires a majority of group members to agree on a given decision.
            When a majority of group members is lost, the group is unable to
            progress and blocks because it cannot secure majority or quorum.
        </p><p style="color:blue;">当需要复制的变更发生时，团队需要达成共识。对于常规事务也是如此，但对于组成员资格更改和一些保持组一致的内部消息传递也是必需的。协商一致要求大多数集团成员就某一决定达成一致意见。当大多数组成员丢失时，该组无法继续并阻止，因为它无法确保多数或仲裁。</p><p>
            Quorum may be lost when there are multiple involuntary failures,
            causing a majority of servers to be removed abruptly from the
            group. For example in a group of 5 servers, if 3 of them become
            silent at once, the majority is compromised and thus no quorum can
            be achieved. In fact, the remaining two are not able to tell if
            the other 3 servers have crashed or whether a network partition
            has isolated these 2 alone and therefore the group cannot be
            reconfigured automatically.
        </p><p style="color:blue;">当出现多个非自愿故障时，仲裁可能会丢失，导致大多数服务器突然从组中删除。例如，在一个由5台服务器组成的组中，如果其中3台服务器同时变为静音，则大多数服务器都会受到影响，因此无法达到仲裁。事实上，剩下的两台无法判断其他3台服务器是否崩溃，或者网络分区是否单独隔离了这2台服务器，因此无法自动重新配置组。</p><p>
            On the other hand, if servers exit the group voluntarily, they
            instruct the group that it should reconfigure itself. In practice,
            this means that a server that is leaving tells others that it is
            going away. This means that other members can reconfigure the
            group properly, the consistency of the membership is maintained
            and the majority is recalculated. For example, in the above
            scenario of 5 servers where 3 leave at once, if the 3 leaving
            servers warn the group that they are leaving, one by one, then the
            membership is able to adjust itself from 5 to 2, and at the same
            time, securing quorum while that happens.
        </p><p style="color:blue;">另一方面，如果服务器自愿退出组，则指示组应该重新配置自身。实际上，这意味着离开的服务器会告诉其他人它正在离开。这意味着其他成员可以正确地重新配置组，保持成员身份的一致性，并重新计算大多数成员。例如，在上述5台服务器中，3台服务器同时离开，如果3台离开的服务器一个接一个地警告组它们要离开，则成员资格可以将自身从5调整为2，同时在发生这种情况时保护仲裁。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    Loss of quorum is by itself a side-effect of bad planning. Plan
                    the group size for the number of expected failures (regardless
                    whether they are consecutive, happen all at once or are
                    sporadic).


                </p><p style="color:blue;">失去法定人数本身就是不良计划的副作用。为预期的失败次数计划组大小（不管它们是连续的、一次发生的还是偶发的）。</p>
            </div>
            <p>
                The following sections explain what to do if the system partitions
                in such a way that no quorum is automatically achieved by the
                servers in the group.
            </p><p style="color:blue;">以下各节说明如果系统分区的方式使组中的服务器无法自动实现仲裁，应如何操作。</p>
            <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Tip
                </div>
                <p>
                    A primary that has been excluded from a group after a majority
                    loss followed by a reconfiguration can contain extra
                    transactions that are not included in the new group. If this
                    happens, the attempt to add back the excluded member from the
                    group results in an error with the message <span class="errortext">This
        member has more executed transactions than those present in the
        group.</span>
                </p><p style="color:blue;">在多数损失之后重新配置后从组中排除的主组可以包含未包含在新组中的额外事务。如果发生这种情况，尝试从组中添加被排除的成员将导致错误消息“此成员的已执行事务比组中的多”。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="group-replication-detecting-partitions"></a>Detecting Partitions</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">replication_group_members</code></a>
                    performance schema table presents the status of each server in
                    the current view from the perspective of this server. The
                    majority of the time the system does not run into partitioning,
                    and therefore the table shows information that is consistent
                    across all servers in the group. In other words, the status of
                    each server on this table is agreed by all in the current view.
                    However, if there is network partitioning, and quorum is lost,
                    then the table shows the status <code class="literal">UNREACHABLE</code>
                    for those servers that it cannot contact. This information is
                    exported by the local failure detector built into Group
                    Replication.
                </p><p style="color:blue;">复制组成员性能架构表从该服务器的角度显示当前视图中每个服务器的状态。大多数情况下，系统不会运行到分区中，因此表中显示的信息在组中的所有服务器上都是一致的。换句话说，当前视图中的所有人都同意此表上每个服务器的状态。但是，如果存在网络分区，并且仲裁丢失，则该表将显示无法与其联系的服务器的状态。此信息由组复制中内置的本地故障检测器导出。</p>
                <div class="figure">
                    <a name="idm140286790483984"></a><p class="title"><b>Figure&nbsp;17.7&nbsp;Losing Quorum</b></p><p style="color:blue;">图17.7失去法定人数</p>
                    <div class="figure-contents">

                        <div class="mediaobject">
                            <img src="images/gr-majority-lost.png" width="265" height="417" alt="Five server instances, S1, S2, S3, S4, and S5, are deployed as an interconnected group, which is a stable group. When three of the servers, S3, S4, and S5, fail, the majority is lost and the group can no longer proceed without intervention.">
                        </div>

                    </div>

                </div>
                <br class="figure-break"><p>
                To understand this type of network partition the following
                section describes a scenario where there are initially 5 servers
                working together correctly, and the changes that then happen to
                the group once only 2 servers are online. The scenario is
                depicted in the



                figure.
            </p><p style="color:blue;">为了理解这种类型的网络分区，下面的部分描述了一个场景，其中最初有5个服务器在一起正常工作，并且在只有2个服务器联机时，组发生的更改。该场景如图所示。</p><p>
                As such, lets assume that there is a group with these 5 servers
                in it:


            </p><p style="color:blue;">因此，假设有一个组包含以下5个服务器：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Server s1 with member identifier
                        <code class="literal">199b2df7-4aaf-11e6-bb16-28b2bd168d07</code>
                    </p><p style="color:blue;">服务器s1，成员标识符199b2df7-4aaf-11e6-bb16-28b2bd168d07</p></li><li class="listitem"><p>
                        Server s2 with member identifier
                        <code class="literal">199bb88e-4aaf-11e6-babe-28b2bd168d07</code>
                    </p><p style="color:blue;">服务器s2，成员标识符199bb88e-4aaf-11e6-babe-28b2bd168d07</p></li><li class="listitem"><p>
                        Server s3 with member identifier
                        <code class="literal">1999b9fb-4aaf-11e6-bb54-28b2bd168d07</code>
                    </p><p style="color:blue;">服务器s3，成员标识符1999b9fb-4aaf-11e6-bb54-28b2bd168d07</p></li><li class="listitem"><p>
                        Server s4 with member identifier
                        <code class="literal">19ab72fc-4aaf-11e6-bb51-28b2bd168d07</code>
                    </p><p style="color:blue;">服务器s4，成员标识符为19ab72fc-4aaf-11e6-bb51-28b2bd168d07</p></li><li class="listitem"><p>
                        Server s5 with member identifier
                        <code class="literal">19b33846-4aaf-11e6-ba81-28b2bd168d07</code>
                    </p><p style="color:blue;">服务器s5，成员标识符为19b33846-4aaf-11e6-ba81-28b2bd168d07</p></li></ul>
                </div>
                <p>
                    Initially the group is running fine and the servers are happily
                    communicating with each other. You can verify this by logging
                    into s1 and looking at its
                    <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">replication_group_members</code></a>
                    performance schema table. For example:
                </p><p style="color:blue;">最初，该组运行良好，服务器彼此通信愉快。您可以通过登录到s1并查看其复制组成员性能架构表来验证这一点。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE, MEMBER_ROLE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+-------------+
| MEMBER_ID                            | MEMBER_STATE |-MEMBER_ROLE |
+--------------------------------------+--------------+-------------+
| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | ONLINE       | SECONDARY   |
| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       | PRIMARY     |
| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       | SECONDARY   |
| 19ab72fc-4aaf-11e6-bb51-28b2bd168d07 | ONLINE       | SECONDARY   |
| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | ONLINE       | SECONDARY   |
+--------------------------------------+--------------+-------------+
</pre><p>
                However, moments later there is a catastrophic failure and
                servers s3, s4 and s5 stop unexpectedly. A few seconds after
                this, looking again at the
                <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">replication_group_members</code></a> table on
                s1 shows that it is still online, but several others members are
                not. In fact, as seen below they are marked as
                <code class="literal">UNREACHABLE</code>. Moreover, the system could not
                reconfigure itself to change the membership, because the
                majority has been lost.
            </p><p style="color:blue;">然而，片刻之后出现灾难性故障，服务器s3、s4和s5意外停止。几秒钟后，再次查看s1上的replication_group_members表，可以看到它仍然在线，但其他几个成员没有。事实上，如下所示，它们被标记为无法到达。此外，该系统无法重新配置自身以更改成员资格，因为大多数成员已丧失。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | UNREACHABLE  |
| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       |
| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       |
| 19ab72fc-4aaf-11e6-bb51-28b2bd168d07 | UNREACHABLE  |
| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | UNREACHABLE  |
+--------------------------------------+--------------+
</pre><p>
                The table shows that s1 is now in a group that has no means of
                progressing without external intervention, because a majority of
                the servers are unreachable. In this particular case, the group
                membership list needs to be reset to allow the system to
                proceed, which is explained in this section. Alternatively, you
                could also choose to stop Group Replication on s1 and s2 (or
                stop completely s1 and s2), figure out what happened with s3, s4
                and s5 and then restart Group Replication (or the servers).
            </p><p style="color:blue;">该表显示，s1现在所在的组在没有外部干预的情况下无法前进，因为大多数服务器都无法访问。在这种特殊情况下，需要重置组成员列表以允许系统继续，本节将对此进行说明。或者，您也可以选择停止s1和s2上的组复制（或完全停止s1和s2），找出s3、s4和s5发生了什么，然后重新启动组复制（或服务器）。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="group-replication-unblocking-a-partition"></a>Unblocking a Partition</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Group replication enables you to reset the group membership list
                    by forcing a specific configuration. For instance in the case
                    above, where s1 and s2 are the only servers online, you could
                    chose to force a membership configuration consisting of only s1
                    and s2. This requires checking some information about s1 and s2
                    and then using the
                    <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
                    variable.
                </p><p style="color:blue;">组复制使您能够通过强制特定配置来重置组成员资格列表。例如，在上面的例子中，s1和s2是唯一联机的服务器，您可以选择强制一个仅由s1和s2组成的成员资格配置。这需要检查有关s1和s2的一些信息，然后使用group_replication_force_members变量。</p>
                <div class="figure">
                    <a name="idm140286790452944"></a><p class="title"><b>Figure&nbsp;17.8&nbsp;Forcing a New Membership</b></p><p style="color:blue;">图17.8强迫新成员</p>
                    <div class="figure-contents">

                        <div class="mediaobject">
                            <img src="images/gr-majority-lost-to-stable-group.png" width="266" height="414" alt="Three of the servers in a group, S3, S4, and S5, have failed, so the majority is lost and the group can no longer proceed without intervention. With the intervention described in the following text, S1 and S2 are able to form a stable group by themselves.">
                        </div>

                    </div>

                </div>
                <br class="figure-break"><p>
                Suppose that you are back in the situation where s1 and s2 are
                the only servers left in the group. Servers s3, s4 and s5 have
                left the group unexpectedly. To make servers s1 and s2 continue,
                you want to force a membership configuration that contains only
                s1 and s2.
            </p><p style="color:blue;">假设您回到了s1和s2是组中仅存的服务器的情况。服务器s3、s4和s5意外地离开了组。要使服务器s1和s2继续，需要强制只包含s1和s2的成员资格配置。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        This procedure uses
                        <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
                        and should be considered a last resort remedy. It
                        <span class="emphasis"><em>must</em></span> be used with extreme care and only
                        for overriding loss of quorum. If misused, it could create an
                        artificial split-brain scenario or block the entire system
                        altogether.
                    </p><p style="color:blue;">此程序使用组复制力成员，应被视为最后的补救措施。必须非常小心地使用，并且仅用于压倒法定人数的损失。如果使用不当，它可能会造成一个人工分裂大脑的场景或完全阻断整个系统。</p>
                </div>
                <p>
                    Recall that the system is blocked and the current configuration
                    is the following (as perceived by the local failure detector on
                    s1):
                </p><p style="color:blue;">回想一下，系统被阻塞，当前配置如下（如s1上的本地故障检测器所感知）：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | UNREACHABLE  |
| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       |
| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       |
| 19ab72fc-4aaf-11e6-bb51-28b2bd168d07 | UNREACHABLE  |
| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | UNREACHABLE  |
+--------------------------------------+--------------+
</pre><p>
                The first thing to do is to check what is the local address
                (group communication identifier) for s1 and s2. Log in to s1 and
                s2 and get that information as follows.
            </p><p style="color:blue;">首先要做的是检查s1和s2的本地地址（组通信标识符）。登录到s1和s2并获取以下信息。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@group_replication_local_address;</code></strong>
</pre><p>
                Once you know the group communication addresses of s1
                (<code class="literal">127.0.0.1:10000</code>) and s2
                (<code class="literal">127.0.0.1:10001</code>), you can use that on one of
                the two servers to inject a new membership configuration, thus
                overriding the existing one that has lost quorum. To do that on
                s1:
            </p><p style="color:blue;">一旦知道S1（127.0.0.1:10000）和S2（127.0.0.1:10001）的组通信地址，就可以使用这两个服务器中的一个来注入新的成员配置，从而重写已经失去法定人数的现有成员资格。要在s1上执行此操作：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_force_members="</code></strong>127.0.0.1:10000,127.0.0.1:10001";
</pre><p>
                This unblocks the group by forcing a different configuration.
                Check <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">replication_group_members</code></a> on
                both s1 and s2 to verify the group membership after this change.
                First on s1.
            </p><p style="color:blue;">这将通过强制其他配置来解除阻止组。检查s1和s2上的复制组成员，以在此更改后验证组成员身份。先到s1。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| b5ffe505-4ab6-11e6-b04b-28b2bd168d07 | ONLINE       |
| b60907e7-4ab6-11e6-afb7-28b2bd168d07 | ONLINE       |
+--------------------------------------+--------------+
</pre><p>
                And then on s2.
            </p><p style="color:blue;">然后在S2。</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| b5ffe505-4ab6-11e6-b04b-28b2bd168d07 | ONLINE       |
| b60907e7-4ab6-11e6-afb7-28b2bd168d07 | ONLINE       |
+--------------------------------------+--------------+
</pre><p>
                When forcing a new membership configuration, make sure that any
                servers are going to be forced out of the group are indeed
                stopped. In the scenario depicted above, if s3, s4 and s5 are
                not really unreachable but instead are online, they may have
                formed their own functional partition (they are 3 out of 5,
                hence they have the majority). In that case, forcing a group
                membership list with s1 and s2 could create an artificial
                split-brain situation. Therefore it is important before forcing
                a new membership configuration to ensure that the servers to be
                excluded are indeed shutdown and if they are not, shut them down
                before proceeding.
            </p><p style="color:blue;">在强制新成员身份配置时，请确保确实已停止将要强制出组的任何服务器。在上面描述的场景中，如果s3、s4和s5不是真的无法访问，而是在线的，那么它们可能已经形成了自己的功能分区（它们是5个分区中的3个，因此占大多数）。在这种情况下，使用s1和s2强制一个组成员列表可能会造成一种人工的大脑分裂情况。因此，在强制新的成员资格配置之前，必须确保要排除的服务器确实已关闭，如果没有，请在继续之前将其关闭。</p><p>
                After you have used the
                <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
                system variable to successfully force a new group membership and
                unblock the group, ensure that you clear the system variable.
                <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
                must be empty in order to issue a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START
                GROUP_REPLICATION</code></a> statement.
            </p><p style="color:blue;">使用GROUP U REPLICATION U FORCE U EMBERS系统变量成功强制新的组成员身份并取消阻止该组后，请确保清除该系统变量。若要发出启动组复制语句，组复制强制成员必须为空。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-enterprise-backup"></a>17.4.4&nbsp;Using MySQL Enterprise Backup with Group Replication</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286790420112"></a><a class="indexterm" name="idm140286790418624"></a><p>
            <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/" target="_top">MySQL Enterprise
                Backup</a> is a commercially-licensed backup utility for MySQL
            Server, available with
            <a class="ulink" href="https://www.mysql.com/products/enterprise/" target="_top">MySQL
                Enterprise Edition</a>. This section explains how to back up
            and subsequently restore a Group Replication member using MySQL Enterprise Backup.
            The same technique can be used to quickly add a new member to a
            group.
        </p><p style="color:blue;">mysql enterprise backup是一个商业许可的mysql服务器备份实用程序，随mysql enterprise edition提供。本节介绍如何使用mysql企业备份备份备份和随后还原组复制成员。可以使用相同的技术快速向组中添加新成员。</p>
            <h4><a name="idm140286790414976"></a>Backing up a Group Replication Member Using MySQL Enterprise Backup</h4>
            <p>
                Backing up a Group Replication member is similar to backing up a
                stand-alone MySQL instance. The following instructions assume that
                you are already familiar with how to use MySQL Enterprise Backup to perform a
                backup; if that is not the case, please review the
                <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/" target="_top">MySQL
                    Enterprise Backup 4.1 User's Guide</a>, especially
                <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/backing-up.html" target="_top">Backing Up a Database Server</a>. Also note the requirements described
                in <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/mysqlbackup.privileges.html" target="_top">Grant MySQL Privileges to Backup Administrator</a> and
                <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/meb-group-replication.html" target="_top">Using MySQL Enterprise Backup with Group Replication</a>.
            </p><p style="color:blue;">备份组复制成员类似于备份独立的mysql实例。以下说明假定您已经熟悉如何使用mysql enterprise backup执行备份；如果不是这样，请查看mysql enterprise backup 4.1用户指南，特别是备份数据库服务器。还请注意在向备份管理员授予mysql权限和将mysql企业备份与组复制一起使用中描述的要求。</p><p>
            Consider the following group with three members,
            <code class="literal">s1</code>, <code class="literal">s2</code>, and
            <code class="literal">s3</code>, running on hosts with the same names:
        </p><p style="color:blue;">考虑以下三个成员（s1、s2和s3）在同名主机上运行的组：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;</code></strong>
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s1          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s3          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre><p>
            Using MySQL Enterprise Backup, create a backup of <code class="literal">s2</code> by issuing
            on its host, for example, the following command:
        </p><p style="color:blue;">使用mysql enterprise backup，通过在s2的主机上发出以下命令创建s2的备份：</p><pre data-lang="terminal" class="programlisting">s2&gt; <strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf --backup-image=/backups/my.mbi_`date +%d%m_%H%M` \
		      --backup-dir=/backups/backup_`date +%d%m_%H%M` --user=root -p \
--host=127.0.0.1 backup-to-image</code></strong></pre>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>

                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="emphasis"><em>For MySQL Enterprise Backup 4.1.1 and earlier</em></span>, when
                        backing up a secondary member, as MySQL Enterprise Backup cannot write backup
                        status and metadata to a read-only server instance, it
                        issues the following warnings during the backup operation:
                    </p><p style="color:blue;">对于mysql enterprise backup 4.1.1及更早版本，由于mysql enterprise backup无法将备份状态和元数据写入只读服务器实例，因此在备份操作过程中会发出以下警告：</p><pre class="programlisting">181113 21:31:08 MAIN WARNING: This backup operation cannot write to backup
progress. The MySQL server is running with the --super-read-only option.</pre><p>
                        You can avoid the warning by using the
                        <code class="option">--no-history-logging</code> option with your
                        backup command. This is not an issue for MySQL Enterprise Backup 4.1.2 and
                        later—see
                        <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/meb-group-replication.html" target="_top">Using MySQL Enterprise Backup with Group Replication</a> for
                        details.
                    </p><p style="color:blue;">您可以在backup命令中使用--no history日志记录选项来避免警告。对于mysql enterprise backup 4.1.2，这不是问题，有关详细信息，请参阅将mysql enterprise backup与组复制结合使用。</p></li></ul>
                </div>

            </div>
            <h4><a name="group-replication-restore-failed-member"></a>Restoring a Failed Member</h4>
            <p>
                Assume one of the members (<code class="literal">s3</code> in the following
                example) is irreconcilably corrupted. The most recent backup of
                group member <code class="literal">s2</code> can be used to restore
                <code class="literal">s3</code>. Here are the steps for performing the
                restore:
            </p><p style="color:blue;">假设其中一个成员（以下示例中的s3）已不可调和地损坏。组成员s2的最新备份可用于还原s3。以下是执行还原的步骤：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="emphasis"><em>Copy the backup of s2 onto the host for
          s3.</em></span> The exact way to copy the backup depends on the
                    operating system and tools available to you. In this example,
                    we assume the hosts are both Linux servers and use SCP to copy
                    the files between them:
                </p><p style="color:blue;">将s2的备份复制到s3的主机上。复制备份的确切方式取决于可用的操作系统和工具。在本例中，我们假设主机都是Linux服务器，并使用SCP在它们之间复制文件：</p><pre data-lang="terminal" class="programlisting">s2/backups&gt; <strong class="userinput"><code>scp my.mbi_2206_1429 s3:/backups</code></strong></pre></li><li class="listitem"><p>
                    <span class="emphasis"><em>Restore the backup.</em></span> Connect to the target
                    host (the host for <code class="literal">s3</code> in this case), and
                    restore the backup using MySQL Enterprise Backup. Here are the steps:
                </p><p style="color:blue;">恢复备份。连接到目标主机（在本例中为s3的主机），并使用mysql enterprise backup还原备份。以下是步骤：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="a"><li class="listitem"><p>
                            Stop the corrupted server, if it is still running. For
                            example, on Linux distributions that use systemd:
                        </p><p style="color:blue;">停止损坏的服务器（如果它仍在运行）。例如，在使用systemd的linux发行版上：</p><pre class="programlisting">s3&gt; systemctl stop mysqld</pre></li><li class="listitem"><p>
                            Preserve the configuration file
                            <code class="filename">auto.cnf</code>, located in the corrupted
                            server's data directory, by copying it to a safe location
                            outside of the data directory. This is for preserving the
                            <a class="link" href="replication.html#sysvar_server_uuid">server's UUID</a>,
                            which is needed later.
                        </p><p style="color:blue;">通过将配置文件auto.cnf复制到数据目录之外的安全位置，保留该文件，该文件位于损坏服务器的数据目录中。这是为了保存服务器的uuid，这是以后需要的。</p></li><li class="listitem"><p>
                            Delete all contents in the data directory of
                            <code class="literal">s3</code>. For example:
                        </p><p style="color:blue;">删除s3数据目录中的所有内容。例如：</p><pre class="programlisting">s3&gt; rm -rf /var/lib/mysql/*</pre><p>
                            If the system variables
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a>,
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir"><code class="literal">innodb_log_group_home_dir</code></a>,
                            and
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>
                            point to any directories other than the data directory,
                            they should also be made empty; otherwise, the restore
                            operation fails.
                        </p><p style="color:blue;">如果系统变量innodb_data_home_dir、innodb_log_group_home_dir和innodb_undo_directory指向数据目录以外的任何目录，则它们也应设为空；否则，还原操作失败。</p></li><li class="listitem"><p>
                            Restore backup of <code class="literal">s2</code> onto the host for
                            <code class="literal">s3</code>:
                        </p><p style="color:blue;">将S2的备份还原到S3的主机上：</p><pre data-lang="terminal" class="programlisting">s3&gt; <strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf \
  --datadir=/var/lib/mysql \
  --backup-image=/backups/my.mbi_2206_1429  \
--backup-dir=/tmp/restore_`date +%d%m_%H%M` copy-back-and-apply-log</code></strong></pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Note
                                </div>
                                <p>
                                    The command above assumes that the binary logs and relay
                                    logs on <code class="literal">s2</code> and <code class="literal">s3</code>
                                    have the same base name and are at the same location on
                                    the two servers. If these conditions are not met, for
                                    MySQL Enterprise Backup 4.1.2 and later, you should use the
                                    <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/server-repository-options.html#option_meb_log-bin" target="_top"><code class="option">--log-bin</code></a> and
                                    <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/server-repository-options.html#option_meb_relay-log" target="_top"><code class="option">--relay-log</code></a> options to
                                    restore the binary log and relay log to their original
                                    file paths on <code class="literal">s3</code>. For example, if you
                                    know that on <code class="literal">s3</code> the binary log's base
                                    name is <code class="literal">s3-bin</code> and the relay-log's
                                    base name is <code class="literal">s3-relay-bin</code>, your
                                    restore command should look like:
                                </p><p style="color:blue;">上面的命令假设s2和s3上的二进制日志和中继日志具有相同的基名，并且位于两台服务器上的相同位置。如果不满足这些条件，对于mysql enterprise backup 4.1.2及更高版本，应使用--log bin和--relay log选项将二进制日志和中继日志还原到它们在s3上的原始文件路径。例如，如果您知道在s3上，二进制日志的基本名称是s3 bin，而中继日志的基本名称是s3 relay bin，那么您的restore命令应该如下所示：</p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf \
  --datadir=/var/lib/mysql \
  --backup-image=/backups/my.mbi_2206_1429  \
  --log-bin=s3-bin --relay-log=s3-relay-bin \
  --backup-dir=/tmp/restore_`date +%d%m_%H%M` copy-back-and-apply-log</code></strong></pre><p>
                                Being able to restore the binary log and relay log to
                                the right file paths makes the restore process easier;
                                if that is impossible for some reason, see
                                <a class="xref" href="group-replication.html#group-replication-rebuild-member" title="Rebuild the Failed Member to Rejoin as a New Member">Rebuild the Failed Member to Rejoin as a New Member</a>.
                            </p><p style="color:blue;">能够将二进制日志和中继日志还原到正确的文件路径使还原过程更容易；如果由于某种原因无法还原，请参阅重新生成失败的成员以作为新成员重新加入。</p>
                            </div>
                        </li></ol>
                    </div>
                </li><li class="listitem"><p>
          <span class="emphasis"><em>Restore the <code class="filename">auto.cnf</code> file for
          s3.</em></span> To rejoin the replication group, the restored
                    member <span class="emphasis"><em>must</em></span> have the same
                    <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> it
                    used to join the group before. Supply the old server UUID by
                    copying the <code class="filename">auto.cnf</code> file preserved in
                    step 2 above into the data directory of the restored member.
                </p><p style="color:blue;">还原s3的auto.cnf文件。若要重新加入复制组，还原的成员必须具有以前加入该组时使用的相同服务器ID。通过将上述步骤2中保留的auto.cnf文件复制到还原成员的数据目录中，提供旧服务器uuid。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If you cannot supply the failed member's original
                            <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a>
                            to the restored member by restoring its old
                            <code class="filename">auto.cnf</code> file, you will have to let the
                            restored member join the group as a new member; see
                            instructions in
                            <a class="xref" href="group-replication.html#group-replication-rebuild-member" title="Rebuild the Failed Member to Rejoin as a New Member">Rebuild the Failed Member to Rejoin as a New Member</a>
                            below on how to do that.
                        </p><p style="color:blue;">如果您无法通过还原失败成员的旧auto.cnf文件将其原始服务器ID提供给还原成员，则必须让还原成员作为新成员加入组；有关如何执行此操作，请参阅下面“重新生成失败成员以重新加入为新成员”中的说明。</p>
                    </div>
                </li><li class="listitem"><p>
                    <span class="emphasis"><em>Start the restored server.</em></span> For example,
                    on Linux distributions that use systemd:
                </p><p style="color:blue;">启动还原的服务器。例如，在使用systemd的linux发行版上：</p><pre class="programlisting">systemctl start mysqld</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If the server you are restoring is a primary member, perform
                            the steps described in
                            <a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="Restoring a Primary Member">Restoring a Primary Member</a>
                            <span class="emphasis"><em>before starting the restored server</em></span>.
                        </p><p style="color:blue;">如果要还原的服务器是主成员，请在启动还原的服务器之前执行还原主成员中描述的步骤。</p>
                    </div>
                </li><li class="listitem"><p>
                    <span class="emphasis"><em>Restart Group Replication.</em></span> Connect to the
                    restarted <code class="literal">s3</code> using, for example, a
                    <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client, and issue the following
                    command:
                </p><p style="color:blue;">重新启动组复制。使用mysql客户端连接到重新启动的s3，并发出以下命令：</p><pre class="programlisting">mysql&gt; START GROUP_REPLICATION;</pre><p>
                    Before the restored instance can become an online member of
                    the group, it needs to apply any transactions that have
                    happened to the group after the backup was taken; this is
                    achieved using Group Replication's
                    <a class="link" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5&nbsp;Distributed Recovery">distributed
                        recovery</a> mechanism, and the process starts after the
                    <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax">START
                        GROUP_REPLICATION</a> statement has been issued. To check
                    the member status of the restored instance, issue:
                </p><p style="color:blue;">在还原的实例成为组的联机成员之前，它需要应用备份后发生在组上的任何事务；这是使用组复制的分布式恢复机制实现的，并且该过程在发出start group_replication语句后开始。要检查还原实例的成员状态，请发出：</p><pre class="programlisting">mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s1          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s3          |        3306 | RECOVERING   |
+-------------+-------------+--------------+
</pre><p>
                    This shows that <code class="literal">s3</code> is applying transactions
                    to catch up with the group. Once it has caught up with the
                    rest of the group, its <code class="literal">member_state</code> changes
                    to <code class="literal">ONLINE</code>:
                </p><p style="color:blue;">这表明s3正在应用事务来赶上组。一旦它赶上了小组的其他成员，它的成员国就改为在线：</p><pre class="programlisting">mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s1          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s3          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If the server you are restoring is a primary member, once it
                            has gained synchrony with the group and become
                            <code class="literal">ONLINE</code>, perform the steps described at
                            the end of
                            <a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="Restoring a Primary Member">Restoring a Primary Member</a> to
                            revert the configuration changes you had made to the server
                            before you started it.
                        </p><p style="color:blue;">如果要还原的服务器是主要成员，则一旦该服务器与组同步并联机，请执行还原主要成员结尾处描述的步骤，以还原启动服务器之前对服务器所做的配置更改。</p>
                    </div>
                </li></ol>
            </div>
            <p>
                The member has now been fully restored from the backup and
                functions as a regular member of the group.
            </p><p style="color:blue;">该成员现在已从备份中完全还原，并作为组的常规成员运行。</p>
            <h4><a name="group-replication-rebuild-member"></a>Rebuild the Failed Member to Rejoin as a New Member</h4>
            <p>
                Sometimes, the steps outlined above in
                <a class="xref" href="group-replication.html#group-replication-restore-failed-member" title="Restoring a Failed Member">Restoring a Failed Member</a>
                cannot be carried out because, for example, the binary log or
                relay log is corrupted, or it is just missing from the backup. In
                such a situation, use the backup to rebuild the member, and then
                add it to the group as a new member. In the steps below, we assume
                the rebuilt member will be named <code class="literal">s3</code>, like the
                failed member, and it will be run on the same host as
                <code class="literal">s3</code> was:
            </p><p style="color:blue;">有时，由于（例如）二进制日志或中继日志已损坏，或者只是从备份中丢失，因此无法执行上述还原失败成员的步骤。在这种情况下，请使用备份重新生成成员，然后将其作为新成员添加到组中。在下面的步骤中，我们假设重建的成员将被命名为s3，与失败的成员一样，它将在与s3 was相同的主机上运行：</p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="emphasis"><em>Copy the backup of s2 onto the host for s3
          .</em></span> The exact way to copy the backup depends on the
                    operating system and tools available to you. In this example
                    we assume the hosts are both Linux servers and use SCP to copy
                    the files between them:
                </p><p style="color:blue;">将s2的备份复制到s3的主机上。复制备份的确切方式取决于可用的操作系统和工具。在本例中，我们假设主机都是Linux服务器，并使用SCP在它们之间复制文件：</p><pre data-lang="terminal" class="programlisting">s2/backups&gt; <strong class="userinput"><code>scp my.mbi_2206_1429 s3:/backups</code></strong></pre></li><li class="listitem"><p>
                    <span class="emphasis"><em>Restore the backup.</em></span> Connect to the target
                    host (the host for <code class="literal">s3</code> in this case), and
                    restore the backup using MySQL Enterprise Backup. Here are the steps:
                </p><p style="color:blue;">恢复备份。连接到目标主机（在本例中为s3的主机），并使用mysql enterprise backup还原备份。以下是步骤：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="a"><li class="listitem"><p>
                            Stop the corrupted server, if it is still running. For
                            example, on Linux distributions that use systemd:
                        </p><p style="color:blue;">停止损坏的服务器（如果它仍在运行）。例如，在使用systemd的linux发行版上：</p><pre class="programlisting">s3&gt; systemctl stop mysqld</pre></li><li class="listitem"><p>
                            Delete all contents in the data directory of
                            <code class="literal">s3</code>. For example:
                        </p><p style="color:blue;">删除s3数据目录中的所有内容。例如：</p><pre class="programlisting">s3&gt; rm -rf /var/lib/mysql/*</pre><p>
                            If the system variables
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a>,
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir"><code class="literal">innodb_log_group_home_dir</code></a>,
                            and
                            <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>
                            point to any directories other than the data directory,
                            they should also be made empty; otherwise, the restore
                            operation will fail.
                        </p><p style="color:blue;">如果系统变量innodb_data_home_dir、innodb_log_group_home_dir和innodb_undo_directory指向数据目录以外的任何目录，则它们也应设为空；否则，还原操作将失败。</p></li><li class="listitem"><p>
                            Restore the backup of <code class="literal">s2</code> onto the host
                            of <code class="literal">s3</code>. With this approach, we are
                            rebuilding <code class="literal"><code class="literal">s3</code></code> as a
                            new member, for which we do not need or do not want to use
                            the old binary and relay logs in the backup; therefore, if
                            these logs have been included in your backup, exclude them
                            using the
                            <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/backup-capacity-options.html#option_meb_skip-binlog" target="_top"><code class="option">--skip-binlog</code></a>
                            and <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/backup-capacity-options.html#option_meb_skip-relaylog" target="_top"><code class="option">--skip-relaylog</code></a> options:
                        </p><p style="color:blue;">将s2备份恢复到s3主机上。使用这种方法，我们将s3重新构建为一个新成员，我们不需要或不希望在备份中使用旧的二进制和中继日志；因此，如果这些日志已包含在备份中，请使用--skip binlog和--skip relaylog选项排除它们：</p><pre data-lang="terminal" class="programlisting">s3&gt; <strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf \
  --datadir=/var/lib/mysql \
  --backup-image=/backups/my.mbi_2206_1429  \
  --backup-dir=/tmp/restore_`date +%d%m_%H%M` \
  --skip-binlog --skip-relaylog \
copy-back-and-apply-log</code></strong></pre>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                                <div class="admon-title">
                                    Notes
                                </div>

                                <div class="itemizedlist">
                                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                        If you have healthy binary log and relay logs in the
                                        backup that you can transfer onto the target host
                                        with no issues, you are recommended to follow the
                                        easier procedure as described in
                                        <a class="xref" href="group-replication.html#group-replication-restore-failed-member" title="Restoring a Failed Member">Restoring a Failed Member</a>
                                        above.
                                    </p><p style="color:blue;">如果备份中有正常的二进制日志和中继日志，可以毫无问题地传输到目标主机上，建议您遵循上面还原失败成员中描述的更简单的过程。</p></li><li class="listitem"><p>
                                        Do NOT restore manually the corrupted server's
                                        <code class="filename">auto.cnf</code> file to the data
                                        directory of the new member—when the rebuilt
                                        <code class="literal">s3</code> joins the group as a new
                                        member, it is going to be assigned a new server
                                        UUID.
                                    </p><p style="color:blue;">不要手动将损坏的服务器auto.cnf文件还原到新成员的数据目录当重建的s3作为新成员加入组时，它将被分配一个新的服务器uuid。</p></li></ul>
                                </div>

                            </div>
                        </li></ol>
                    </div>
                </li><li class="listitem"><p>
                    <span class="emphasis"><em>Start the restored server.</em></span> For example,
                    on Linux distributions that use systemd:
                </p><p style="color:blue;">启动还原的服务器。例如，在使用systemd的linux发行版上：</p><pre class="programlisting">systemctl start mysqld</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If the server you are restoring is a primary member, perform
                            the steps described in
                            <a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="Restoring a Primary Member">Restoring a Primary Member</a>
                            <span class="emphasis"><em>before starting the restored server</em></span>.
                        </p><p style="color:blue;">如果要还原的服务器是主成员，请在启动还原的服务器之前执行还原主成员中描述的步骤。</p>
                    </div>
                </li><li class="listitem"><p>
          <span class="emphasis"><em>Reconfigure the restored member to join Group
          Replication.</em></span> Connect to the restored server with a
                    <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client and reset the master and slave
                    information with the following commands:
                </p><p style="color:blue;">重新配置还原的成员以加入组复制。使用mysql客户端连接到还原的服务器，并使用以下命令重置主服务器和从服务器信息：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>RESET MASTER;</code></strong></pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>RESET SLAVE ALL;</code></strong></pre><p>
                    For the restored server to be able to recover automatically
                    using Group Replication's built-in mechanism for
                    <a class="link" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5&nbsp;Distributed Recovery">distributed
                        recovery</a>, configure the server's
                    <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> variable. To do
                    this, use the <code class="filename">backup_gtid_executed.sql</code>
                    file included in the backup of <code class="literal">s2</code>, which is
                    usually restored under the restored member's data directory.
                    Disable binary logging, use the
                    <code class="filename">backup_gtid_executed.sql</code> file to
                    configure <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>, and
                    then re-enable binary logging by issuing the following
                    statements with your <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client:
                </p><p style="color:blue;">要使还原的服务器能够使用组复制的内置分布式恢复机制自动恢复，请配置服务器的gtid_executed变量。为此，请使用s2备份中包含的backup_gtid_executed.sql文件，该文件通常还原到还原成员的数据目录下。禁用二进制日志记录，使用backup gtid_executed.sql文件配置gtid_executed，然后通过对mysql客户端发出以下语句重新启用二进制日志记录：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>SOURCE <em class="replaceable"><code>datadir</code></em>/backup_gtid_executed.sql</code></strong>
mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=ON;</code></strong>
</pre><p>
                    Then, configure the
                    <a class="link" href="group-replication.html#group-replication-user-credentials" title="17.2.1.3&nbsp;User Credentials">Group
                        Replication user credentials</a> on the member:
                </p><p style="color:blue;">然后，在成员上配置组复制用户凭据：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' /
		FOR CHANNEL 'group_replication_recovery';</code></strong></pre></li><li class="listitem"><p>
                    <span class="emphasis"><em>Restart Group Replication.</em></span> Issue the
                    following command to the restored server with your
                    <a class="link" href="programs.html#mysql" title="4.5.1&nbsp;mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client:
                </p><p style="color:blue;">重新启动组复制。对MySQL客户端还原的服务器发出以下命令：</p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong></pre><p>
                    Before the restored instance can become an online member of
                    the group, it needs to apply any transactions that have
                    happened to the group after the backup was taken; this is
                    achieved using Group Replication's
                    <a class="link" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5&nbsp;Distributed Recovery">distributed
                        recovery</a> mechanism, and the process starts after the
                    <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax">START
                        GROUP_REPLICATION</a> statement has been issued. To check
                    the member status of the restored instance, issue:
                </p><p style="color:blue;">在还原的实例成为组的联机成员之前，它需要应用备份后发生在组上的任何事务；这是使用组复制的分布式恢复机制实现的，并且该过程在发出start group_replication语句后开始。要检查还原实例的成员状态，请发出：</p><pre class="programlisting">mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s3          |        3306 | RECOVERING   |
| s2          |        3306 | ONLINE       |
| s1          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre><p>
                    This shows that <code class="literal">s3</code> is applying transactions
                    to catch up with the group. Once it has caught up with the
                    rest of the group, its <code class="literal">member_state</code> changes
                    to <code class="literal">ONLINE</code>:
                </p><p style="color:blue;">这表明s3正在应用事务来赶上组。一旦它赶上了小组的其他成员，它的成员国就改为在线：</p><pre class="programlisting">mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s3          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s1          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            If the server you are restoring is a primary member, once it
                            has gained synchrony with the group and become
                            <code class="literal">ONLINE</code>, perform the steps described at
                            the end of
                            <a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="Restoring a Primary Member">Restoring a Primary Member</a> to
                            revert the configuration changes you had made to the server
                            before you started it.
                        </p><p style="color:blue;">如果要还原的服务器是主要成员，则一旦该服务器与组同步并联机，请执行还原主要成员结尾处描述的步骤，以还原启动服务器之前对服务器所做的配置更改。</p>
                    </div>
                </li></ol>
            </div>
            <p>
                The member has now been restored to the group as a new member.
            </p><p style="color:blue;">该成员现在已作为新成员还原到组中。</p><p><a name="group-replication-meb-restore-primary"></a><b>Restoring a Primary Member.&nbsp;</b>
            If the restored member is a primary in the group, care must be
            taken to prevent writes to the restored database during the
            Group Replication recovery phase: Depending on how the group is
            accessed by clients, there is a possibility of DML statements
            being executed on the restored member once it becomes accessible
            on the network, prior to the member finishing its catch-up on
            the activities it has missed while off the group. To avoid this,
            <span class="emphasis"><em>before starting the restored server</em></span>,
            configure the following system variables in the server option
            file:
        </p><p style="color:blue;">还原主要成员。如果还原的成员是组中的主要成员，则必须注意防止在组复制恢复阶段写入还原的数据库：根据客户端对组的访问方式，还原的成员一旦在网络上可访问，就有可能在该成员之前对其执行DML语句完成在小组外错过的活动。为了避免这种情况，在启动还原的服务器之前，请在服务器选项文件中配置以下系统变量：</p><pre data-lang="ini" class="programlisting">group_replication_start_on_boot=OFF
super_read_only=ON
event_scheduler=OFF
</pre><p>
            These settings ensure that the member becomes read-only at startup
            and that the event scheduler is turned off while the member is
            catching up with the group during the recovery phase. Adequate
            error handling must also be configured on the clients, as they
            will be prevented temporarily from performing DML operations
            during this period on the restored member. Once the restore
            process is fully completed and the restored member is in-sync with
            the rest of the group, revert those changes; restart the event
            scheduler:
        </p><p style="color:blue;">这些设置确保成员在启动时变为只读，并且在成员在恢复阶段追赶组时关闭事件计划程序。还必须在客户端上配置足够的错误处理，因为在此期间，将暂时阻止客户端在还原的成员上执行DML操作。还原过程完全完成且还原的成员与组的其他成员同步后，还原这些更改；重新启动事件计划程序：</p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SET global event_scheduler=ON;</code></strong>
</pre><p>
            Edit the following system variables in the member's option
            file, so things are correctly configured for the next startup:
        </p><p style="color:blue;">在成员的选项文件中编辑以下系统变量，以便为下次启动正确配置：</p><pre data-lang="ini" class="programlisting">group_replication_start_on_boot=ON
super_read_only=OFF
event_scheduler=ON</pre>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="group-replication-security"></a>17.5&nbsp;Group Replication Security</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-ip-address-whitelisting">17.5.1 Group Replication IP Address Whitelisting</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-secure-socket-layer-support-ssl">17.5.2 Group Replication Secure Socket Layer (SSL) Support</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-virtual-private-networks-vpn">17.5.3 Group Replication and Virtual Private Networks (VPNs)</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286790252640"></a><p>
        This section explains how to secure a group, securing the
        connections between members of a group, or by establishing a
        security perimeter using IP address whitelisting.
    </p><p style="color:blue;">本节说明如何保护组、保护组成员之间的连接，或使用IP地址白名单建立安全外围。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-ip-address-whitelisting"></a>17.5.1&nbsp;Group Replication IP Address Whitelisting</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286790249312"></a><a class="indexterm" name="idm140286790247824"></a><a class="indexterm" name="idm140286790246336"></a><p>
            The Group Replication plugin has a configuration option to
            determine from which hosts an incoming Group Communication System
            connection can be accepted. This option is called
            <a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist"><code class="literal">group_replication_ip_whitelist</code></a>.
            If you set this option on a server s1, then when server s2 is
            establishing a connection to s1 for the purpose of engaging group
            communication, s1 first checks the whitelist before accepting the
            connection from s2. If s2 is in the whitelist, then s1 accepts the
            connection, otherwise s1 rejects the connection attempt by s2.
        </p><p style="color:blue;">组复制插件有一个配置选项，用于确定从哪个主机可以接受传入的组通信系统连接。此选项称为组复制IP白名单。如果在服务器s1上设置此选项，则当服务器s2正在建立与s1的连接以进行组通信时，s1首先检查白名单，然后再接受来自s2的连接。如果s2在白名单中，那么s1接受连接，否则s1拒绝s2的连接尝试。</p><p>
            If you do not specify a whitelist explicitly, the group
            communication engine (XCom) automatically scans active interfaces
            on the host, and identifies those with addresses on private
            subnetworks. These addresses and the <code class="literal">localhost</code>
            IP address for IPv4 are used to create an automatic Group
            Replication whitelist. The automatic whitelist therefore includes
            any IP addresses found for the host in the following ranges:
        </p><p style="color:blue;">如果未显式指定白名单，则组通信引擎（xcom）会自动扫描主机上的活动接口，并用专用子网上的地址标识这些接口。这些地址和IPv4的本地主机IP地址用于创建自动组复制白名单。因此，自动白名单包含在以下范围内为主机找到的任何IP地址：</p><pre data-lang="none" class="programlisting">10/8 prefix       (10.0.0.0 - 10.255.255.255) - Class A
172.16/12 prefix  (172.16.0.0 - 172.31.255.255) - Class B
192.168/16 prefix (192.168.0.0 - 192.168.255.255) - Class C
127.0.0.1 - localhost for IPv4</pre><p>
            An entry is added to the error log stating the addresses that have
            been whitelisted automatically for the host.
        </p><p style="color:blue;">将向错误日志中添加一个条目，说明已自动为主机列出白名单的地址。</p><p>
            The automatic whitelist of private addresses cannot be used for
            connections from servers outside the private network, so a server,
            even if it has interfaces on public IPs, does not by default allow
            Group Replication connections from external hosts. For Group
            Replication connections between server instances that are on
            different machines, you must provide public IP addresses and
            specify these as an explicit whitelist. If you specify any entries
            for the whitelist, the private and <code class="literal">localhost</code>
            addresses are not added automatically, so if you use any of these,
            you must specify them explicitly.
        </p><p style="color:blue;">专用地址的自动白名单不能用于来自专用网络外部服务器的连接，因此服务器（即使它在公共IP上有接口）默认情况下不允许来自外部主机的组复制连接。对于不同计算机上的服务器实例之间的组复制连接，必须提供公用IP地址并将其指定为显式白名单。如果为白名单指定任何条目，则不会自动添加专用地址和本地主机地址，因此如果使用其中任何一个，则必须显式指定它们。</p><p>
            To specify a whitelist manually, use the
            <a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist"><code class="literal">group_replication_ip_whitelist</code></a>
            option. You cannot change the whitelist on a server while it is an
            active member of a replication group. If the member is active, you
            must issue a <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2&nbsp;STOP GROUP_REPLICATION Syntax"><code class="literal">STOP GROUP_REPLICATION</code></a>
            statement before changing the whitelist, and a
            <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a> statement
            afterwards.
        </p><p style="color:blue;">要手动指定白名单，请使用组复制白名单选项。当服务器是复制组的活动成员时，不能更改该服务器上的白名单。如果成员处于活动状态，则必须在更改白名单之前发出stop group_replication语句，然后发出start group_replication语句。</p><p>
            In the whitelist, you can specify any combination of the
            following:
        </p><p style="color:blue;">在白名单中，您可以指定以下任意组合：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    IPv4 addresses (for example, <code class="literal">198.51.100.44</code>)
                </p><p style="color:blue;">IPv4地址（例如198.51.100.44）</p></li><li class="listitem"><p>
                    IPv4 addresses with CIDR notation (for example,
                    <code class="literal">192.0.2.21/24</code>)
                </p><p style="color:blue;">带CIDR符号的IPv4地址（例如，192.0.2.21/24）</p></li><li class="listitem"><p>
                    Host names, from MySQL 5.7.21 (for example,
                    <code class="literal">example.org</code>)
                </p><p style="color:blue;">主机名，来自mysql 5.7.21（例如，example.org）</p></li><li class="listitem"><p>
                    Host names with CIDR notation, from MySQL 5.7.21 (for example,
                    <code class="literal">www.example.com/24</code>)
                </p><p style="color:blue;">带有cidr符号的主机名，来自mysql 5.7.21（例如，www.example.com/24）</p></li></ul>
            </div>
            <p>
                IPv6 addresses, and host names that resolve to IPv6 addresses, are
                not supported in MySQL 5.7. You can use CIDR notation in
                combination with host names or IP addresses to whitelist a block
                of IP addresses with a particular network prefix, but do ensure
                that all the IP addresses in the specified subnet are under your
                control.
            </p><p style="color:blue;">mysql 5.7不支持IPv6地址和解析为IPv6地址的主机名。您可以将cidr表示法与主机名或ip地址结合使用，列出具有特定网络前缀的ip地址块，但请确保指定子网中的所有ip地址都在您的控制之下。</p><p>
            You must stop and restart Group Replication on a member in order
            to change its whitelist. A comma must separate each entry in the
            whitelist. For example:
        </p><p style="color:blue;">必须停止并重新启动成员上的组复制，才能更改其白名单。必须用逗号分隔白名单中的每个条目。例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; STOP GROUP_REPLICATION;
mysql&gt; SET GLOBAL group_replication_ip_whitelist="192.0.2.21/24,198.51.100.44,203.0.113.0/24,example.org,www.example.com/24";
mysql&gt; START GROUP_REPLICATION;</pre><p>
            The whitelist must contain the IP address or host name that is
            specified in each member's
            <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
            system variable. This address is not the same as the MySQL server
            SQL protocol host and port, and is not specified in the
            <a class="link" href="server-administration.html#sysvar_bind_address"><code class="literal">bind_address</code></a> system variable for
            the server instance.
        </p><p style="color:blue;">白名单必须包含在每个成员的组复制本地地址系统变量中指定的IP地址或主机名。此地址与mysql server sql协议主机和端口不同，并且未在服务器实例的bind_address系统变量中指定。</p><p>
            When a replication group is reconfigured (for example, when a new
            primary is elected or a member joins or leaves), the group members
            re-establish connections between themselves. If a group member is
            only whitelisted by servers that are no longer part of the
            replication group after the reconfiguration, it is unable to
            reconnect to the remaining servers in the replication group that
            do not whitelist it. To avoid this scenario entirely, specify the
            same whitelist for all servers that are members of the replication
            group.
        </p><p style="color:blue;">重新配置复制组时（例如，当选择新的主组或成员加入或离开时），组成员会在它们之间重新建立连接。如果组成员在重新配置后仅由不再是复制组一部分的服务器白名单，则无法重新连接到复制组中未白名单的其余服务器。要完全避免这种情况，请为属于复制组的所有服务器指定相同的白名单。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    It is possible to configure different whitelists on different
                    group members according to your security requirements, for
                    example, in order to keep different subnets separate. If you
                    need to configure different whitelists to meet your security
                    requirements, ensure that there is sufficient overlap between
                    the whitelists in the replication group to maximize the
                    possibility of servers being able to reconnect in the absence of
                    their original seed member.
                </p><p style="color:blue;">可以根据您的安全要求在不同的组成员上配置不同的白名单，例如，为了使不同的子网保持独立。如果需要配置不同的白名单以满足安全性要求，则确保复制组中白名单之间有足够的重叠，以最大化服务器在没有原始种子成员的情况下能够重新连接的可能性。</p>
            </div>
            <p>
                For host names, name resolution takes place only when a connection
                request is made by another server. A host name that cannot be
                resolved is not considered for whitelist validation, and a warning
                message is written to the error log. Forward-confirmed reverse DNS
                (FCrDNS) verification is carried out for resolved host names.
            </p><p style="color:blue;">对于主机名，只有当另一台服务器发出连接请求时，才会进行名称解析。白名单验证不考虑无法解析的主机名，并将警告消息写入错误日志。对解析的主机名执行正向确认的反向dns（fcrdns）验证。</p>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Warning
                </div>
                <p>
                    Host names are inherently less secure than IP addresses in a
                    whitelist. FCrDNS verification provides a good level of
                    protection, but can be compromised by certain types of attack.
                    Specify host names in your whitelist only when strictly
                    necessary, and ensure that all components used for name
                    resolution, such as DNS servers, are maintained under your
                    control. You can also implement name resolution locally using
                    the hosts file, to avoid the use of external components.
                </p><p style="color:blue;">主机名本质上不如白名单中的IP地址安全。fcrdns验证提供了很好的保护级别，但可能会受到某些类型的攻击的危害。仅在严格必要时在白名单中指定主机名，并确保用于名称解析的所有组件（如DNS服务器）都在您的控制下维护。还可以使用hosts文件在本地实现名称解析，以避免使用外部组件。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-secure-socket-layer-support-ssl"></a>17.5.2&nbsp;Group Replication Secure Socket Layer (SSL) Support</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286790213952"></a><a class="indexterm" name="idm140286790212448"></a><p>
            Group communication connections as well as recovery connections,
            are secured using SSL. The following sections explain how to
            configure connections.
        </p><p style="color:blue;">使用ssl保护组通信连接和恢复连接。以下各节说明如何配置连接。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="group-replication-configuring-ssl-for-recovery"></a>Configuring SSL for Group Replication Recovery</h4>
                        </div>
                    </div>
                </div>
                <p>
                    Recovery is performed through a regular asynchronous replication
                    connection. Once the donor is selected, the server joining the
                    group establishes an asynchronous replication connection. This
                    is all automatic.
                </p><p style="color:blue;">通过常规异步复制连接执行恢复。一旦选择了捐赠者，加入组的服务器将建立异步复制连接。这是全自动的。</p><p>
                However, a user that requires an SSL connection must have been
                created before the server joining the group connects to the
                donor. Typically, this is set up at the time one is provisioning
                a server to join the group.
            </p><p style="color:blue;">但是，在加入组的服务器连接到捐赠者之前，必须先创建需要ssl连接的用户。通常，这是在设置服务器以加入组时设置的。</p><pre data-lang="sql" class="programlisting">donor&gt; SET SQL_LOG_BIN=0;
donor&gt; CREATE USER 'rec_ssl_user'@'%' REQUIRE SSL;
donor&gt; GRANT replication slave ON *.* TO 'rec_ssl_user'@'%';
donor&gt; SET SQL_LOG_BIN=1;</pre><p>
                Assuming that all servers already in the group have a
                replication user set up to use SSL, you configure the server
                joining the group to use those credentials when connecting to
                the donor. That is done according to the values of the SSL
                options provided for the Group Replication plugin.
            </p><p style="color:blue;">假设组中的所有服务器都已将复制用户设置为使用ssl，则将加入组的服务器配置为在连接到捐助者时使用这些凭据。这是根据为组复制插件提供的ssl选项的值来完成的。</p><pre data-lang="sql" class="programlisting">new_member&gt; SET GLOBAL group_replication_recovery_use_ssl=1;
new_member&gt; SET GLOBAL group_replication_recovery_ssl_ca= '.../cacert.pem';
new_member&gt; SET GLOBAL group_replication_recovery_ssl_cert= '.../client-cert.pem';
new_member&gt; SET GLOBAL group_replication_recovery_ssl_key= '.../client-key.pem';</pre><p>
                And by configuring the recovery channel to use the credentials
                of the user that requires an SSL connection.
            </p><p style="color:blue;">通过配置恢复通道来使用需要ssl连接的用户的凭据。</p><pre data-lang="sql" class="programlisting">new_member&gt; CHANGE MASTER TO MASTER_USER="rec_ssl_user" FOR CHANNEL "group_replication_recovery";
new_member&gt; START GROUP_REPLICATION;</pre>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="group-replication-configuring-ssl-for-group-communication"></a>Configuring SSL for Group Communication</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Secure sockets can be used to establish communication between
                    members in a group. The configuration for this depends on the
                    server's SSL configuration. As such, if the server has SSL
                    configured, the Group Replication plugin also has SSL
                    configured. For more information on the options for configuring
                    the server SSL, see
                    <a class="xref" href="programs.html#encrypted-connection-options" title="Command Options for Encrypted Connections">Command Options for Encrypted Connections</a>. The options
                    which configure Group Replication are shown in the following
                    table.
                </p><p style="color:blue;">安全套接字可用于在组中的成员之间建立通信。此配置取决于服务器的ssl配置。因此，如果服务器配置了ssl，那么组复制插件也配置了ssl。有关配置服务器ssl的选项的更多信息，请参阅加密连接的命令选项。配置组复制的选项如下表所示。</p>
                <div class="table">
                    <a name="idm140286790199712"></a><p class="title"><b>Table&nbsp;17.2&nbsp;SSL Options</b></p><p style="color:blue;">表17.2 SSL选项</p>
                    <div class="table-contents">
                        <table summary="Lists the server configuration options for SSL and describes their effect on the configuration of the Group Replication plugin for SSL."><colgroup><col width="0.43%"><col width="0.57%"></colgroup><thead><tr>
                            <th scope="col"><p>
                                Server Configuration
                            </p><p style="color:blue;">服务器配置</p></th>
                            <th scope="col"><p>
                                Plugin Configuration Description
                            </p><p style="color:blue;">插件配置说明</p></th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><p>
                                ssl_key
                            </p><p style="color:blue;">SSL密钥</p></td>
                            <td><p>
                                Path of key file. To be used as client and server
                                certificate.
                            </p><p style="color:blue;">密钥文件的路径。用作客户端和服务器证书。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                ssl_cert
                            </p><p style="color:blue;">SSL证书</p></td>
                            <td><p>
                                Path of certificate file. To be used as client and
                                server certificate.
                            </p><p style="color:blue;">证书文件的路径。用作客户端和服务器证书。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                ssl_ca
                            </p><p style="color:blue;">安大略省</p></td>
                            <td><p>
                                Path of file with SSL Certificate Authorities that are
                                trusted.
                            </p><p style="color:blue;">具有受信任的SSL证书颁发机构的文件路径。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                ssl_capath
                            </p><p style="color:blue;">ssl_capath公司</p></td>
                            <td><p>
                                Path of directory containing certificates for SSL
                                Certificate Authorities that are trusted.
                            </p><p style="color:blue;">包含受信任的SSL证书颁发机构证书的目录的路径。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                ssl_crl
                            </p><p style="color:blue;">ssl_crl公司</p></td>
                            <td><p>
                                Path of file containing the certificate revocation
                                lists.
                            </p><p style="color:blue;">包含证书吊销列表的文件的路径。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                ssl_crlpath
                            </p><p style="color:blue;">SSL路径</p></td>
                            <td><p>
                                Path of directory containing revoked certificate lists.
                            </p><p style="color:blue;">包含已吊销证书列表的目录的路径。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                ssl_cipher
                            </p><p style="color:blue;">SSL密码</p></td>
                            <td><p>
                                Permitted ciphers to use while encrypting data over the
                                connection.
                            </p><p style="color:blue;">允许在通过连接加密数据时使用密码。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                tls_version
                            </p><p style="color:blue;">TLS U版本</p></td>
                            <td><p>
                                Secure communication will use this version and its
                                protocols.
                            </p><p style="color:blue;">安全通信将使用此版本及其协议。</p></td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                These options are MySQL Server configuration options which Group
                Replication relies on for its configuration. In addition there
                is the following Group Replication specific option to configure
                SSL on the plugin itself.
            </p><p style="color:blue;">这些选项是mysql服务器配置选项，组复制依赖这些选项进行配置。此外，还有以下特定于组复制的选项，用于在插件本身上配置ssl。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="group-replication.html#sysvar_group_replication_ssl_mode"><code class="literal">group_replication_ssl_mode</code></a>
                        - specifies the security state of the connection between
                        Group Replication members.
                    </p><p style="color:blue;">group_replication_ssl_mode-指定组复制成员之间连接的安全状态。</p></li></ul>
                </div>

                <div class="table">
                    <a name="idm140286790167824"></a><p class="title"><b>Table&nbsp;17.3&nbsp;group_replication_ssl_mode configuration values</b></p><p style="color:blue;">表17.3组复制ssl模式配置值</p>
                    <div class="table-contents">
                        <table summary="Lists the possible values for group_replication_ssl_mode and describes their effect on how replication group members connect to each other."><colgroup><col width="0.43%"><col width="0.57%"></colgroup><thead><tr>
                            <th scope="col"><p>
                                Value
                            </p><p style="color:blue;">价值</p></th>
                            <th scope="col"><p>
                                Description
                            </p><p style="color:blue;">描述</p></th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><p>
                                <span class="emphasis"><em>DISABLED</em></span>
                            </p><p style="color:blue;">残疾人</p></td>
                            <td><p>
                                Establish an unencrypted connection
                                (<span class="emphasis"><em>default</em></span>).
                            </p><p style="color:blue;">建立未加密的连接（默认）。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                REQUIRED
                            </p><p style="color:blue;">必修的</p></td>
                            <td><p>
                                Establish a secure connection if the server supports
                                secure connections.
                            </p><p style="color:blue;">如果服务器支持安全连接，请建立安全连接。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                VERIFY_CA
                            </p><p style="color:blue;">验证CA</p></td>
                            <td><p>
                                Like REQUIRED, but additionally verify the server TLS
                                certificate against the configured Certificate Authority
                                (CA) certificates.
                            </p><p style="color:blue;">与必需的类似，但还要根据配置的证书颁发机构（CA）证书验证服务器TLS证书。</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                VERIFY_IDENTITY
                            </p><p style="color:blue;">验证身份</p></td>
                            <td><p>
                                Like VERIFY_CA, but additionally verify that the server
                                certificate matches the host to which the connection is
                                attempted.
                            </p><p style="color:blue;">与verify_ca类似，但还要验证服务器证书是否与尝试连接的主机匹配。</p></td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                The following example shows an example my.cnf file section used
                to configure SSL on a server and how activate it for Group
                Replication.
            </p><p style="color:blue;">下面的示例显示了一个示例my.cnf文件节，该节用于在服务器上配置ssl，以及如何为组复制激活它。</p><pre data-lang="ini" class="programlisting">[mysqld]
ssl_ca = "cacert.pem"
ssl_capath = "/.../ca_directory"
ssl_cert = "server-cert.pem"
ssl_cipher = "DHE-RSA-AEs256-SHA"
ssl_crl = "crl-server-revoked.crl"
ssl_crlpath = "/.../crl_directory"
ssl_key = "server-key.pem"
group_replication_ssl_mode= REQUIRED</pre><p>
                The only plugin specific configuration option that is listed is
                <a class="link" href="group-replication.html#sysvar_group_replication_ssl_mode"><code class="literal">group_replication_ssl_mode</code></a>.
                This option activates the SSL communication between members of
                the group, by configuring the SSL framework with the
                <code class="literal">ssl_*</code> parameters that are provided to the
                server.
            </p><p style="color:blue;">列出的唯一特定于插件的配置选项是group_replication_ssl_mode。此选项通过使用提供给服务器的ssl参数配置ssl框架来激活组成员之间的ssl通信。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-virtual-private-networks-vpn"></a>17.5.3&nbsp;Group Replication and Virtual Private Networks (VPNs)</h3>

                    </div>

                </div>

            </div>
            <p>


                There is nothing preventing Group Replication from operating over
                a virtual private network. At its core, it just relies on an IPv4
                socket to establish connections between servers for the purpose of
                propagating messages between them.
            </p><p style="color:blue;">没有什么可以阻止组复制在虚拟专用网络上运行。在其核心，它仅仅依靠ipv4套接字在服务器之间建立连接，以便在服务器之间传播消息。</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="group-replication-options"></a>17.6&nbsp;Group Replication System Variables</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286790140512"></a><p>
        This section lists the system variables that are specific to the
        Group Replication plugin. Every configuration option is prefixed
        with "<code class="literal">group_replication</code>".
    </p><p style="color:blue;">本节列出特定于组复制插件的系统变量。每个配置选项都以“组复制”作为前缀。</p><p>
        Most system variables for Group Replication are described as
        dynamic, and their values can be changed while the server is
        running. However, in most cases, the change only takes effect after
        you stop and restart Group Replication on the group member using a
        <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2&nbsp;STOP GROUP_REPLICATION Syntax"><code class="literal">STOP GROUP_REPLICATION</code></a> statement
        followed by a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a>
        statement. Changes to the following system variables take effect
        without stopping and restarting Group Replication:
    </p><p style="color:blue;">用于组复制的大多数系统变量都被描述为动态的，它们的值可以在服务器运行时更改。但是，在大多数情况下，更改仅在使用stop group_replication语句和start group_replication语句停止并重新启动组成员上的组复制后生效。对以下系统变量的更改在不停止和重新启动组复制的情况下生效：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_applier_threshold"><code class="literal">group_replication_flow_control_applier_threshold</code></a>
            </p><p style="color:blue;">组复制流控制应用程序阈值</p></li><li class="listitem"><p>
                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_certifier_threshold"><code class="literal">group_replication_flow_control_certifier_threshold</code></a>
            </p><p style="color:blue;">组复制流控制证书阈值</p></li><li class="listitem"><p>
                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_mode"><code class="literal">group_replication_flow_control_mode</code></a>
            </p><p style="color:blue;">组复制流控制模式</p></li></ul>
        </div>
        <p>
            Most system variables for Group Replication can have different
            values on different group members. For the following system
            variables, it is advisable to set the same value on all members of a
            group in order to avoid unnecessary rollback of transactions,
            failure of message delivery, or failure of message recovery:
        </p><p style="color:blue;">组复制的大多数系统变量在不同的组成员上可以有不同的值。对于以下系统变量，建议在组的所有成员上设置相同的值，以避免不必要的事务回滚、消息传递失败或消息恢复失败：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment"><code class="literal">group_replication_auto_increment_increment</code></a>
            </p><p style="color:blue;">组复制自动递增</p></li><li class="listitem"><p>
                <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
            </p><p style="color:blue;">组复制压缩阈值</p></li><li class="listitem"><p>
                <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
            </p><p style="color:blue;">组复制事务大小限制</p></li></ul>
        </div>
        <p>
            Some system variables on a Group Replication group member, including
            some Group Replication-specific system variables and some general
            system variables, are group-wide configuration settings. These
            system variables must have the same value on all group members,
            cannot be changed while Group Replication is running, and require a
            full reboot of the group (a bootstrap by a server with
            <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=ON</code></a>)
            in order for the value change to take effect. These conditions apply
            to the following system variables:
        </p><p style="color:blue;">组复制组成员上的某些系统变量（包括某些组复制特定的系统变量和某些常规系统变量）是组范围的配置设置。这些系统变量在所有组成员上必须具有相同的值，在组复制运行时无法更改，并且需要完全重新启动组（由组复制为“启动”的服务器启动）才能使值更改生效。这些条件适用于以下系统变量：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode"><code class="literal">group_replication_single_primary_mode</code></a>
            </p><p style="color:blue;">组复制单主模式</p></li><li class="listitem"><p>
                <a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks"><code class="literal">group_replication_enforce_update_everywhere_checks</code></a>
            </p><p style="color:blue;">组复制强制到处更新检查</p></li><li class="listitem"><p>
                <a class="link" href="group-replication.html#sysvar_group_replication_gtid_assignment_block_size"><code class="literal">group_replication_gtid_assignment_block_size</code></a>
            </p><p style="color:blue;">组复制块大小</p></li><li class="listitem"><p>
                <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_default_table_encryption" target="_top"><code class="literal">default_table_encryption</code></a>
            </p><p style="color:blue;">默认表加密</p></li><li class="listitem"><p>
                <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a>
            </p><p style="color:blue;">小写字母表名</p></li><li class="listitem"><p>
                <a class="link" href="replication.html#sysvar_transaction_write_set_extraction"><code class="literal">transaction_write_set_extraction</code></a>
            </p><p style="color:blue;">事务写入集提取</p></li></ul>
        </div>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
            <div class="admon-title">
                Important
            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    A number of system variables for Group Replication are not
                    completely validated during server startup if they are passed
                    as command line arguments to the server. These system
                    variables include
                    <a class="link" href="group-replication.html#sysvar_group_replication_group_name"><code class="literal">group_replication_group_name</code></a>,
                    <a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode"><code class="literal">group_replication_single_primary_mode</code></a>,
                    <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>,
                    the SSL variables, and the flow control system variables. They
                    are only fully validated after the server has started.
                </p><p style="color:blue;">在服务器启动期间，如果将组复制的一些系统变量作为命令行参数传递给服务器，则它们不会完全验证。这些系统变量包括group_replication_group_name、group_replication_single_primary_mode、group_replication_force_members、ssl变量和流控制系统变量。只有在服务器启动后才能完全验证它们。</p></li><li class="listitem"><p>
                    System variables for Group Replication that specify IP
                    addresses or host names for group members are not validated
                    until a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a>
                    statement is issued. Group Replication's Group Communication
                    System (GCS) is not available to validate the values until
                    that point.
                </p><p style="color:blue;">在发出START GROUP\U REPLICATION语句之前，不会验证用于为组成员指定IP地址或主机名的组复制的系统变量。在此之前，组复制的组通信系统（GCS）无法验证这些值。</p></li></ul>
            </div>

        </div>
        <p>
            The system variables that are specific to the Group Replication
            plugin are as follows:
        </p><p style="color:blue;">特定于组复制插件的系统变量如下：</p>
        <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_group_replication_allow_local_disjoint_gtids_join"></a>
                <a class="indexterm" name="idm140286790095824"></a>

                <a class="indexterm" name="idm140286790094784"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_allow_local_disjoint_gtids_join"><code class="literal">group_replication_allow_local_disjoint_gtids_join</code></a>
            </p><p style="color:blue;">组复制允许本地不相交</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_allow_local_disjoint_gtids_join"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-allow-local-disjoint-gtids-join[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
                        <td>5.7.21</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_allow_local_disjoint_gtids_join">group_replication_allow_local_disjoint_gtids_join</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Deprecated in version 5.7.21 and scheduled for removal in a
                    future version. Allows the server to join the group even if it
                    has local transactions that are not present in the group.
                </p><p style="color:blue;">在版本5.7.21中已弃用，并计划在以后的版本中删除。允许服务器加入组，即使其具有组中不存在的本地事务。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Use caution when enabling this option as incorrect usage can
                        lead to conflicts in the group and rollback of transactions.
                        The option should only be enabled as a last resort method to
                        allow a server that has local transactions to join an existing
                        group, and then only if the local transactions do not affect
                        the data that is handled by the group (for example, an
                        administrative action that was written to the binary log). The
                        option should not be left enabled on all group members.
                    </p><p style="color:blue;">启用此选项时请小心，因为不正确的使用可能导致组中的冲突和事务回滚。该选项只应作为最后一种方法启用，以允许具有本地事务的服务器加入现有组，然后仅当本地事务不影响组所处理的数据（例如，写入二进制日志的管理动作）。不应在所有组成员上都启用该选项。</p>
                </div>
            </li><li class="listitem"><p><a name="sysvar_group_replication_allow_local_lower_version_join"></a>
                <a class="indexterm" name="idm140286790059280"></a>

                <a class="indexterm" name="idm140286790058240"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_allow_local_lower_version_join"><code class="literal">group_replication_allow_local_lower_version_join</code></a>
            </p><p style="color:blue;">组复制允许本地版本加入</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_allow_local_lower_version_join"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-allow-local-lower-version-join[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_allow_local_lower_version_join">group_replication_allow_local_lower_version_join</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Allows the current server to join the group even if it has a
                    lower major version than the group. With the default setting
                    <code class="literal">OFF</code>, servers are not permitted to join a
                    replication group if they have a lower major version than the
                    existing group members. For example, a MySQL 5.7 server cannot
                    join a group that consists of MySQL 8.0 servers. This standard
                    policy ensures that all members of a group are able to exchange
                    messages and apply transactions. Set
                    <a class="link" href="group-replication.html#sysvar_group_replication_allow_local_lower_version_join"><code class="literal">group_replication_allow_local_lower_version_join</code></a>
                    to <code class="literal">ON</code> only in the following scenarios:
                </p><p style="color:blue;">允许当前服务器加入组，即使其主版本低于组。在默认设置下，如果服务器具有比现有组成员更低的主版本，则不允许服务器加入复制组。例如，mysql 5.7服务器无法加入由mysql 8.0服务器组成的组。此标准策略确保组中的所有成员都能够交换消息和应用事务。仅在以下情况下，将组复制允许本地版本加入设置为打开：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        A server must be added to the group in an emergency in order
                        to improve the group's fault tolerance, and only older
                        versions are available.
                    </p><p style="color:blue;">必须在紧急情况下向组中添加服务器以提高组的容错性，并且只有旧版本可用。</p></li><li class="listitem"><p>
                        You want to carry out a downgrade of the replication group
                        members without shutting down the whole group and
                        bootstrapping it again.
                    </p><p style="color:blue;">您希望在不关闭整个组并再次引导它的情况下对复制组成员执行降级。</p></li></ul>
                </div>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Setting this option to <code class="literal">ON</code> does not make the
                        new member compatible with the group, and allows it to join
                        the group without any safeguards against incompatible
                        behaviors by the existing members. To ensure the new member's
                        correct operation, take <span class="emphasis"><em>both</em></span> of the
                        following precautions:
                    </p><p style="color:blue;">将此选项设置为ON不会使新成员与该组兼容，并允许它加入该组，而不需要现有成员对任何不兼容行为的任何防范措施。为确保新成员的正确操作，请采取以下两种预防措施：</p>
                    <div class="orderedlist">
                        <ol class="orderedlist" type="1"><li class="listitem"><p>
                            Before the server with the lower major version joins the
                            group, stop all writes on that server.
                        </p><p style="color:blue;">在主版本较低的服务器加入组之前，请停止该服务器上的所有写入操作。</p></li><li class="listitem"><p>
                            From the point where the server with the lower major
                            version joins the group, stop all writes on the other
                            servers in the group.
                        </p><p style="color:blue;">从主版本较低的服务器加入组的点开始，停止组中其他服务器上的所有写操作。</p></li></ol>
                    </div>
                    <p>
                        Without these precautions, the server with the lower major
                        version is likely to experience difficulties and terminate
                        with an error.
                    </p><p style="color:blue;">如果没有这些预防措施，主版本较低的服务器可能会遇到困难，并以错误终止。</p>
                </div>
            </li><li class="listitem"><p><a name="sysvar_group_replication_auto_increment_increment"></a>
                <a class="indexterm" name="idm140286790016016"></a>

                <a class="indexterm" name="idm140286790014896"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment"><code class="literal">group_replication_auto_increment_increment</code></a>
            </p><p style="color:blue;">组复制自动递增</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_auto_increment_increment"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-auto-increment-increment=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment">group_replication_auto_increment_increment</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">7</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">65535</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Determines the interval between successive column values for
                    transactions that execute on this server instance. This system
                    variable should have the same value on all group members. When
                    Group Replication is started on a server, the value of the
                    server system variable
                    <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> is
                    changed to this value, and the value of the server system
                    variable <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
                    is changed to the server ID. These settings avoid the selection
                    of duplicate auto-increment values for writes on group members,
                    which causes rollback of transactions. The changes are reverted
                    when Group Replication is stopped. These changes are only made
                    and reverted if
                    <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> and
                    <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a> each have
                    their default value of 1. If their values have already been
                    modified from the default, Group Replication does not alter
                    them. From MySQL 8.0, the system variables are also not modified
                    when Group Replication is in single-primary mode, where only one
                    server writes.
                </p><p style="color:blue;">确定在此服务器实例上执行的事务的连续列值之间的间隔。此系统变量在所有组成员上应具有相同的值。在服务器上启动组复制时，服务器系统变量auto_increment_increment的值将更改为该值，服务器系统变量auto_increment_offset的值将更改为服务器ID。这些设置避免为组成员上的写入选择重复的自动增量值，导致事务回滚。当组复制停止时，将还原更改。仅当“自动增量”和“自动增量偏移”的默认值均为1时，才会进行和还原这些更改。如果已从默认值修改了它们的值，则组复制不会更改它们。在mysql 8.0中，当组复制处于单主模式（只有一个服务器写入）时，也不会修改系统变量。</p><p>
                    The default value of 7 represents a balance between the number
                    of usable values and the permitted maximum size of a replication
                    group (9 members). If your group has more or fewer members, you
                    can set this system variable to match the expected number of
                    group members before Group Replication is started. You cannot
                    change the setting while Group Replication is running.
                </p><p style="color:blue;">默认值7表示可用值的数量与复制组（9个成员）的允许最大大小之间的平衡。如果组中有多个或少个成员，则可以在启动组复制之前将此系统变量设置为与预期的组成员数匹配。当组复制正在运行时，不能更改设置。</p></li><li class="listitem"><p><a name="sysvar_group_replication_bootstrap_group"></a>
                <a class="indexterm" name="idm140286789970752"></a>

                <a class="indexterm" name="idm140286789969712"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
            </p><p style="color:blue;">组复制引导组</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_bootstrap_group"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-bootstrap-group[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group">group_replication_bootstrap_group</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Configure this server to bootstrap the group. This option must
                    only be set on one server and only when starting the group for
                    the first time or restarting the entire group. After the group
                    has been bootstrapped, set this option to
                    <code class="literal">OFF</code>. It should be set to
                    <code class="literal">OFF</code> both dynamically and in the configuration
                    files. Starting two servers or restarting one server with this
                    option set while the group is running may lead to an artificial
                    split brain situation, where two independent groups with the
                    same name are bootstrapped.
                </p><p style="color:blue;">配置此服务器以引导组。此选项只能在一台服务器上设置，并且只能在首次启动组或重新启动整个组时设置。启动组后，将此选项设置为禁用。它应该在动态和配置文件中设置为关闭。在组运行时启动两台服务器或使用此选项集重新启动一台服务器可能会导致人工拆分大脑的情况，其中两个同名的独立组将被引导。</p></li><li class="listitem"><p><a name="sysvar_group_replication_components_stop_timeout"></a>
                <a class="indexterm" name="idm140286789936784"></a>

                <a class="indexterm" name="idm140286789935664"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_components_stop_timeout"><code class="literal">group_replication_components_stop_timeout</code></a>
            </p><p style="color:blue;">组复制组件停止超时</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_components_stop_timeout"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-components-stop-timeout=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_components_stop_timeout">group_replication_components_stop_timeout</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">31536000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">2</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">31536000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Timeout, in seconds, that Group Replication waits for each of
                    the components when shutting down.
                </p><p style="color:blue;">超时，以秒为单位，该组复制在关闭时等待每个组件。</p></li><li class="listitem"><p><a name="sysvar_group_replication_compression_threshold"></a>
                <a class="indexterm" name="idm140286789898400"></a>

                <a class="indexterm" name="idm140286789897360"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
            </p><p style="color:blue;">组复制压缩阈值</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_compression_threshold"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-compression-threshold=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold">group_replication_compression_threshold</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1000000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The value in bytes above which (LZ4) compression is enforced.
                    When set to zero, deactivates compression. The value of
                    <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
                    should be the same on all group members.
                </p><p style="color:blue;">强制（lz4）压缩的字节值。设置为零时，取消压缩。组复制压缩阈值的值应在所有组成员上相同。</p></li><li class="listitem"><p><a name="sysvar_group_replication_enforce_update_everywhere_checks"></a>
                <a class="indexterm" name="idm140286789858608"></a>

                <a class="indexterm" name="idm140286789857568"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks"><code class="literal">group_replication_enforce_update_everywhere_checks</code></a>
            </p><p style="color:blue;">组复制强制到处更新检查</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_enforce_update_everywhere_checks"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-enforce-update-everywhere-checks[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks">group_replication_enforce_update_everywhere_checks</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Enable or disable strict consistency checks for multi-primary
                    update everywhere. The default is that checks are disabled. In
                    single-primary mode, this option must be disabled on all group
                    members. In multi-primary mode, when this option is enabled,
                    statements are checked as follows to ensure they are compatible
                    with multi-primary mode:
                </p><p style="color:blue;">对所有位置的多个主更新启用或禁用严格的一致性检查。默认设置是禁用检查。在单一主模式下，必须对所有组成员禁用此选项。在多主模式下，启用此选项时，将按如下方式检查语句，以确保它们与多主模式兼容：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        If a transaction is executed under the
                        <code class="literal">SERIALIZABLE</code> isolation level, then its
                        commit fails when synchronizing itself with the group.
                    </p><p style="color:blue;">如果事务是在可序列化的隔离级别下执行的，则其提交将在与组同步时失败。</p></li><li class="listitem"><p>
                        If a transaction executes against a table that has foreign
                        keys with cascading constraints, then the transaction fails
                        to commit when synchronizing itself with the group.
                    </p><p style="color:blue;">如果事务针对具有外键且具有级联约束的表执行，则事务在与组同步时将无法提交。</p></li></ul>
                </div>
                <p>
                    This system variable is a group-wide configuration setting. It
                    must have the same value on all group members, cannot be changed
                    while Group Replication is running, and requires a full reboot
                    of the group (a bootstrap by a server with
                    <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=ON</code></a>)
                    in order for the value change to take effect.
                </p><p style="color:blue;">此系统变量是组范围的配置设置。它必须在所有组成员上具有相同的值，在组复制运行时无法更改，并且需要完全重新启动组（由具有组复制的服务器启动）才能使值更改生效。</p></li><li class="listitem"><p><a name="sysvar_group_replication_exit_state_action"></a>
                <a class="indexterm" name="idm140286789820912"></a>

                <a class="indexterm" name="idm140286789819872"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action"><code class="literal">group_replication_exit_state_action</code></a>
            </p><p style="color:blue;">群组复制</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_exit_state_action"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-exit-state-action=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.24</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action">group_replication_exit_state_action</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">READ_ONLY</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">ABORT_SERVER</code></p><p style="color:blue;">中止服务器</p><p class="valid-value"><code class="literal">READ_ONLY</code></p><p style="color:blue;">只读</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Configures how Group Replication behaves when a server instance
                    leaves the group unintentionally, for example after encountering
                    an applier error, or in the case of a loss of majority, or when
                    another member of the group expels it due to a suspicion timing
                    out. The timeout period for a member to leave the group in the
                    case of a loss of majority is set by the
                    <a class="link" href="group-replication.html#sysvar_group_replication_unreachable_majority_timeout"><code class="literal">group_replication_unreachable_majority_timeout</code></a>
                    system variable. Note that an expelled group member does not
                    know that it was expelled until it reconnects to the group, so
                    the specified action is only taken if the member manages to
                    reconnect, or if the member raises a suspicion on itself and
                    expels itself.
                </p><p style="color:blue;">配置当服务器实例无意中离开组时（例如在遇到applier错误后），或在失去多数的情况下，或当组的另一个成员由于怀疑超时而将其排除时，组复制的行为方式。成员在失去多数的情况下离开组的超时时间由GROUP U REPLICATION U UNREACHABLE U MALIST U timeout系统变量设置。请注意，被驱逐的组成员在重新连接到组之前不知道已被驱逐，因此只有在该成员成功重新连接，或者该成员对自己产生怀疑并驱逐自己时，才会执行指定的操作。</p></li><li class="listitem"><p>
                When
                <a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action"><code class="literal">group_replication_exit_state_action</code></a>
                is set to <code class="literal">ABORT_SERVER</code>, if the member exits
                the group unintentionally, the instance shuts down MySQL.
            </p><p style="color:blue;">当GROP.PrimeCudioTyExtStEnEXAct设置为Apple ToServer时，如果该成员无意中退出该组，则该实例关闭MySQL。</p><p>
                When
                <a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action"><code class="literal">group_replication_exit_state_action</code></a>
                is set to <code class="literal">READ_ONLY</code>, if the member exits the
                group unintentionally, the instance switches MySQL to super read
                only mode (by setting the system variable
                <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> to
                <code class="literal">ON</code>). This setting is the default in MySQL
                5.7.
            </p><p style="color:blue;">当GypPosixPixItExItItStEnEffAct被设置为只读时，如果该成员无意中退出该组，则实例将MySQL切换为超级只读模式（通过将系统变量SuffiRead仅设置为ON）。此设置是mysql 5.7中的默认设置。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        If a failure occurs before the member has successfully joined
                        the group, the specified exit action <span class="emphasis"><em>is not
          taken</em></span>. This is the case if there is a failure
                        during the local configuration check, or a mismatch between
                        the configuration of the joining member and the configuration
                        of the group. In these situations, the
                        <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> system
                        variable is left with its original value, and the server does
                        not shut down MySQL. To ensure that the server cannot accept
                        updates when Group Replication did not start, we therefore
                        recommend that
                        <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only=ON</code></a> is set in
                        the server's configuration file at startup, which Group
                        Replication will change to <code class="literal">OFF</code> on primary
                        members after it has been started successfully. This safeguard
                        is particularly important when the server is configured to
                        start Group Replication on server boot
                        (<a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot"><code class="literal">group_replication_start_on_boot=ON</code></a>),
                        but it is also useful when Group Replication is started
                        manually using a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START
                        GROUP_REPLICATION</code></a> command.
                    </p><p style="color:blue;">如果在成员成功加入组之前发生故障，则不执行指定的退出操作。如果在本地配置检查期间出现故障，或者加入成员的配置与组的配置不匹配，则会出现这种情况。在这些情况下，super_read_only系统变量将保留其原始值，并且服务器不会关闭mysql。为了确保在组复制未启动时服务器无法接受更新，因此建议在启动时在服务器的配置文件中设置super_read_only=on，在成功启动主成员后，哪个组复制将更改为off。当服务器配置为在服务器启动时启动组复制（group_replication_start_on_boot=on）时，此保护特别重要，但当使用start group_replication命令手动启动组复制时，此保护也很有用。</p><p>
                    If a failure occurs after the member has successfully joined
                    the group, the specified exit action <span class="emphasis"><em>is
          taken</em></span>. This is the case if there is an applier
                    error, if the member is expelled from the group, or if the
                    member is set to time out in the event of an unreachable
                    majority. In these situations, if <code class="literal">READ_ONLY</code>
                    is the exit action, the
                    <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> system
                    variable is set to <code class="literal">ON</code>, or if
                    <code class="literal">ABORT_SERVER</code> is the exit action, the server
                    shuts down MySQL.
                </p><p style="color:blue;">如果成员成功加入组后发生故障，则采取指定的退出操作。如果存在applier错误，如果成员被开除出组，或者如果成员被设置为在无法达到多数的情况下超时，则会出现这种情况。在这些情况下，如果Read仅为退出操作，则将SuffiRead仅系统变量设置为ON，或者如果Apple ToServer是退出操作，则服务器关闭MySQL。</p>
                </div>

                <div class="table">
                    <a name="idm140286789763568"></a><p class="title"><b>Table&nbsp;17.4&nbsp;Exit actions in Group Replication failure situations</b></p><p style="color:blue;">表17.4组复制失败情况下的退出操作</p>
                    <div class="table-contents">
                        <table frame="all" summary="Summarizes how the selected exit action does or does not operate depending on the failure situation"><colgroup><col width="33%" align="left"><col width="33%" align="left"><col width="33%" align="left"></colgroup><thead><tr>
                            <th scope="col"><p>
                                Failure situation
                            </p><p style="color:blue;">故障情况</p></th>
                            <th scope="col"><p>
                                Group Replication started with <code class="literal">START
                                GROUP_REPLICATION</code>
                            </p><p style="color:blue;">组复制从启动组复制开始</p></th>
                            <th scope="col"><p>
                                Group Replication started with
                                <code class="literal">group_replication_start_on_boot =ON</code>
                            </p><p style="color:blue;">组复制从组复制开始</p></th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><p>
                                Member fails local configuration check
                            </p><p style="color:blue;">成员未通过本地配置检查</p><p>
                                OR
                            </p><p style="color:blue;">或者</p><p>
                                Mismatch between joining member and group configuration
                            </p><p style="color:blue;">加入成员和组配置之间不匹配</p></td>
                            <td><p>
                                <code class="literal">super_read_only</code> unchanged
                            </p><p style="color:blue;">超级只读</p><p>
                                MySQL continues running
                            </p><p style="color:blue;">MySQL继续运行</p><p>
                                Set <code class="literal">super_read_only=ON</code> at startup to
                                prevent updates
                            </p><p style="color:blue;">在启动时设置super_read_only=on以防止更新</p></td>
                            <td><p>
                                <code class="literal">super_read_only</code> unchanged
                            </p><p style="color:blue;">超级只读</p><p>
                                MySQL continues running
                            </p><p style="color:blue;">MySQL继续运行</p><p>
                                Set <code class="literal">super_read_only=ON</code> at startup to
                                prevent updates (Important)
                            </p><p style="color:blue;">设置super_read_only=启动时打开以防止更新（重要）</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                Applier error on member
                            </p><p style="color:blue;">成员上的应用程序错误</p><p>
                                OR
                            </p><p style="color:blue;">或者</p><p>
                                Member expelled from group
                            </p><p style="color:blue;">被开除出组的成员</p><p>
                                OR
                            </p><p style="color:blue;">或者</p><p>
                                Unreachable majority timeout
                            </p><p style="color:blue;">无法到达多数超时</p></td>
                            <td><p>
                                <code class="literal">super_read_only</code> set to
                                <code class="literal">ON</code>
                            </p><p style="color:blue;">super_read_only设置为on</p><p>
                                OR
                            </p><p style="color:blue;">或者</p><p>
                                MySQL shuts down
                            </p><p style="color:blue;">MySQL关闭</p></td>
                            <td><p>
                                <code class="literal">super_read_only</code> set to
                                <code class="literal">ON</code>
                            </p><p style="color:blue;">super_read_only设置为on</p><p>
                                OR
                            </p><p style="color:blue;">或者</p><p>
                                MySQL shuts down
                            </p><p style="color:blue;">MySQL关闭</p></td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_applier_threshold"></a>
                <a class="indexterm" name="idm140286789733904"></a>

                <a class="indexterm" name="idm140286789732784"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_applier_threshold"><code class="literal">group_replication_flow_control_applier_threshold</code></a>
            </p><p style="color:blue;">组复制流控制应用程序阈值</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_flow_control_applier_threshold"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-flow-control-applier-threshold=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_applier_threshold">group_replication_flow_control_applier_threshold</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">25000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2147483647</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the number of waiting transactions in the applier
                    queue that trigger flow control. This variable can be changed
                    without resetting Group Replication.
                </p><p style="color:blue;">指定触发流控制的applier队列中等待的事务数。可以在不重置组复制的情况下更改此变量。</p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_certifier_threshold"></a>
                <a class="indexterm" name="idm140286789695344"></a>

                <a class="indexterm" name="idm140286789694304"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_certifier_threshold"><code class="literal">group_replication_flow_control_certifier_threshold</code></a>
            </p><p style="color:blue;">组复制流控制证书阈值</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_flow_control_certifier_threshold"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-flow-control-certifier-threshold=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_certifier_threshold">group_replication_flow_control_certifier_threshold</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">25000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2147483647</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the number of waiting transactions in the certifier
                    queue that trigger flow control. This variable can be changed
                    without resetting Group Replication.
                </p><p style="color:blue;">指定触发流控制的证书颁发器队列中等待的事务数。可以在不重置组复制的情况下更改此变量。</p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_hold_percent"></a>
                <a class="indexterm" name="idm140286789656656"></a>

                <a class="indexterm" name="idm140286789655616"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_hold_percent"><code class="literal">group_replication_flow_control_hold_percent</code></a>
            </p><p style="color:blue;">组复制流量控制保持百分比</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_flow_control_hold_percent"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-flow-control-hold-percent=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_hold_percent">group_replication_flow_control_hold_percent</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">10</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines what percentage of the group quota remains unused to
                    allow a cluster under flow control to catch up on backlog. A
                    value of 0 implies that no part of the quota is reserved for
                    catching up on the work backlog.
                </p><p style="color:blue;">定义未使用的组配额的百分比，以允许流控制下的群集赶上积压工作。值为0意味着配额的任何部分都不会保留以赶上工作积压。</p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_max_commit_quota"></a>
                <a class="indexterm" name="idm140286789620736"></a>

                <a class="indexterm" name="idm140286789619616"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_max_commit_quota"><code class="literal">group_replication_flow_control_max_commit_quota</code></a>
            </p><p style="color:blue;">组复制流控制最大提交配额</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_flow_control_max_commit_quota"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-flow-control-max-commit-quota=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_max_commit_quota">group_replication_flow_control_max_commit_quota</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2147483647</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the maximum flow control quota of the group, or the
                    maximum available quota for any period while flow control is
                    enabled. A value of 0 implies that there is no maximum quota
                    set. Cannot be smaller than
                    <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_quota"><code class="literal">group_replication_flow_control_min_quota</code></a>
                    and
                    <code class="literal">group_replication_flow_control_min_recovery_quota</code>.
                </p><p style="color:blue;">定义组的最大流量控制配额，或启用流量控制时的任何可用的最大配额。值为0意味着没有最大限额设置。不能小于组复制流量控制最小配额和组复制流量控制最小恢复配额。</p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_member_quota_percent"></a>
                <a class="indexterm" name="idm140286789582400"></a>

                <a class="indexterm" name="idm140286789581360"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_member_quota_percent"><code class="literal">group_replication_flow_control_member_quota_percent</code></a>
            </p><p style="color:blue;">组复制流量控制成员配额百分比</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_flow_control_member_quota_percent"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-flow-control-member-quota-percent=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_member_quota_percent">group_replication_flow_control_member_quota_percent</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Defines the percentage of the quota that a member should assume
                    is available for itself when calculating the quotas. A value of
                    0 implies that the quota should be split equally between members
                    that were writers in the last period.
                </p><p style="color:blue;">定义成员在计算配额时应假定其自身可用的配额百分比。值为0意味着配额应该平均分配给在上一个期间担任编写者的成员。</p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_min_quota"></a>
                <a class="indexterm" name="idm140286789546304"></a>

                <a class="indexterm" name="idm140286789545264"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_quota"><code class="literal">group_replication_flow_control_min_quota</code></a>
            </p><p style="color:blue;">组复制流量控制最小配额</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_flow_control_min_quota"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-flow-control-min-quota=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_quota">group_replication_flow_control_min_quota</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2147483647</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Controls the lowest flow control quota that can be assigned to a
                    member, independently of the calculated minimum quota executed
                    in the last period. A value of 0 implies that there is no
                    minimum quota. Cannot be larger than
                    <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_max_commit_quota"><code class="literal">group_replication_flow_control_max_commit_quota</code></a>.
                </p><p style="color:blue;">控制可分配给成员的最低流量控制配额，与上一期间执行的计算的最低配额无关。值为0表示没有最小配额。不能大于组复制流控制最大提交配额。</p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_min_recovery_quota"></a>
                <a class="indexterm" name="idm140286789509104"></a>

                <a class="indexterm" name="idm140286789508064"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_recovery_quota"><code class="literal">group_replication_flow_control_min_recovery_quota</code></a>
            </p><p style="color:blue;">组复制流量控制最小恢复配额</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_flow_control_min_recovery_quota"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-flow-control-min-recovery-quota=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_recovery_quota">group_replication_flow_control_min_recovery_quota</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2147483647</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Controls the lowest quota that can be assigned to a member
                    because of another recovering member in the group, independently
                    of the calculated minimum quota executed in the last period. A
                    value of 0 implies that there is no minimum quota. Cannot be
                    larger than
                    <code class="literal">group_replication_flow_control_max_commit_quota</code>.
                </p><p style="color:blue;">控制由于组中的另一个恢复成员而可以分配给某个成员的最低配额，与上一期间执行的计算的最低配额无关。值为0表示没有最小配额。不能大于组复制流控制最大提交配额。</p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_mode"></a>
                <a class="indexterm" name="idm140286789472192"></a>

                <a class="indexterm" name="idm140286789471152"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_mode"><code class="literal">group_replication_flow_control_mode</code></a>
            </p><p style="color:blue;">组复制流控制模式</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_flow_control_mode"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-flow-control-mode=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_mode">group_replication_flow_control_mode</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">QUOTA</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">DISABLED</code></p><p style="color:blue;">残疾人</p><p class="valid-value"><code class="literal">QUOTA</code></p><p style="color:blue;">配额</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the mode used for flow control. This variable can be
                    changed without resetting Group Replication.
                </p><p style="color:blue;">指定用于流控制的模式。可以在不重置组复制的情况下更改此变量。</p></li><li class="listitem"><p><a name="sysvar_group_replication_force_members"></a>
                <a class="indexterm" name="idm140286789435632"></a>

                <a class="indexterm" name="idm140286789434624"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
            </p><p style="color:blue;">集团复制部队成员</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_force_members"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-force-members=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_force_members">group_replication_force_members</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    A list of peer addresses as a comma separated list such as
                    <code class="literal">host1:port1</code>,<code class="literal">host2:port2</code>.
                    This option is used to force a new group membership, in which
                    the excluded members do not receive a new view and are blocked.
                    (You need to manually kill the excluded servers.) Any invalid
                    host names in the list could cause this action to fail because
                    they could block group membership. For a description of the
                    procedure to follow, see
                    <a class="xref" href="group-replication.html#group-replication-network-partitioning" title="17.4.3&nbsp;Network Partitioning">Section&nbsp;17.4.3, “Network Partitioning”</a>.
                </p><p style="color:blue;">以逗号分隔的对等地址列表，如host1:port1、host2:port2。此选项用于强制新的组成员身份，其中排除的成员不会收到新视图并被阻止。（您需要手动终止排除的服务器。）列表中的任何无效主机名都可能导致此操作失败，因为它们可能阻止组成员身份。有关要遵循的过程的说明，请参阅第17.4.3节“网络分区”。</p><p>
                    You must specify the address or host name and port as they are
                    given in the
                    <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                    option for each member. For example:
                </p><p style="color:blue;">必须为每个成员指定组复制本地地址选项中给定的地址或主机名和端口。例如：</p><pre data-lang="simple" class="programlisting">"198.51.100.44:33061,example.org:33061"</pre><p>
                    After you have used the
                    <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
                    system variable to successfully force a new group membership and
                    unblock the group, ensure that you clear the system variable.
                    <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
                    must be empty in order to issue a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START
                    GROUP_REPLICATION</code></a> statement.
                </p><p style="color:blue;">使用GROUP U REPLICATION U FORCE U EMBERS系统变量成功强制新的组成员身份并取消阻止该组后，请确保清除该系统变量。若要发出启动组复制语句，组复制强制成员必须为空。</p></li><li class="listitem"><p><a name="sysvar_group_replication_group_name"></a>
                <a class="indexterm" name="idm140286789396864"></a>

                <a class="indexterm" name="idm140286789395760"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_group_name"><code class="literal">group_replication_group_name</code></a>
            </p><p style="color:blue;">组复制组名</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_group_name"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-group-name=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_group_name">group_replication_group_name</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The name of the group which this server instance belongs to.
                    Must be a valid UUID. This UUID is used internally when setting
                    GTIDs for Group Replication events in the binary log.
                </p><p style="color:blue;">此服务器实例所属的组的名称。必须是有效的uuid。在为二进制日志中的组复制事件设置gtid时，在内部使用此uuid。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        A unique UUID must be used.
                    </p><p style="color:blue;">必须使用唯一的uuid。</p>
                </div>
            </li><li class="listitem"><p><a name="sysvar_group_replication_group_seeds"></a>
                <a class="indexterm" name="idm140286789366928"></a>

                <a class="indexterm" name="idm140286789365824"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
            </p><p style="color:blue;">组复制组种子</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_group_seeds"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-group-seeds=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_group_seeds">group_replication_group_seeds</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    A list of group members that provide a member which joins the
                    group with the data required for the joining member to gain
                    synchrony with the group. The list consists of the seed member's
                    network addresses specified as a comma separated list, such as
                    <code class="literal">host1:port1</code>,<code class="literal">host2:port2</code>.
                </p><p style="color:blue;">一个组成员的列表，它提供一个成员，该成员将组与加入成员所需的数据连接起来，以便与组同步。该列表由指定为逗号分隔列表的种子成员的网络地址组成，例如host1:port1、host2:port2。</p>
                <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Important
                    </div>
                    <p>
                        These addresses must not be the member's SQL hostname and
                        port.
                    </p><p style="color:blue;">这些地址不能是成员的SQL主机名和端口。</p>
                </div>
                <p>
                    Note that the value you specify for this variable is not
                    validated until a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START
                    GROUP_REPLICATION</code></a> statement is issued and the Group
                    Communication System (GCS) is available.
                </p><p style="color:blue;">请注意，在发出START GROUP U REPLICATION语句并且组通信系统（GCS）可用之前，不会验证为此变量指定的值。</p><p>
                    Usually this list consists of all members of the group, but you
                    can choose a subset of the group members to be seeds. The list
                    must contain at least one valid member address. Each address is
                    validated when starting Group Replication. If the list does not
                    contain any valid host names, issuing <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START
                    GROUP_REPLICATION</code></a> fails.
                </p><p style="color:blue;">通常此列表由组的所有成员组成，但您可以选择组成员的子集作为种子。列表必须至少包含一个有效的成员地址。启动组复制时验证每个地址。如果列表不包含任何有效的主机名，则发出启动组复制失败。</p></li><li class="listitem"><p><a name="sysvar_group_replication_gtid_assignment_block_size"></a>
                <a class="indexterm" name="idm140286789331600"></a>

                <a class="indexterm" name="idm140286789330480"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_gtid_assignment_block_size"><code class="literal">group_replication_gtid_assignment_block_size</code></a>
            </p><p style="color:blue;">组复制块大小</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_gtid_assignment_block_size"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-gtid-assignment-block-size=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_gtid_assignment_block_size">group_replication_gtid_assignment_block_size</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">1000000</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">1</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                        <td><code class="literal">9223372036854775807</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of consecutive GTIDs that are reserved for each
                    member. Each member consumes its blocks and reserves more when
                    needed.
                </p><p style="color:blue;">为每个成员保留的连续gtid数。每个成员都会消耗其块，并在需要时保留更多块。</p><p>
                    This system variable is a group-wide configuration setting. It
                    must have the same value on all group members, cannot be changed
                    while Group Replication is running, and requires a full reboot
                    of the group (a bootstrap by a server with
                    <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=ON</code></a>)
                    in order for the value change to take effect.
                </p><p style="color:blue;">此系统变量是组范围的配置设置。它必须在所有组成员上具有相同的值，在组复制运行时无法更改，并且需要完全重新启动组（由具有组复制的服务器启动）才能使值更改生效。</p></li><li class="listitem"><p><a name="sysvar_group_replication_ip_whitelist"></a>
                <a class="indexterm" name="idm140286789287728"></a>

                <a class="indexterm" name="idm140286789286688"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist"><code class="literal">group_replication_ip_whitelist</code></a>
            </p><p style="color:blue;">组复制IP白名单</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_ip_whitelist"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-ip-whitelist=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist">group_replication_ip_whitelist</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">AUTOMATIC</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies which hosts are permitted to connect to the group. The
                    address that you specify for each group member in
                    <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                    must be whitelisted on the other servers in the replication
                    group. Note that the value you specify for this variable is not
                    validated until a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START
                    GROUP_REPLICATION</code></a> statement is issued and the Group
                    Communication System (GCS) is available.
                </p><p style="color:blue;">指定允许哪些主机连接到组。为组复制本地地址中的每个组成员指定的地址必须在复制组中的其他服务器上白名单。请注意，在发出START GROUP U REPLICATION语句并且组通信系统（GCS）可用之前，不会验证为此变量指定的值。</p><p>
                    By default, this system variable is set to
                    <code class="literal">AUTOMATIC</code>, which permits connections from
                    private subnetworks active on the host. The group communication
                    engine (XCom) automatically scans active interfaces on the host,
                    and identifies those with addresses on private subnetworks.
                    These addresses and the <code class="literal">localhost</code> IP address
                    for IPv4 are used to create the Group Replication whitelist. For
                    a list of the ranges from which addresses are automatically
                    whitelisted, see
                    <a class="xref" href="group-replication.html#group-replication-ip-address-whitelisting" title="17.5.1&nbsp;Group Replication IP Address Whitelisting">Section&nbsp;17.5.1, “Group Replication IP Address Whitelisting”</a>.
                </p><p style="color:blue;">默认情况下，此系统变量设置为“自动”，允许来自主机上活动的专用子网的连接。组通信引擎（xcom）自动扫描主机上的活动接口，并识别那些在私有子网上有地址的接口。这些地址和IPv4的本地主机IP地址用于创建组复制白名单。有关自动白名单地址范围的列表，请参阅17.5.1节“组复制IP地址白名单”。</p><p>
                    The automatic whitelist of private addresses cannot be used for
                    connections from servers outside the private network. For Group
                    Replication connections between server instances that are on
                    different machines, you must provide public IP addresses and
                    specify these as an explicit whitelist. If you specify any
                    entries for the whitelist, the private and
                    <code class="literal">localhost</code> addresses are not added
                    automatically, so if you use any of these, you must specify them
                    explicitly.
                </p><p style="color:blue;">专用地址的自动白名单不能用于来自专用网络外部服务器的连接。对于不同计算机上的服务器实例之间的组复制连接，必须提供公用IP地址并将其指定为显式白名单。如果为白名单指定任何条目，则不会自动添加专用地址和本地主机地址，因此如果使用其中任何一个，则必须显式指定它们。</p><p>
                    As the value of the
                    <a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist"><code class="literal">group_replication_ip_whitelist</code></a>
                    option, you can specify any combination of the following:
                </p><p style="color:blue;">作为组复制IP白名单选项的值，您可以指定以下任意组合：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        IPv4 addresses (for example,
                        <code class="literal">198.51.100.44</code>)
                    </p><p style="color:blue;">IPv4地址（例如198.51.100.44）</p></li><li class="listitem"><p>
                        IPv4 addresses with CIDR notation (for example,
                        <code class="literal">192.0.2.21/24</code>)
                    </p><p style="color:blue;">带CIDR符号的IPv4地址（例如，192.0.2.21/24）</p></li><li class="listitem"><p>
                        Host names, from MySQL 5.7.21 (for example,
                        <code class="literal">example.org</code>)
                    </p><p style="color:blue;">主机名，来自mysql 5.7.21（例如，example.org）</p></li><li class="listitem"><p>
                        Host names with CIDR notation, from MySQL 5.7.21 (for
                        example, <code class="literal">www.example.com/24</code>)
                    </p><p style="color:blue;">带有cidr符号的主机名，来自mysql 5.7.21（例如，www.example.com/24）</p></li></ul>
                </div>
                <p>
                    IPv6 addresses, and host names that resolve to IPv6 addresses,
                    are not supported in MySQL 5.7. You can use CIDR notation in
                    combination with host names or IP addresses to whitelist a block
                    of IP addresses with a particular network prefix, but do ensure
                    that all the IP addresses in the specified subnet are under your
                    control.
                </p><p style="color:blue;">mysql 5.7不支持IPv6地址和解析为IPv6地址的主机名。您可以将cidr表示法与主机名或ip地址结合使用，列出具有特定网络前缀的ip地址块，但请确保指定子网中的所有ip地址都在您的控制之下。</p><p>
                    A comma must separate each entry in the whitelist. For example:
                </p><p style="color:blue;">必须用逗号分隔白名单中的每个条目。例如：</p><pre data-lang="none" class="programlisting">192.0.2.22,198.51.100.0/24,example.org,www.example.com/24</pre><p>
                    It is possible to configure different whitelists on different
                    group members according to your security requirements, for
                    example, in order to keep different subnets separate. However,
                    this can cause issues when a group is reconfigured. If you do
                    not have a specific security requirement to do otherwise, use
                    the same whitelist on all members of a group. For more details,
                    see <a class="xref" href="group-replication.html#group-replication-ip-address-whitelisting" title="17.5.1&nbsp;Group Replication IP Address Whitelisting">Section&nbsp;17.5.1, “Group Replication IP Address Whitelisting”</a>.
                </p><p style="color:blue;">可以根据您的安全要求在不同的组成员上配置不同的白名单，例如，为了使不同的子网保持独立。但是，在重新配置组时，这可能会导致问题。如果没有特定的安全要求，请对组的所有成员使用相同的白名单。有关更多详细信息，请参阅第17.5.1节“组复制IP地址白名单”。</p><p>
                    For host names, name resolution takes place only when a
                    connection request is made by another server. A host name that
                    cannot be resolved is not considered for whitelist validation,
                    and a warning message is written to the error log.
                    Forward-confirmed reverse DNS (FCrDNS) verification is carried
                    out for resolved host names.
                </p><p style="color:blue;">对于主机名，只有当另一台服务器发出连接请求时，才会进行名称解析。白名单验证不考虑无法解析的主机名，并将警告消息写入错误日志。对解析的主机名执行正向确认的反向dns（fcrdns）验证。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Host names are inherently less secure than IP addresses in a
                        whitelist. FCrDNS verification provides a good level of
                        protection, but can be compromised by certain types of attack.
                        Specify host names in your whitelist only when strictly
                        necessary, and ensure that all components used for name
                        resolution, such as DNS servers, are maintained under your
                        control. You can also implement name resolution locally using
                        the hosts file, to avoid the use of external components.
                    </p><p style="color:blue;">主机名本质上不如白名单中的IP地址安全。fcrdns验证提供了很好的保护级别，但可能会受到某些类型的攻击的危害。仅在严格必要时在白名单中指定主机名，并确保用于名称解析的所有组件（如DNS服务器）都在您的控制下维护。还可以使用hosts文件在本地实现名称解析，以避免使用外部组件。</p>
                </div>
            </li><li class="listitem"><p><a name="sysvar_group_replication_local_address"></a>
                <a class="indexterm" name="idm140286789233584"></a>

                <a class="indexterm" name="idm140286789232480"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
            </p><p style="color:blue;">组复制本地地址</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_local_address"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-local-address=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_local_address">group_replication_local_address</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The network address which the member provides for connections
                    from other members, specified as a <code class="literal">host:port</code>
                    formatted string. This address must be reachable by all members
                    of the group because it is used by the group communication
                    engine for Group Replication (XCom, a Paxos variant) for TCP
                    communication between remote XCom instances. Communication with
                    the local instance is over an input channel using shared memory.
                </p><p style="color:blue;">成员为来自其他成员的连接提供的网络地址，指定为host:port格式的字符串。此地址必须可由组的所有成员访问，因为组通信引擎用于在远程xcom实例之间进行tcp通信的组复制（xcom，paxos变体）。与本地实例的通信是通过使用共享内存的输入通道进行的。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        Do not use this address for communication with the member.
                    </p><p style="color:blue;">不要使用此地址与成员通信。</p>
                </div>
                <p>
                    Other Group Replication members contact this member through this
                    <code class="literal">host:port</code> for all internal group
                    communication. This is not the MySQL server SQL protocol host
                    and port.
                </p><p style="color:blue;">其他组复制成员通过此主机：端口与此成员联系以进行所有内部组通信。这不是mysql服务器的sql协议主机和端口。</p><p>
                    The address or host name that you specify in
                    <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                    is used by Group Replication as the unique identifier for a
                    group member within the replication group. You can use the same
                    port for all members of a replication group as long as the host
                    names or IP addresses are all different, and you can use the
                    same host name or IP address for all members as long as the
                    ports are all different. The recommended port for
                    <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                    is 33061. Note that the value you specify for this variable is
                    not validated until the <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START
                    GROUP_REPLICATION</code></a> statement is issued and the Group
                    Communication System (GCS) is available.
                </p><p style="color:blue;">组复制使用在组复制本地地址中指定的地址或主机名作为复制组内组成员的唯一标识符。只要主机名或IP地址都不同，就可以对复制组的所有成员使用相同的端口；只要端口都不同，就可以对所有成员使用相同的主机名或IP地址。组复制本地地址的建议端口是33061。请注意，在发出START GROUP U REPLICATION语句并且组通信系统（GCS）可用之前，不会验证为此变量指定的值。</p></li><li class="listitem"><p><a name="sysvar_group_replication_member_weight"></a>
                <a class="indexterm" name="idm140286789196496"></a>

                <a class="indexterm" name="idm140286789195392"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>
            </p><p style="color:blue;">组复制成员权重</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_member_weight"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-member-weight=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.20</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_member_weight">group_replication_member_weight</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">50</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">100</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    A percentage weight that can be assigned to members to influence
                    the chance of the member being elected as primary in the event
                    of failover, for example when the existing primary leaves a
                    single-primary group. Assign numeric weights to members to
                    ensure that specific members are elected, for example during
                    scheduled maintenance of the primary or to ensure certain
                    hardware is prioritized in the event of failover.
                </p><p style="color:blue;">一个百分比权重，可分配给成员，以影响成员在故障转移时当选为主要成员的机会，例如当现有主离开单个主组时。为成员分配数字权重以确保选定特定成员，例如在主成员的计划维护期间，或确保在故障转移时对某些硬件进行优先级排序。</p><p>
                    For a group with members configured as follows:
                </p><p style="color:blue;">对于成员配置如下的组：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                        <code class="literal">member-1</code>:
                        group_replication_member_weight=30, server_uuid=aaaa
                    </p><p style="color:blue;">成员1:组复制成员权重=30，服务器ID=AAAA</p></li><li class="listitem"><p>
                        <code class="literal">member-2</code>:
                        group_replication_member_weight=40, server_uuid=bbbb
                    </p><p style="color:blue;">成员2:组复制成员权重=40，服务器ID=bbbb</p></li><li class="listitem"><p>
                        <code class="literal">member-3</code>:
                        group_replication_member_weight=40, server_uuid=cccc
                    </p><p style="color:blue;">成员3:组复制成员权重=40，服务器ID=CCCC</p></li><li class="listitem"><p>
                        <code class="literal">member-4</code>:
                        group_replication_member_weight=40, server_uuid=dddd
                    </p><p style="color:blue;">成员4:组复制成员权重=40，服务器ID=dddd</p></li></ul>
                </div>
                <p>
                    during election of a new primary the members above would be
                    sorted as <code class="literal">member-2</code>,
                    <code class="literal">member-3</code>, <code class="literal">member-4</code>, and
                    <code class="literal">member-1</code>. This results in
                    <code class="literal">member</code>-2 being chosen as the new primary in
                    the event of failover. For more information, see
                    <a class="xref" href="group-replication.html#group-replication-single-primary-mode" title="17.4.1.1&nbsp;Single-Primary Mode">Section&nbsp;17.4.1.1, “Single-Primary Mode”</a>.
                </p><p style="color:blue;">在新的初选中，上述成员将被分为2号、3号、4号和1号。这将导致在发生故障转移时选择成员2作为新的主节点。有关更多信息，请参见第17.4.1.1节“单主模式”。</p></li><li class="listitem"><p><a name="sysvar_group_replication_poll_spin_loops"></a>
                <a class="indexterm" name="idm140286789145824"></a>

                <a class="indexterm" name="idm140286789144784"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_poll_spin_loops"><code class="literal">group_replication_poll_spin_loops</code></a>
            </p><p style="color:blue;">组复制轮询自旋循环</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_poll_spin_loops"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-poll-spin-loops=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_poll_spin_loops">group_replication_poll_spin_loops</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
                        <td><code class="literal">18446744073709551615</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
                        <td><code class="literal">4294967295</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of times the group communication thread waits for the
                    communication engine mutex to be released before the thread
                    waits for more incoming network messages.
                </p><p style="color:blue;">组通信线程在等待更多传入网络消息之前等待通信引擎互斥体释放的次数。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_retry_count"></a>
                <a class="indexterm" name="idm140286789104144"></a>

                <a class="indexterm" name="idm140286789103104"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_retry_count"><code class="literal">group_replication_recovery_retry_count</code></a>
            </p><p style="color:blue;">组复制恢复重试计数</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_retry_count"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-retry-count=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_retry_count">group_replication_recovery_retry_count</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">10</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">31536000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The number of times that the member that is joining tries to
                    connect to the available donors before giving up.
                </p><p style="color:blue;">正在加入的成员在放弃前尝试连接到可用捐助者的次数。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_reconnect_interval"></a>
                <a class="indexterm" name="idm140286789065808"></a>

                <a class="indexterm" name="idm140286789064688"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_reconnect_interval"><code class="literal">group_replication_recovery_reconnect_interval</code></a>
            </p><p style="color:blue;">组复制恢复重新连接间隔</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_reconnect_interval"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-reconnect-interval=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_reconnect_interval">group_replication_recovery_reconnect_interval</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">60</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">31536000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    The sleep time, in seconds, between reconnection attempts when
                    no donor was found in the group.
                </p><p style="color:blue;">当在组中找不到供者时，重新连接尝试之间的睡眠时间（秒）。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_use_ssl"></a>
                <a class="indexterm" name="idm140286789027408"></a>

                <a class="indexterm" name="idm140286789026368"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_use_ssl"><code class="literal">group_replication_recovery_use_ssl</code></a>
            </p><p style="color:blue;">组复制恢复使用SSL</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_use_ssl"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-use-ssl[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_use_ssl">group_replication_recovery_use_ssl</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Whether Group Replication recovery connection should use SSL or
                    not.
                </p><p style="color:blue;">组复制恢复连接是否应使用SSL。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_ca"></a>
                <a class="indexterm" name="idm140286788995248"></a>

                <a class="indexterm" name="idm140286788994208"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_ca"><code class="literal">group_replication_recovery_ssl_ca</code></a>
            </p><p style="color:blue;">组复制恢复</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_ca"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-ssl-ca=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_ca">group_replication_recovery_ssl_ca</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The path to a file that contains a list of trusted SSL
                    certificate authorities.
                </p><p style="color:blue;">包含受信任的SSL证书颁发机构列表的文件的路径。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_capath"></a>
                <a class="indexterm" name="idm140286788966144"></a>

                <a class="indexterm" name="idm140286788965104"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_capath"><code class="literal">group_replication_recovery_ssl_capath</code></a>
            </p><p style="color:blue;">组复制恢复</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_capath"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-ssl-capath=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_capath">group_replication_recovery_ssl_capath</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The path to a directory that contains trusted SSL certificate
                    authority certificates.
                </p><p style="color:blue;">包含受信任的SSL证书颁发机构证书的目录的路径。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_cert"></a>
                <a class="indexterm" name="idm140286788937024"></a>

                <a class="indexterm" name="idm140286788935984"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cert"><code class="literal">group_replication_recovery_ssl_cert</code></a>
            </p><p style="color:blue;">组复制恢复SSL证书</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_cert"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-ssl-cert=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cert">group_replication_recovery_ssl_cert</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The name of the SSL certificate file to use for establishing a
                    secure connection.
                </p><p style="color:blue;">用于建立安全连接的SSL证书文件的名称。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_key"></a>
                <a class="indexterm" name="idm140286788907904"></a>

                <a class="indexterm" name="idm140286788906864"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_key"><code class="literal">group_replication_recovery_ssl_key</code></a>
            </p><p style="color:blue;">组复制恢复SSL密钥</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_key"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-ssl-key=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_key">group_replication_recovery_ssl_key</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The name of the SSL key file to use for establishing a secure
                    connection.
                </p><p style="color:blue;">用于建立安全连接的SSL密钥文件的名称。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_cipher"></a>
                <a class="indexterm" name="idm140286788878864"></a>

                <a class="indexterm" name="idm140286788877824"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cipher"><code class="literal">group_replication_recovery_ssl_cipher</code></a>
            </p><p style="color:blue;">组复制恢复SSL密码</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_cipher"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-ssl-cipher=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cipher">group_replication_recovery_ssl_cipher</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>String</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The list of permissible ciphers for SSL encryption.
                </p><p style="color:blue;">SSL加密允许的密码列表。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_crl"></a>
                <a class="indexterm" name="idm140286788849792"></a>

                <a class="indexterm" name="idm140286788848752"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crl"><code class="literal">group_replication_recovery_ssl_crl</code></a>
            </p><p style="color:blue;">组复制恢复</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_crl"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-ssl-crl=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crl">group_replication_recovery_ssl_crl</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>File name</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The path to a directory that contains files containing
                    certificate revocation lists.
                </p><p style="color:blue;">包含包含证书吊销列表的文件的目录的路径。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_crlpath"></a>
                <a class="indexterm" name="idm140286788820672"></a>

                <a class="indexterm" name="idm140286788819632"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crlpath"><code class="literal">group_replication_recovery_ssl_crlpath</code></a>
            </p><p style="color:blue;">组复制恢复</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_crlpath"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-ssl-crlpath=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crlpath">group_replication_recovery_ssl_crlpath</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Directory name</td>
                    </tr></tbody></table>
                </div>
                <p>
                    The path to a directory that contains files containing
                    certificate revocation lists.
                </p><p style="color:blue;">包含包含证书吊销列表的文件的目录的路径。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_verify_server_cert"></a>
                <a class="indexterm" name="idm140286788791504"></a>

                <a class="indexterm" name="idm140286788790464"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_verify_server_cert"><code class="literal">group_replication_recovery_ssl_verify_server_cert</code></a>
            </p><p style="color:blue;">组复制恢复SSL验证服务器证书</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_verify_server_cert"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-ssl-verify-server-cert[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_verify_server_cert">group_replication_recovery_ssl_verify_server_cert</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">OFF</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Make the recovery process check the server's Common Name value
                    in the donor sent certificate.
                </p><p style="color:blue;">使恢复过程检查捐赠者发送的证书中服务器的公用名值。</p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_complete_at"></a>
                <a class="indexterm" name="idm140286788759168"></a>

                <a class="indexterm" name="idm140286788758128"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_recovery_complete_at"><code class="literal">group_replication_recovery_complete_at</code></a>
            </p><p style="color:blue;">组复制恢复完成</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_recovery_complete_at"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-recovery-complete-at=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_complete_at">group_replication_recovery_complete_at</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">TRANSACTIONS_APPLIED</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">TRANSACTIONS_CERTIFIED</code></p><p style="color:blue;">经认证的交易</p><p class="valid-value"><code class="literal">TRANSACTIONS_APPLIED</code></p><p style="color:blue;">应用的交易</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Recovery policies when handling cached transactions after state
                    transfer. This option specifies whether a member is marked
                    online after it has received all transactions that it missed
                    before it joined the group
                    (<code class="literal">TRANSACTIONS_CERTIFIED</code>) or after it has
                    received and applied them
                    (<code class="literal">TRANSACTIONS_APPLIED</code>).
                </p><p style="color:blue;">状态传输后处理缓存事务时的恢复策略。此选项指定成员在接收到加入组之前错过的所有交易（已认证的交易）或在接收并应用这些交易（已应用的交易）后是否标记为联机。</p></li><li class="listitem"><p><a name="sysvar_group_replication_single_primary_mode"></a>
                <a class="indexterm" name="idm140286788720880"></a>

                <a class="indexterm" name="idm140286788719840"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode"><code class="literal">group_replication_single_primary_mode</code></a>
            </p><p style="color:blue;">组复制单主模式</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_single_primary_mode"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-single-primary-mode[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode">group_replication_single_primary_mode</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Instructs the group to automatically pick a single server to be
                    the one that handles read/write workload. This server is the
                    PRIMARY and all others are SECONDARIES.
                </p><p style="color:blue;">指示组自动选择单个服务器作为处理读/写工作负载的服务器。此服务器是主服务器，其他所有服务器都是辅助服务器。</p><p>
                    This system variable is a group-wide configuration setting. It
                    must have the same value on all group members, cannot be changed
                    while Group Replication is running, and requires a full reboot
                    of the group (a bootstrap by a server with
                    <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=ON</code></a>)
                    in order for the value change to take effect.
                </p><p style="color:blue;">此系统变量是组范围的配置设置。它必须在所有组成员上具有相同的值，在组复制运行时无法更改，并且需要完全重新启动组（由具有组复制的服务器启动）才能使值更改生效。</p></li><li class="listitem"><p><a name="sysvar_group_replication_ssl_mode"></a>
                <a class="indexterm" name="idm140286788686640"></a>

                <a class="indexterm" name="idm140286788685536"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_ssl_mode"><code class="literal">group_replication_ssl_mode</code></a>
            </p><p style="color:blue;">组复制模式</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_ssl_mode"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-ssl-mode=value</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_ssl_mode">group_replication_ssl_mode</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Enumeration</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">DISABLED</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
                        <td><p class="valid-value"><code class="literal">DISABLED</code></p><p style="color:blue;">残疾人</p><p class="valid-value"><code class="literal">REQUIRED</code></p><p style="color:blue;">必修的</p><p class="valid-value"><code class="literal">VERIFY_CA</code></p><p style="color:blue;">验证CA</p><p class="valid-value"><code class="literal">VERIFY_IDENTITY</code></p><p style="color:blue;">验证身份</p></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Specifies the security state of the connection between Group
                    Replication members.
                </p><p style="color:blue;">指定组复制成员之间连接的安全状态。</p></li><li class="listitem"><p><a name="sysvar_group_replication_start_on_boot"></a>
                <a class="indexterm" name="idm140286788648176"></a>

                <a class="indexterm" name="idm140286788647072"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot"><code class="literal">group_replication_start_on_boot</code></a>
            </p><p style="color:blue;">组复制启动</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_start_on_boot"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-start-on-boot[={OFF|ON}]</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.17</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot">group_replication_start_on_boot</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Boolean</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">ON</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Whether the server should start Group Replication or not during
                    server start.
                </p><p style="color:blue;">服务器是否应在服务器启动期间启动组复制。</p></li><li class="listitem"><p><a name="sysvar_group_replication_transaction_size_limit"></a>
                <a class="indexterm" name="idm140286788616064"></a>

                <a class="indexterm" name="idm140286788614944"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
            </p><p style="color:blue;">组复制事务大小限制</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_transaction_size_limit"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-transaction-size-limit=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.19</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit">group_replication_transaction_size_limit</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">2147483647</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Configures the maximum transaction size in bytes which the
                    replication group accepts. Transactions larger than this size
                    are rolled back by the receiving member and are not broadcast to
                    the group. Large transactions can cause problems for a
                    replication group in terms of memory allocation, which can cause
                    the system to slow down, or in terms of network bandwidth
                    consumption, which can cause a member to be suspected of having
                    failed because it is busy processing the large transaction.
                </p><p style="color:blue;">配置复制组接受的字节的最大事务大小。大于此大小的事务将由接收成员回滚，并且不会广播到组。大型事务可能会导致复制组在内存分配方面出现问题，这可能会导致系统速度减慢，或者在网络带宽消耗方面出现问题，这可能会导致成员因忙于处理大型事务而被怀疑失败。</p><p>
                    When this system variable is set to 0, which is the default in
                    MySQL 5.7, there is no limit to the size of transactions the
                    group accepts. From MySQL 8.0, the default setting for this
                    system variable is 150000000 bytes (approximately 143 MB).
                    Adjust the value of this system variable depending on the
                    maximum message size that you need the group to tolerate,
                    bearing in mind that the time taken to process a transaction is
                    proportional to its size. The value of
                    <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
                    should be the same on all group members. For further mitigation
                    strategies for large transactions, see
                    <a class="xref" href="group-replication.html#group-replication-limitations" title="17.7.2&nbsp;Group Replication Limitations">Section&nbsp;17.7.2, “Group Replication Limitations”</a>.
                </p><p style="color:blue;">当此系统变量设置为0（mysql 5.7中的默认值）时，对组接受的事务大小没有限制。从MySQL 8，这个系统变量的默认设置是150000000字节（大约143 MB）。根据您需要组容忍的最大消息大小来调整该系统变量的值，记住处理事务所花费的时间与它的大小成比例。组复制事务大小限制的值应在所有组成员上相同。有关大型事务的进一步缓解策略，请参阅第17.7.2节“组复制限制”。</p></li><li class="listitem"><p><a name="sysvar_group_replication_unreachable_majority_timeout"></a>
                <a class="indexterm" name="idm140286788573936"></a>

                <a class="indexterm" name="idm140286788572896"></a>

                <a class="link" href="group-replication.html#sysvar_group_replication_unreachable_majority_timeout"><code class="literal">group_replication_unreachable_majority_timeout</code></a>
            </p><p style="color:blue;">组复制无法访问多数超时</p>
                <div class="informaltable">
                    <table frame="box" rules="all" summary="Properties for group_replication_unreachable_majority_timeout"><colgroup><col width="30%"><col width="70%"></colgroup><thead><tr><th scope="col">Property</th>
                        <th scope="col">Value</th>
                    </tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
                        <td><code class="literal">--group-replication-unreachable-majority-timeout=#</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
                        <td>5.7.19</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
                        <td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_unreachable_majority_timeout">group_replication_unreachable_majority_timeout</a></code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
                        <td>Global</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
                        <td>Yes</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
                        <td>Integer</td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
                        <td><code class="literal">0</code></td>
                    </tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
                        <td><code class="literal">31536000</code></td>
                    </tr></tbody></table>
                </div>
                <p>
                    Configures how long members that suffer a network partition and
                    cannot connect to the majority wait before leaving the group.
                </p><p style="color:blue;">配置遭受网络分区且无法连接到大多数成员的成员在离开组之前等待的时间。</p><p>
                    In a group of 5 servers (S1,S2,S3,S4,S5), if there is a
                    disconnection between (S1,S2) and (S3,S4,S5) there is a network
                    partition. The first group (S1,S2) is now in a minority because
                    it cannot contact more than half of the group. While the
                    majority group (S3,S4,S5) remains running, the minority group
                    waits for the specified time for a network reconnection. Any
                    transactions processed by the minority group are blocked until
                    Group Replication is stopped using <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2&nbsp;STOP GROUP_REPLICATION Syntax"><code class="literal">STOP
                    GROUP REPLICATION</code></a> on the members of the minority. Note
                    that
                    <a class="link" href="group-replication.html#sysvar_group_replication_unreachable_majority_timeout"><code class="literal">group_replication_unreachable_majority_timeout</code></a>
                    has no effect if it is set on the servers in the minority group
                    after the loss of majority has been detected.
                </p><p style="color:blue;">在一组5台服务器（s1、s2、s3、s4、s5）中，如果（s1、s2）和（s3、s4、s5）之间存在断开连接，则存在网络分区。第一组（s1，s2）现在是少数，因为它不能接触超过一半的人。当多数组（s3、s4、s5）保持运行时，少数组等待指定的时间进行网络重新连接。在使用少数组成员上的停止组复制停止组复制之前，少数组处理的任何事务都将被阻止。请注意，如果在检测到多数丢失后在少数组中的服务器上设置了组复制不可到达多数超时，则该超时无效。</p><p>
                    By default, this system variable is set to 0, which means that
                    members that find themselves in a minority due to a network
                    partition wait forever to leave the group. If configured to a
                    number of seconds, members wait for this amount of time after
                    losing contact with the majority of members before leaving the
                    group. When the specified time elapses, all pending transactions
                    processed by the minority are rolled back, and the servers in
                    the minority partition move to the <code class="literal">ERROR</code>
                    state. These servers then follow the action specified by the
                    system variable
                    <a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action"><code class="literal">group_replication_exit_state_action</code></a>,
                    which can be to set themselves to super read only mode or shut
                    down MySQL.
                </p><p style="color:blue;">默认情况下，此系统变量设置为0，这意味着由于网络分区而处于少数的成员将永远等待离开组。如果配置为秒数，则成员在与大多数成员失去联系后等待此时间量，然后再离开组。指定的时间过后，少数群体处理的所有挂起事务都将回滚，少数群体分区中的服务器将移动到错误状态。然后，这些服务器遵循由系统变量GROP.PrimeCaseEXITHSTATEYAXY指定的操作，可以将其设置为超级只读模式或关闭MySQL。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        When you have a symmetric group, with just two members for
                        example (S0,S2), if there is a network partition and there is
                        no majority, after the configured timeout all members enter
                        <code class="literal">ERROR</code> state.
                    </p><p style="color:blue;">当您有一个只有两个成员（例如s0、s2）的对称组时，如果有一个网络分区并且没有大多数成员，则在配置的超时之后，所有成员都将进入错误状态。</p>
                </div>
            </li></ul>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-status-variables"></a>Group Replication Status Variable</h3>

                    </div>

                </div>

            </div>
            <p>
                This section describes the status variables which provide
                information about Group Replication. The variable has the
                following meaning:
            </p><p style="color:blue;">本节介绍提供有关组复制信息的状态变量。变量具有以下含义：</p>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="server-administration.html#statvar_group_replication_primary_member"><code class="literal">group_replication_primary_member</code></a>
                </p><p style="color:blue;">组复制主要成员</p><p>
                    Shows the primary member's UUID when the group is operating in
                    single-primary mode. If the group is operating in
                    multi-primary mode, shows an empty string. See
                    <a class="xref" href="group-replication.html#group-replication-find-primary" title="17.4.1.3&nbsp;Finding the Primary">Section&nbsp;17.4.1.3, “Finding the Primary”</a>.
                </p><p style="color:blue;">当组在单一主模式下操作时，显示主成员的uuid。如果组在多主模式下操作，则显示空字符串。见第17.4.1.3节“寻找主要”。</p></li></ul>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="group-replication-requirements-and-limitations"></a>17.7&nbsp;Requirements and Limitations</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-requirements">17.7.1 Group Replication Requirements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-limitations">17.7.2 Group Replication Limitations</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286788520320"></a><p>
        This section lists and explains the requirements and limitations of
        Group Replication.
    </p><p style="color:blue;">本节列出并解释组复制的要求和限制。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-requirements"></a>17.7.1&nbsp;Group Replication Requirements</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286788517232"></a><p>
            Server instances that you want to use for Group Replication must
            satisfy the following requirements.
        </p><p style="color:blue;">要用于组复制的服务器实例必须满足以下要求。</p>
            <div class="simplesect">

                <div class="titlepage">
                    <div>

                        <div class="simple">
                            <h4 class="title"><a name="group-replication-infrastructure"></a>Infrastructure</h4>
                        </div>
                    </div>
                </div>

                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>InnoDB Storage Engine.&nbsp;</b>
                        Data must be stored in the
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> transactional storage
                        engine. Transactions are executed optimistically and then,
                        at commit time, are checked for conflicts. If there are
                        conflicts, in order to maintain consistency across the
                        group, some transactions are rolled back. This means that
                        a transactional storage engine is required. Moreover,
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> provides some
                        additional functionality that enables better management
                        and handling of conflicts when operating together with
                        Group Replication. The use of other storage engines,
                        including the temporary
                        <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3&nbsp;The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> storage engine, might
                        cause errors in Group Replication. You can prevent the use
                        of other storage engines by setting the
                        <a class="link" href="server-administration.html#sysvar_disabled_storage_engines"><code class="literal">disabled_storage_engines</code></a>
                        system variable on group members, for example:
                    </p><p style="color:blue;">InnoDB存储引擎。数据必须存储在innodb事务存储引擎中。事务以乐观的方式执行，然后在提交时检查冲突。如果存在冲突，为了在整个组中保持一致性，将回滚某些事务。这意味着需要事务性存储引擎。此外，innodb还提供了一些附加功能，当与组复制一起操作时，可以更好地管理和处理冲突。使用其他存储引擎（包括临时内存存储引擎）可能会导致组复制中出现错误。您可以通过在组成员上设置disabled_storage_engines系统变量来防止使用其他存储引擎，例如：</p><pre data-lang="ini" class="programlisting">disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"
</pre></li><li class="listitem"><p><b>Primary Keys.&nbsp;</b>
                        Every table that is to be replicated by the group must
                        have a defined primary key, or primary key equivalent
                        where the equivalent is a non-null unique key. Such keys
                        are required as a unique identifier for every row within a
                        table, enabling the system to determine which transactions
                        conflict by identifying exactly which rows each
                        transaction has modified.
                    </p><p style="color:blue;">主键。要由组复制的每个表都必须具有定义的主键或等效主键，其中等效主键是非空的唯一键。这些键是表中每一行的唯一标识符，使系统能够通过准确标识每个事务修改了哪些行来确定哪些事务发生冲突。</p></li><li class="listitem"><p><b>IPv4 Network.&nbsp;</b>
                        The group communication engine used by MySQL Group
                        Replication only supports IPv4. Therefore, Group
                        Replication requires an IPv4 network infrastructure.
                    </p><p style="color:blue;">IPv4网络。MySQL组复制使用的组通信引擎仅支持IPv4。因此，组复制需要IPv4网络基础结构。</p></li><li class="listitem"><p><b>Network Performance.&nbsp;</b>
                        MySQL Group Replication is designed to be deployed in a
                        cluster environment where server instances are very close
                        to each other. The performance and stabiity of a group can
                        be impacted by both network latency and network bandwidth.
                        Bi-directional communication must be maintained at all
                        times between all group members. If either inbound or
                        outbound communication is blocked for a server instance
                        (for example, by a firewall, or by connectivity issues),
                        the member cannot function in the group, and the group
                        members (including the member with issues) might not be
                        able to report the correct member status for the affected
                        server instance.
                    </p><p style="color:blue;">网络性能。mysql组复制被设计为部署在一个集群环境中，其中服务器实例彼此非常接近。网络延迟和网络带宽都会影响组的性能和稳定性。所有组成员之间必须始终保持双向通信。如果服务器实例的入站或出站通信被阻止（例如，防火墙或连接问题），则该成员无法在组中运行，并且组成员（包括有问题的成员）可能无法报告受影响服务器实例的正确成员状态。</p></li></ul>
                </div>

            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="group-replication-configuration"></a>Server Instance Configuration</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The following options must be configured on server instances
                    that are members of a group.
                </p><p style="color:blue;">必须在作为组成员的服务器实例上配置以下选项。</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Binary Log Active.&nbsp;</b>
                        Set
                        <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">--log-bin[=log_file_name]</code></a>.
                        MySQL Group Replication replicates binary log contents,
                        therefore the binary log needs to be on for it to operate.
                        This option is enabled by default. See
                        <a class="xref" href="server-administration.html#binary-log" title="5.4.4&nbsp;The Binary Log">Section&nbsp;5.4.4, “The Binary Log”</a>.
                    </p><p style="color:blue;">二进制日志激活。set--log bin[=日志文件名]。mysql group replication复制二进制日志内容，因此需要打开二进制日志才能进行操作。默认情况下，此选项处于启用状态。见第5.4.4节“二进制日志”。</p></li><li class="listitem"><p><b>Slave Updates Logged.&nbsp;</b>
                        Set <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">--log-slave-updates</code></a>.
                        Servers need to log binary logs that are applied through
                        the replication applier. Servers in the group need to log
                        all transactions that they receive and apply from the
                        group. This is required because recovery is conducted by
                        relying on binary logs form participants in the group.
                        Therefore, copies of each transaction need to exist on
                        every server, even for those transactions that were not
                        initiated on the server itself.
                    </p><p style="color:blue;">记录从机更新。set—记录从更新。服务器需要记录通过复制应用程序应用的二进制日志。组中的服务器需要记录从组接收和应用的所有事务。这是必需的，因为恢复是通过依赖组中参与者的二进制日志进行的。因此，每个事务的副本都需要存在于每个服务器上，甚至对于服务器本身未启动的事务也是如此。</p></li><li class="listitem"><p><b>Binary Log Row Format.&nbsp;</b>
                        Set <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">--binlog-format=row</code></a>.
                        Group Replication relies on row-based replication format
                        to propagate changes consistently among the servers in the
                        group. It relies on row-based infrastructure to be able to
                        extract the necessary information to detect conflicts
                        among transactions that execute concurrently in different
                        servers in the group. See
                        <a class="xref" href="replication.html#replication-formats" title="16.2.1&nbsp;Replication Formats">Section&nbsp;16.2.1, “Replication Formats”</a>.
                    </p><p style="color:blue;">二进制日志行格式。set--binlog format=row。组复制依赖于基于行的复制格式在组中的服务器之间一致地传播更改。它依赖于基于行的基础设施来提取必要的信息，以检测在组中不同服务器上并发执行的事务之间的冲突。见第16.2.1节“复制格式”。</p></li><li class="listitem"><p><b>Binary Log Checksums Off.&nbsp;</b>
                        Set
                        <a class="link" href="replication.html#sysvar_binlog_checksum"><code class="literal">--binlog-checksum=NONE</code></a>.
                        Due to a design limitation of replication event checksums,
                        Group Replication cannot make use of them, and they must
                        be disabled.
                    </p><p style="color:blue;">二进制日志校验和关闭。set--binlog checksum=none。由于复制事件校验和的设计限制，组复制无法使用它们，必须禁用它们。</p></li><li class="listitem"><p><b>Global Transaction Identifiers On.&nbsp;</b>
                        Set <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>. Group
                        Replication uses global transaction identifiers to track
                        exactly which transactions have been committed on every
                        server instance and thus be able to infer which servers
                        have executed transactions that could conflict with
                        already committed transactions elsewhere. In other words,
                        explicit transaction identifiers are a fundamental part of
                        the framework to be able to determine which transactions
                        may conflict. See <a class="xref" href="replication.html#replication-gtids" title="16.1.3&nbsp;Replication with Global Transaction Identifiers">Section&nbsp;16.1.3, “Replication with Global Transaction Identifiers”</a>.
                    </p><p style="color:blue;">上的全局事务标识符。设置gtid_mode=on。组复制使用全局事务标识符精确跟踪每个服务器实例上已提交的事务，从而能够推断哪些服务器已执行可能与其他已提交事务冲突的事务。换句话说，显式事务标识符是框架的一个基本部分，可以确定哪些事务可能发生冲突。请参阅第16.1.3节“使用全局事务标识符复制”。</p></li><li class="listitem"><p><b>Replication Information Repositories.&nbsp;</b>
                        Set
                        <a class="link" href="replication.html#sysvar_master_info_repository"><code class="literal">--master-info-repository=TABLE</code></a>
                        and
                        <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">--relay-log-info-repository=TABLE</code></a>.
                        The replication applier needs to have the master
                        information and relay log metadata written to the
                        <code class="literal">mysql.slave_master_info</code> and
                        <code class="literal">mysql.slave_relay_log_info</code> system
                        tables. This ensures the Group Replication plugin has
                        consistent recoverability and transactional management of
                        the replication metadata. See
                        <a class="xref" href="replication.html#slave-logs-status" title="16.2.4.2&nbsp;Slave Status Logs">Section&nbsp;16.2.4.2, “Slave Status Logs”</a>.
                    </p><p style="color:blue;">复制信息存储库。设置--master info repository=table和--relay log info repository=table。复制应用程序需要将主信息和中继日志元数据写入mysql.slave_master_info和mysql.slave_relay_log_info系统表。这确保了组复制插件对复制元数据具有一致的可恢复性和事务管理。见第16.2.4.2节“从机状态日志”。</p></li><li class="listitem"><p><b>Transaction Write Set Extraction.&nbsp;</b>
                        Set
                        <a class="link" href="replication.html#sysvar_transaction_write_set_extraction"><code class="literal">--transaction-write-set-extraction=XXHASH64</code></a>
                        so that while collecting rows to log them to the binary
                        log, the server collects the write set as well. The write
                        set is based on the primary keys of each row and is a
                        simplified and compact view of a tag that uniquely
                        identifies the row that was changed. This tag is then used
                        for detecting conflicts.
                    </p><p style="color:blue;">事务写入集提取。set--transaction write set extraction=xxhash64，这样在收集行以将它们记录到二进制日志时，服务器也会收集写集。写集基于每一行的主键，是一个简单紧凑的标记视图，它唯一地标识了更改的行。然后使用此标记检测冲突。</p></li><li class="listitem"><p><b>Lower Case Table Names.&nbsp;</b>
                        Set
                        <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">--lower-case-table-names</code></a>
                        to the same value on all group members. A setting of 1 is
                        correct for the use of the
                        <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> storage engine, which
                        is required for Group Replication. Note that this setting
                        is not the default on all platforms.
                    </p><p style="color:blue;">小写表名。在所有组成员上将小写表名设置为相同的值。对于使用innodb存储引擎，设置1是正确的，这是组复制所必需的。请注意，此设置并非所有平台上的默认设置。</p></li><li class="listitem"><p><b>Multithreaded Appliers.&nbsp;</b>
                        Group Replication members can be configured as
                        multithreaded appliers, enabling transactions to be
                        applied in parallel. Set
                        <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">--slave-parallel-workers=N</code></a>
                        (where <code class="literal">N</code> is the number of parallel
                        applier threads),
                        <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">--slave-preserve-commit-order=1</code></a>,
                        and
                        <a class="link" href="replication.html#sysvar_slave_parallel_type"><code class="literal">--slave-parallel-type=LOGICAL_CLOCK</code></a>.
                        Setting
                        <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">--slave-parallel-workers=N</code></a>
                        enables the multithreaded applier on the member. Group
                        Replication relies on consistency mechanisms built around
                        the guarantee that all participating members receive and
                        apply committed transaction in the same order, so you must
                        also set
                        <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">--slave-preserve-commit-order=1</code></a>
                        to ensure that the final commit of parallel transactions
                        is in the same order as the original transactions.
                        Finally, in order to determine which transactions can be
                        executed in parallel, the relay log must contain
                        transaction parent information generated with
                        <a class="link" href="replication.html#sysvar_slave_parallel_type"><code class="literal">--slave-parallel-type=LOGICAL_CLOCK</code></a>.
                        Attempting to add a member with
                        <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">--slave-parallel-workers</code></a>
                        set to greater than 0 without also setting the other two
                        options, generates an error and the instance is prevented
                        from joining.
                    </p><p style="color:blue;">多线程应用程序。组复制成员可以配置为多线程应用程序，从而使事务能够并行应用。set--slave parallel workers=n（其中n是并行applier线程数），--slave preserve commit order=1，和--slave parallel type=logical_clock。设置--slave parallel workers=n启用成员上的多线程应用程序。组复制依赖于围绕确保所有参与成员以相同顺序接收和应用提交的事务而构建的一致性机制，因此还必须设置--slave preserve commit order=1，以确保并行事务的最终提交与原始事务的顺序相同。最后，为了确定哪些事务可以并行执行，中继日志必须包含用--slave parallel type=logical_clock生成的事务父信息。如果尝试添加一个成员，而将--slave parallel workers设置为大于0，而不同时设置其他两个选项，则会生成一个错误并阻止该实例加入。</p></li></ul>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-limitations"></a>17.7.2&nbsp;Group Replication Limitations</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286788450528"></a><p>
            The following known limitations exist for Group Replication. Note
            that the limitations and issues described for multi-primary mode
            groups can also apply in single-primary mode clusters during a
            failover event, while the newly elected primary flushes out its
            applier queue from the old primary.
        </p><p style="color:blue;">群组复制存在以下已知限制。请注意，在故障转移事件期间，为多主模式组描述的限制和问题也可以应用于单主模式群集，而新选择的主模式会从旧主模式中清除其applier队列。</p>
            <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Tip
                </div>
                <p>
                    Group Replication is built on GTID based replication, therefore
                    you should also be aware of
                    <a class="xref" href="replication.html#replication-gtids-restrictions" title="16.1.3.6&nbsp;Restrictions on Replication with GTIDs">Section&nbsp;16.1.3.6, “Restrictions on Replication with GTIDs”</a>.
                </p><p style="color:blue;">组复制是建立在基于gtid的复制之上的，因此您还应该注意16.1.3.6节，“使用gtid复制的限制”。</p>
            </div>
            <div class="itemizedlist">
                <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Gap Locks.&nbsp;</b>
                    The certification process does not take into account
                    <a class="link" href="glossary.html#glos_gap_lock" title="gap lock">gap locks</a>, as
                    information about gap locks is not available outside of
                    <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;14&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>. See
                    <a class="xref" href="innodb-storage-engine.html#innodb-gap-locks" title="Gap Locks">Gap Locks</a> for more information.
                </p><p style="color:blue;">间隙锁。认证过程没有考虑间隙锁，因为在innodb之外没有间隙锁的信息。有关详细信息，请参见间隙锁。</p>
                    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                        <div class="admon-title">
                            Note
                        </div>
                        <p>
                            Unless you rely on <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE
                            READ</code></a> semantics in your applications, we recommend
                            using the <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>
                            isolation level with Group Replication. InnoDB does not use
                            gap locks in <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ
                            COMMITTED</code></a>, which aligns the local conflict
                            detection within InnoDB with the distributed conflict
                            detection performed by Group Replication.
                        </p><p style="color:blue;">除非您在应用程序中依赖可重复的读取语义，否则我们建议对组复制使用读取提交隔离级别。innodb在read committed中不使用间隙锁，它将innodb中的本地冲突检测与组复制执行的分布式冲突检测对齐。</p>
                    </div>
                </li><li class="listitem"><p><b>Table Locks and Named Locks.&nbsp;</b>
                    The certification process does not take into account table
                    locks (see <a class="xref" href="sql-syntax.html#lock-tables" title="13.3.5&nbsp;LOCK TABLES and UNLOCK TABLES Syntax">Section&nbsp;13.3.5, “LOCK TABLES and UNLOCK TABLES Syntax”</a>) or named locks
                    (see <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a>).
                </p><p style="color:blue;">表锁和命名锁。认证过程不考虑表锁（参见第13.3.5节“锁定表和解锁表语法”）或命名锁（参见get_lock（））。</p></li><li class="listitem"><p><b>Replication Event Checksums.&nbsp;</b>
                    Due to a design limitation of replication event checksums,
                    Group Replication cannot currently make use of them.
                    Therefore set
                    <a class="link" href="replication.html#sysvar_binlog_checksum"><code class="literal">--binlog-checksum=NONE</code></a>.
                </p><p style="color:blue;">复制事件校验和。由于复制事件校验和的设计限制，组复制当前无法使用它们。因此设置--binlog checksum=none。</p></li><li class="listitem"><p><b>SERIALIZABLE Isolation Level.&nbsp;</b>
                    <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a> isolation
                    level is not supported in multi-primary groups by default.
                    Setting a transaction isolation level to
                    <code class="literal">SERIALIZABLE</code> configures Group Replication
                    to refuse to commit the transaction.
                </p><p style="color:blue;">可序列化隔离级别。默认情况下，多个主组中不支持可序列化隔离级别。将事务隔离级别设置为可序列化可将组复制配置为拒绝提交事务。</p></li><li class="listitem"><p><b>Concurrent DDL versus DML Operations.&nbsp;</b>
                    Concurrent data definition statements and data manipulation
                    statements executing against the same object but on
                    different servers is not supported when using multi-primary
                    mode. During execution of Data Definition Language (DDL)
                    statements on an object, executing concurrent Data
                    Manipulation Language (DML) on the same object but on a
                    different server instance has the risk of conflicting DDL
                    executing on different instances not being detected.
                </p><p style="color:blue;">并发ddl与dml操作。使用多主模式时，不支持对同一对象但在不同服务器上执行的并发数据定义语句和数据操作语句。在对象上执行数据定义语言（DDL）语句期间，在同一对象上但在不同服务器实例上执行并发数据操作语言（DML）有在未检测到的不同实例上执行冲突DDL的风险。</p></li><li class="listitem"><p><b>Foreign Keys with Cascading Constraints.&nbsp;</b>
                    Multi-primary mode groups (members all configured with
                    <a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode"><code class="literal">group_replication_single_primary_mode=OFF</code></a>)
                    do not support tables with multi-level foreign key
                    dependencies, specifically tables that have defined
                    <code class="literal">CASCADING</code>
                    <a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY constraint"> foreign key
                        constraints</a>. This is because foreign key constraints
                    that result in cascading operations executed by a
                    multi-primary mode group can result in undetected conflicts
                    and lead to inconsistent data across the members of the
                    group. Therefore we recommend setting
                    <a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks"><code class="literal">group_replication_enforce_update_everywhere_checks=ON</code></a>
                    on server instances used in multi-primary mode groups to
                    avoid undetected conflicts.
                </p><p style="color:blue;">具有级联约束的外键。多主模式组（所有成员都配置为group_replication_single_primary_mode=off）不支持具有多级外键依赖关系的表，特别是定义了级联外键约束的表。这是因为导致多主模式组执行级联操作的外键约束可能导致未检测到的冲突，并导致组成员之间的数据不一致。因此，我们建议在多主模式组中使用的服务器实例上设置group_replication_enforce_update_everywhere_checks=on，以避免未检测到的冲突。</p><p>
                    In single-primary mode this is not a problem as it does not
                    allow concurrent writes to multiple members of the group and
                    thus there is no risk of undetected conflicts.
                </p><p style="color:blue;">在单主模式下，这不是问题，因为它不允许对组的多个成员进行并发写入，因此不存在未检测到冲突的风险。</p></li><li class="listitem"><p><b>MySQL Enterprise Audit and MySQL Enterprise Firewall.&nbsp;</b>
                    Prior to version 5.7.21 MySQL Enterprise Audit and MySQL Enterprise Firewall use
                    <code class="literal">MyISAM</code> tables in the
                    <code class="literal">mysql</code> system database. Group Replication
                    does not support <code class="literal">MyISAM</code> tables.


                </p><p style="color:blue;">mysql企业审计和mysql企业防火墙。在版本5.7.21之前，mysql企业审计和mysql企业防火墙使用mysql系统数据库中的myisam表。组复制不支持myisam表。</p><a class="indexterm" name="idm140286788412960"></a><a class="indexterm" name="idm140286788411472"></a></li><li class="listitem"><p><b>Multi-primary Mode Deadlock.&nbsp;</b>
                    When a group is operating in multi-primary mode,
                    <code class="literal">SELECT .. FOR UPDATE</code> statements can
                    result in a deadlock. This is because the lock is not shared
                    across the members of the group, therefore the expectation
                    for such a statement might not be reached.
                </p><p style="color:blue;">多主模式死锁。当组在多主模式下运行时，选择..for update语句可能导致死锁。这是因为锁不是在组成员之间共享的，因此可能无法达到对这样一个语句的期望。</p></li><li class="listitem"><p><b>Replication Filters.&nbsp;</b>
                    Replication filters cannot be used on a MySQL server
                    instance that is configured for Group Replication, because
                    filtering transactions on some servers would make the group
                    unable to reach agreement on a consistent state.
                </p><p style="color:blue;">复制筛选器。无法在为组复制配置的MySQL服务器实例上使用复制筛选器，因为在某些服务器上筛选事务将使组无法就一致状态达成一致。</p></li></ul>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="idm140286788405248"></a>Limit on Group Size</h4>

                        </div>

                    </div>

                </div>
                <p>
                    The maximum number of MySQL servers that can be members of a
                    single replication group is 9. If further members attempt to
                    join the group, their request is refused. This limit has been
                    identified from testing and benchmarking as a safe boundary
                    where the group performs reliably on a stable local area
                    network.
                </p><p style="color:blue;">可以是单个复制组成员的MySQL服务器的最大数量是9。如果其他成员试图加入该组，则拒绝他们的请求。这一限制已从测试和基准测试中确定为集团在稳定局域网上可靠运行的安全边界。</p>
            </div>
            <div class="simplesect">
                <div class="titlepage">
                    <div>
                        <div class="simple">
                            <h4 class="title"><a name="idm140286788403376"></a>Limits on Transaction Size</h4>

                        </div>

                    </div>

                </div>
                <p>
                    If an individual transaction results in message contents which
                    are large enough that the message cannot be copied between group
                    members over the network within a 5-second window, members can
                    be suspected of having failed, and then expelled, just because
                    they are busy processing the transaction. Large transactions can
                    also cause the system to slow due to problems with memory
                    allocation. To avoid these issues use the following mitigations:
                </p><p style="color:blue;">如果单个事务导致消息内容足够大，以至于无法在5秒钟的时间内通过网络在组成员之间复制该消息，则可能怀疑成员失败，然后仅因为他们正忙于处理该事务而被驱逐。由于内存分配问题，大型事务也会导致系统运行缓慢。要避免这些问题，请使用以下缓解措施：</p>
                <div class="itemizedlist">
                    <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Where possible, try and limit the size of your transactions.
                        For example, split up files used with <code class="literal">LOAD
                        DATA</code> into smaller chunks.
                    </p><p style="color:blue;">在可能的情况下，尽量限制交易的规模。例如，将用于加载数据的文件拆分为较小的块。</p></li><li class="listitem"><p>
                        Use the system variable
                        <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
                        to specify a maximum transaction size that the group will
                        accept. In MySQL 5.7, this system variable defaults to zero,
                        but in MySQL 8.0, it defaults to a maximum transaction size
                        of 150000000 bytes (approximately 143 MB). Transactions
                        above this limit are rolled back and are not sent to Group
                        Replication's Group Communication System (GCS) for
                        distribution to the group. Adjust the value of this variable
                        depending on the maximum message size that you need the
                        group to tolerate, bearing in mind that the time taken to
                        process a transaction is proportional to its size.
                    </p><p style="color:blue;">使用系统变量GROP.PrimeCudioTraceActhOnsiZyLimax来指定组将接受的最大事务大小。在MySQL 5.7中，这个系统变量默认为零，但是在MySQL 8中，它默认为最大事务大小为150000000字节（约143 MB）。超过此限制的事务将回滚，并且不会发送到组复制的组通信系统（GCS）以分发到组。根据您需要组容忍的最大消息大小来调整此变量的值，记住处理事务所花费的时间与它的大小成比例。</p></li><li class="listitem"><p>
                        Use the system variable
                        <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
                        to specify a message size above which compression is
                        applied. This system variable defaults to 1000000 bytes (1
                        MB), so large messages are automatically compressed.
                        Compression is carried out by Group Replication's Group
                        Communication System (GCS) when it receives a message that
                        was permitted by the
                        <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
                        setting but exceeds the
                        <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
                        setting. If you set the system variable value to zero,
                        compression is deactivated. For more information, see
                        <a class="xref" href="group-replication.html#group-replication-message-compression" title="17.9.7.2&nbsp;Message Compression">Section&nbsp;17.9.7.2, “Message Compression”</a>.
                    </p><p style="color:blue;">使用系统变量group_replication_compression_threshold指定应用压缩的消息大小。此系统变量默认为1000000字节（1 MB），因此会自动压缩大消息。当组复制的组通信系统（GCS）接收到组复制事务大小限制设置允许但超过组复制压缩阈值设置的消息时，将执行压缩。如果将系统变量值设置为零，则会停用压缩。有关更多信息，请参见第17.9.7.2节“消息压缩”。</p></li></ul>
                </div>
                <p>
                    If you have deactivated message compression and do not specify a
                    maximum transaction size, the upper size limit for a message
                    that can be handled by the applier thread on a member of a
                    replication group is the value of the member's
                    <a class="link" href="replication.html#sysvar_slave_max_allowed_packet"><code class="literal">slave_max_allowed_packet</code></a> system
                    variable, which has a default and maximum value of 1073741824
                    bytes (1 GB). A message that exceeds this limit fails when the
                    receiving member attempts to handle it. The upper size limit for
                    a message that a group member can originate and attempt to
                    transmit to the group is 4294967295 bytes (approximately 4 GB).
                    This is a hard limit on the packet size that is accepted by the
                    group communication engine for Group Replication (XCom, a Paxos
                    variant), which receives messages after GCS has handled them. A
                    message that exceeds this limit fails when the originating
                    member attempts to broadcast it.
                </p><p style="color:blue;">如果已停用消息压缩且未指定最大事务大小，则可由复制组成员上的应用程序线程处理的消息的上限大小限制为成员的SavaveMax允许1073741824字节分组系统变量，其默认值和最大值为1字节（字节）。超过此限制的消息在接收成员尝试处理时失败。群组成员可以发起和尝试发送给组的消息的上限大小为4294967295字节（约4 GB）。这是对组复制的组通信引擎（xcom，paxos变体）接受的数据包大小的硬限制，该引擎在gcs处理消息后接收消息。超过此限制的消息在原始成员尝试广播时失败。</p>
            </div>

        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="group-replication-frequently-asked-questions"></a>17.8&nbsp;Frequently Asked Questions</h2>

                </div>

            </div>

        </div>
        <a class="indexterm" name="idm140286788385456"></a><p>
        This section provides answers to frequently asked questions.
    </p><p style="color:blue;">本节提供常见问题的答案。</p>
        <div class="simplesect">

            <div class="titlepage">
                <div>

                    <div class="simple">
                        <h3 class="title"><a name="group-replication-maximum-number-servers"></a>What is the maximum number of MySQL servers in a group?</h3>
                    </div>
                </div>
            </div>
            <p>
                A group can consist of maximum 9 servers. Attempting to add
                another server to a group with 9 members causes the request to
                join to be refused. This limit has been identified from testing
                and benchmarking as a safe boundary where the group performs
                reliably on a stable local area network.
            </p><p style="color:blue;">一个组可以由最多9个服务器组成。尝试将其他服务器添加到包含9个成员的组中会导致请求加入被拒绝。这一限制已从测试和基准测试中确定为集团在稳定局域网上可靠运行的安全边界。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-servers-in-a-group-connected"></a>How are servers in a group connected?</h3>

                    </div>

                </div>

            </div>
            <p>
                Servers in a group connect to the other servers in the group by
                opening a peer-to-peer TCP connection. These connections are only
                used for internal communication and message passing between
                servers in the group. This address is configured by the
                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                variable.
            </p><p style="color:blue;">组中的服务器通过打开对等TCP连接连接到组中的其他服务器。这些连接仅用于组中服务器之间的内部通信和消息传递。此地址由GROUP U REPLICATION U本地U地址变量配置。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-what-is-the-group-replication-bootstrap-group-option-used-for"></a>What is the group_replication_bootstrap_group option used for?</h3>

                    </div>

                </div>

            </div>
            <p>
                The bootstrap flag instructs a member to
                <span class="emphasis"><em>create</em></span> a group and act as the initial seed
                server. The second member joining the group needs to ask the
                member that bootstrapped the group to dynamically change the
                configuration in order for it to be added to the group.
            </p><p style="color:blue;">引导标志指示成员创建组并充当初始种子服务器。加入组的第二个成员需要要求启动组的成员动态更改配置，以便将其添加到组中。</p><p>
            A member needs to bootstrap the group in two scenarios. When the
            group is originally created, or when shutting down and restarting
            the entire group.
        </p><p style="color:blue;">成员需要在两种情况下引导组。最初创建组时，或关闭并重新启动整个组时。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-credentials-for-recovery"></a>How do I set credentials for the recovery procedure?</h3>

                    </div>

                </div>

            </div>
            <p>
                You pre-configure the Group Replication recovery channel
                credentials using the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1&nbsp;CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
                TO</code></a> statement.
            </p><p style="color:blue;">您可以使用change master to语句预先配置组复制恢复通道凭据。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-scale-out-write-load"></a>Can I scale-out my write-load using Group Replication?</h3>

                    </div>

                </div>

            </div>
            <p>
                Not directly, but MySQL Group replication is a shared nothing full
                replication solution, where all servers in the group replicate the
                same amount of data. Therefore if one member in the group writes N
                bytes to storage as the result of a transaction commit operation,
                then roughly N bytes are written to storage on other members as
                well, because the transaction is replicated everywhere.
            </p><p style="color:blue;">不是直接的，但是mysql组复制是一个无共享的完整复制解决方案，其中组中的所有服务器复制相同数量的数据。因此，如果组中的一个成员作为事务提交操作的结果向存储写入n个字节，那么也会向其他成员上的存储写入大约n个字节，因为事务会在任何地方复制。</p><p>
            However, given that other members do not have to do the same
            amount of processing that the original member had to do when it
            originally executed the transaction, they apply the changes
            faster. Transactions are replicated in a format that is used to
            apply row transformations only, without having to re-execute
            transactions again (row-based format).
        </p><p style="color:blue;">但是，考虑到其他成员不必执行与原始成员最初执行事务时相同的处理量，因此它们可以更快地应用更改。事务以仅用于应用行转换的格式复制，而无需再次重新执行事务（基于行的格式）。</p><p>
            Furthermore, given that changes are propagated and applied in
            row-based format, this means that they are received in an
            optimized and compact format, and likely reducing the number of IO
            operations required when compared to the originating member.
        </p><p style="color:blue;">此外，考虑到更改是以基于行的格式传播和应用的，这意味着它们是以优化和紧凑的格式接收的，并且与原始成员相比可能减少所需的io操作的数量。</p><p>
            To summarize, you can scale-out processing, by spreading conflict
            free transactions throughout different members in the group. And
            you can likely scale-out a small fraction of your IO operations,
            since remote servers receive only the necessary changes to
            read-modify-write changes to stable storage.
        </p><p style="color:blue;">总而言之，您可以通过在组中的不同成员之间传播无冲突事务来扩展处理。而且，由于远程服务器只接收到对稳定存储的读修改写更改所必需的更改，因此您可能可以扩展一小部分IO操作。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-performance-compared"></a>Does Group Replication require more network bandwidth and CPU, when
                            compared to simple replication and under the same workload?</h3>
                    </div>
                </div>
            </div>
            <p>
                Some additional load is expected because servers need to be
                constantly interacting with each other for synchronization
                purposes. It is difficult to quantify how much more data. It also
                depends on the size of the group (three servers puts less stress
                on the bandwidth requirements than nine servers in the group).
            </p><p style="color:blue;">一些额外的负载是预期的，因为服务器需要不断地相互交互以达到同步的目的。很难量化还有多少数据。它还取决于组的大小（三台服务器比组中的九台服务器对带宽需求的压力更小）。</p><p>
            Also the memory and CPU footprint are larger, because more complex
            work is done for the server synchronization part and for the group
            messaging.
        </p><p style="color:blue;">此外，内存和cpu占用空间也更大，因为服务器同步部分和组消息传递要完成更复杂的工作。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-deploy-across-wide-area-network"></a>Can I deploy Group Replication across wide-area networks?</h3>

                    </div>

                </div>

            </div>
            <p>
                Yes, but the network connection between each member
                <span class="emphasis"><em>must</em></span> be reliable and have suitable
                perfomance. Low latency, high bandwidth network connections are a
                requirement for optimal performance.
            </p><p style="color:blue;">是的，但是每个成员之间的网络连接必须可靠并且具有适当的性能。低延迟、高带宽的网络连接是最佳性能的要求。</p><p>
            If network bandwidth alone is an issue, then
            <a class="xref" href="group-replication.html#group-replication-message-compression" title="17.9.7.2&nbsp;Message Compression">Section&nbsp;17.9.7.2, “Message Compression”</a> can be
            used to lower the bandwidth required. However, if the network
            drops packets, leading to re-transmissions and higher end-to-end
            latency, throughput and latency are both negatively affected.
        </p><p style="color:blue;">如果仅网络带宽是一个问题，那么可以使用第17.9.7.2节“消息压缩”来降低所需的带宽。但是，如果网络丢弃数据包，导致重新传输和更高的端到端延迟，则吞吐量和延迟都会受到负面影响。</p>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Warning
                </div>
                <p>
                    When the network round-trip time (RTT) between any group members
                    is 5 seconds or more you could encounter problems as the
                    built-in failure detection mechanism could be incorrectly
                    triggered.
                </p><p style="color:blue;">当任何组成员之间的网络往返时间（rtt）为5秒或更长时，您可能会遇到问题，因为内置的故障检测机制可能会被错误地触发。</p>
            </div>

        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-automatically-rejoin-temporary-problems"></a>Do members automatically rejoin a group in case of temporary
                            connectivity problems?</h3>
                    </div>
                </div>
            </div>
            <p>
                This depends on the reason for the connectivity problem. If the
                connectivity problem is transient and the reconnection is quick
                enough that the failure detector is not aware of it, then the
                server may not be removed from the group. If it is a
                "long" connectivity problem, then the failure detector
                eventually suspects a problem and the server is removed from the
                group.
            </p><p style="color:blue;">这取决于连接问题的原因。如果连接问题是暂时性的，并且重新连接的速度足够快，以至于故障检测器没有意识到它，则可能无法从组中删除服务器。如果这是一个“长”连接问题，那么故障检测器最终会怀疑一个问题，并将服务器从组中删除。</p><p>
            Once a server is removed from the group, you need to join it back
            again. In other words, after a server is removed explicitly from
            the group you need to rejoin it manually (or have a script doing
            it automatically).
        </p><p style="color:blue;">从组中删除服务器后，您需要重新将其加入。换句话说，在从组中显式地删除服务器之后，您需要手动重新加入它（或者让脚本自动执行）。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-member-excluded"></a>When is a member excluded from a group?</h3>

                    </div>

                </div>

            </div>
            <p>
                If the member becomes silent, the other members remove it from the
                group configuration. In practice this may happen when the member
                has crashed or there is a network disconnection.
            </p><p style="color:blue;">如果成员变为静默状态，则其他成员会将其从组配置中移除。实际上，当成员崩溃或网络断开连接时，可能会发生这种情况。</p><p>
            The failure is detected after a given timeout elapses for a given
            member and a new configuration without the silent member in it is
            created.
        </p><p style="color:blue;">在给定成员的给定超时时间过后检测到故障，并创建不包含静默成员的新配置。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-node-lag"></a>What happens when one node is significantly lagging behind?</h3>

                    </div>

                </div>

            </div>
            <p>
                There is no method for defining policies for when to expel members
                automatically from the group. You need to find out why a member is
                lagging behind and fix that or remove the member from the group.
                Otherwise, if the server is so slow that it triggers the flow
                control, then the entire group slows down as well. The flow
                control can be configured according to the your needs.
            </p><p style="color:blue;">没有定义何时自动从组中驱逐成员的策略的方法。您需要找出某个成员落后的原因，并修复该问题或将该成员从组中移除。否则，如果服务器速度太慢以至于触发了流控制，那么整个组的速度也会减慢。流量控制可以根据您的需要进行配置。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-member-responsible-reconfiguration"></a>Upon suspicion of a problem in the group, is there a special member
                            responsible for triggering a reconfiguration?</h3>
                    </div>
                </div>
            </div>
            <p>
                No, there is no special member in the group in charge of
                triggering a reconfiguration.
            </p><p style="color:blue;">不，组中没有负责触发重新配置的特殊成员。</p><p>
            Any member can suspect that there is a problem. All members need
            to (automatically) agree that a given member has failed. One
            member is in charge of expelling it from the group, by triggering
            a reconfiguration. Which member is responsible for expelling the
            member is not something you can control or set.
        </p><p style="color:blue;">任何成员都可能怀疑存在问题。所有成员必须（自动）同意给定成员失败。一个成员负责通过触发重新配置将其从组中排除。哪个成员负责驱逐该成员不是你可以控制或设置的。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-provide-sharding"></a>Can I use Group Replication for sharding?</h3>

                    </div>

                </div>

            </div>
            <p>
                Group Replication is designed to provide highly available replica
                sets; data and writes are duplicated on each member in the group.
                For scaling beyond what a single system can provide, you need an
                orchestration and sharding framework built around a number of
                Group Replication sets, where each replica set maintains and
                manages a given shard or partition of your total dataset. This
                type of setup, often called a <span class="quote">“<span class="quote">sharded cluster</span>”</span>,
                allows you to scale reads and writes linearly and without limit.
            </p><p style="color:blue;">组复制旨在提供高可用的副本集；数据和写入在组中的每个成员上重复。为了扩展到单个系统所能提供的范围之外，您需要一个围绕多个组复制集构建的编排和分片框架，其中每个复制集维护和管理总数据集的给定分片或分区。这种类型的设置，通常称为“分片集群”，允许您无限制地线性缩放读写。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-using-selinux"></a>How do I use Group Replication with SELinux?</h3>

                    </div>

                </div>

            </div>
            <p>
                If SELinux is enabled, which you can verify using
                <span class="command"><strong>sestatus -v</strong></span>, then you need to enable the use of
                the Group Replication communication port, configured by
                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>,
                for <a class="link" href="programs.html#mysqld" title="4.3.1&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> so that it can bind to it and listen
                there. To see which ports MySQL is currently allowed to use, issue
                <span class="command"><strong>semanage port -l | grep mysqld</strong></span>. Assuming the
                port configured is 33061, add the necessary port to those
                permitted by SELinux by issuing <span class="command"><strong>semanage port -a -t
      mysqld_port_t -p tcp 33061</strong></span>.
            </p><p style="color:blue;">如果启用了selinux，您可以使用sestatus-v验证它，那么您需要为mysqld启用组复制通信端口（由组复制本地地址配置），以便它可以绑定到该端口并在那里侦听。要查看mysql当前允许使用哪些端口，请发出semanage port-l grep mysqld。假设配置的端口是33061，那么通过发出semanage port-a-t mysqld_port_t-p tcp 33061将必要的端口添加到selinux允许的端口。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-using-iptables"></a>How do I use Group Replication with iptables?</h3>

                    </div>

                </div>

            </div>
            <p>
                If <span class="command"><strong>iptables</strong></span> is enabled, then you need to open
                up the Group Replication port for communication between the
                machines. To see the current rules in place on each machine, issue
                <span class="command"><strong>iptables -L</strong></span>. Assuming the port configured is
                33061, enable communication over the necessary port by issuing
                <span class="command"><strong>iptables -A INPUT -p tcp --dport 33061 -j
      ACCEPT</strong></span>.
            </p><p style="color:blue;">如果启用了iptables，则需要打开组复制端口以在计算机之间进行通信。要查看每台计算机上的当前规则，请发出iptables-l。假设配置的端口为33061，则通过发出iptables-a input-p tcp--dport 33061-j accept启用必要端口上的通信。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-recover-relay-log"></a>How do I recover the relay log for a replication channel used by a group
                            member?</h3>
                    </div>
                </div>
            </div>
            <p>
                The replication channels used by Group Replication behave in the
                same way as replication channels used in master to slave
                replication, and as such rely on the relay log. In the event of a
                change of the <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> variable,
                or when the option is not set and the host name changes, there is
                a chance of errors. See <a class="xref" href="replication.html#slave-logs-relaylog" title="16.2.4.1&nbsp;The Slave Relay Log">Section&nbsp;16.2.4.1, “The Slave Relay Log”</a> for
                a recovery procedure in this situation. Alternatively, another way
                of fixing the issue specifically in Group Replication is to issue
                a <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2&nbsp;STOP GROUP_REPLICATION Syntax"><code class="literal">STOP GROUP_REPLICATION</code></a> statement
                and then a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1&nbsp;START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a>
                statement to restart the instance. The Group Replication plugin
                creates the <code class="literal">group_replication_applier</code> channel
                again.
            </p><p style="color:blue;">组复制使用的复制通道的行为与主-从复制中使用的复制通道的行为相同，因此依赖于中继日志。如果中继日志变量发生更改，或者未设置该选项并且主机名发生更改，则可能会出现错误。有关这种情况下的恢复过程，请参见第16.2.4.1节“从继电器日志”。或者，另一种在群组复制中专门解决问题的方法是发出停止群组复制语句，然后启动GROUP GROPYPROMENT语句重新启动实例。组复制插件再次创建组复制应用程序通道。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-two-bind-addresses"></a>Why does Group Replication use two bind addresses?</h3>

                    </div>

                </div>

            </div>
            <p>
                Group Replication uses two bind addresses in order to split
                network traffic between the SQL address, used by clients to
                communicate with the member, and the
                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>,
                used internally by the group members to communicate. For example,
                assume a server with two network interfaces assigned to the
                network addresses <code class="literal">203.0.113.1</code> and
                <code class="literal">198.51.100.179</code>. In such a situation you could
                use <code class="literal">203.0.113.1:33061</code> for the internal group
                network address by setting
                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address=203.0.113.1:33061</code></a>.
                Then you could use <code class="literal">198.51.100.179</code> for
                <a class="link" href="server-administration.html#sysvar_hostname"><code class="literal">hostname</code></a> and
                <code class="literal">3306</code> for the
                <a class="link" href="server-administration.html#sysvar_port"><code class="literal">port</code></a>. Client SQL applications
                would then connect to the member at
                <code class="literal">198.51.100.179:3306</code>. This enables you to
                configure different rules on the different networks. Similarly,
                the internal group communication can be separated from the network
                connection used for client applications, for increased security.
            </p><p style="color:blue;">组复制使用两个绑定地址，以便在客户端用于与成员通信的SQL地址和组成员内部用于通信的组复制本地地址之间分割网络通信。例如，假设服务器具有分配给网络地址203.0.113.1和198.51.100.179的两个网络接口。在这种情况下，可以通过设置group_replication_local_address=203.0.113.1:33061来使用203.0.113.1:33061作为内部组网络地址。然后可以使用198.51.100.179作为主机名，使用3306作为端口。客户端SQL应用程序将在198.51.100.179:3306连接到该成员。这使您能够在不同的网络上配置不同的规则。类似地，内部组通信可以与用于客户端应用程序的网络连接分离，以提高安全性。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-hostnames"></a>How does Group Replication use network addresses and hostnames?</h3>

                    </div>

                </div>

            </div>
            <p>
                Group Replication uses network connections between members and
                therefore its functionality is directly impacted by how you
                configure hostnames and ports. For example, the Group Replication
                recovery procedure is based on asynchronous replication which uses
                the server's hostname and port. When a member joins a group it
                receives the group membership information, using the network
                address information that is listed at
                <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7&nbsp;The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>.
                One of the members listed in that table is selected as the donor
                of the missing data from the group to the new member.
            </p><p style="color:blue;">组复制使用成员之间的网络连接，因此其功能直接受配置主机名和端口的方式影响。例如，组复制恢复过程基于使用服务器主机名和端口的异步复制。当一个成员加入一个组时，它将使用performance_schema.replication_group_members中列出的网络地址信息接收组成员身份信息。该表中列出的一个成员将被选为组中丢失数据的捐赠者。</p><p>
            This means that any value you configure using a hostname, such as
            the SQL network address or the group seeds address, must be a
            fully qualified name and resolvable by each member of the group.
            You can ensure this for example through DNS, or correctly
            configured <code class="filename">/etc/hosts</code> files, or other local
            processes. If a you want to configure the
            <code class="literal">MEMBER_HOST</code> value on a server, specify it using
            the <a class="link" href="replication.html#sysvar_report_host"><code class="option">--report-host</code></a> option on the
            server before joining it to the group.
        </p><p style="color:blue;">这意味着，使用主机名配置的任何值（如SQL网络地址或组种子地址）都必须是完全限定的名称，并且可以由组的每个成员解析。例如，您可以通过dns、正确配置的/etc/hosts文件或其他本地进程来确保这一点。如果要在服务器上配置成员主机值，请在将其加入组之前使用服务器上的--report host选项指定该值。</p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Important
                </div>
                <p>
                    The assigned value is used directly and is not affected by the
                    <a class="link" href="server-administration.html#option_mysqld_skip-name-resolve"><code class="option">--skip-name-resolve</code></a> option.
                </p><p style="color:blue;">赋值是直接使用的，不受--skip name resolve选项的影响。</p>
            </div>
            <p>
                To configure <code class="literal">MEMBER_PORT</code> on a server, specify
                it using the <a class="link" href="replication.html#sysvar_report_port"><code class="option">--report-port</code></a> option.
            </p><p style="color:blue;">要在服务器上配置成员端口，请使用--report port选项指定它。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-auto-increment-increment"></a>Why did the auto increment setting on the server change?</h3>

                    </div>

                </div>

            </div>
            <p>
                When Group Replication is started on a server, the value of
                <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> is
                changed to the value of
                <a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment"><code class="literal">group_replication_auto_increment_increment</code></a>,
                which defaults to 7, and the value of
                <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a> is changed
                to the server ID. The changes are reverted when Group Replication
                is stopped. These settings avoid the selection of duplicate
                auto-increment values for writes on group members, which causes
                rollback of transactions. The default auto increment value of 7
                for Group Replication represents a balance between the number of
                usable values and the permitted maximum size of a replication
                group (9 members).
            </p><p style="color:blue;">在服务器上启动组复制时，自动增量值更改为组复制增量值（默认为7），自动增量偏移值更改为服务器ID。当组复制停止时，更改将还原。这些设置避免为组成员上的写入选择重复的自动增量值，这会导致事务回滚。组复制的默认自动增量值7表示可用值的数量与复制组（9个成员）的允许最大大小之间的平衡。</p><p>
            The changes are only made and reverted if
            <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> and
            <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a> each have
            their default value of 1. If their values have already been
            modified from the default, Group Replication does not alter them.
        </p><p style="color:blue;">仅当“自动增量”和“自动增量偏移”的默认值均为1时，才会进行和还原更改。如果已从默认值修改了它们的值，则组复制不会更改它们。</p>
        </div>
        <div class="simplesect">
            <div class="titlepage">
                <div>
                    <div class="simple">
                        <h3 class="title"><a name="group-replication-how-to-find-primary"></a>How do I find the primary?</h3>

                    </div>

                </div>

            </div>
            <p>
                If the group is operating in single-primary mode, it can be useful
                to find out which member is the primary. See
                <a class="xref" href="group-replication.html#group-replication-find-primary" title="17.4.1.3&nbsp;Finding the Primary">Section&nbsp;17.4.1.3, “Finding the Primary”</a>
            </p><p style="color:blue;">如果组是在单主模式下运行的，则可以找出哪个成员是主成员。见第17.4.1.3节“寻找主要”</p>
        </div>

    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a name="group-replication-technical-details"></a>17.9&nbsp;Group Replication Technical Details</h2>

                </div>

            </div>

        </div>
        <div class="toc">
            <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-plugin-architecture">17.9.1 Group Replication Plugin Architecture</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-the-group">17.9.2 The Group</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-data-manipulation-statements">17.9.3 Data Manipulation Statements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-data-definition-statements">17.9.4 Data Definition Statements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery">17.9.5 Distributed Recovery</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-observability">17.9.6 Observability</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-performance">17.9.7 Group Replication Performance</a></span></dt></dl>
        </div>
        <a class="indexterm" name="idm140286788292720"></a><p>
        This section provides more technical details about MySQL Group
        Replication.
    </p><p style="color:blue;">本节提供有关mysql组复制的更多技术详细信息。</p>
        <div class="section">

            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-plugin-architecture"></a>17.9.1&nbsp;Group Replication Plugin Architecture</h3>
                    </div>
                </div>
            </div>
            <a class="indexterm" name="idm140286788289600"></a><a class="indexterm" name="idm140286788288112"></a><a class="indexterm" name="idm140286788286608"></a><p>
            MySQL Group Replication is a MySQL plugin and it builds on the
            existing MySQL replication infrastructure, taking advantage of
            features such as the binary log, row-based logging, and global
            transaction identifiers. It integrates with current MySQL
            frameworks, such as the performance schema or plugin and service
            infrastructures. The following figure presents a block diagram
            depicting the overall architecture of MySQL Group Replication.
        </p><p style="color:blue;">MySQL群组复制是MySQL插件，它基于现有的MySQL复制基础设施，利用诸如二进制日志、基于行的日志记录和全局事务标识符等特征。它与当前的mysql框架集成，例如性能模式或插件和服务基础架构。下图显示了描述mysql组复制总体架构的框图。</p>
            <div class="figure">
                <a name="idm140286788284240"></a><p class="title"><b>Figure&nbsp;17.9&nbsp;Group Replication Plugin Block Diagram</b></p><p style="color:blue;">图17.9组复制插件框图</p>
                <div class="figure-contents">

                    <div class="mediaobject">
                        <img src="images/gr-plugin-blocks.png" width="455" height="393" alt="The text following the figure describes the content of the diagram.">
                    </div>

                </div>

            </div>
            <br class="figure-break"><p>
            The MySQL Group Replication plugin includes a set of APIs for
            capture, apply, and lifecycle, which control how the plugin
            interacts with MySQL Server. There are interfaces to make
            information flow from the server to the plugin and vice versa.
            These interfaces isolate the MySQL Server core from the Group
            Replication plugin, and are mostly hooks placed in the transaction
            execution pipeline. In one direction, from server to the plugin,
            there are notifications for events such as the server starting,
            the server recovering, the server being ready to accept
            connections, and the server being about to commit a transaction.
            In the other direction, the plugin instructs the server to perform
            actions such as committing or aborting ongoing transactions, or
            queuing transactions in the relay log.
        </p><p style="color:blue;">mysql组复制插件包括一组用于捕获、应用和生命周期的api，这些api控制插件如何与mysql服务器交互。有接口使信息从服务器流向插件，反之亦然。这些接口将mysql服务器核心与组复制插件隔离开来，主要是放置在事务执行管道中的挂钩。在一个方向上，从服务器到插件，都有事件的通知，例如服务器启动、服务器恢复、服务器准备接受连接以及服务器即将提交事务。另一方面，插件指示服务器执行操作，例如提交或中止正在进行的事务，或在中继日志中对事务进行排队。</p><p>
            The next layer of the Group Replication plugin architecture is a
            set of components that react when a notification is routed to
            them. The capture component is responsible for keeping track of
            context related to transactions that are executing. The applier
            component is responsible for executing remote transactions on the
            database. The recovery component manages distributed recovery, and
            is responsible for getting a server that is joining the group up
            to date by selecting the donor, orchestrating the catch up
            procedure and reacting to donor failures.
        </p><p style="color:blue;">组复制插件体系结构的下一层是一组组件，当通知被路由到它们时，它们会做出反应。捕获组件负责跟踪与正在执行的事务相关的上下文。applier组件负责在数据库上执行远程事务。恢复组件管理分布式恢复，并负责通过选择捐赠者、协调追赶过程和对捐赠者失败作出反应，使加入组的服务器保持最新状态。</p><p>
            Continuing down the stack, the replication protocol module
            contains the specific logic of the replication protocol. It
            handles conflict detection, and receives and propagates
            transactions to the group.
        </p><p style="color:blue;">继续向下，复制协议模块包含复制协议的特定逻辑。它处理冲突检测，接收事务并将其传播到组。</p><p>
            The final two layers of the Group Replication plugin architecture
            are the Group Communication System (GCS) API, and an
            implementation of a Paxos-based group communication engine (XCom).
            The GCS API is a high level API that abstracts the properties
            required to build a replicated state machine (see
            <a class="xref" href="group-replication.html#group-replication-background" title="17.1&nbsp;Group Replication Background">Section&nbsp;17.1, “Group Replication Background”</a>). It therefore
            decouples the implementation of the messaging layer from the
            remaining upper layers of the plugin. The group communication
            engine handles communications with the members of the replication
            group.
        </p><p style="color:blue;">组复制插件体系结构的最后两层是组通信系统（gcs）api和基于paxos的组通信引擎（xcom）的实现。gcs api是一个高级api，它抽象了构建复制状态机所需的属性（请参阅17.1节，“组复制背景”）。因此，它将消息传递层的实现与插件的其余上层分离。组通信引擎处理与复制组成员的通信。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-the-group"></a>17.9.2&nbsp;The Group</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286788271664"></a><p>
            In MySQL Group Replication, a set of servers forms a replication
            group. A group has a name, which takes the form of a UUID. The
            group is dynamic and servers can leave (either voluntarily or
            involuntarily) and join it at any time. The group adjusts itself
            whenever servers join or leave.
        </p><p style="color:blue;">在mysql组复制中，一组服务器构成一个复制组。组有一个名称，其形式为uuid。该组是动态的，服务器可以随时离开（自愿或非自愿）并加入它。每当服务器加入或离开时，组会自动调整。</p><p>
            If a server joins the group, it automatically brings itself up to
            date by fetching the missing state from an existing server. This
            state is transferred by means of Asynchronous MySQL replication.
            If a server leaves the group, for instance it was taken down for
            maintenance, the remaining servers notice that it has left and
            reconfigure the group automatically. The group membership service
            described at <a class="xref" href="group-replication.html#group-replication-group-membership" title="17.1.3.1&nbsp;Group Membership">Section&nbsp;17.1.3.1, “Group Membership”</a>
            powers all of this.
        </p><p style="color:blue;">如果一个服务器加入了该组，它就可以通过从现有服务器中获取丢失的状态来自动更新自己。此状态通过异步mysql复制进行传输。如果某个服务器离开组（例如，它是为了维护而被取下的），则其余的服务器会注意到它已经离开并自动重新配置该组。第17.1.3.1节所述的集团成员服务，“集团成员”对所有这些都有权力。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-data-manipulation-statements"></a>17.9.3&nbsp;Data Manipulation Statements</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286788266432"></a><p>
            As there are no primary servers (masters) for any particular data
            set, every server in the group is allowed to execute transactions
            at any time, even transactions that change state (RW
            transactions).
        </p><p style="color:blue;">由于没有用于任何特定数据集的主服务器（master），因此允许组中的每个服务器在任何时候执行事务，甚至可以执行更改状态的事务（rw事务）。</p><p>
            Any server may execute a transaction without any <span class="emphasis"><em>a
      priori</em></span>



            coordination. But, at commit time, it coordinates with the rest of
            the servers in the group to reach a decision on the fate of that
            transaction. This coordination serves two purposes: (i) check
            whether the transaction should commit or not; (ii) and propagate
            the changes so that other servers can apply the transaction as
            well.
        </p><p style="color:blue;">任何服务器都可以在没有任何先验协调的情况下执行事务。但是，在提交时，它与组中的其他服务器进行协调，以对事务的命运做出决定。这种协调有两个目的：（i）检查事务是否应该提交；（ii）传播更改，以便其他服务器也可以应用该事务。</p><p>
            As a transaction is sent through an atomic broadcast, either all
            servers in the group receive the transaction or none do. If they
            receive it, then they all receive it in the same order with
            respect to other transactions that were sent before. Conflict
            detection is carried out by inspecting and comparing write sets of
            transactions. Thus, they are detected at the row level. Conflict
            resolution follows the first committer wins rule. If t1 and t2
            execute concurrently at different sites, because t2 is ordered
            before t1, and both changed the same row, then t2 wins the
            conflict and t1 aborts. In other words, t1 was trying to change
            data that had been rendered stale by t2.
        </p><p style="color:blue;">当事务通过原子广播发送时，组中的所有服务器要么接收事务，要么不接收。如果他们收到了，那么他们都会按照与之前发送的其他交易相同的顺序收到它。冲突检测是通过检查和比较事务的写入集来执行的。因此，在行级别检测它们。冲突解决遵循第一个提交者获胜规则。如果T1和T2在不同的站点并发执行，因为T2在T1之前排序，并且两者都更改了同一行，那么T2将赢得冲突，T1将中止。换言之，T1试图更改T2已过时的数据。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    If two transactions are bound to conflict more often than not,
                    then it is a good practice to start them on the same server.
                    They then have a chance to synchronize on the local lock manager
                    instead of aborting later in the replication protocol.
                </p><p style="color:blue;">如果两个事务经常会发生冲突，那么最好在同一台服务器上启动它们。然后，他们有机会在本地锁管理器上进行同步，而不是在以后的复制协议中中止。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-data-definition-statements"></a>17.9.4&nbsp;Data Definition Statements</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286788258752"></a><p>
            In a Group Replication topology, care needs to be taken when
            executing data definition statements also commonly known as data
            definition language (DDL). Given that MySQL does not support
            atomic or transactional DDL, one cannot optimistically execute DDL
            statements and later roll back if needs be. Consequently, the lack
            of atomicity does not fit directly into the optimistic replication
            paradigm that Group Replication is based on.
        </p><p style="color:blue;">在组复制拓扑中，执行数据定义语句（也称为数据定义语言（DDL））时需要小心。由于mysql不支持原子或事务ddl，因此不能乐观地执行ddl语句，如果需要，可以稍后回滚。因此，缺乏原子性并不能直接适应组复制所基于的乐观复制范式。</p><p>
            Therefore, more care needs to be taken when replicating data
            definition statements. Schema changes and changes to the data that
            the object contains need to be handled through the same server
            while the schema operation has not yet completed and replicated
            everywhere. Failure to do so can result in data inconsistency.
        </p><p style="color:blue;">因此，在复制数据定义语句时需要更加小心。架构更改和对象包含的数据更改需要通过同一服务器处理，而架构操作尚未完成并在所有位置复制。否则可能导致数据不一致。</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

                <div class="admon-title">
                    Note
                </div>
                <p>
                    If the group is deployed in single-primary mode, then this is
                    not a problem, because all changes are performed through the
                    same server, the primary.
                </p><p style="color:blue;">如果组是以单一主模式部署的，则这不是问题，因为所有更改都是通过同一服务器主服务器执行的。</p>
            </div>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                <div class="admon-title">
                    Warning
                </div>
                <p>
                    MySQL DDL execution is not atomic or transactional. The server
                    executes and commits without securing group agreement first. As
                    such, you must route DDL and DML for the same object through the
                    same server, while the DDL is executing and has not replicated
                    everywhere yet.
                </p><p style="color:blue;">mysql ddl执行不是原子的或事务性的。服务器在执行和提交时不首先保护组协议。因此，您必须通过同一服务器为同一对象路由ddl和dml，而ddl正在执行且尚未在任何地方复制。</p>
            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-distributed-recovery"></a>17.9.5&nbsp;Distributed Recovery</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery-basics">17.9.5.1 Distributed Recovery Basics</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-recovering-from-a-point-in-time">17.9.5.2 Recovering From a Point-in-time</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-view-changes">17.9.5.3 View Changes</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-usage-advice-and-limitations-of-distributed-recovery">17.9.5.4 Usage Advice and Limitations of Distributed Recovery</a></span></dt></dl>
            </div>
            <a class="indexterm" name="idm140286788252304"></a><p>
            This section describes the process through which a member joining
            a group catches up with the remaining servers in the group, called
            distributed recovery. Distributed recovery can be summarized as
            the process through which a server gets missing transactions from
            the group so that it can then join the group having processed the
            same set of transactions as the other group members.
        </p><p style="color:blue;">本节描述加入组的成员追赶组中剩余服务器的过程，称为分布式恢复。分布式恢复可以概括为服务器从组中获取丢失事务的过程，这样服务器就可以加入处理了与其他组成员相同的事务集的组。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-distributed-recovery-basics"></a>17.9.5.1&nbsp;Distributed Recovery Basics</h4>
                        </div>
                    </div>
                </div>
                <a class="indexterm" name="idm140286788248752"></a><p>
                Whenever a member joins a replication group, it connects to an
                existing member to carry out state transfer. The server joining
                the group transfers all the transactions that took place in the
                group before it joined, which are provided by the existing
                member (called the <span class="emphasis"><em>donor</em></span>). Next, the server
                joining the group applies the transactions that took place in
                the group while this state transfer was in progress. When the
                server joining the group has caught up with the remaining
                servers in the group, it begins to participate normally in the
                group. This process is called distributed recovery.
            </p><p style="color:blue;">每当成员加入复制组时，它就连接到现有成员进行状态转移。加入组的服务器将在组加入之前发生的所有事务转移，这是由现有成员（称为供体）提供的。接下来，加入组的服务器将应用在进行此状态传输时在组中发生的事务。当加入组的服务器赶上组中剩余的服务器时，它开始正常地加入组。此过程称为分布式恢复。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="group-replication-phase-1"></a>Phase 1</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        In the first phase, the server joining the group selects one
                        of the online servers on the group to be the
                        <span class="emphasis"><em>donor</em></span> of the state that it is missing.
                        The donor is responsible for providing the server joining the
                        group all the data it is missing up to the moment it has
                        joined the group. This is achieved by relying on a standard
                        asynchronous replication channel, established between the
                        donor and the server joining the group, see
                        <a class="xref" href="replication.html#replication-channels" title="16.2.3&nbsp;Replication Channels">Section&nbsp;16.2.3, “Replication Channels”</a>. Through this
                        replication channel, the donor's binary logs are replicated
                        until the point that the view change happened when the server
                        joining the group became part of the group. The server joining
                        the group applies the donor's binary logs as it receives them.
                    </p><p style="color:blue;">在第一阶段，加入组的服务器选择组上的一个联机服务器作为丢失状态的提供者。捐赠者负责向加入组的服务器提供其加入组时丢失的所有数据。这是通过依赖一个标准的异步复制通道来实现的，该通道建立在捐赠者和加入组的服务器之间，请参见第16.2.3节“复制通道”。通过此复制通道，将复制捐赠者的二进制日志，直到加入组的服务器成为组的一部分时视图发生更改为止。加入组的服务器在接收到捐赠方的二进制日志时应用这些日志。</p><p>
                    While the binary log is being replicated, the server joining
                    the group also caches every transaction that is exchanged
                    within the group. In other words it is listening for
                    transactions that are happening after it joined the group and
                    while it is applying the missing state from the donor. When
                    the first phase ends and the replication channel to the donor
                    is closed, the server joining the group then starts phase two:
                    the catch up.
                </p><p style="color:blue;">复制二进制日志时，加入组的服务器还缓存组内交换的每个事务。换句话说，它正在监听加入组后发生的事务，同时它正在从捐赠者应用丢失的状态。当第一个阶段结束并且到捐助者的复制通道关闭时，加入组的服务器随后开始第二个阶段：追赶。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="group-replication-phase-2"></a>Phase 2</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        In this phase, the server joining the group proceeds to the
                        execution of the cached transactions. When the number of
                        transactions queued for execution finally reaches zero, the
                        member is declared online.
                    </p><p style="color:blue;">在此阶段，加入组的服务器将继续执行缓存事务。当排队等待执行的事务数最终达到零时，该成员将被声明为联机。</p>
                </div>
                <div class="simplesect">
                    <div class="titlepage">
                        <div>
                            <div class="simple">
                                <h5 class="title"><a name="group-replication-resilience"></a>Resilience</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The recovery procedure withstands donor failures while the
                        server joining the group is fetching binary logs from it. In
                        such cases, whenever a donor fails during phase 1, the server
                        joining the group fails over to a new donor and resumes from
                        that one. When that happens the server joining the group
                        closes the connection to the failed server joining the group
                        explicitly and opens a connection to a new donor. This happens
                        automatically.
                    </p><p style="color:blue;">当加入组的服务器正在从中获取二进制日志时，恢复过程可以承受捐赠者失败。在这种情况下，在阶段1中，每当捐赠者失败时，加入组的服务器将故障转移到新的捐赠者并从该捐赠者恢复。发生这种情况时，加入组的服务器将显式关闭与加入组的失败服务器的连接，并打开与新捐助者的连接。这是自动发生的。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-recovering-from-a-point-in-time"></a>17.9.5.2&nbsp;Recovering From a Point-in-time</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286788235632"></a><p>
                To synchronize the server joining the group with the donor up to
                a specific point in time, the server joining the group and donor
                make use of the MySQL Global Transaction Identifiers (GTIDs)
                mechanism. See <a class="xref" href="replication.html#replication-gtids" title="16.1.3&nbsp;Replication with Global Transaction Identifiers">Section&nbsp;16.1.3, “Replication with Global Transaction Identifiers”</a>. However,
                GTIDS only provide a means to realize which transactions the
                server joining the group is missing, they do not help marking a
                specific point in time to which the server joining the group
                must catch up, nor do they help conveying certification
                information. This is the job of binary log view markers, which
                mark view changes in the binary log stream, and also contain
                additional metadata information, provisioning the server joining
                the group with missing certification related data.
            </p><p style="color:blue;">为了将加入组的服务器与捐赠者同步到特定的时间点，加入组和捐赠者的服务器使用mysql全局事务标识符（gtid）机制。请参阅第16.1.3节“使用全局事务标识符复制”。然而，gtid仅提供了一种方法来了解加入组的服务器缺少哪些事务，它们无助于标记加入组的服务器必须赶上的特定时间点，也无助于传递认证信息。这是二进制日志视图标记的工作，它标记二进制日志流中的视图更改，还包含其他元数据信息，为加入组的服务器提供丢失的证书相关数据。</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="group-replication-view-and-view-changes"></a>View and View Changes</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        To explain the concept of view change markers, it is important
                        to understand what a view and a view change are.
                    </p><p style="color:blue;">为了解释视图更改标记的概念，理解什么是视图和视图更改是很重要的。</p><p>
                    A <span class="emphasis"><em>view</em></span> corresponds to a group of members
                    participating actively in the current configuration, in other
                    words at a specific point in time. They are correct and online
                    in the system.
                </p><p style="color:blue;">视图对应于积极参与当前配置的一组成员，换句话说，在特定的时间点。它们在系统中是正确的和在线的。</p><p>
                    A <span class="emphasis"><em>view change</em></span> occurs when a modification
                    to the group configuration happens, such as a member joining
                    or leaving. Any group membership change results in an
                    independent view change communicated to all members at the
                    same logical point in time.
                </p><p style="color:blue;">当修改组配置（如成员加入或离开）时，会发生视图更改。任何组成员身份更改都会导致在同一逻辑时间点与所有成员通信的独立视图更改。</p><p>
                    A <span class="emphasis"><em>view identifier</em></span> uniquely identifies a
                    view. It is generated whenever a view change happens
                </p><p style="color:blue;">视图标识符唯一标识视图。每当视图发生更改时生成</p><p>
                    At the group communication layer, view changes with their
                    associated view ids are then boundaries between the data
                    exchanged before and after a member joins. This concept is
                    implemented through a new binary log event: the"view
                    change log event". The view id thus becomes a marker as
                    well for transactions transmitted before and after changes
                    happen in the group membership.
                </p><p style="color:blue;">在组通信层，视图更改及其关联的视图id是在成员联接之前和之后交换的数据之间的边界。这个概念是通过一个新的二进制日志事件实现的：“视图更改日志事件”。因此，视图id也成为在组成员身份发生更改之前和之后传输的事务的标记。</p><p>
                    The view identifier itself is built from two parts:
                    <span class="emphasis"><em>(i)</em></span> one that is randomly generated and
                    <span class="emphasis"><em>(ii)</em></span> a monotonically increasing integer.
                    The first part is generated when the group is created, and
                    remains unchanged while there is at least one member in the
                    group. The second part is incremented every time a view change
                    happens.
                </p><p style="color:blue;">视图标识符本身由两部分构成：（i）一部分是随机生成的；（ii）一个单调递增的整数。第一部分在创建组时生成，并且在组中至少有一个成员时保持不变。第二部分在每次发生视图更改时递增。</p><p>
                    The reason for this heterogeneous pair that makes up the view
                    id is the need to unambiguously mark group changes whenever a
                    member joins or leaves but also whenever all members leave the
                    group and no information remains of what view the group was
                    in. In fact, the sole use of monotonic increasing identifiers
                    could lead to the reuse of the same id after full group
                    shutdowns, destroying the uniqueness of the binary log data
                    markers that recovery depends on. To summarize, the first part
                    identifies whenever the group was started from the beginning
                    and the incremental part when the group changed from that
                    point on.
                </p><p style="color:blue;">构成视图id的这种异构对的原因是，需要在成员加入或离开时，以及在所有成员离开组且没有关于组所在视图的信息时，明确标记组更改。事实上，仅使用单调递增的标识符可能会导致在完全关闭组后重复使用同一ID，从而破坏恢复所依赖的二进制日志数据标记的唯一性。总而言之，第一部分确定了组从一开始就启动的时间，以及组从那一点开始更改时的增量部分。</p>
                </div>

            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-view-changes"></a>17.9.5.3&nbsp;View Changes</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286788222336"></a><p>
                This section explains the process which controls how the view
                change identifier is incorporated into a binary log event and
                written to the log, The following steps are taken:
            </p><p style="color:blue;">本节说明控制如何将视图更改标识符合并到二进制日志事件并写入日志的过程，将采取以下步骤：</p>
                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="group-replication-begin-stable-group"></a>Begin: Stable Group</h5>
                            </div>
                        </div>
                    </div>
                    <p>
                        All servers are online and processing incoming transactions
                        from the group. Some servers may be a little behind in terms
                        of transactions replicated, but eventually they converge. The
                        group acts as one distributed and replicated database.
                    </p><p style="color:blue;">所有服务器都处于联机状态，正在处理来自组的传入事务。一些服务器在事务复制方面可能有点落后，但最终它们会聚在一起。该组充当一个分布式和复制的数据库。</p>
                    <div class="figure">
                        <a name="idm140286788218368"></a><p class="title"><b>Figure&nbsp;17.10&nbsp;Stable Group</b></p><p style="color:blue;">图17.10稳定组</p>
                        <div class="figure-contents">

                            <div class="mediaobject">
                                <img src="images/gr-recovery-1.png" width="534" height="525" alt="Servers S1, S2, and S3 are members of the group. The most recent item in all of their binary logs is transaction T20.">
                            </div>

                        </div>

                    </div>
                    <br class="figure-break">
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="group-replication-view-change-member-joins"></a>View Change: a Member Joins</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Whenever a new member joins the group and therefore a view
                        change is performed, every online server queues a view change
                        log event for execution. This is queued because before the
                        view change, several transactions can be queued on the server
                        to be applied and as such, these belong to the old view.
                        Queuing the view change event after them guarantees a correct
                        marking of when this happened.
                    </p><p style="color:blue;">每当新成员加入组并因此执行视图更改时，每个联机服务器都会将视图更改日志事件排队等待执行。这是排队的，因为在视图更改之前，可以在服务器上排队应用多个事务，因此这些事务属于旧视图。在视图更改事件之后对其进行排队可确保正确标记发生此事件的时间。</p><p>
                    Meanwhile, the server joining the group selects the donor from
                    the list of online servers as stated by the membership service
                    through the view abstraction. A member joins on view 4 and the
                    online members write a View change event to the binary log.
                </p><p style="color:blue;">同时，加入组的服务器通过视图抽象从成员服务声明的在线服务器列表中选择捐赠者。视图4上的成员联接和联机成员将视图更改事件写入二进制日志。</p>
                    <div class="figure">
                        <a name="idm140286788208720"></a><p class="title"><b>Figure&nbsp;17.11&nbsp;A Member Joins</b></p><p style="color:blue;">图17.11构件连接</p>
                        <div class="figure-contents">

                            <div class="mediaobject">
                                <img src="images/gr-recovery-2.png" width="654" height="559" alt="Server S4 joins the group and looks for a donor. Servers S1, S2, and S3 each queue the view change entry VC4 for their binary logs. Meanwhile, server S1 is receiving new transaction T21.">
                            </div>

                        </div>

                    </div>
                    <br class="figure-break">
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="group-replication-state-transfer-catching-up"></a>State Transfer: Catching Up</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Once the server joining the group has chosen which server in
                        the group is to be the donor, a new asynchronous replication
                        connection is established between the two and the state
                        transfer begins (phase 1). This interaction with the donor
                        continues until the server joining the group's applier
                        thread processes the view change log event that corresponds to
                        the view change triggered when the server joining the group
                        came into the group. In other words, the server joining the
                        group replicates from the donor, until it gets to the marker
                        with the view identifier which matches the view marker it is
                        already in.
                    </p><p style="color:blue;">一旦加入组的服务器选择了组中的哪个服务器作为施主，则在两者之间建立新的异步复制连接，并开始状态传输（阶段1）。在加入组的applier线程的服务器处理与加入组的服务器进入组时触发的视图更改相对应的视图更改日志事件之前，与捐赠者的交互将继续。换言之，加入组的服务器从捐赠者复制，直到它使用与它已经在的视图标记匹配的视图标识符到达标记为止。</p>
                    <div class="figure">
                        <a name="idm140286788199456"></a><p class="title"><b>Figure&nbsp;17.12&nbsp;State Transfer: Catching Up</b></p><p style="color:blue;">图17.12国家转移：追赶</p>
                        <div class="figure-contents">

                            <div class="mediaobject">
                                <img src="images/gr-recovery-3.png" width="603" height="525" alt="Server S4 has chosen server S2 as the donor. State transfer is executed from server S2 to server S4 until the view change entry VC4 is reached (view_id = VC4). Server S4 uses a temporary applier buffer for state transfer, and its binary log is currently empty.">
                            </div>

                        </div>

                    </div>
                    <br class="figure-break"><p>
                    As view identifiers are transmitted to all members in the
                    group at the same logical time, the server joining the group
                    knows at which view identifier it should stop replicating.
                    This avoids complex GTID set calculations because the view id
                    clearly marks which data belongs to each group view.
                </p><p style="color:blue;">由于视图标识符在同一逻辑时间传输到组中的所有成员，加入该组的服务器知道应在哪个视图标识符停止复制。这避免了复杂的gtid集计算，因为视图id清楚地标记了哪些数据属于每个组视图。</p><p>
                    While the server joining the group is replicating from the
                    donor, it is also caching incoming transactions from the
                    group. Eventually, it stops replicating from the donor and
                    switches to applying those that are cached.
                </p><p style="color:blue;">当加入组的服务器从捐助者复制时，它还缓存来自组的传入事务。最后，它停止从捐赠者复制，并切换到应用那些被缓存的内容。</p>
                    <div class="figure">
                        <a name="idm140286788191152"></a><p class="title"><b>Figure&nbsp;17.13&nbsp;Queued Transactions</b></p><p style="color:blue;">图17.13排队事务</p>
                        <div class="figure-contents">

                            <div class="mediaobject">
                                <img src="images/gr-recovery-4.png" width="644" height="525" alt="State transfer is complete. Server S4 has applied the transactions up to T20 and written them to its binary log. Server S4 has cached transaction T21, which arrived after the view change, in a temporary applier buffer while recovering.">
                            </div>

                        </div>

                    </div>
                    <br class="figure-break">
                </div>

                <div class="simplesect">

                    <div class="titlepage">
                        <div>

                            <div class="simple">
                                <h5 class="title"><a name="group-replication-finish-caught-up"></a>Finish: Caught Up</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        When the server joining the group recognizes a view change log
                        event with the expected view identifier, the connection to the
                        donor is terminated and it starts applying the cached
                        transactions. An important point to understand is the final
                        recovery procedure. Although it acts as a marker in the binary
                        log, delimiting view changes, the view change log event also
                        plays another role. It conveys the certification information
                        as perceived by all servers when the server joining the group
                        entered the group, in other words the last view change.
                        Without it, the server joining the group would not have the
                        necessary information to be able to certify (detect conflicts)
                        subsequent transactions.
                    </p><p style="color:blue;">当加入组的服务器识别出具有预期视图标识符的视图更改日志事件时，与捐赠者的连接将终止，并开始应用缓存的事务。需要了解的一个重要点是最终的恢复过程。尽管它在二进制日志中充当标记，分隔视图更改，但视图更改日志事件也扮演另一个角色。当加入组的服务器进入组（换句话说，最后一次视图更改）时，它传递所有服务器所感知的认证信息。如果没有它，加入组的服务器将没有必要的信息来验证（检测冲突）后续事务。</p><p>
                    The duration of the catch up (phase 2) is not deterministic,
                    because it depends on the workload and the rate of incoming
                    transactions to the group. This process is completely online
                    and the server joining the group does not block any other
                    server in the group while it is catching up. Therefore the
                    number of transactions the server joining the group is behind
                    when it moves to phase 2 can, for this reason, vary and thus
                    increase or decrease according to the workload.
                </p><p style="color:blue;">追赶（阶段2）的持续时间不是确定的，因为它取决于工作负载和传入组的事务的速率。此进程完全联机，加入组的服务器在追赶时不会阻止组中的任何其他服务器。因此，当服务器移动到第2阶段时，加入组的事务数可能会因此而变化，并因此根据工作负载增加或减少。</p><p>
                    When the server joining the group reaches zero queued
                    transactions and its stored data is equal to the other
                    members, its public state changes to online.
                </p><p style="color:blue;">当加入组的服务器达到零队列事务且其存储的数据等于其他成员时，其公共状态将更改为联机。</p>
                    <div class="figure">
                        <a name="idm140286788180304"></a><p class="title"><b>Figure&nbsp;17.14&nbsp;Instance Online</b></p><p style="color:blue;">图17.14在线实例</p>
                        <div class="figure-contents">

                            <div class="mediaobject">
                                <img src="images/gr-recovery-5.png" width="597" height="525" alt="Server S4 is now an online member of the group. It has applied cached transaction T21, so its binary log shows the same items as the binary logs of the other group members, and it no longer needs the temporary applier buffer. New incoming transaction T22 is now received and applied by all group members.">
                            </div>

                        </div>

                    </div>
                    <br class="figure-break">
                </div>

            </div>

            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-usage-advice-and-limitations-of-distributed-recovery"></a>17.9.5.4&nbsp;Usage Advice and Limitations of Distributed Recovery</h4>

                        </div>

                    </div>

                </div>
                <a class="indexterm" name="idm140286788171824"></a><p>
                Distributed recovery does have some limitations. It is based on
                classic asynchronous replication and as such it may be slow if
                the server joining the group is not provisioned at all or is
                provisioned with a very old backup image. This means that if the
                data to transfer is too big at phase 1, the server may take a
                very long time to recover. As such, the recommendation is that
                before adding a server to the group, one should provision it
                with a fairly recent snapshot of a server already in the group.
                This minimizes the length of phase 1 and reduces the impact on
                the donor server, since it has to save and transfer less binary
                logs.
            </p><p style="color:blue;">分布式恢复确实有一些限制。它基于典型的异步复制，因此，如果加入组的服务器根本没有配置或配置了非常旧的备份映像，则速度可能会很慢。这意味着，如果在阶段1要传输的数据太大，服务器可能需要很长时间才能恢复。因此，建议在将服务器添加到组之前，应为其提供组中已存在的服务器的最新快照。这使得阶段1的长度最小化，并减少了对捐助服务器的影响，因为它必须保存和传输更少的二进制日志。</p>
                <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

                    <div class="admon-title">
                        Warning
                    </div>
                    <p>
                        It is recommended that a server is provisioned before it is
                        added to a group. That way, one minimizes the time spent on
                        the recovery step.
                    </p><p style="color:blue;">建议先设置服务器，然后再将其添加到组中。这样，就可以最大限度地减少在恢复步骤上花费的时间。</p>
                </div>

            </div>

        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-observability"></a>17.9.6&nbsp;Observability</h3>

                    </div>

                </div>

            </div>
            <a class="indexterm" name="idm140286788166720"></a><p>
            There is a lot of automation built into the Group Replication
            plugin. Nonetheless, you might sometimes need to understand what
            is happening behind the scenes. This is where the instrumentation
            of Group Replication and Performance Schema becomes important. The
            entire state of the system (including the view, conflict
            statistics and service states) can be queried through
            performance_schema tables. The distributed nature of the
            replication protocol and the fact that server instances agree and
            thus synchronize on transactions and metadata makes it simpler to
            inspect the state of the group. For example, you can connect to a
            single server in the group and obtain both local and global
            information by issuing select statements on the Group Replication
            related Performance Schema tables. For more information, see
            <a class="xref" href="group-replication.html#group-replication-monitoring" title="17.3&nbsp;Monitoring Group Replication">Section&nbsp;17.3, “Monitoring Group Replication”</a>.
        </p><p style="color:blue;">组复制插件中内置了许多自动化功能。尽管如此，有时你可能需要了解幕后发生的事情。在这里，组复制和性能模式的检测变得非常重要。可以通过性能架构表查询系统的整个状态（包括视图、冲突统计信息和服务状态）。复制协议的分布式特性以及服务器实例在事务和元数据上一致并因此同步的事实，使得检查组的状态更加简单。例如，可以连接到组中的单个服务器，并通过对与组复制相关的性能架构表发出select语句来获取本地和全局信息。有关更多信息，请参阅第17.3节“监视组复制”。</p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a name="group-replication-performance"></a>17.9.7&nbsp;Group Replication Performance</h3>

                    </div>

                </div>

            </div>
            <div class="toc">
                <dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-fine-tuning-the-group-communication-thread">17.9.7.1 Fine Tuning the Group Communication Thread</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-message-compression">17.9.7.2 Message Compression</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-flow-control">17.9.7.3 Flow Control</a></span></dt></dl>
            </div>
            <p>
                This section explains how to use the available configuration
                options to gain the best performance from your group.
            </p><p style="color:blue;">本节介绍如何使用可用的配置选项从组中获得最佳性能。</p>
            <div class="section">

                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-fine-tuning-the-group-communication-thread"></a>17.9.7.1&nbsp;Fine Tuning the Group Communication Thread</h4>
                        </div>
                    </div>
                </div>
                <p>
                    The group communication thread (GCT) runs in a loop while the
                    Group Replication plugin is loaded. The GCT receives messages
                    from the group and from the plugin, handles quorum and failure
                    detection related tasks, sends out some keep alive messages and
                    also handles the incoming and outgoing transactions from/to the
                    server/group. The GCT waits for incoming messages in a queue.
                    When there are no messages, the GCT waits. By configuring this
                    wait to be a little longer (doing an active wait) before
                    actually going to sleep can prove to be beneficial in some
                    cases. This is because the alternative is for the operating
                    system to switch out the GCT from the processor and do a context
                    switch.
                </p><p style="color:blue;">加载组复制插件时，组通信线程（gct）在循环中运行。gct接收来自组和插件的消息，处理与仲裁和故障检测相关的任务，发送一些保持活动的消息，还处理从/到服务器/组的传入和传出事务。gct等待队列中的传入消息。当没有消息时，gct会等待。在某些情况下，将此等待配置为在实际进入睡眠状态之前稍长一点（进行活动等待）可能是有益的。这是因为另一种选择是操作系统从处理器中切换出gct并执行上下文切换。</p><p>
                To force the GCT do an active wait, use the
                <a class="link" href="group-replication.html#sysvar_group_replication_poll_spin_loops"><code class="literal">group_replication_poll_spin_loops</code></a>
                option, which makes the GCT loop, doing nothing relevant for the
                configured number of loops, before actually polling the queue
                for the next message.
            </p><p style="color:blue;">要强制gct执行活动等待，请在实际轮询队列以获取下一条消息之前，使用group_replication_poll_spin_loops选项，使gct循环与配置的循环数无关。</p><p>
                For example:
            </p><p style="color:blue;">例如：</p><pre data-lang="sql" class="programlisting">mysql&gt; SET GLOBAL group_replication_poll_spin_loops= 10000;</pre>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-message-compression"></a>17.9.7.2&nbsp;Message Compression</h4>

                        </div>

                    </div>

                </div>
                <p>
                    When network bandwidth is a bottleneck, message compression can
                    provide up to 30-40% throughput improvement at the group
                    communication level. This is especially important within the
                    context of large groups of servers under load.
                </p><p style="color:blue;">当网络带宽成为瓶颈时，消息压缩可以在组通信级别提供高达30-40%的吞吐量改进。对于负载下的大型服务器组，这一点尤其重要。</p>
                <div class="table">
                    <a name="idm140286788153664"></a><p class="title"><b>Table&nbsp;17.5&nbsp;LZ4 Compression Ratios for Different Binary Log Formats</b></p><p style="color:blue;">表17.5不同二进制日志格式的lz4压缩比</p>
                    <div class="table-contents">
                        <table summary="Compares the compression ratio for the ROW and STATEMENT binary log formats with different workloads."><colgroup><col width="0.59%"><col width="0.18%"><col width="0.24%"></colgroup><thead><tr>
                            <th scope="col"><p>
                                Workload
                            </p><p style="color:blue;">工作量</p></th>
                            <th scope="col"><p>
                                Ratio for ROW
                            </p><p style="color:blue;">行比率</p></th>
                            <th scope="col"><p>
                                Ratio for STMT
                            </p><p style="color:blue;">短期投资比率</p></th>
                        </tr></thead><tbody><tr>
                            <td scope="row"><p>
                                mysqlslapd
                            </p><p style="color:blue;">mysqlslapd公司</p></td>
                            <td><p>
                                4,5
                            </p><p style="color:blue;">4,5个</p></td>
                            <td><p>
                                4,1
                            </p><p style="color:blue;">4、1</p></td>
                        </tr><tr>
                            <td scope="row"><p>
                                sysbench
                            </p><p style="color:blue;">系统工作台</p></td>
                            <td><p>
                                3,4
                            </p><p style="color:blue;">3,4个</p></td>
                            <td><p>
                                2,9
                            </p><p style="color:blue;">2,9个</p></td>
                        </tr></tbody></table>
                    </div>

                </div>
                <br class="table-break"><p>
                The TCP peer-to-peer nature of the interconnections between
                <span class="emphasis"><em>N</em></span> participants on the group makes the
                sender send the same amount of data <span class="emphasis"><em>N</em></span>
                times. Furthermore, binary logs are likely to exhibit a high
                compression ratio (see table above). This makes compression a
                compelling feature for workloads that contain large transaction.
            </p><p style="color:blue;">组中n个参与者之间互连的tcp对等性质使得发送者发送相同数量的数据n次。此外，二进制日志可能表现出高压缩比（见上表）。这使得压缩成为包含大型事务的工作负载的一个引人注目的特性。</p>
                <div class="figure">
                    <a name="idm140286788136080"></a><p class="title"><b>Figure&nbsp;17.15&nbsp;Compression Support</b></p><p style="color:blue;">图17.15压缩支架</p>
                    <div class="figure-contents">

                        <div class="mediaobject">
                            <img src="images/gr-compress-decompress.png" width="603" height="492" alt="The MySQL Group Replication plugin architecture is shown as described in an earlier topic, with the five layers of the plugin positioned between the MySQL server and the replication group. Compression and decompression are handled by the Group Communication System API, which is the fourth layer of the Group Replication plugin. The group communication engine (the fifth layer of the plugin) and the group members use the compressed transactions with the smaller data size. The MySQL Server core and the three higher layers of the Group Replication plugin (the APIs, the capture, applier, and recovery components, and the replication protocol module) use the original transactions with the larger data size.">
                        </div>

                    </div>

                </div>
                <br class="figure-break"><p>
                Compression happens at the group communication engine level,
                before the data is handed over to the group communication
                thread, so it happens within the context of the mysql user
                session thread. Transaction payloads may be compressed before
                being sent out to the group and decompressed when received.
                Compression is conditional and depends on a configured
                threshold. By default compression is enabled.
            </p><p style="color:blue;">压缩发生在组通信引擎级别，在将数据移交给组通信线程之前，因此它发生在mysql用户会话线程的上下文中。事务有效负载可以在发送到组之前进行压缩，并在收到时进行解压缩。压缩是有条件的，取决于配置的阈值。默认情况下启用压缩。</p><p>
                In addition, there is no requirement that all servers in the
                group have compression enabled to be able to work together. Upon
                receiving a message, the member checks the message envelope to
                verify whether it is compressed or not. If needed, then the
                member decompresses the transaction, before delivering it to the
                upper layer.
            </p><p style="color:blue;">此外，不要求组中的所有服务器都启用压缩功能，以便能够协同工作。在接收到消息时，成员检查消息信封以验证它是否被压缩。如果需要，则成员在将事务传递到上层之前将其解压缩。</p><p>
                The compression algorithm used is LZ4. Compression is enabled by
                default with threshold of 1000000 bytes. The compression
                threshold, in bytes, may be set to something larger than
                default. In that case, only transactions that have a payload
                larger than the threshold are compressed. Below is an example of
                how to set a compression threshold.
            </p><p style="color:blue;">使用的压缩算法是lz4。默认情况下启用压缩，阈值为1000000字节。压缩阈值（以字节为单位）可以设置为大于默认值的值。在这种情况下，只有负载大于阈值的事务才会被压缩。下面是如何设置压缩阈值的示例。</p><pre data-lang="sql" class="programlisting">STOP GROUP_REPLICATION;
SET GLOBAL group_replication_compression_threshold= 2097152;
START GROUP_REPLICATION;</pre><p>
                This sets the compression threshold to 2MB. If a transaction
                generates a replication message with a payload larger than 2MB,
                for example a binary log transaction entry larger than 2MB, then
                it is compressed. To disable compression set threshold to 0.
            </p><p style="color:blue;">这将压缩阈值设置为2mb。如果事务生成负载大于2MB的复制消息，例如二进制日志事务项大于2MB，则对其进行压缩。若要禁用压缩，请将阈值设置为0。</p>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h4 class="title"><a name="group-replication-flow-control"></a>17.9.7.3&nbsp;Flow Control</h4>

                        </div>

                    </div>

                </div>
                <p>
                    Group Replication ensures that a transaction only commits after
                    a majority of the members in a group have received it and agreed
                    on the relative order between all transactions that were sent
                    concurrently.
                </p><p style="color:blue;">组复制确保只有在组中的大多数成员收到事务并同意并发发送的所有事务之间的相对顺序后，才提交事务。</p><p>
                This approach works well if the total number of writes to the
                group does not exceed the write capacity of any member in the
                group. If it does and some of the members have less write
                throughput than others, particularly less than the writer
                members, those members can start lagging behind of the writers.
            </p><p style="color:blue;">如果对组的写入总数不超过组中任何成员的写入容量，则此方法可以很好地工作。如果确实如此，并且某些成员的写吞吐量比其他成员（特别是小于writer成员）要小，则这些成员可能会开始落后于writer成员。</p><p>
                Having some members lagging behind the group brings some
                problematic consequences, particularly, the reads on such
                members may externalize very old data. Depending on why the
                member is lagging behind, other members in the group may have to
                save more or less replication context to be able to fulfil
                potential data transfer requests from the slow member.
            </p><p style="color:blue;">有些成员落后于组会带来一些问题后果，特别是对这些成员的读取可能会将非常旧的数据外部化。根据成员落后的原因，组中的其他成员可能必须或多或少地保存复制上下文，才能满足来自慢成员的潜在数据传输请求。</p><p>
                There is however a mechanism in the replication protocol to
                avoid having too much distance, in terms of transactions
                applied, between fast and slow members. This is known as the
                flow control mechanism. It tries to address several goals:
            </p><p style="color:blue;">然而，复制协议中有一种机制，可以避免在应用事务方面，快速成员和慢速成员之间有太大的距离。这就是所谓的流量控制机制。它试图实现几个目标：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        to keep the members close enough to make buffering and
                        de-synchronization between members a small problem;
                    </p><p style="color:blue;">保持成员足够接近，使成员之间的缓冲和取消同步成为一个小问题；</p></li><li class="listitem"><p>
                        to adapt quickly to changing conditions like different
                        workloads or more writers in the group;
                    </p><p style="color:blue;">快速适应不断变化的环境，如不同的工作负载或组中的更多写入程序；</p></li><li class="listitem"><p>
                        to give each member a fair share of the available write
                        capacity;
                    </p><p style="color:blue;">给予每一成员公平的可写容量份额；</p></li><li class="listitem"><p>
                        to not reduce throughput more than strictly necessary to
                        avoid wasting resources.
                    </p><p style="color:blue;">为了避免浪费资源，不要严格地降低吞吐量。</p></li></ol>
                </div>
                <p>
                    Given the design of Group Replication, the decision whether to
                    throttle or not may be decided taking into account two work
                    queues: <span class="emphasis"><em>(i)</em></span> the
                    <span class="emphasis"><em>certification</em></span> queue;
                    <span class="emphasis"><em>(ii)</em></span> and on the binary log
                    <span class="emphasis"><em>applier</em></span> queue. Whenever the size of one of
                    these queues exceeds the user-defined threshold, the throttling
                    mechanism is triggered. Only configure: <span class="emphasis"><em>(i)</em></span>
                    whether to do flow control at the certifier or at the applier
                    level, or both; and <span class="emphasis"><em>(ii)</em></span> what is the
                    threshold for each queue.
                </p><p style="color:blue;">考虑到组复制的设计，可以考虑两个工作队列来决定是否限制：（i）证书队列；（ii）和二进制日志应用程序队列。每当其中一个队列的大小超过用户定义的阈值时，就会触发限制机制。仅配置：（i）是在认证器级别还是在应用程序级别进行流控制，或同时在这两个级别进行流控制；和（ii）每个队列的阈值是多少。</p><p>
                The flow control depends on two basic mechanisms:
            </p><p style="color:blue;">流量控制取决于两个基本机制：</p>
                <div class="orderedlist">
                    <ol class="orderedlist" type="1"><li class="listitem"><p>
                        the monitoring of members to collect some statistics on
                        throughput and queue sizes of all group members to make
                        educated guesses on what is the maximum write pressure each
                        member should be subjected to;
                    </p><p style="color:blue;">对成员的监控，收集所有成员的吞吐量和队列大小的统计数据，以便对每个成员应承受的最大写入压力作出有根据的猜测；</p></li><li class="listitem"><p>
                        the throttling of members that are trying to write beyond
                        their fair-share of the available capacity at each moment in
                        time.
                    </p><p style="color:blue;">限制那些试图在每个时刻都超出其可利用容量的公平份额的成员。</p></li></ol>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="group-replication-probes-and-statistics"></a>17.9.7.3.1&nbsp;Probes and Statistics</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        The monitoring mechanism works by having each member deploying
                        a set of probes to collect information about its work queues
                        and throughput. It then propagates that information to the
                        group periodically to share that data with the other members.
                    </p><p style="color:blue;">监视机制通过让每个成员部署一组探测来收集有关其工作队列和吞吐量的信息来工作。然后它定期将该信息传播到组中，以便与其他成员共享该数据。</p><p>
                    Such probes are scattered throughout the plugin stack and
                    allow one to establish metrics, such as:
                </p><p style="color:blue;">这样的探测分散在整个插件堆栈中，允许建立度量，例如：</p>
                    <div class="itemizedlist">
                        <ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            the certifier queue size;
                        </p><p style="color:blue;">认证者队列大小；</p></li><li class="listitem"><p>
                            the replication applier queue size;
                        </p><p style="color:blue;">复制应用程序队列大小；</p></li><li class="listitem"><p>
                            the total number of transactions certified;
                        </p><p style="color:blue;">经认证的交易总数；</p></li><li class="listitem"><p>
                            the total number of remote transactions applied in the
                            member;
                        </p><p style="color:blue;">成员中应用的远程事务总数；</p></li><li class="listitem"><p>
                            the total number of local transactions.
                        </p><p style="color:blue;">本地事务的总数。</p></li></ul>
                    </div>
                    <p>
                        Once a member receives a message with statistics from another
                        member, it calculates additional metrics regarding how many
                        transactions were certified, applied and locally executed in
                        the last monitoring period.
                    </p><p style="color:blue;">一旦一个成员从另一个成员接收到一条带有统计信息的消息，它就会计算关于在上一个监视周期中认证、应用和本地执行了多少事务的额外度量。</p><p>
                    Monitoring data is shared with others in the group
                    periodically. The monitoring period must be high enough to
                    allow the other members to decide on the current write
                    requests, but low enough that it has minimal impact on group
                    bandwidth. The information is shared every second, and this
                    period is sufficient to address both concerns.
                </p><p style="color:blue;">监控数据定期与组中的其他人共享。监视周期必须足够长，以允许其他成员决定当前的写入请求，但必须足够低，以使它对组带宽的影响最小。信息每秒共享一次，这段时间足以解决这两个问题。</p>
                </div>
                <div class="section">
                    <div class="titlepage">
                        <div>
                            <div>
                                <h5 class="title"><a name="group-replication-throttling"></a>17.9.7.3.2&nbsp;Group Replication Throttling</h5>

                            </div>

                        </div>

                    </div>
                    <p>
                        Based on the metrics gathered across all servers in the group,
                        a throttling mechanism kicks in and decides whether to limit
                        the rate a member is able to execute/commit new transactions.
                    </p><p style="color:blue;">根据在组中所有服务器上收集的度量，将启动一个限制机制，并决定是否限制成员执行/提交新事务的速率。</p><p>
                    Therefore, metrics acquired from all members are the basis for
                    calculating the capacity of each member: if a member has a
                    large queue (for certification or the applier thread), then
                    the capacity to execute new transactions should be close to
                    ones certified or applied in the last period.
                </p><p style="color:blue;">因此，从所有成员获取的度量是计算每个成员的容量的基础：如果一个成员有一个大队列（用于认证或applier线程），那么执行新事务的容量应该接近上一个周期中认证或应用的容量。</p><p>
                    The lowest capacity of all the members in the group determines
                    the real capacity of the group, while the number of local
                    transactions determines how many members are writing to it,
                    and, consequently, how many members should that available
                    capacity be shared with.
                </p><p style="color:blue;">组中所有成员的最低容量决定了组的实际容量，而本地事务的数量决定了有多少成员正在向其写入数据，因此，应该与多少成员共享该可用容量。</p><p>
                    This means that every member has an established write quota
                    based on the available capacity, in other words a number of
                    transactions it can safely issue for the next period. The
                    writer-quota will be enforced by the throttling mechanism if
                    the queue size of the certifier or the binary log applier
                    exceeds a user-defined threshold.


                </p><p style="color:blue;">这意味着每个成员都有一个基于可用容量的已建立的写配额，换句话说，它可以在下一个期间安全地发出一些事务。如果证书颁发器或二进制日志应用程序的队列大小超过用户定义的阈值，则写入程序配额将由限制机制强制执行。</p><p>
                    The quota is reduced by the number of transactions that were
                    delayed in the last period, and then also further reduced by
                    10% to allow the queue that triggered the problem to reduce
                    its size. In order to avoid large jumps in throughput once the
                    queue size goes beyond the threshold, the throughput is only
                    allowed to grow by the same 10% per period after that.
                </p><p style="color:blue;">配额将减少上一个期间延迟的事务数，然后进一步减少10%，以允许触发问题的队列减小其大小。为了避免队列大小超过阈值时吞吐量的大跳跃，在此之后，每个周期的吞吐量只允许以相同的10%增长。</p><p>
                    The current throttling mechanism does not penalize
                    transactions below quota, but delays finishing those
                    transactions that exceed it until the end of the monitoring
                    period. As a consequence, if the quota is very small for the
                    write requests issued some transactions may have latencies
                    close to the monitoring period.
                </p><p style="color:blue;">当前的限制机制不会惩罚低于配额的事务，但会延迟完成超过配额的事务，直到监视期结束。因此，如果对发出的写请求的配额非常小，则某些事务可能具有接近监视周期的延迟。</p>
                </div>

            </div>

        </div>

    </div>

</div>
<div class="copyright-footer">

</div>
<div class="navfooter">
    <hr>
    <table width="100%" summary="Navigation footer">
        <tbody><tr>
            <td width="40%" align="left"><a accesskey="p" href="replication.html">Prev</a></td>
            <td width="20%" align="center"><a accesskey="u" href="">Up</a></td>
            <td width="40%" align="right">&nbsp;<a accesskey="n" href="mysql-shell-userguide.html">Next</a></td>
        </tr>
        <tr>
            <td width="40%" align="left" valign="top">Chapter&nbsp;16 Replication</td>
            <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
            <td width="40%" align="right" valign="top">Chapter&nbsp;18 MySQL Shell</td>
        </tr>
        </tbody></table>
</div>


</body></html>